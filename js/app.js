/*!
 * jQuery JavaScript Library v2.1.1
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-05-01T17:11Z
 */

(function( global, factory ) {

    if ( typeof module === "object" && typeof module.exports === "object" ) {
        // For CommonJS and CommonJS-like environments where a proper window is present,
        // execute the factory and get jQuery
        // For environments that do not inherently posses a window with a document
        // (such as Node.js), expose a jQuery-making factory as module.exports
        // This accentuates the need for the creation of a real window
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info
        module.exports = global.document ?
            factory( global, true ) :
            function( w ) {
                if ( !w.document ) {
                    throw new Error( "jQuery requires a window with a document" );
                }
                return factory( w );
            };
    } else {
        factory( global );
    }

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

    var arr = [];

    var slice = arr.slice;

    var concat = arr.concat;

    var push = arr.push;

    var indexOf = arr.indexOf;

    var class2type = {};

    var toString = class2type.toString;

    var hasOwn = class2type.hasOwnProperty;

    var support = {};



    var
        // Use the correct document accordingly with window argument (sandbox)
        document = window.document,

        version = "2.1.1",

        // Define a local copy of jQuery
        jQuery = function( selector, context ) {
            // The jQuery object is actually just the init constructor 'enhanced'
            // Need init if jQuery is called (just allow error to be thrown if not included)
            return new jQuery.fn.init( selector, context );
        },

        // Support: Android<4.1
        // Make sure we trim BOM and NBSP
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

        // Matches dashed string for camelizing
        rmsPrefix = /^-ms-/,
        rdashAlpha = /-([\da-z])/gi,

        // Used by jQuery.camelCase as callback to replace()
        fcamelCase = function( all, letter ) {
            return letter.toUpperCase();
        };

    jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,

        constructor: jQuery,

        // Start with an empty selector
        selector: "",

        // The default length of a jQuery object is 0
        length: 0,

        toArray: function() {
            return slice.call( this );
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function( num ) {
            return num != null ?

                // Return just the one element from the set
                ( num < 0 ? this[ num + this.length ] : this[ num ] ) :

                // Return all the elements in a clean array
                slice.call( this );
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function( elems ) {

            // Build a new jQuery matched element set
            var ret = jQuery.merge( this.constructor(), elems );

            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
            ret.context = this.context;

            // Return the newly-formed element set
            return ret;
        },

        // Execute a callback for every element in the matched set.
        // (You can seed the arguments with an array of args, but this is
        // only used internally.)
        each: function( callback, args ) {
            return jQuery.each( this, callback, args );
        },

        map: function( callback ) {
            return this.pushStack( jQuery.map(this, function( elem, i ) {
                return callback.call( elem, i, elem );
            }));
        },

        slice: function() {
            return this.pushStack( slice.apply( this, arguments ) );
        },

        first: function() {
            return this.eq( 0 );
        },

        last: function() {
            return this.eq( -1 );
        },

        eq: function( i ) {
            var len = this.length,
                j = +i + ( i < 0 ? len : 0 );
            return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
        },

        end: function() {
            return this.prevObject || this.constructor(null);
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
            deep = target;

            // skip the boolean and the target
            target = arguments[ i ] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
            target = {};
        }

        // extend jQuery itself if only one argument is passed
        if ( i === length ) {
            target = this;
            i--;
        }

        for ( ; i < length; i++ ) {
            // Only deal with non-null/undefined values
            if ( (options = arguments[ i ]) != null ) {
                // Extend the base object
                for ( name in options ) {
                    src = target[ name ];
                    copy = options[ name ];

                    // Prevent never-ending loop
                    if ( target === copy ) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                        if ( copyIsArray ) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[ name ] = jQuery.extend( deep, clone, copy );

                        // Don't bring in undefined values
                    } else if ( copy !== undefined ) {
                        target[ name ] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };

    jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

        // Assume jQuery is ready without the ready module
        isReady: true,

        error: function( msg ) {
            throw new Error( msg );
        },

        noop: function() {},

        // See test/unit/core.js for details concerning isFunction.
        // Since version 1.3, DOM methods and functions like alert
        // aren't supported. They return false on IE (#2968).
        isFunction: function( obj ) {
            return jQuery.type(obj) === "function";
        },

        isArray: Array.isArray,

        isWindow: function( obj ) {
            return obj != null && obj === obj.window;
        },

        isNumeric: function( obj ) {
            // parseFloat NaNs numeric-cast false positives (null|true|false|"")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            return !jQuery.isArray( obj ) && obj - parseFloat( obj ) >= 0;
        },

        isPlainObject: function( obj ) {
            // Not plain objects:
            // - Any object or value whose internal [[Class]] property is not "[object Object]"
            // - DOM nodes
            // - window
            if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
                return false;
            }

            if ( obj.constructor &&
                !hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
                return false;
            }

            // If the function hasn't returned already, we're confident that
            // |obj| is a plain object, created by {} or constructed with new Object
            return true;
        },

        isEmptyObject: function( obj ) {
            var name;
            for ( name in obj ) {
                return false;
            }
            return true;
        },

        type: function( obj ) {
            if ( obj == null ) {
                return obj + "";
            }
            // Support: Android < 4.0, iOS < 6 (functionish RegExp)
            return typeof obj === "object" || typeof obj === "function" ?
                class2type[ toString.call(obj) ] || "object" :
                typeof obj;
        },

        // Evaluates a script in a global context
        globalEval: function( code ) {
            var script,
                indirect = eval;

            code = jQuery.trim( code );

            if ( code ) {
                // If the code includes a valid, prologue position
                // strict mode pragma, execute code by injecting a
                // script tag into the document.
                if ( code.indexOf("use strict") === 1 ) {
                    script = document.createElement("script");
                    script.text = code;
                    document.head.appendChild( script ).parentNode.removeChild( script );
                } else {
                    // Otherwise, avoid the DOM node creation, insertion
                    // and removal by using an indirect global eval
                    indirect( code );
                }
            }
        },

        // Convert dashed to camelCase; used by the css and data modules
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function( string ) {
            return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
        },

        nodeName: function( elem, name ) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },

        // args is for internal usage only
        each: function( obj, callback, args ) {
            var value,
                i = 0,
                length = obj.length,
                isArray = isArraylike( obj );

            if ( args ) {
                if ( isArray ) {
                    for ( ; i < length; i++ ) {
                        value = callback.apply( obj[ i ], args );

                        if ( value === false ) {
                            break;
                        }
                    }
                } else {
                    for ( i in obj ) {
                        value = callback.apply( obj[ i ], args );

                        if ( value === false ) {
                            break;
                        }
                    }
                }

                // A special, fast, case for the most common use of each
            } else {
                if ( isArray ) {
                    for ( ; i < length; i++ ) {
                        value = callback.call( obj[ i ], i, obj[ i ] );

                        if ( value === false ) {
                            break;
                        }
                    }
                } else {
                    for ( i in obj ) {
                        value = callback.call( obj[ i ], i, obj[ i ] );

                        if ( value === false ) {
                            break;
                        }
                    }
                }
            }

            return obj;
        },

        // Support: Android<4.1
        trim: function( text ) {
            return text == null ?
                "" :
                ( text + "" ).replace( rtrim, "" );
        },

        // results is for internal usage only
        makeArray: function( arr, results ) {
            var ret = results || [];

            if ( arr != null ) {
                if ( isArraylike( Object(arr) ) ) {
                    jQuery.merge( ret,
                        typeof arr === "string" ?
                            [ arr ] : arr
                    );
                } else {
                    push.call( ret, arr );
                }
            }

            return ret;
        },

        inArray: function( elem, arr, i ) {
            return arr == null ? -1 : indexOf.call( arr, elem, i );
        },

        merge: function( first, second ) {
            var len = +second.length,
                j = 0,
                i = first.length;

            for ( ; j < len; j++ ) {
                first[ i++ ] = second[ j ];
            }

            first.length = i;

            return first;
        },

        grep: function( elems, callback, invert ) {
            var callbackInverse,
                matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert;

            // Go through the array, only saving the items
            // that pass the validator function
            for ( ; i < length; i++ ) {
                callbackInverse = !callback( elems[ i ], i );
                if ( callbackInverse !== callbackExpect ) {
                    matches.push( elems[ i ] );
                }
            }

            return matches;
        },

        // arg is for internal usage only
        map: function( elems, callback, arg ) {
            var value,
                i = 0,
                length = elems.length,
                isArray = isArraylike( elems ),
                ret = [];

            // Go through the array, translating each of the items to their new values
            if ( isArray ) {
                for ( ; i < length; i++ ) {
                    value = callback( elems[ i ], i, arg );

                    if ( value != null ) {
                        ret.push( value );
                    }
                }

                // Go through every key on the object,
            } else {
                for ( i in elems ) {
                    value = callback( elems[ i ], i, arg );

                    if ( value != null ) {
                        ret.push( value );
                    }
                }
            }

            // Flatten any nested arrays
            return concat.apply( [], ret );
        },

        // A global GUID counter for objects
        guid: 1,

        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function( fn, context ) {
            var tmp, args, proxy;

            if ( typeof context === "string" ) {
                tmp = fn[ context ];
                context = fn;
                fn = tmp;
            }

            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if ( !jQuery.isFunction( fn ) ) {
                return undefined;
            }

            // Simulated bind
            args = slice.call( arguments, 2 );
            proxy = function() {
                return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
            };

            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;

            return proxy;
        },

        now: Date.now,

        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    });

// Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
        class2type[ "[object " + name + "]" ] = name.toLowerCase();
    });

    function isArraylike( obj ) {
        var length = obj.length,
            type = jQuery.type( obj );

        if ( type === "function" || jQuery.isWindow( obj ) ) {
            return false;
        }

        if ( obj.nodeType === 1 && length ) {
            return true;
        }

        return type === "array" || length === 0 ||
            typeof length === "number" && length > 0 && ( length - 1 ) in obj;
    }
    var Sizzle =
        /*!
 * Sizzle CSS Selector Engine v1.10.19
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-04-18
 */
        (function( window ) {

            var i,
                support,
                Expr,
                getText,
                isXML,
                tokenize,
                compile,
                select,
                outermostContext,
                sortInput,
                hasDuplicate,

                // Local document vars
                setDocument,
                document,
                docElem,
                documentIsHTML,
                rbuggyQSA,
                rbuggyMatches,
                matches,
                contains,

                // Instance-specific data
                expando = "sizzle" + -(new Date()),
                preferredDoc = window.document,
                dirruns = 0,
                done = 0,
                classCache = createCache(),
                tokenCache = createCache(),
                compilerCache = createCache(),
                sortOrder = function( a, b ) {
                    if ( a === b ) {
                        hasDuplicate = true;
                    }
                    return 0;
                },

                // General-purpose constants
                strundefined = typeof undefined,
                MAX_NEGATIVE = 1 << 31,

                // Instance methods
                hasOwn = ({}).hasOwnProperty,
                arr = [],
                pop = arr.pop,
                push_native = arr.push,
                push = arr.push,
                slice = arr.slice,
                // Use a stripped-down indexOf if we can't use a native one
                indexOf = arr.indexOf || function( elem ) {
                    var i = 0,
                        len = this.length;
                    for ( ; i < len; i++ ) {
                        if ( this[i] === elem ) {
                            return i;
                        }
                    }
                    return -1;
                },

                booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

                // Regular expressions

                // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
                whitespace = "[\\x20\\t\\r\\n\\f]",
                // http://www.w3.org/TR/css3-syntax/#characters
                characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

                // Loosely modeled on CSS identifier characters
                // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
                // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                identifier = characterEncoding.replace( "w", "w#" ),

                // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
                    // Operator (capture 2)
                    "*([*^$|!~]?=)" + whitespace +
                    // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                    "*\\]",

                pseudos = ":(" + characterEncoding + ")(?:\\((" +
                    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                    // 1. quoted (capture 3; capture 4 or capture 5)
                    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                    // 2. simple (capture 6)
                    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                    // 3. anything else (capture 2)
                    ".*" +
                    ")\\)|)",

                // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

                rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
                rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

                rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

                rpseudo = new RegExp( pseudos ),
                ridentifier = new RegExp( "^" + identifier + "$" ),

                matchExpr = {
                    "ID": new RegExp( "^#(" + characterEncoding + ")" ),
                    "CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
                    "TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
                    "ATTR": new RegExp( "^" + attributes ),
                    "PSEUDO": new RegExp( "^" + pseudos ),
                    "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                        "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                        "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
                    "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
                    // For use in libraries implementing .is()
                    // We use this for POS matching in `select`
                    "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                        whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
                },

                rinputs = /^(?:input|select|textarea|button)$/i,
                rheader = /^h\d$/i,

                rnative = /^[^{]+\{\s*\[native \w/,

                // Easily-parseable/retrievable ID or TAG or CLASS selectors
                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                rsibling = /[+~]/,
                rescape = /'|\\/g,

                // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
                funescape = function( _, escaped, escapedWhitespace ) {
                    var high = "0x" + escaped - 0x10000;
                    // NaN means non-codepoint
                    // Support: Firefox<24
                    // Workaround erroneous numeric interpretation of +"0x"
                    return high !== high || escapedWhitespace ?
                        escaped :
                        high < 0 ?
                            // BMP codepoint
                            String.fromCharCode( high + 0x10000 ) :
                            // Supplemental Plane codepoint (surrogate pair)
                            String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
                };

// Optimize for push.apply( _, NodeList )
            try {
                push.apply(
                    (arr = slice.call( preferredDoc.childNodes )),
                    preferredDoc.childNodes
                );
                // Support: Android<4.0
                // Detect silently failing push.apply
                arr[ preferredDoc.childNodes.length ].nodeType;
            } catch ( e ) {
                push = { apply: arr.length ?

                        // Leverage slice if possible
                        function( target, els ) {
                            push_native.apply( target, slice.call(els) );
                        } :

                        // Support: IE<9
                        // Otherwise append directly
                        function( target, els ) {
                            var j = target.length,
                                i = 0;
                            // Can't trust NodeList.length
                            while ( (target[j++] = els[i++]) ) {}
                            target.length = j - 1;
                        }
                };
            }

            function Sizzle( selector, context, results, seed ) {
                var match, elem, m, nodeType,
                    // QSA vars
                    i, groups, old, nid, newContext, newSelector;

                if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
                    setDocument( context );
                }

                context = context || document;
                results = results || [];

                if ( !selector || typeof selector !== "string" ) {
                    return results;
                }

                if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
                    return [];
                }

                if ( documentIsHTML && !seed ) {

                    // Shortcuts
                    if ( (match = rquickExpr.exec( selector )) ) {
                        // Speed-up: Sizzle("#ID")
                        if ( (m = match[1]) ) {
                            if ( nodeType === 9 ) {
                                elem = context.getElementById( m );
                                // Check parentNode to catch when Blackberry 4.6 returns
                                // nodes that are no longer in the document (jQuery #6963)
                                if ( elem && elem.parentNode ) {
                                    // Handle the case where IE, Opera, and Webkit return items
                                    // by name instead of ID
                                    if ( elem.id === m ) {
                                        results.push( elem );
                                        return results;
                                    }
                                } else {
                                    return results;
                                }
                            } else {
                                // Context is not a document
                                if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
                                    contains( context, elem ) && elem.id === m ) {
                                    results.push( elem );
                                    return results;
                                }
                            }

                            // Speed-up: Sizzle("TAG")
                        } else if ( match[2] ) {
                            push.apply( results, context.getElementsByTagName( selector ) );
                            return results;

                            // Speed-up: Sizzle(".CLASS")
                        } else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
                            push.apply( results, context.getElementsByClassName( m ) );
                            return results;
                        }
                    }

                    // QSA path
                    if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
                        nid = old = expando;
                        newContext = context;
                        newSelector = nodeType === 9 && selector;

                        // qSA works strangely on Element-rooted queries
                        // We can work around this by specifying an extra ID on the root
                        // and working up from there (Thanks to Andrew Dupont for the technique)
                        // IE 8 doesn't work on object elements
                        if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
                            groups = tokenize( selector );

                            if ( (old = context.getAttribute("id")) ) {
                                nid = old.replace( rescape, "\\$&" );
                            } else {
                                context.setAttribute( "id", nid );
                            }
                            nid = "[id='" + nid + "'] ";

                            i = groups.length;
                            while ( i-- ) {
                                groups[i] = nid + toSelector( groups[i] );
                            }
                            newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
                            newSelector = groups.join(",");
                        }

                        if ( newSelector ) {
                            try {
                                push.apply( results,
                                    newContext.querySelectorAll( newSelector )
                                );
                                return results;
                            } catch(qsaError) {
                            } finally {
                                if ( !old ) {
                                    context.removeAttribute("id");
                                }
                            }
                        }
                    }
                }

                // All others
                return select( selector.replace( rtrim, "$1" ), context, results, seed );
            }

            /**
             * Create key-value caches of limited size
             * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
             *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
             *	deleting the oldest entry
             */
            function createCache() {
                var keys = [];

                function cache( key, value ) {
                    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                    if ( keys.push( key + " " ) > Expr.cacheLength ) {
                        // Only keep the most recent entries
                        delete cache[ keys.shift() ];
                    }
                    return (cache[ key + " " ] = value);
                }
                return cache;
            }

            /**
             * Mark a function for special use by Sizzle
             * @param {Function} fn The function to mark
             */
            function markFunction( fn ) {
                fn[ expando ] = true;
                return fn;
            }

            /**
             * Support testing using an element
             * @param {Function} fn Passed the created div and expects a boolean result
             */
            function assert( fn ) {
                var div = document.createElement("div");

                try {
                    return !!fn( div );
                } catch (e) {
                    return false;
                } finally {
                    // Remove from its parent by default
                    if ( div.parentNode ) {
                        div.parentNode.removeChild( div );
                    }
                    // release memory in IE
                    div = null;
                }
            }

            /**
             * Adds the same handler for all of the specified attrs
             * @param {String} attrs Pipe-separated list of attributes
             * @param {Function} handler The method that will be applied
             */
            function addHandle( attrs, handler ) {
                var arr = attrs.split("|"),
                    i = attrs.length;

                while ( i-- ) {
                    Expr.attrHandle[ arr[i] ] = handler;
                }
            }

            /**
             * Checks document order of two siblings
             * @param {Element} a
             * @param {Element} b
             * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
             */
            function siblingCheck( a, b ) {
                var cur = b && a,
                    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                        ( ~b.sourceIndex || MAX_NEGATIVE ) -
                        ( ~a.sourceIndex || MAX_NEGATIVE );

                // Use IE sourceIndex if available on both nodes
                if ( diff ) {
                    return diff;
                }

                // Check if b follows a
                if ( cur ) {
                    while ( (cur = cur.nextSibling) ) {
                        if ( cur === b ) {
                            return -1;
                        }
                    }
                }

                return a ? 1 : -1;
            }

            /**
             * Returns a function to use in pseudos for input types
             * @param {String} type
             */
            function createInputPseudo( type ) {
                return function( elem ) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for buttons
             * @param {String} type
             */
            function createButtonPseudo( type ) {
                return function( elem ) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for positionals
             * @param {Function} fn
             */
            function createPositionalPseudo( fn ) {
                return markFunction(function( argument ) {
                    argument = +argument;
                    return markFunction(function( seed, matches ) {
                        var j,
                            matchIndexes = fn( [], seed.length, argument ),
                            i = matchIndexes.length;

                        // Match elements found at the specified indexes
                        while ( i-- ) {
                            if ( seed[ (j = matchIndexes[i]) ] ) {
                                seed[j] = !(matches[j] = seed[j]);
                            }
                        }
                    });
                });
            }

            /**
             * Checks a node for validity as a Sizzle context
             * @param {Element|Object=} context
             * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
             */
            function testContext( context ) {
                return context && typeof context.getElementsByTagName !== strundefined && context;
            }

// Expose support vars for convenience
            support = Sizzle.support = {};

            /**
             * Detects XML nodes
             * @param {Element|Object} elem An element or a document
             * @returns {Boolean} True iff elem is a non-HTML XML node
             */
            isXML = Sizzle.isXML = function( elem ) {
                // documentElement is verified for cases where it doesn't yet exist
                // (such as loading iframes in IE - #4833)
                var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                return documentElement ? documentElement.nodeName !== "HTML" : false;
            };

            /**
             * Sets document-related variables once based on the current document
             * @param {Element|Object} [doc] An element or document object to use to set the document
             * @returns {Object} Returns the current document
             */
            setDocument = Sizzle.setDocument = function( node ) {
                var hasCompare,
                    doc = node ? node.ownerDocument || node : preferredDoc,
                    parent = doc.defaultView;

                // If no document and documentElement is available, return
                if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
                    return document;
                }

                // Set our document
                document = doc;
                docElem = doc.documentElement;

                // Support tests
                documentIsHTML = !isXML( doc );

                // Support: IE>8
                // If iframe document is assigned to "document" variable and if iframe has been reloaded,
                // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
                // IE6-8 do not support the defaultView property so parent will be undefined
                if ( parent && parent !== parent.top ) {
                    // IE11 does not have attachEvent, so all must suffer
                    if ( parent.addEventListener ) {
                        parent.addEventListener( "unload", function() {
                            setDocument();
                        }, false );
                    } else if ( parent.attachEvent ) {
                        parent.attachEvent( "onunload", function() {
                            setDocument();
                        });
                    }
                }

                /* Attributes
	---------------------------------------------------------------------- */

                // Support: IE<8
                // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
                support.attributes = assert(function( div ) {
                    div.className = "i";
                    return !div.getAttribute("className");
                });

                /* getElement(s)By*
	---------------------------------------------------------------------- */

                // Check if getElementsByTagName("*") returns only elements
                support.getElementsByTagName = assert(function( div ) {
                    div.appendChild( doc.createComment("") );
                    return !div.getElementsByTagName("*").length;
                });

                // Check if getElementsByClassName can be trusted
                support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
                    div.innerHTML = "<div class='a'></div><div class='a i'></div>";

                    // Support: Safari<4
                    // Catch class over-caching
                    div.firstChild.className = "i";
                    // Support: Opera<10
                    // Catch gEBCN failure to find non-leading classes
                    return div.getElementsByClassName("i").length === 2;
                });

                // Support: IE<10
                // Check if getElementById returns elements by name
                // The broken getElementById methods don't pick up programatically-set names,
                // so use a roundabout getElementsByName test
                support.getById = assert(function( div ) {
                    docElem.appendChild( div ).id = expando;
                    return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
                });

                // ID find and filter
                if ( support.getById ) {
                    Expr.find["ID"] = function( id, context ) {
                        if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
                            var m = context.getElementById( id );
                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            return m && m.parentNode ? [ m ] : [];
                        }
                    };
                    Expr.filter["ID"] = function( id ) {
                        var attrId = id.replace( runescape, funescape );
                        return function( elem ) {
                            return elem.getAttribute("id") === attrId;
                        };
                    };
                } else {
                    // Support: IE6/7
                    // getElementById is not reliable as a find shortcut
                    delete Expr.find["ID"];

                    Expr.filter["ID"] =  function( id ) {
                        var attrId = id.replace( runescape, funescape );
                        return function( elem ) {
                            var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                            return node && node.value === attrId;
                        };
                    };
                }

                // Tag
                Expr.find["TAG"] = support.getElementsByTagName ?
                    function( tag, context ) {
                        if ( typeof context.getElementsByTagName !== strundefined ) {
                            return context.getElementsByTagName( tag );
                        }
                    } :
                    function( tag, context ) {
                        var elem,
                            tmp = [],
                            i = 0,
                            results = context.getElementsByTagName( tag );

                        // Filter out possible comments
                        if ( tag === "*" ) {
                            while ( (elem = results[i++]) ) {
                                if ( elem.nodeType === 1 ) {
                                    tmp.push( elem );
                                }
                            }

                            return tmp;
                        }
                        return results;
                    };

                // Class
                Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
                    if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
                        return context.getElementsByClassName( className );
                    }
                };

                /* QSA/matchesSelector
	---------------------------------------------------------------------- */

                // QSA and matchesSelector support

                // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                rbuggyMatches = [];

                // qSa(:focus) reports false when true (Chrome 21)
                // We allow this because of a bug in IE8/9 that throws an error
                // whenever `document.activeElement` is accessed on an iframe
                // So, we allow :focus to pass through QSA all the time to avoid the IE error
                // See http://bugs.jquery.com/ticket/13378
                rbuggyQSA = [];

                if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
                    // Build QSA regex
                    // Regex strategy adopted from Diego Perini
                    assert(function( div ) {
                        // Select is set to empty string on purpose
                        // This is to test IE's treatment of not explicitly
                        // setting a boolean content attribute,
                        // since its presence should be enough
                        // http://bugs.jquery.com/ticket/12359
                        div.innerHTML = "<select msallowclip=''><option selected=''></option></select>";

                        // Support: IE8, Opera 11-12.16
                        // Nothing should be selected when empty strings follow ^= or $= or *=
                        // The test attribute must be unknown in Opera but "safe" for WinRT
                        // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                        if ( div.querySelectorAll("[msallowclip^='']").length ) {
                            rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
                        }

                        // Support: IE8
                        // Boolean attributes and "value" are not treated correctly
                        if ( !div.querySelectorAll("[selected]").length ) {
                            rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
                        }

                        // Webkit/Opera - :checked should return selected option elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        // IE8 throws error here and will not see later tests
                        if ( !div.querySelectorAll(":checked").length ) {
                            rbuggyQSA.push(":checked");
                        }
                    });

                    assert(function( div ) {
                        // Support: Windows 8 Native Apps
                        // The type and name attributes are restricted during .innerHTML assignment
                        var input = doc.createElement("input");
                        input.setAttribute( "type", "hidden" );
                        div.appendChild( input ).setAttribute( "name", "D" );

                        // Support: IE8
                        // Enforce case-sensitivity of name attribute
                        if ( div.querySelectorAll("[name=d]").length ) {
                            rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
                        }

                        // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                        // IE8 throws error here and will not see later tests
                        if ( !div.querySelectorAll(":enabled").length ) {
                            rbuggyQSA.push( ":enabled", ":disabled" );
                        }

                        // Opera 10-11 does not throw on post-comma invalid pseudos
                        div.querySelectorAll("*,:x");
                        rbuggyQSA.push(",.*:");
                    });
                }

                if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
                        docElem.webkitMatchesSelector ||
                        docElem.mozMatchesSelector ||
                        docElem.oMatchesSelector ||
                        docElem.msMatchesSelector) )) ) {

                    assert(function( div ) {
                        // Check to see if it's possible to do matchesSelector
                        // on a disconnected node (IE 9)
                        support.disconnectedMatch = matches.call( div, "div" );

                        // This should fail with an exception
                        // Gecko does not error, returns false instead
                        matches.call( div, "[s!='']:x" );
                        rbuggyMatches.push( "!=", pseudos );
                    });
                }

                rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
                rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

                /* Contains
	---------------------------------------------------------------------- */
                hasCompare = rnative.test( docElem.compareDocumentPosition );

                // Element contains another
                // Purposefully does not implement inclusive descendent
                // As in, an element does not contain itself
                contains = hasCompare || rnative.test( docElem.contains ) ?
                    function( a, b ) {
                        var adown = a.nodeType === 9 ? a.documentElement : a,
                            bup = b && b.parentNode;
                        return a === bup || !!( bup && bup.nodeType === 1 && (
                            adown.contains ?
                                adown.contains( bup ) :
                                a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
                        ));
                    } :
                    function( a, b ) {
                        if ( b ) {
                            while ( (b = b.parentNode) ) {
                                if ( b === a ) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };

                /* Sorting
	---------------------------------------------------------------------- */

                // Document order sorting
                sortOrder = hasCompare ?
                    function( a, b ) {

                        // Flag for duplicate removal
                        if ( a === b ) {
                            hasDuplicate = true;
                            return 0;
                        }

                        // Sort on method existence if only one input has compareDocumentPosition
                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        if ( compare ) {
                            return compare;
                        }

                        // Calculate position if both inputs belong to the same document
                        compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
                            a.compareDocumentPosition( b ) :

                            // Otherwise we know they are disconnected
                            1;

                        // Disconnected nodes
                        if ( compare & 1 ||
                            (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

                            // Choose the first element that is related to our preferred document
                            if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
                                return -1;
                            }
                            if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
                                return 1;
                            }

                            // Maintain original order
                            return sortInput ?
                                ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                                0;
                        }

                        return compare & 4 ? -1 : 1;
                    } :
                    function( a, b ) {
                        // Exit early if the nodes are identical
                        if ( a === b ) {
                            hasDuplicate = true;
                            return 0;
                        }

                        var cur,
                            i = 0,
                            aup = a.parentNode,
                            bup = b.parentNode,
                            ap = [ a ],
                            bp = [ b ];

                        // Parentless nodes are either documents or disconnected
                        if ( !aup || !bup ) {
                            return a === doc ? -1 :
                                b === doc ? 1 :
                                    aup ? -1 :
                                        bup ? 1 :
                                            sortInput ?
                                                ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                                                0;

                            // If the nodes are siblings, we can do a quick check
                        } else if ( aup === bup ) {
                            return siblingCheck( a, b );
                        }

                        // Otherwise we need full lists of their ancestors for comparison
                        cur = a;
                        while ( (cur = cur.parentNode) ) {
                            ap.unshift( cur );
                        }
                        cur = b;
                        while ( (cur = cur.parentNode) ) {
                            bp.unshift( cur );
                        }

                        // Walk down the tree looking for a discrepancy
                        while ( ap[i] === bp[i] ) {
                            i++;
                        }

                        return i ?
                            // Do a sibling check if the nodes have a common ancestor
                            siblingCheck( ap[i], bp[i] ) :

                            // Otherwise nodes in our document sort first
                            ap[i] === preferredDoc ? -1 :
                                bp[i] === preferredDoc ? 1 :
                                    0;
                    };

                return doc;
            };

            Sizzle.matches = function( expr, elements ) {
                return Sizzle( expr, null, null, elements );
            };

            Sizzle.matchesSelector = function( elem, expr ) {
                // Set document vars if needed
                if ( ( elem.ownerDocument || elem ) !== document ) {
                    setDocument( elem );
                }

                // Make sure that attribute selectors are quoted
                expr = expr.replace( rattributeQuotes, "='$1']" );

                if ( support.matchesSelector && documentIsHTML &&
                    ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
                    ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

                    try {
                        var ret = matches.call( elem, expr );

                        // IE 9's matchesSelector returns false on disconnected nodes
                        if ( ret || support.disconnectedMatch ||
                            // As well, disconnected nodes are said to be in a document
                            // fragment in IE 9
                            elem.document && elem.document.nodeType !== 11 ) {
                            return ret;
                        }
                    } catch(e) {}
                }

                return Sizzle( expr, document, null, [ elem ] ).length > 0;
            };

            Sizzle.contains = function( context, elem ) {
                // Set document vars if needed
                if ( ( context.ownerDocument || context ) !== document ) {
                    setDocument( context );
                }
                return contains( context, elem );
            };

            Sizzle.attr = function( elem, name ) {
                // Set document vars if needed
                if ( ( elem.ownerDocument || elem ) !== document ) {
                    setDocument( elem );
                }

                var fn = Expr.attrHandle[ name.toLowerCase() ],
                    // Don't get fooled by Object.prototype properties (jQuery #13807)
                    val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
                        fn( elem, name, !documentIsHTML ) :
                        undefined;

                return val !== undefined ?
                    val :
                    support.attributes || !documentIsHTML ?
                        elem.getAttribute( name ) :
                        (val = elem.getAttributeNode(name)) && val.specified ?
                            val.value :
                            null;
            };

            Sizzle.error = function( msg ) {
                throw new Error( "Syntax error, unrecognized expression: " + msg );
            };

            /**
             * Document sorting and removing duplicates
             * @param {ArrayLike} results
             */
            Sizzle.uniqueSort = function( results ) {
                var elem,
                    duplicates = [],
                    j = 0,
                    i = 0;

                // Unless we *know* we can detect duplicates, assume their presence
                hasDuplicate = !support.detectDuplicates;
                sortInput = !support.sortStable && results.slice( 0 );
                results.sort( sortOrder );

                if ( hasDuplicate ) {
                    while ( (elem = results[i++]) ) {
                        if ( elem === results[ i ] ) {
                            j = duplicates.push( i );
                        }
                    }
                    while ( j-- ) {
                        results.splice( duplicates[ j ], 1 );
                    }
                }

                // Clear input after sorting to release objects
                // See https://github.com/jquery/sizzle/pull/225
                sortInput = null;

                return results;
            };

            /**
             * Utility function for retrieving the text value of an array of DOM nodes
             * @param {Array|Element} elem
             */
            getText = Sizzle.getText = function( elem ) {
                var node,
                    ret = "",
                    i = 0,
                    nodeType = elem.nodeType;

                if ( !nodeType ) {
                    // If no nodeType, this is expected to be an array
                    while ( (node = elem[i++]) ) {
                        // Do not traverse comment nodes
                        ret += getText( node );
                    }
                } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
                    // Use textContent for elements
                    // innerText usage removed for consistency of new lines (jQuery #11153)
                    if ( typeof elem.textContent === "string" ) {
                        return elem.textContent;
                    } else {
                        // Traverse its children
                        for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                            ret += getText( elem );
                        }
                    }
                } else if ( nodeType === 3 || nodeType === 4 ) {
                    return elem.nodeValue;
                }
                // Do not include comment or processing instruction nodes

                return ret;
            };

            Expr = Sizzle.selectors = {

                // Can be adjusted by the user
                cacheLength: 50,

                createPseudo: markFunction,

                match: matchExpr,

                attrHandle: {},

                find: {},

                relative: {
                    ">": { dir: "parentNode", first: true },
                    " ": { dir: "parentNode" },
                    "+": { dir: "previousSibling", first: true },
                    "~": { dir: "previousSibling" }
                },

                preFilter: {
                    "ATTR": function( match ) {
                        match[1] = match[1].replace( runescape, funescape );

                        // Move the given value to match[3] whether quoted or unquoted
                        match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

                        if ( match[2] === "~=" ) {
                            match[3] = " " + match[3] + " ";
                        }

                        return match.slice( 0, 4 );
                    },

                    "CHILD": function( match ) {
                        /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                        match[1] = match[1].toLowerCase();

                        if ( match[1].slice( 0, 3 ) === "nth" ) {
                            // nth-* requires argument
                            if ( !match[3] ) {
                                Sizzle.error( match[0] );
                            }

                            // numeric x and y parameters for Expr.filter.CHILD
                            // remember that false/true cast respectively to 0/1
                            match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                            match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

                            // other types prohibit arguments
                        } else if ( match[3] ) {
                            Sizzle.error( match[0] );
                        }

                        return match;
                    },

                    "PSEUDO": function( match ) {
                        var excess,
                            unquoted = !match[6] && match[2];

                        if ( matchExpr["CHILD"].test( match[0] ) ) {
                            return null;
                        }

                        // Accept quoted arguments as-is
                        if ( match[3] ) {
                            match[2] = match[4] || match[5] || "";

                            // Strip excess characters from unquoted arguments
                        } else if ( unquoted && rpseudo.test( unquoted ) &&
                            // Get excess from tokenize (recursively)
                            (excess = tokenize( unquoted, true )) &&
                            // advance to the next closing parenthesis
                            (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

                            // excess is a negative index
                            match[0] = match[0].slice( 0, excess );
                            match[2] = unquoted.slice( 0, excess );
                        }

                        // Return only captures needed by the pseudo filter method (type and argument)
                        return match.slice( 0, 3 );
                    }
                },

                filter: {

                    "TAG": function( nodeNameSelector ) {
                        var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
                        return nodeNameSelector === "*" ?
                            function() { return true; } :
                            function( elem ) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                            };
                    },

                    "CLASS": function( className ) {
                        var pattern = classCache[ className + " " ];

                        return pattern ||
                            (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                            classCache( className, function( elem ) {
                                return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
                            });
                    },

                    "ATTR": function( name, operator, check ) {
                        return function( elem ) {
                            var result = Sizzle.attr( elem, name );

                            if ( result == null ) {
                                return operator === "!=";
                            }
                            if ( !operator ) {
                                return true;
                            }

                            result += "";

                            return operator === "=" ? result === check :
                                operator === "!=" ? result !== check :
                                    operator === "^=" ? check && result.indexOf( check ) === 0 :
                                        operator === "*=" ? check && result.indexOf( check ) > -1 :
                                            operator === "$=" ? check && result.slice( -check.length ) === check :
                                                operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
                                                    operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                                                        false;
                        };
                    },

                    "CHILD": function( type, what, argument, first, last ) {
                        var simple = type.slice( 0, 3 ) !== "nth",
                            forward = type.slice( -4 ) !== "last",
                            ofType = what === "of-type";

                        return first === 1 && last === 0 ?

                            // Shortcut for :nth-*(n)
                            function( elem ) {
                                return !!elem.parentNode;
                            } :

                            function( elem, context, xml ) {
                                var cache, outerCache, node, diff, nodeIndex, start,
                                    dir = simple !== forward ? "nextSibling" : "previousSibling",
                                    parent = elem.parentNode,
                                    name = ofType && elem.nodeName.toLowerCase(),
                                    useCache = !xml && !ofType;

                                if ( parent ) {

                                    // :(first|last|only)-(child|of-type)
                                    if ( simple ) {
                                        while ( dir ) {
                                            node = elem;
                                            while ( (node = node[ dir ]) ) {
                                                if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
                                                    return false;
                                                }
                                            }
                                            // Reverse direction for :only-* (if we haven't yet done so)
                                            start = dir = type === "only" && !start && "nextSibling";
                                        }
                                        return true;
                                    }

                                    start = [ forward ? parent.firstChild : parent.lastChild ];

                                    // non-xml :nth-child(...) stores cache data on `parent`
                                    if ( forward && useCache ) {
                                        // Seek `elem` from a previously-cached index
                                        outerCache = parent[ expando ] || (parent[ expando ] = {});
                                        cache = outerCache[ type ] || [];
                                        nodeIndex = cache[0] === dirruns && cache[1];
                                        diff = cache[0] === dirruns && cache[2];
                                        node = nodeIndex && parent.childNodes[ nodeIndex ];

                                        while ( (node = ++nodeIndex && node && node[ dir ] ||

                                            // Fallback to seeking `elem` from the start
                                            (diff = nodeIndex = 0) || start.pop()) ) {

                                            // When found, cache indexes on `parent` and break
                                            if ( node.nodeType === 1 && ++diff && node === elem ) {
                                                outerCache[ type ] = [ dirruns, nodeIndex, diff ];
                                                break;
                                            }
                                        }

                                        // Use previously-cached element index if available
                                    } else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
                                        diff = cache[1];

                                        // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                    } else {
                                        // Use the same loop as above to seek `elem` from the start
                                        while ( (node = ++nodeIndex && node && node[ dir ] ||
                                            (diff = nodeIndex = 0) || start.pop()) ) {

                                            if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
                                                // Cache the index of each encountered element
                                                if ( useCache ) {
                                                    (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
                                                }

                                                if ( node === elem ) {
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    // Incorporate the offset, then check against cycle size
                                    diff -= last;
                                    return diff === first || ( diff % first === 0 && diff / first >= 0 );
                                }
                            };
                    },

                    "PSEUDO": function( pseudo, argument ) {
                        // pseudo-class names are case-insensitive
                        // http://www.w3.org/TR/selectors/#pseudo-classes
                        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                        // Remember that setFilters inherits from pseudos
                        var args,
                            fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                                Sizzle.error( "unsupported pseudo: " + pseudo );

                        // The user may use createPseudo to indicate that
                        // arguments are needed to create the filter function
                        // just as Sizzle does
                        if ( fn[ expando ] ) {
                            return fn( argument );
                        }

                        // But maintain support for old signatures
                        if ( fn.length > 1 ) {
                            args = [ pseudo, pseudo, "", argument ];
                            return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                                markFunction(function( seed, matches ) {
                                    var idx,
                                        matched = fn( seed, argument ),
                                        i = matched.length;
                                    while ( i-- ) {
                                        idx = indexOf.call( seed, matched[i] );
                                        seed[ idx ] = !( matches[ idx ] = matched[i] );
                                    }
                                }) :
                                function( elem ) {
                                    return fn( elem, 0, args );
                                };
                        }

                        return fn;
                    }
                },

                pseudos: {
                    // Potentially complex pseudos
                    "not": markFunction(function( selector ) {
                        // Trim the selector passed to compile
                        // to avoid treating leading and trailing
                        // spaces as combinators
                        var input = [],
                            results = [],
                            matcher = compile( selector.replace( rtrim, "$1" ) );

                        return matcher[ expando ] ?
                            markFunction(function( seed, matches, context, xml ) {
                                var elem,
                                    unmatched = matcher( seed, null, xml, [] ),
                                    i = seed.length;

                                // Match elements unmatched by `matcher`
                                while ( i-- ) {
                                    if ( (elem = unmatched[i]) ) {
                                        seed[i] = !(matches[i] = elem);
                                    }
                                }
                            }) :
                            function( elem, context, xml ) {
                                input[0] = elem;
                                matcher( input, null, xml, results );
                                return !results.pop();
                            };
                    }),

                    "has": markFunction(function( selector ) {
                        return function( elem ) {
                            return Sizzle( selector, elem ).length > 0;
                        };
                    }),

                    "contains": markFunction(function( text ) {
                        return function( elem ) {
                            return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
                        };
                    }),

                    // "Whether an element is represented by a :lang() selector
                    // is based solely on the element's language value
                    // being equal to the identifier C,
                    // or beginning with the identifier C immediately followed by "-".
                    // The matching of C against the element's language value is performed case-insensitively.
                    // The identifier C does not have to be a valid language name."
                    // http://www.w3.org/TR/selectors/#lang-pseudo
                    "lang": markFunction( function( lang ) {
                        // lang value must be a valid identifier
                        if ( !ridentifier.test(lang || "") ) {
                            Sizzle.error( "unsupported lang: " + lang );
                        }
                        lang = lang.replace( runescape, funescape ).toLowerCase();
                        return function( elem ) {
                            var elemLang;
                            do {
                                if ( (elemLang = documentIsHTML ?
                                        elem.lang :
                                        elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

                                    elemLang = elemLang.toLowerCase();
                                    return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                                }
                            } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
                            return false;
                        };
                    }),

                    // Miscellaneous
                    "target": function( elem ) {
                        var hash = window.location && window.location.hash;
                        return hash && hash.slice( 1 ) === elem.id;
                    },

                    "root": function( elem ) {
                        return elem === docElem;
                    },

                    "focus": function( elem ) {
                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                    },

                    // Boolean properties
                    "enabled": function( elem ) {
                        return elem.disabled === false;
                    },

                    "disabled": function( elem ) {
                        return elem.disabled === true;
                    },

                    "checked": function( elem ) {
                        // In CSS3, :checked should return both checked and selected elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        var nodeName = elem.nodeName.toLowerCase();
                        return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                    },

                    "selected": function( elem ) {
                        // Accessing this property makes selected-by-default
                        // options in Safari work properly
                        if ( elem.parentNode ) {
                            elem.parentNode.selectedIndex;
                        }

                        return elem.selected === true;
                    },

                    // Contents
                    "empty": function( elem ) {
                        // http://www.w3.org/TR/selectors/#empty-pseudo
                        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                        //   but not by others (comment: 8; processing instruction: 7; etc.)
                        // nodeType < 6 works because attributes (2) do not appear as children
                        for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                            if ( elem.nodeType < 6 ) {
                                return false;
                            }
                        }
                        return true;
                    },

                    "parent": function( elem ) {
                        return !Expr.pseudos["empty"]( elem );
                    },

                    // Element/input types
                    "header": function( elem ) {
                        return rheader.test( elem.nodeName );
                    },

                    "input": function( elem ) {
                        return rinputs.test( elem.nodeName );
                    },

                    "button": function( elem ) {
                        var name = elem.nodeName.toLowerCase();
                        return name === "input" && elem.type === "button" || name === "button";
                    },

                    "text": function( elem ) {
                        var attr;
                        return elem.nodeName.toLowerCase() === "input" &&
                            elem.type === "text" &&

                            // Support: IE<8
                            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                            ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
                    },

                    // Position-in-collection
                    "first": createPositionalPseudo(function() {
                        return [ 0 ];
                    }),

                    "last": createPositionalPseudo(function( matchIndexes, length ) {
                        return [ length - 1 ];
                    }),

                    "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
                        return [ argument < 0 ? argument + length : argument ];
                    }),

                    "even": createPositionalPseudo(function( matchIndexes, length ) {
                        var i = 0;
                        for ( ; i < length; i += 2 ) {
                            matchIndexes.push( i );
                        }
                        return matchIndexes;
                    }),

                    "odd": createPositionalPseudo(function( matchIndexes, length ) {
                        var i = 1;
                        for ( ; i < length; i += 2 ) {
                            matchIndexes.push( i );
                        }
                        return matchIndexes;
                    }),

                    "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                        var i = argument < 0 ? argument + length : argument;
                        for ( ; --i >= 0; ) {
                            matchIndexes.push( i );
                        }
                        return matchIndexes;
                    }),

                    "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                        var i = argument < 0 ? argument + length : argument;
                        for ( ; ++i < length; ) {
                            matchIndexes.push( i );
                        }
                        return matchIndexes;
                    })
                }
            };

            Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
            for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
                Expr.pseudos[ i ] = createInputPseudo( i );
            }
            for ( i in { submit: true, reset: true } ) {
                Expr.pseudos[ i ] = createButtonPseudo( i );
            }

// Easy API for creating new setFilters
            function setFilters() {}
            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();

            tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
                var matched, match, tokens, type,
                    soFar, groups, preFilters,
                    cached = tokenCache[ selector + " " ];

                if ( cached ) {
                    return parseOnly ? 0 : cached.slice( 0 );
                }

                soFar = selector;
                groups = [];
                preFilters = Expr.preFilter;

                while ( soFar ) {

                    // Comma and first run
                    if ( !matched || (match = rcomma.exec( soFar )) ) {
                        if ( match ) {
                            // Don't consume trailing commas as valid
                            soFar = soFar.slice( match[0].length ) || soFar;
                        }
                        groups.push( (tokens = []) );
                    }

                    matched = false;

                    // Combinators
                    if ( (match = rcombinators.exec( soFar )) ) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            // Cast descendant combinators to space
                            type: match[0].replace( rtrim, " " )
                        });
                        soFar = soFar.slice( matched.length );
                    }

                    // Filters
                    for ( type in Expr.filter ) {
                        if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                                (match = preFilters[ type ]( match ))) ) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: type,
                                matches: match
                            });
                            soFar = soFar.slice( matched.length );
                        }
                    }

                    if ( !matched ) {
                        break;
                    }
                }

                // Return the length of the invalid excess
                // if we're just parsing
                // Otherwise, throw an error or return tokens
                return parseOnly ?
                    soFar.length :
                    soFar ?
                        Sizzle.error( selector ) :
                        // Cache the tokens
                        tokenCache( selector, groups ).slice( 0 );
            };

            function toSelector( tokens ) {
                var i = 0,
                    len = tokens.length,
                    selector = "";
                for ( ; i < len; i++ ) {
                    selector += tokens[i].value;
                }
                return selector;
            }

            function addCombinator( matcher, combinator, base ) {
                var dir = combinator.dir,
                    checkNonElements = base && dir === "parentNode",
                    doneName = done++;

                return combinator.first ?
                    // Check against closest ancestor/preceding element
                    function( elem, context, xml ) {
                        while ( (elem = elem[ dir ]) ) {
                            if ( elem.nodeType === 1 || checkNonElements ) {
                                return matcher( elem, context, xml );
                            }
                        }
                    } :

                    // Check against all ancestor/preceding elements
                    function( elem, context, xml ) {
                        var oldCache, outerCache,
                            newCache = [ dirruns, doneName ];

                        // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                        if ( xml ) {
                            while ( (elem = elem[ dir ]) ) {
                                if ( elem.nodeType === 1 || checkNonElements ) {
                                    if ( matcher( elem, context, xml ) ) {
                                        return true;
                                    }
                                }
                            }
                        } else {
                            while ( (elem = elem[ dir ]) ) {
                                if ( elem.nodeType === 1 || checkNonElements ) {
                                    outerCache = elem[ expando ] || (elem[ expando ] = {});
                                    if ( (oldCache = outerCache[ dir ]) &&
                                        oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

                                        // Assign to newCache so results back-propagate to previous elements
                                        return (newCache[ 2 ] = oldCache[ 2 ]);
                                    } else {
                                        // Reuse newcache so results back-propagate to previous elements
                                        outerCache[ dir ] = newCache;

                                        // A match means we're done; a fail means we have to keep checking
                                        if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    };
            }

            function elementMatcher( matchers ) {
                return matchers.length > 1 ?
                    function( elem, context, xml ) {
                        var i = matchers.length;
                        while ( i-- ) {
                            if ( !matchers[i]( elem, context, xml ) ) {
                                return false;
                            }
                        }
                        return true;
                    } :
                    matchers[0];
            }

            function multipleContexts( selector, contexts, results ) {
                var i = 0,
                    len = contexts.length;
                for ( ; i < len; i++ ) {
                    Sizzle( selector, contexts[i], results );
                }
                return results;
            }

            function condense( unmatched, map, filter, context, xml ) {
                var elem,
                    newUnmatched = [],
                    i = 0,
                    len = unmatched.length,
                    mapped = map != null;

                for ( ; i < len; i++ ) {
                    if ( (elem = unmatched[i]) ) {
                        if ( !filter || filter( elem, context, xml ) ) {
                            newUnmatched.push( elem );
                            if ( mapped ) {
                                map.push( i );
                            }
                        }
                    }
                }

                return newUnmatched;
            }

            function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
                if ( postFilter && !postFilter[ expando ] ) {
                    postFilter = setMatcher( postFilter );
                }
                if ( postFinder && !postFinder[ expando ] ) {
                    postFinder = setMatcher( postFinder, postSelector );
                }
                return markFunction(function( seed, results, context, xml ) {
                    var temp, i, elem,
                        preMap = [],
                        postMap = [],
                        preexisting = results.length,

                        // Get initial elements from seed or context
                        elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

                        // Prefilter to get matcher input, preserving a map for seed-results synchronization
                        matcherIn = preFilter && ( seed || !selector ) ?
                            condense( elems, preMap, preFilter, context, xml ) :
                            elems,

                        matcherOut = matcher ?
                            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                            postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                                // ...intermediate processing is necessary
                                [] :

                                // ...otherwise use results directly
                                results :
                            matcherIn;

                    // Find primary matches
                    if ( matcher ) {
                        matcher( matcherIn, matcherOut, context, xml );
                    }

                    // Apply postFilter
                    if ( postFilter ) {
                        temp = condense( matcherOut, postMap );
                        postFilter( temp, [], context, xml );

                        // Un-match failing elements by moving them back to matcherIn
                        i = temp.length;
                        while ( i-- ) {
                            if ( (elem = temp[i]) ) {
                                matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                            }
                        }
                    }

                    if ( seed ) {
                        if ( postFinder || preFilter ) {
                            if ( postFinder ) {
                                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                temp = [];
                                i = matcherOut.length;
                                while ( i-- ) {
                                    if ( (elem = matcherOut[i]) ) {
                                        // Restore matcherIn since elem is not yet a final match
                                        temp.push( (matcherIn[i] = elem) );
                                    }
                                }
                                postFinder( null, (matcherOut = []), temp, xml );
                            }

                            // Move matched elements from seed to results to keep them synchronized
                            i = matcherOut.length;
                            while ( i-- ) {
                                if ( (elem = matcherOut[i]) &&
                                    (temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

                                    seed[temp] = !(results[temp] = elem);
                                }
                            }
                        }

                        // Add elements to results, through postFinder if defined
                    } else {
                        matcherOut = condense(
                            matcherOut === results ?
                                matcherOut.splice( preexisting, matcherOut.length ) :
                                matcherOut
                        );
                        if ( postFinder ) {
                            postFinder( null, results, matcherOut, xml );
                        } else {
                            push.apply( results, matcherOut );
                        }
                    }
                });
            }

            function matcherFromTokens( tokens ) {
                var checkContext, matcher, j,
                    len = tokens.length,
                    leadingRelative = Expr.relative[ tokens[0].type ],
                    implicitRelative = leadingRelative || Expr.relative[" "],
                    i = leadingRelative ? 1 : 0,

                    // The foundational matcher ensures that elements are reachable from top-level context(s)
                    matchContext = addCombinator( function( elem ) {
                        return elem === checkContext;
                    }, implicitRelative, true ),
                    matchAnyContext = addCombinator( function( elem ) {
                        return indexOf.call( checkContext, elem ) > -1;
                    }, implicitRelative, true ),
                    matchers = [ function( elem, context, xml ) {
                        return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                            (checkContext = context).nodeType ?
                                matchContext( elem, context, xml ) :
                                matchAnyContext( elem, context, xml ) );
                    } ];

                for ( ; i < len; i++ ) {
                    if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
                        matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
                    } else {
                        matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

                        // Return special upon seeing a positional matcher
                        if ( matcher[ expando ] ) {
                            // Find the next relative operator (if any) for proper handling
                            j = ++i;
                            for ( ; j < len; j++ ) {
                                if ( Expr.relative[ tokens[j].type ] ) {
                                    break;
                                }
                            }
                            return setMatcher(
                                i > 1 && elementMatcher( matchers ),
                                i > 1 && toSelector(
                                // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
                                ).replace( rtrim, "$1" ),
                                matcher,
                                i < j && matcherFromTokens( tokens.slice( i, j ) ),
                                j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                                j < len && toSelector( tokens )
                            );
                        }
                        matchers.push( matcher );
                    }
                }

                return elementMatcher( matchers );
            }

            function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
                var bySet = setMatchers.length > 0,
                    byElement = elementMatchers.length > 0,
                    superMatcher = function( seed, context, xml, results, outermost ) {
                        var elem, j, matcher,
                            matchedCount = 0,
                            i = "0",
                            unmatched = seed && [],
                            setMatched = [],
                            contextBackup = outermostContext,
                            // We must always have either seed elements or outermost context
                            elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
                            // Use integer dirruns iff this is the outermost matcher
                            dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                            len = elems.length;

                        if ( outermost ) {
                            outermostContext = context !== document && context;
                        }

                        // Add elements passing elementMatchers directly to results
                        // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                        // Support: IE<9, Safari
                        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                        for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
                            if ( byElement && elem ) {
                                j = 0;
                                while ( (matcher = elementMatchers[j++]) ) {
                                    if ( matcher( elem, context, xml ) ) {
                                        results.push( elem );
                                        break;
                                    }
                                }
                                if ( outermost ) {
                                    dirruns = dirrunsUnique;
                                }
                            }

                            // Track unmatched elements for set filters
                            if ( bySet ) {
                                // They will have gone through all possible matchers
                                if ( (elem = !matcher && elem) ) {
                                    matchedCount--;
                                }

                                // Lengthen the array for every element, matched or not
                                if ( seed ) {
                                    unmatched.push( elem );
                                }
                            }
                        }

                        // Apply set filters to unmatched elements
                        matchedCount += i;
                        if ( bySet && i !== matchedCount ) {
                            j = 0;
                            while ( (matcher = setMatchers[j++]) ) {
                                matcher( unmatched, setMatched, context, xml );
                            }

                            if ( seed ) {
                                // Reintegrate element matches to eliminate the need for sorting
                                if ( matchedCount > 0 ) {
                                    while ( i-- ) {
                                        if ( !(unmatched[i] || setMatched[i]) ) {
                                            setMatched[i] = pop.call( results );
                                        }
                                    }
                                }

                                // Discard index placeholder values to get only actual matches
                                setMatched = condense( setMatched );
                            }

                            // Add matches to results
                            push.apply( results, setMatched );

                            // Seedless set matches succeeding multiple successful matchers stipulate sorting
                            if ( outermost && !seed && setMatched.length > 0 &&
                                ( matchedCount + setMatchers.length ) > 1 ) {

                                Sizzle.uniqueSort( results );
                            }
                        }

                        // Override manipulation of globals by nested matchers
                        if ( outermost ) {
                            dirruns = dirrunsUnique;
                            outermostContext = contextBackup;
                        }

                        return unmatched;
                    };

                return bySet ?
                    markFunction( superMatcher ) :
                    superMatcher;
            }

            compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
                var i,
                    setMatchers = [],
                    elementMatchers = [],
                    cached = compilerCache[ selector + " " ];

                if ( !cached ) {
                    // Generate a function of recursive functions that can be used to check each element
                    if ( !match ) {
                        match = tokenize( selector );
                    }
                    i = match.length;
                    while ( i-- ) {
                        cached = matcherFromTokens( match[i] );
                        if ( cached[ expando ] ) {
                            setMatchers.push( cached );
                        } else {
                            elementMatchers.push( cached );
                        }
                    }

                    // Cache the compiled function
                    cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

                    // Save selector and tokenization
                    cached.selector = selector;
                }
                return cached;
            };

            /**
             * A low-level selection function that works with Sizzle's compiled
             *  selector functions
             * @param {String|Function} selector A selector or a pre-compiled
             *  selector function built with Sizzle.compile
             * @param {Element} context
             * @param {Array} [results]
             * @param {Array} [seed] A set of elements to match against
             */
            select = Sizzle.select = function( selector, context, results, seed ) {
                var i, tokens, token, type, find,
                    compiled = typeof selector === "function" && selector,
                    match = !seed && tokenize( (selector = compiled.selector || selector) );

                results = results || [];

                // Try to minimize operations if there is no seed and only one group
                if ( match.length === 1 ) {

                    // Take a shortcut and set the context if the root selector is an ID
                    tokens = match[0] = match[0].slice( 0 );
                    if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                        support.getById && context.nodeType === 9 && documentIsHTML &&
                        Expr.relative[ tokens[1].type ] ) {

                        context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
                        if ( !context ) {
                            return results;

                            // Precompiled matchers will still verify ancestry, so step up a level
                        } else if ( compiled ) {
                            context = context.parentNode;
                        }

                        selector = selector.slice( tokens.shift().value.length );
                    }

                    // Fetch a seed set for right-to-left matching
                    i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
                    while ( i-- ) {
                        token = tokens[i];

                        // Abort if we hit a combinator
                        if ( Expr.relative[ (type = token.type) ] ) {
                            break;
                        }
                        if ( (find = Expr.find[ type ]) ) {
                            // Search, expanding context for leading sibling combinators
                            if ( (seed = find(
                                    token.matches[0].replace( runescape, funescape ),
                                    rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
                                )) ) {

                                // If seed is empty or no tokens remain, we can return early
                                tokens.splice( i, 1 );
                                selector = seed.length && toSelector( tokens );
                                if ( !selector ) {
                                    push.apply( results, seed );
                                    return results;
                                }

                                break;
                            }
                        }
                    }
                }

                // Compile and execute a filtering function if one is not provided
                // Provide `match` to avoid retokenization if we modified the selector above
                ( compiled || compile( selector, match ) )(
                    seed,
                    context,
                    !documentIsHTML,
                    results,
                    rsibling.test( selector ) && testContext( context.parentNode ) || context
                );
                return results;
            };

// One-time assignments

// Sort stability
            support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
            support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
            setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
            support.sortDetached = assert(function( div1 ) {
                // Should return 1, but returns 4 (following)
                return div1.compareDocumentPosition( document.createElement("div") ) & 1;
            });

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
            if ( !assert(function( div ) {
                    div.innerHTML = "<a href='#'></a>";
                    return div.firstChild.getAttribute("href") === "#" ;
                }) ) {
                addHandle( "type|href|height|width", function( elem, name, isXML ) {
                    if ( !isXML ) {
                        return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
                    }
                });
            }

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
            if ( !support.attributes || !assert(function( div ) {
                    div.innerHTML = "<input/>";
                    div.firstChild.setAttribute( "value", "" );
                    return div.firstChild.getAttribute( "value" ) === "";
                }) ) {
                addHandle( "value", function( elem, name, isXML ) {
                    if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
                        return elem.defaultValue;
                    }
                });
            }

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
            if ( !assert(function( div ) {
                    return div.getAttribute("disabled") == null;
                }) ) {
                addHandle( booleans, function( elem, name, isXML ) {
                    var val;
                    if ( !isXML ) {
                        return elem[ name ] === true ? name.toLowerCase() :
                            (val = elem.getAttributeNode( name )) && val.specified ?
                                val.value :
                                null;
                    }
                });
            }

            return Sizzle;

        })( window );



    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;



    var rneedsContext = jQuery.expr.match.needsContext;

    var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



    var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
    function winnow( elements, qualifier, not ) {
        if ( jQuery.isFunction( qualifier ) ) {
            return jQuery.grep( elements, function( elem, i ) {
                /* jshint -W018 */
                return !!qualifier.call( elem, i, elem ) !== not;
            });

        }

        if ( qualifier.nodeType ) {
            return jQuery.grep( elements, function( elem ) {
                return ( elem === qualifier ) !== not;
            });

        }

        if ( typeof qualifier === "string" ) {
            if ( risSimple.test( qualifier ) ) {
                return jQuery.filter( qualifier, elements, not );
            }

            qualifier = jQuery.filter( qualifier, elements );
        }

        return jQuery.grep( elements, function( elem ) {
            return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
        });
    }

    jQuery.filter = function( expr, elems, not ) {
        var elem = elems[ 0 ];

        if ( not ) {
            expr = ":not(" + expr + ")";
        }

        return elems.length === 1 && elem.nodeType === 1 ?
            jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
            jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
                return elem.nodeType === 1;
            }));
    };

    jQuery.fn.extend({
        find: function( selector ) {
            var i,
                len = this.length,
                ret = [],
                self = this;

            if ( typeof selector !== "string" ) {
                return this.pushStack( jQuery( selector ).filter(function() {
                    for ( i = 0; i < len; i++ ) {
                        if ( jQuery.contains( self[ i ], this ) ) {
                            return true;
                        }
                    }
                }) );
            }

            for ( i = 0; i < len; i++ ) {
                jQuery.find( selector, self[ i ], ret );
            }

            // Needed because $( selector, context ) becomes $( context ).find( selector )
            ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function( selector ) {
            return this.pushStack( winnow(this, selector || [], false) );
        },
        not: function( selector ) {
            return this.pushStack( winnow(this, selector || [], true) );
        },
        is: function( selector ) {
            return !!winnow(
                this,

                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                typeof selector === "string" && rneedsContext.test( selector ) ?
                    jQuery( selector ) :
                    selector || [],
                false
            ).length;
        }
    });


// Initialize a jQuery object


// A central reference to the root jQuery(document)
    var rootjQuery,

        // A simple way to check for HTML strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
        // Strict HTML recognition (#11290: must start with <)
        rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

        init = jQuery.fn.init = function( selector, context ) {
            var match, elem;

            // HANDLE: $(""), $(null), $(undefined), $(false)
            if ( !selector ) {
                return this;
            }

            // Handle HTML strings
            if ( typeof selector === "string" ) {
                if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [ null, selector, null ];

                } else {
                    match = rquickExpr.exec( selector );
                }

                // Match html or make sure no context is specified for #id
                if ( match && (match[1] || !context) ) {

                    // HANDLE: $(html) -> $(array)
                    if ( match[1] ) {
                        context = context instanceof jQuery ? context[0] : context;

                        // scripts is true for back-compat
                        // Intentionally let the error be thrown if parseHTML is not present
                        jQuery.merge( this, jQuery.parseHTML(
                            match[1],
                            context && context.nodeType ? context.ownerDocument || context : document,
                            true
                        ) );

                        // HANDLE: $(html, props)
                        if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
                            for ( match in context ) {
                                // Properties of context are called as methods if possible
                                if ( jQuery.isFunction( this[ match ] ) ) {
                                    this[ match ]( context[ match ] );

                                    // ...and otherwise set as attributes
                                } else {
                                    this.attr( match, context[ match ] );
                                }
                            }
                        }

                        return this;

                        // HANDLE: $(#id)
                    } else {
                        elem = document.getElementById( match[2] );

                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        if ( elem && elem.parentNode ) {
                            // Inject the element directly into the jQuery object
                            this.length = 1;
                            this[0] = elem;
                        }

                        this.context = document;
                        this.selector = selector;
                        return this;
                    }

                    // HANDLE: $(expr, $(...))
                } else if ( !context || context.jquery ) {
                    return ( context || rootjQuery ).find( selector );

                    // HANDLE: $(expr, context)
                    // (which is just equivalent to: $(context).find(expr)
                } else {
                    return this.constructor( context ).find( selector );
                }

                // HANDLE: $(DOMElement)
            } else if ( selector.nodeType ) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;

                // HANDLE: $(function)
                // Shortcut for document ready
            } else if ( jQuery.isFunction( selector ) ) {
                return typeof rootjQuery.ready !== "undefined" ?
                    rootjQuery.ready( selector ) :
                    // Execute immediately if ready is not present
                    selector( jQuery );
            }

            if ( selector.selector !== undefined ) {
                this.selector = selector.selector;
                this.context = selector.context;
            }

            return jQuery.makeArray( selector, this );
        };

// Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

// Initialize central reference
    rootjQuery = jQuery( document );


    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
        // methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };

    jQuery.extend({
        dir: function( elem, dir, until ) {
            var matched = [],
                truncate = until !== undefined;

            while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
                if ( elem.nodeType === 1 ) {
                    if ( truncate && jQuery( elem ).is( until ) ) {
                        break;
                    }
                    matched.push( elem );
                }
            }
            return matched;
        },

        sibling: function( n, elem ) {
            var matched = [];

            for ( ; n; n = n.nextSibling ) {
                if ( n.nodeType === 1 && n !== elem ) {
                    matched.push( n );
                }
            }

            return matched;
        }
    });

    jQuery.fn.extend({
        has: function( target ) {
            var targets = jQuery( target, this ),
                l = targets.length;

            return this.filter(function() {
                var i = 0;
                for ( ; i < l; i++ ) {
                    if ( jQuery.contains( this, targets[i] ) ) {
                        return true;
                    }
                }
            });
        },

        closest: function( selectors, context ) {
            var cur,
                i = 0,
                l = this.length,
                matched = [],
                pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
                    jQuery( selectors, context || this.context ) :
                    0;

            for ( ; i < l; i++ ) {
                for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
                    // Always skip document fragments
                    if ( cur.nodeType < 11 && (pos ?
                            pos.index(cur) > -1 :

                            // Don't pass non-elements to Sizzle
                            cur.nodeType === 1 &&
                            jQuery.find.matchesSelector(cur, selectors)) ) {

                        matched.push( cur );
                        break;
                    }
                }
            }

            return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
        },

        // Determine the position of an element within
        // the matched set of elements
        index: function( elem ) {

            // No argument, return index in parent
            if ( !elem ) {
                return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
            }

            // index in selector
            if ( typeof elem === "string" ) {
                return indexOf.call( jQuery( elem ), this[ 0 ] );
            }

            // Locate the position of the desired element
            return indexOf.call( this,

                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[ 0 ] : elem
            );
        },

        add: function( selector, context ) {
            return this.pushStack(
                jQuery.unique(
                    jQuery.merge( this.get(), jQuery( selector, context ) )
                )
            );
        },

        addBack: function( selector ) {
            return this.add( selector == null ?
                this.prevObject : this.prevObject.filter(selector)
            );
        }
    });

    function sibling( cur, dir ) {
        while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
        return cur;
    }

    jQuery.each({
        parent: function( elem ) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function( elem ) {
            return jQuery.dir( elem, "parentNode" );
        },
        parentsUntil: function( elem, i, until ) {
            return jQuery.dir( elem, "parentNode", until );
        },
        next: function( elem ) {
            return sibling( elem, "nextSibling" );
        },
        prev: function( elem ) {
            return sibling( elem, "previousSibling" );
        },
        nextAll: function( elem ) {
            return jQuery.dir( elem, "nextSibling" );
        },
        prevAll: function( elem ) {
            return jQuery.dir( elem, "previousSibling" );
        },
        nextUntil: function( elem, i, until ) {
            return jQuery.dir( elem, "nextSibling", until );
        },
        prevUntil: function( elem, i, until ) {
            return jQuery.dir( elem, "previousSibling", until );
        },
        siblings: function( elem ) {
            return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
        },
        children: function( elem ) {
            return jQuery.sibling( elem.firstChild );
        },
        contents: function( elem ) {
            return elem.contentDocument || jQuery.merge( [], elem.childNodes );
        }
    }, function( name, fn ) {
        jQuery.fn[ name ] = function( until, selector ) {
            var matched = jQuery.map( this, fn, until );

            if ( name.slice( -5 ) !== "Until" ) {
                selector = until;
            }

            if ( selector && typeof selector === "string" ) {
                matched = jQuery.filter( selector, matched );
            }

            if ( this.length > 1 ) {
                // Remove duplicates
                if ( !guaranteedUnique[ name ] ) {
                    jQuery.unique( matched );
                }

                // Reverse order for parents* and prev-derivatives
                if ( rparentsprev.test( name ) ) {
                    matched.reverse();
                }
            }

            return this.pushStack( matched );
        };
    });
    var rnotwhite = (/\S+/g);



// String to Object options format cache
    var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
    function createOptions( options ) {
        var object = optionsCache[ options ] = {};
        jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
            object[ flag ] = true;
        });
        return object;
    }

    /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
    jQuery.Callbacks = function( options ) {

        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ?
            ( optionsCache[ options ] || createOptions( options ) ) :
            jQuery.extend( {}, options );

        var // Last fire value (for non-forgettable lists)
            memory,
            // Flag to know if list was already fired
            fired,
            // Flag to know if list is currently firing
            firing,
            // First callback to fire (used internally by add and fireWith)
            firingStart,
            // End of the loop when firing
            firingLength,
            // Index of currently firing callback (modified by remove if needed)
            firingIndex,
            // Actual callback list
            list = [],
            // Stack of fire calls for repeatable lists
            stack = !options.once && [],
            // Fire callbacks
            fire = function( data ) {
                memory = options.memory && data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for ( ; list && firingIndex < firingLength; firingIndex++ ) {
                    if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
                        memory = false; // To prevent further calls using add
                        break;
                    }
                }
                firing = false;
                if ( list ) {
                    if ( stack ) {
                        if ( stack.length ) {
                            fire( stack.shift() );
                        }
                    } else if ( memory ) {
                        list = [];
                    } else {
                        self.disable();
                    }
                }
            },
            // Actual Callbacks object
            self = {
                // Add a callback or a collection of callbacks to the list
                add: function() {
                    if ( list ) {
                        // First, we save the current length
                        var start = list.length;
                        (function add( args ) {
                            jQuery.each( args, function( _, arg ) {
                                var type = jQuery.type( arg );
                                if ( type === "function" ) {
                                    if ( !options.unique || !self.has( arg ) ) {
                                        list.push( arg );
                                    }
                                } else if ( arg && arg.length && type !== "string" ) {
                                    // Inspect recursively
                                    add( arg );
                                }
                            });
                        })( arguments );
                        // Do we need to add the callbacks to the
                        // current firing batch?
                        if ( firing ) {
                            firingLength = list.length;
                            // With memory, if we're not firing then
                            // we should call right away
                        } else if ( memory ) {
                            firingStart = start;
                            fire( memory );
                        }
                    }
                    return this;
                },
                // Remove a callback from the list
                remove: function() {
                    if ( list ) {
                        jQuery.each( arguments, function( _, arg ) {
                            var index;
                            while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                                list.splice( index, 1 );
                                // Handle firing indexes
                                if ( firing ) {
                                    if ( index <= firingLength ) {
                                        firingLength--;
                                    }
                                    if ( index <= firingIndex ) {
                                        firingIndex--;
                                    }
                                }
                            }
                        });
                    }
                    return this;
                },
                // Check if a given callback is in the list.
                // If no argument is given, return whether or not list has callbacks attached.
                has: function( fn ) {
                    return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
                },
                // Remove all callbacks from the list
                empty: function() {
                    list = [];
                    firingLength = 0;
                    return this;
                },
                // Have the list do nothing anymore
                disable: function() {
                    list = stack = memory = undefined;
                    return this;
                },
                // Is it disabled?
                disabled: function() {
                    return !list;
                },
                // Lock the list in its current state
                lock: function() {
                    stack = undefined;
                    if ( !memory ) {
                        self.disable();
                    }
                    return this;
                },
                // Is it locked?
                locked: function() {
                    return !stack;
                },
                // Call all callbacks with the given context and arguments
                fireWith: function( context, args ) {
                    if ( list && ( !fired || stack ) ) {
                        args = args || [];
                        args = [ context, args.slice ? args.slice() : args ];
                        if ( firing ) {
                            stack.push( args );
                        } else {
                            fire( args );
                        }
                    }
                    return this;
                },
                // Call all the callbacks with the given arguments
                fire: function() {
                    self.fireWith( this, arguments );
                    return this;
                },
                // To know if the callbacks have already been called at least once
                fired: function() {
                    return !!fired;
                }
            };

        return self;
    };


    jQuery.extend({

        Deferred: function( func ) {
            var tuples = [
                    // action, add listener, listener list, final state
                    [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
                    [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
                    [ "notify", "progress", jQuery.Callbacks("memory") ]
                ],
                state = "pending",
                promise = {
                    state: function() {
                        return state;
                    },
                    always: function() {
                        deferred.done( arguments ).fail( arguments );
                        return this;
                    },
                    then: function( /* fnDone, fnFail, fnProgress */ ) {
                        var fns = arguments;
                        return jQuery.Deferred(function( newDefer ) {
                            jQuery.each( tuples, function( i, tuple ) {
                                var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
                                // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                deferred[ tuple[1] ](function() {
                                    var returned = fn && fn.apply( this, arguments );
                                    if ( returned && jQuery.isFunction( returned.promise ) ) {
                                        returned.promise()
                                            .done( newDefer.resolve )
                                            .fail( newDefer.reject )
                                            .progress( newDefer.notify );
                                    } else {
                                        newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function( obj ) {
                        return obj != null ? jQuery.extend( obj, promise ) : promise;
                    }
                },
                deferred = {};

            // Keep pipe for back-compat
            promise.pipe = promise.then;

            // Add list-specific methods
            jQuery.each( tuples, function( i, tuple ) {
                var list = tuple[ 2 ],
                    stateString = tuple[ 3 ];

                // promise[ done | fail | progress ] = list.add
                promise[ tuple[1] ] = list.add;

                // Handle state
                if ( stateString ) {
                    list.add(function() {
                        // state = [ resolved | rejected ]
                        state = stateString;

                        // [ reject_list | resolve_list ].disable; progress_list.lock
                    }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
                }

                // deferred[ resolve | reject | notify ]
                deferred[ tuple[0] ] = function() {
                    deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
                    return this;
                };
                deferred[ tuple[0] + "With" ] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise( deferred );

            // Call given func if any
            if ( func ) {
                func.call( deferred, deferred );
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function( subordinate /* , ..., subordinateN */ ) {
            var i = 0,
                resolveValues = slice.call( arguments ),
                length = resolveValues.length,

                // the count of uncompleted subordinates
                remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

                // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

                // Update function for both resolve and progress values
                updateFunc = function( i, contexts, values ) {
                    return function( value ) {
                        contexts[ i ] = this;
                        values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                        if ( values === progressValues ) {
                            deferred.notifyWith( contexts, values );
                        } else if ( !( --remaining ) ) {
                            deferred.resolveWith( contexts, values );
                        }
                    };
                },

                progressValues, progressContexts, resolveContexts;

            // add listeners to Deferred subordinates; treat others as resolved
            if ( length > 1 ) {
                progressValues = new Array( length );
                progressContexts = new Array( length );
                resolveContexts = new Array( length );
                for ( ; i < length; i++ ) {
                    if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                        resolveValues[ i ].promise()
                            .done( updateFunc( i, resolveContexts, resolveValues ) )
                            .fail( deferred.reject )
                            .progress( updateFunc( i, progressContexts, progressValues ) );
                    } else {
                        --remaining;
                    }
                }
            }

            // if we're not waiting on anything, resolve the master
            if ( !remaining ) {
                deferred.resolveWith( resolveContexts, resolveValues );
            }

            return deferred.promise();
        }
    });


// The deferred used on DOM ready
    var readyList;

    jQuery.fn.ready = function( fn ) {
        // Add the callback
        jQuery.ready.promise().done( fn );

        return this;
    };

    jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Hold (or release) the ready event
        holdReady: function( hold ) {
            if ( hold ) {
                jQuery.readyWait++;
            } else {
                jQuery.ready( true );
            }
        },

        // Handle when the DOM is ready
        ready: function( wait ) {

            // Abort if there are pending holds or we're already ready
            if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
                return;
            }

            // Remember that the DOM is ready
            jQuery.isReady = true;

            // If a normal DOM Ready event fired, decrement, and wait if need be
            if ( wait !== true && --jQuery.readyWait > 0 ) {
                return;
            }

            // If there are functions bound, to execute
            readyList.resolveWith( document, [ jQuery ] );

            // Trigger any bound ready events
            if ( jQuery.fn.triggerHandler ) {
                jQuery( document ).triggerHandler( "ready" );
                jQuery( document ).off( "ready" );
            }
        }
    });

    /**
     * The ready event handler and self cleanup method
     */
    function completed() {
        document.removeEventListener( "DOMContentLoaded", completed, false );
        window.removeEventListener( "load", completed, false );
        jQuery.ready();
    }

    jQuery.ready.promise = function( obj ) {
        if ( !readyList ) {

            readyList = jQuery.Deferred();

            // Catch cases where $(document).ready() is called after the browser event has already occurred.
            // we once tried to use readyState "interactive" here, but it caused issues like the one
            // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
            if ( document.readyState === "complete" ) {
                // Handle it asynchronously to allow scripts the opportunity to delay ready
                setTimeout( jQuery.ready );

            } else {

                // Use the handy event callback
                document.addEventListener( "DOMContentLoaded", completed, false );

                // A fallback to window.onload, that will always work
                window.addEventListener( "load", completed, false );
            }
        }
        return readyList.promise( obj );
    };

// Kick off the DOM ready check even if the user does not
    jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
    var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
        var i = 0,
            len = elems.length,
            bulk = key == null;

        // Sets many values
        if ( jQuery.type( key ) === "object" ) {
            chainable = true;
            for ( i in key ) {
                jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
            }

            // Sets one value
        } else if ( value !== undefined ) {
            chainable = true;

            if ( !jQuery.isFunction( value ) ) {
                raw = true;
            }

            if ( bulk ) {
                // Bulk operations run against the entire set
                if ( raw ) {
                    fn.call( elems, value );
                    fn = null;

                    // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function( elem, key, value ) {
                        return bulk.call( jQuery( elem ), value );
                    };
                }
            }

            if ( fn ) {
                for ( ; i < len; i++ ) {
                    fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
                }
            }
        }

        return chainable ?
            elems :

            // Gets
            bulk ?
                fn.call( elems ) :
                len ? fn( elems[0], key ) : emptyGet;
    };


    /**
     * Determines whether an object can have data
     */
    jQuery.acceptData = function( owner ) {
        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        /* jshint -W018 */
        return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
    };


    function Data() {
        // Support: Android < 4,
        // Old WebKit does not have Object.preventExtensions/freeze method,
        // return new empty object instead with no [[set]] accessor
        Object.defineProperty( this.cache = {}, 0, {
            get: function() {
                return {};
            }
        });

        this.expando = jQuery.expando + Math.random();
    }

    Data.uid = 1;
    Data.accepts = jQuery.acceptData;

    Data.prototype = {
        key: function( owner ) {
            // We can accept data for non-element nodes in modern browsers,
            // but we should not, see #8335.
            // Always return the key for a frozen object.
            if ( !Data.accepts( owner ) ) {
                return 0;
            }

            var descriptor = {},
                // Check if the owner object already has a cache key
                unlock = owner[ this.expando ];

            // If not, create one
            if ( !unlock ) {
                unlock = Data.uid++;

                // Secure it in a non-enumerable, non-writable property
                try {
                    descriptor[ this.expando ] = { value: unlock };
                    Object.defineProperties( owner, descriptor );

                    // Support: Android < 4
                    // Fallback to a less secure definition
                } catch ( e ) {
                    descriptor[ this.expando ] = unlock;
                    jQuery.extend( owner, descriptor );
                }
            }

            // Ensure the cache object
            if ( !this.cache[ unlock ] ) {
                this.cache[ unlock ] = {};
            }

            return unlock;
        },
        set: function( owner, data, value ) {
            var prop,
                // There may be an unlock assigned to this node,
                // if there is no entry for this "owner", create one inline
                // and set the unlock as though an owner entry had always existed
                unlock = this.key( owner ),
                cache = this.cache[ unlock ];

            // Handle: [ owner, key, value ] args
            if ( typeof data === "string" ) {
                cache[ data ] = value;

                // Handle: [ owner, { properties } ] args
            } else {
                // Fresh assignments by object are shallow copied
                if ( jQuery.isEmptyObject( cache ) ) {
                    jQuery.extend( this.cache[ unlock ], data );
                    // Otherwise, copy the properties one-by-one to the cache object
                } else {
                    for ( prop in data ) {
                        cache[ prop ] = data[ prop ];
                    }
                }
            }
            return cache;
        },
        get: function( owner, key ) {
            // Either a valid cache is found, or will be created.
            // New caches will be created and the unlock returned,
            // allowing direct access to the newly created
            // empty data object. A valid owner object must be provided.
            var cache = this.cache[ this.key( owner ) ];

            return key === undefined ?
                cache : cache[ key ];
        },
        access: function( owner, key, value ) {
            var stored;
            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if ( key === undefined ||
                ((key && typeof key === "string") && value === undefined) ) {

                stored = this.get( owner, key );

                return stored !== undefined ?
                    stored : this.get( owner, jQuery.camelCase(key) );
            }

            // [*]When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set( owner, key, value );

            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function( owner, key ) {
            var i, name, camel,
                unlock = this.key( owner ),
                cache = this.cache[ unlock ];

            if ( key === undefined ) {
                this.cache[ unlock ] = {};

            } else {
                // Support array or space separated string of keys
                if ( jQuery.isArray( key ) ) {
                    // If "name" is an array of keys...
                    // When data is initially created, via ("key", "val") signature,
                    // keys will be converted to camelCase.
                    // Since there is no way to tell _how_ a key was added, remove
                    // both plain key and camelCase key. #12786
                    // This will only penalize the array argument path.
                    name = key.concat( key.map( jQuery.camelCase ) );
                } else {
                    camel = jQuery.camelCase( key );
                    // Try the string as a key before any manipulation
                    if ( key in cache ) {
                        name = [ key, camel ];
                    } else {
                        // If a key with the spaces exists, use it.
                        // Otherwise, create an array by matching non-whitespace
                        name = camel;
                        name = name in cache ?
                            [ name ] : ( name.match( rnotwhite ) || [] );
                    }
                }

                i = name.length;
                while ( i-- ) {
                    delete cache[ name[ i ] ];
                }
            }
        },
        hasData: function( owner ) {
            return !jQuery.isEmptyObject(
                this.cache[ owner[ this.expando ] ] || {}
            );
        },
        discard: function( owner ) {
            if ( owner[ this.expando ] ) {
                delete this.cache[ owner[ this.expando ] ];
            }
        }
    };
    var data_priv = new Data();

    var data_user = new Data();



    /*
	Implementation Summary

	1. Enforce API surface and semantic compatibility with 1.9.x branch
	2. Improve the module's maintainability by reducing the storage
		paths to a single mechanism.
	3. Use the same single mechanism to support "private" and "user" data.
	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	5. Avoid exposing implementation details on user objects (eg. expando properties)
	6. Provide a clear path for implementation upgrade to WeakMap in 2014
*/
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /([A-Z])/g;

    function dataAttr( elem, key, data ) {
        var name;

        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if ( data === undefined && elem.nodeType === 1 ) {
            name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
            data = elem.getAttribute( name );

            if ( typeof data === "string" ) {
                try {
                    data = data === "true" ? true :
                        data === "false" ? false :
                            data === "null" ? null :
                                // Only convert to a number if it doesn't change the string
                                +data + "" === data ? +data :
                                    rbrace.test( data ) ? jQuery.parseJSON( data ) :
                                        data;
                } catch( e ) {}

                // Make sure we set the data so it isn't changed later
                data_user.set( elem, key, data );
            } else {
                data = undefined;
            }
        }
        return data;
    }

    jQuery.extend({
        hasData: function( elem ) {
            return data_user.hasData( elem ) || data_priv.hasData( elem );
        },

        data: function( elem, name, data ) {
            return data_user.access( elem, name, data );
        },

        removeData: function( elem, name ) {
            data_user.remove( elem, name );
        },

        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to data_priv methods, these can be deprecated.
        _data: function( elem, name, data ) {
            return data_priv.access( elem, name, data );
        },

        _removeData: function( elem, name ) {
            data_priv.remove( elem, name );
        }
    });

    jQuery.fn.extend({
        data: function( key, value ) {
            var i, name, data,
                elem = this[ 0 ],
                attrs = elem && elem.attributes;

            // Gets all values
            if ( key === undefined ) {
                if ( this.length ) {
                    data = data_user.get( elem );

                    if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
                        i = attrs.length;
                        while ( i-- ) {

                            // Support: IE11+
                            // The attrs elements can be null (#14894)
                            if ( attrs[ i ] ) {
                                name = attrs[ i ].name;
                                if ( name.indexOf( "data-" ) === 0 ) {
                                    name = jQuery.camelCase( name.slice(5) );
                                    dataAttr( elem, name, data[ name ] );
                                }
                            }
                        }
                        data_priv.set( elem, "hasDataAttrs", true );
                    }
                }

                return data;
            }

            // Sets multiple values
            if ( typeof key === "object" ) {
                return this.each(function() {
                    data_user.set( this, key );
                });
            }

            return access( this, function( value ) {
                var data,
                    camelKey = jQuery.camelCase( key );

                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if ( elem && value === undefined ) {
                    // Attempt to get data from the cache
                    // with the key as-is
                    data = data_user.get( elem, key );
                    if ( data !== undefined ) {
                        return data;
                    }

                    // Attempt to get data from the cache
                    // with the key camelized
                    data = data_user.get( elem, camelKey );
                    if ( data !== undefined ) {
                        return data;
                    }

                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr( elem, camelKey, undefined );
                    if ( data !== undefined ) {
                        return data;
                    }

                    // We tried really hard, but the data doesn't exist.
                    return;
                }

                // Set the data...
                this.each(function() {
                    // First, attempt to store a copy or reference of any
                    // data that might've been store with a camelCased key.
                    var data = data_user.get( this, camelKey );

                    // For HTML5 data-* attribute interop, we have to
                    // store property names with dashes in a camelCase form.
                    // This might not apply to all properties...*
                    data_user.set( this, camelKey, value );

                    // *... In the case of properties that might _actually_
                    // have dashes, we need to also store a copy of that
                    // unchanged property.
                    if ( key.indexOf("-") !== -1 && data !== undefined ) {
                        data_user.set( this, key, value );
                    }
                });
            }, null, value, arguments.length > 1, null, true );
        },

        removeData: function( key ) {
            return this.each(function() {
                data_user.remove( this, key );
            });
        }
    });


    jQuery.extend({
        queue: function( elem, type, data ) {
            var queue;

            if ( elem ) {
                type = ( type || "fx" ) + "queue";
                queue = data_priv.get( elem, type );

                // Speed up dequeue by getting out quickly if this is just a lookup
                if ( data ) {
                    if ( !queue || jQuery.isArray( data ) ) {
                        queue = data_priv.access( elem, type, jQuery.makeArray(data) );
                    } else {
                        queue.push( data );
                    }
                }
                return queue || [];
            }
        },

        dequeue: function( elem, type ) {
            type = type || "fx";

            var queue = jQuery.queue( elem, type ),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks( elem, type ),
                next = function() {
                    jQuery.dequeue( elem, type );
                };

            // If the fx queue is dequeued, always remove the progress sentinel
            if ( fn === "inprogress" ) {
                fn = queue.shift();
                startLength--;
            }

            if ( fn ) {

                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if ( type === "fx" ) {
                    queue.unshift( "inprogress" );
                }

                // clear up the last queue stop function
                delete hooks.stop;
                fn.call( elem, next, hooks );
            }

            if ( !startLength && hooks ) {
                hooks.empty.fire();
            }
        },

        // not intended for public consumption - generates a queueHooks object, or returns the current one
        _queueHooks: function( elem, type ) {
            var key = type + "queueHooks";
            return data_priv.get( elem, key ) || data_priv.access( elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    data_priv.remove( elem, [ type + "queue", key ] );
                })
            });
        }
    });

    jQuery.fn.extend({
        queue: function( type, data ) {
            var setter = 2;

            if ( typeof type !== "string" ) {
                data = type;
                type = "fx";
                setter--;
            }

            if ( arguments.length < setter ) {
                return jQuery.queue( this[0], type );
            }

            return data === undefined ?
                this :
                this.each(function() {
                    var queue = jQuery.queue( this, type, data );

                    // ensure a hooks for this queue
                    jQuery._queueHooks( this, type );

                    if ( type === "fx" && queue[0] !== "inprogress" ) {
                        jQuery.dequeue( this, type );
                    }
                });
        },
        dequeue: function( type ) {
            return this.each(function() {
                jQuery.dequeue( this, type );
            });
        },
        clearQueue: function( type ) {
            return this.queue( type || "fx", [] );
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function( type, obj ) {
            var tmp,
                count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function() {
                    if ( !( --count ) ) {
                        defer.resolveWith( elements, [ elements ] );
                    }
                };

            if ( typeof type !== "string" ) {
                obj = type;
                type = undefined;
            }
            type = type || "fx";

            while ( i-- ) {
                tmp = data_priv.get( elements[ i ], type + "queueHooks" );
                if ( tmp && tmp.empty ) {
                    count++;
                    tmp.empty.add( resolve );
                }
            }
            resolve();
            return defer.promise( obj );
        }
    });
    var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

    var isHidden = function( elem, el ) {
        // isHidden might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
    };

    var rcheckableType = (/^(?:checkbox|radio)$/i);



    (function() {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild( document.createElement( "div" ) ),
            input = document.createElement( "input" );

        // #11217 - WebKit loses check when the name is after the checked attribute
        // Support: Windows Web Apps (WWA)
        // `name` and `type` need .setAttribute for WWA
        input.setAttribute( "type", "radio" );
        input.setAttribute( "checked", "checked" );
        input.setAttribute( "name", "t" );

        div.appendChild( input );

        // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
        // old WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

        // Make sure textarea (and checkbox) defaultValue is properly cloned
        // Support: IE9-IE11+
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
    })();
    var strundefined = typeof undefined;



    support.focusinBubbles = "onfocusin" in window;


    var
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

    function returnTrue() {
        return true;
    }

    function returnFalse() {
        return false;
    }

    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch ( err ) { }
    }

    /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
    jQuery.event = {

        global: {},

        add: function( elem, types, handler, data, selector ) {

            var handleObjIn, eventHandle, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = data_priv.get( elem );

            // Don't attach events to noData or text/comment nodes (but allow plain objects)
            if ( !elemData ) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if ( handler.handler ) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if ( !handler.guid ) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            if ( !(events = elemData.events) ) {
                events = elemData.events = {};
            }
            if ( !(eventHandle = elemData.handle) ) {
                eventHandle = elemData.handle = function( e ) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
                        jQuery.event.dispatch.apply( elem, arguments ) : undefined;
                };
            }

            // Handle multiple events separated by a space
            types = ( types || "" ).match( rnotwhite ) || [ "" ];
            t = types.length;
            while ( t-- ) {
                tmp = rtypenamespace.exec( types[t] ) || [];
                type = origType = tmp[1];
                namespaces = ( tmp[2] || "" ).split( "." ).sort();

                // There *must* be a type, no attaching namespace-only handlers
                if ( !type ) {
                    continue;
                }

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[ type ] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = ( selector ? special.delegateType : special.bindType ) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[ type ] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                    namespace: namespaces.join(".")
                }, handleObjIn );

                // Init the event handler queue if we're the first
                if ( !(handlers = events[ type ]) ) {
                    handlers = events[ type ] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener if the special events handler returns false
                    if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                        if ( elem.addEventListener ) {
                            elem.addEventListener( type, eventHandle, false );
                        }
                    }
                }

                if ( special.add ) {
                    special.add.call( elem, handleObj );

                    if ( !handleObj.handler.guid ) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if ( selector ) {
                    handlers.splice( handlers.delegateCount++, 0, handleObj );
                } else {
                    handlers.push( handleObj );
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[ type ] = true;
            }

        },

        // Detach an event or set of events from an element
        remove: function( elem, types, handler, selector, mappedTypes ) {

            var j, origCount, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = data_priv.hasData( elem ) && data_priv.get( elem );

            if ( !elemData || !(events = elemData.events) ) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = ( types || "" ).match( rnotwhite ) || [ "" ];
            t = types.length;
            while ( t-- ) {
                tmp = rtypenamespace.exec( types[t] ) || [];
                type = origType = tmp[1];
                namespaces = ( tmp[2] || "" ).split( "." ).sort();

                // Unbind all events (on this namespace, if provided) for the element
                if ( !type ) {
                    for ( type in events ) {
                        jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                    }
                    continue;
                }

                special = jQuery.event.special[ type ] || {};
                type = ( selector ? special.delegateType : special.bindType ) || type;
                handlers = events[ type ] || [];
                tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

                // Remove matching events
                origCount = j = handlers.length;
                while ( j-- ) {
                    handleObj = handlers[ j ];

                    if ( ( mappedTypes || origType === handleObj.origType ) &&
                        ( !handler || handler.guid === handleObj.guid ) &&
                        ( !tmp || tmp.test( handleObj.namespace ) ) &&
                        ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
                        handlers.splice( j, 1 );

                        if ( handleObj.selector ) {
                            handlers.delegateCount--;
                        }
                        if ( special.remove ) {
                            special.remove.call( elem, handleObj );
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if ( origCount && !handlers.length ) {
                    if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
                        jQuery.removeEvent( elem, type, elemData.handle );
                    }

                    delete events[ type ];
                }
            }

            // Remove the expando if it's no longer used
            if ( jQuery.isEmptyObject( events ) ) {
                delete elemData.handle;
                data_priv.remove( elem, "events" );
            }
        },

        trigger: function( event, data, elem, onlyHandlers ) {

            var i, cur, tmp, bubbleType, ontype, handle, special,
                eventPath = [ elem || document ],
                type = hasOwn.call( event, "type" ) ? event.type : event,
                namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

            cur = tmp = elem = elem || document;

            // Don't do events on text and comment nodes
            if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                return;
            }

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
                return;
            }

            if ( type.indexOf(".") >= 0 ) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;

            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[ jQuery.expando ] ?
                event :
                new jQuery.Event( type, typeof event === "object" && event );

            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ?
                new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
                null;

            // Clean up the event in case it is being reused
            event.result = undefined;
            if ( !event.target ) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ?
                [ event ] :
                jQuery.makeArray( data, [ event ] );

            // Allow special events to draw outside the lines
            special = jQuery.event.special[ type ] || {};
            if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

                bubbleType = special.delegateType || type;
                if ( !rfocusMorph.test( bubbleType + type ) ) {
                    cur = cur.parentNode;
                }
                for ( ; cur; cur = cur.parentNode ) {
                    eventPath.push( cur );
                    tmp = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if ( tmp === (elem.ownerDocument || document) ) {
                    eventPath.push( tmp.defaultView || tmp.parentWindow || window );
                }
            }

            // Fire handlers on the event path
            i = 0;
            while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

                event.type = i > 1 ?
                    bubbleType :
                    special.bindType || type;

                // jQuery handler
                handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
                if ( handle ) {
                    handle.apply( cur, data );
                }

                // Native handler
                handle = ontype && cur[ ontype ];
                if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
                    event.result = handle.apply( cur, data );
                    if ( event.result === false ) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if ( !onlyHandlers && !event.isDefaultPrevented() ) {

                if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
                    jQuery.acceptData( elem ) ) {

                    // Call a native DOM method on the target with the same name name as the event.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ ontype ];

                        if ( tmp ) {
                            elem[ ontype ] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        elem[ type ]();
                        jQuery.event.triggered = undefined;

                        if ( tmp ) {
                            elem[ ontype ] = tmp;
                        }
                    }
                }
            }

            return event.result;
        },

        dispatch: function( event ) {

            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix( event );

            var i, j, ret, matched, handleObj,
                handlerQueue = [],
                args = slice.call( arguments ),
                handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
                special = jQuery.event.special[ event.type ] || {};

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            event.delegateTarget = this;

            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
                return;
            }

            // Determine handlers
            handlerQueue = jQuery.event.handlers.call( this, event, handlers );

            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
                event.currentTarget = matched.elem;

                j = 0;
                while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

                    // Triggered event must either 1) have no namespace, or
                    // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                    if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

                        event.handleObj = handleObj;
                        event.data = handleObj.data;

                        ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                            .apply( matched.elem, args );

                        if ( ret !== undefined ) {
                            if ( (event.result = ret) === false ) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            // Call the postDispatch hook for the mapped type
            if ( special.postDispatch ) {
                special.postDispatch.call( this, event );
            }

            return event.result;
        },

        handlers: function( event, handlers ) {
            var i, matches, sel, handleObj,
                handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur = event.target;

            // Find delegate handlers
            // Black-hole SVG <use> instance trees (#13180)
            // Avoid non-left-click bubbling in Firefox (#3861)
            if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

                for ( ; cur !== this; cur = cur.parentNode || this ) {

                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if ( cur.disabled !== true || event.type !== "click" ) {
                        matches = [];
                        for ( i = 0; i < delegateCount; i++ ) {
                            handleObj = handlers[ i ];

                            // Don't conflict with Object.prototype properties (#13203)
                            sel = handleObj.selector + " ";

                            if ( matches[ sel ] === undefined ) {
                                matches[ sel ] = handleObj.needsContext ?
                                    jQuery( sel, this ).index( cur ) >= 0 :
                                    jQuery.find( sel, this, null, [ cur ] ).length;
                            }
                            if ( matches[ sel ] ) {
                                matches.push( handleObj );
                            }
                        }
                        if ( matches.length ) {
                            handlerQueue.push({ elem: cur, handlers: matches });
                        }
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            if ( delegateCount < handlers.length ) {
                handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
            }

            return handlerQueue;
        },

        // Includes some event props shared by KeyEvent and MouseEvent
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

        fixHooks: {},

        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function( event, original ) {

                // Add which for key events
                if ( event.which == null ) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }

                return event;
            }
        },

        mouseHooks: {
            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function( event, original ) {
                var eventDoc, doc, body,
                    button = original.button;

                // Calculate pageX/Y if missing and clientX/Y available
                if ( event.pageX == null && original.clientX != null ) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;

                    event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                    event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
                }

                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if ( !event.which && button !== undefined ) {
                    event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
                }

                return event;
            }
        },

        fix: function( event ) {
            if ( event[ jQuery.expando ] ) {
                return event;
            }

            // Create a writable copy of the event object and normalize some properties
            var i, prop, copy,
                type = event.type,
                originalEvent = event,
                fixHook = this.fixHooks[ type ];

            if ( !fixHook ) {
                this.fixHooks[ type ] = fixHook =
                    rmouseEvent.test( type ) ? this.mouseHooks :
                        rkeyEvent.test( type ) ? this.keyHooks :
                            {};
            }
            copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

            event = new jQuery.Event( originalEvent );

            i = copy.length;
            while ( i-- ) {
                prop = copy[ i ];
                event[ prop ] = originalEvent[ prop ];
            }

            // Support: Cordova 2.5 (WebKit) (#13255)
            // All events should have a target; Cordova deviceready doesn't
            if ( !event.target ) {
                event.target = document;
            }

            // Support: Safari 6.0+, Chrome < 28
            // Target should not be a text node (#504, #13143)
            if ( event.target.nodeType === 3 ) {
                event.target = event.target.parentNode;
            }

            return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
        },

        special: {
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            focus: {
                // Fire native event if possible so blur/focus sequence is correct
                trigger: function() {
                    if ( this !== safeActiveElement() && this.focus ) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if ( this === safeActiveElement() && this.blur ) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
                // For checkbox, fire native event so checked state will be right
                trigger: function() {
                    if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
                        this.click();
                        return false;
                    }
                },

                // For cross-browser consistency, don't fire native .click() on links
                _default: function( event ) {
                    return jQuery.nodeName( event.target, "a" );
                }
            },

            beforeunload: {
                postDispatch: function( event ) {

                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if ( event.result !== undefined && event.originalEvent ) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },

        simulate: function( type, elem, event, bubble ) {
            // Piggyback on a donor event to simulate a different one.
            // Fake originalEvent to avoid donor's stopPropagation, but if the
            // simulated event prevents default then we do the same on the donor.
            var e = jQuery.extend(
                new jQuery.Event(),
                event,
                {
                    type: type,
                    isSimulated: true,
                    originalEvent: {}
                }
            );
            if ( bubble ) {
                jQuery.event.trigger( e, null, elem );
            } else {
                jQuery.event.dispatch.call( elem, e );
            }
            if ( e.isDefaultPrevented() ) {
                event.preventDefault();
            }
        }
    };

    jQuery.removeEvent = function( elem, type, handle ) {
        if ( elem.removeEventListener ) {
            elem.removeEventListener( type, handle, false );
        }
    };

    jQuery.Event = function( src, props ) {
        // Allow instantiation without the 'new' keyword
        if ( !(this instanceof jQuery.Event) ) {
            return new jQuery.Event( src, props );
        }

        // Event object
        if ( src && src.type ) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented ||
            src.defaultPrevented === undefined &&
            // Support: Android < 4.0
            src.returnValue === false ?
                returnTrue :
                returnFalse;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if ( props ) {
            jQuery.extend( this, props );
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || jQuery.now();

        // Mark it as fixed
        this[ jQuery.expando ] = true;
    };

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,

        preventDefault: function() {
            var e = this.originalEvent;

            this.isDefaultPrevented = returnTrue;

            if ( e && e.preventDefault ) {
                e.preventDefault();
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;

            this.isPropagationStopped = returnTrue;

            if ( e && e.stopPropagation ) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;

            this.isImmediatePropagationStopped = returnTrue;

            if ( e && e.stopImmediatePropagation ) {
                e.stopImmediatePropagation();
            }

            this.stopPropagation();
        }
    };

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function( orig, fix ) {
        jQuery.event.special[ orig ] = {
            delegateType: fix,
            bindType: fix,

            handle: function( event ) {
                var ret,
                    target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj;

                // For mousenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply( this, arguments );
                    event.type = fix;
                }
                return ret;
            }
        };
    });

// Create "bubbling" focus and blur events
// Support: Firefox, Chrome, Safari
    if ( !support.focusinBubbles ) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

            // Attach a single capturing handler on the document while someone wants focusin/focusout
            var handler = function( event ) {
                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
            };

            jQuery.event.special[ fix ] = {
                setup: function() {
                    var doc = this.ownerDocument || this,
                        attaches = data_priv.access( doc, fix );

                    if ( !attaches ) {
                        doc.addEventListener( orig, handler, true );
                    }
                    data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
                },
                teardown: function() {
                    var doc = this.ownerDocument || this,
                        attaches = data_priv.access( doc, fix ) - 1;

                    if ( !attaches ) {
                        doc.removeEventListener( orig, handler, true );
                        data_priv.remove( doc, fix );

                    } else {
                        data_priv.access( doc, fix, attaches );
                    }
                }
            };
        });
    }

    jQuery.fn.extend({

        on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
            var origFn, type;

            // Types can be a map of types/handlers
            if ( typeof types === "object" ) {
                // ( types-Object, selector, data )
                if ( typeof selector !== "string" ) {
                    // ( types-Object, data )
                    data = data || selector;
                    selector = undefined;
                }
                for ( type in types ) {
                    this.on( type, selector, data, types[ type ], one );
                }
                return this;
            }

            if ( data == null && fn == null ) {
                // ( types, fn )
                fn = selector;
                data = selector = undefined;
            } else if ( fn == null ) {
                if ( typeof selector === "string" ) {
                    // ( types, selector, fn )
                    fn = data;
                    data = undefined;
                } else {
                    // ( types, data, fn )
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if ( fn === false ) {
                fn = returnFalse;
            } else if ( !fn ) {
                return this;
            }

            if ( one === 1 ) {
                origFn = fn;
                fn = function( event ) {
                    // Can use an empty set, since event contains the info
                    jQuery().off( event );
                    return origFn.apply( this, arguments );
                };
                // Use same guid so caller can remove using origFn
                fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
            }
            return this.each( function() {
                jQuery.event.add( this, types, fn, data, selector );
            });
        },
        one: function( types, selector, data, fn ) {
            return this.on( types, selector, data, fn, 1 );
        },
        off: function( types, selector, fn ) {
            var handleObj, type;
            if ( types && types.preventDefault && types.handleObj ) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery( types.delegateTarget ).off(
                    handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                    handleObj.selector,
                    handleObj.handler
                );
                return this;
            }
            if ( typeof types === "object" ) {
                // ( types-object [, selector] )
                for ( type in types ) {
                    this.off( type, selector, types[ type ] );
                }
                return this;
            }
            if ( selector === false || typeof selector === "function" ) {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if ( fn === false ) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove( this, types, fn, selector );
            });
        },

        trigger: function( type, data ) {
            return this.each(function() {
                jQuery.event.trigger( type, data, this );
            });
        },
        triggerHandler: function( type, data ) {
            var elem = this[0];
            if ( elem ) {
                return jQuery.event.trigger( type, data, elem, true );
            }
        }
    });


    var
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
        rtagName = /<([\w:]+)/,
        rhtml = /<|&#?\w+;/,
        rnoInnerhtml = /<(?:script|style|link)/i,
        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptType = /^$|\/(?:java|ecma)script/i,
        rscriptTypeMasked = /^true\/(.*)/,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

        // We have to close these tags to support XHTML (#13200)
        wrapMap = {

            // Support: IE 9
            option: [ 1, "<select multiple='multiple'>", "</select>" ],

            thead: [ 1, "<table>", "</table>" ],
            col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
            tr: [ 2, "<table><tbody>", "</tbody></table>" ],
            td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

            _default: [ 0, "", "" ]
        };

// Support: IE 9
    wrapMap.optgroup = wrapMap.option;

    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
    function manipulationTarget( elem, content ) {
        return jQuery.nodeName( elem, "table" ) &&
        jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

            elem.getElementsByTagName("tbody")[0] ||
            elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
            elem;
    }

// Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript( elem ) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript( elem ) {
        var match = rscriptTypeMasked.exec( elem.type );

        if ( match ) {
            elem.type = match[ 1 ];
        } else {
            elem.removeAttribute("type");
        }

        return elem;
    }

// Mark scripts as having already been evaluated
    function setGlobalEval( elems, refElements ) {
        var i = 0,
            l = elems.length;

        for ( ; i < l; i++ ) {
            data_priv.set(
                elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
            );
        }
    }

    function cloneCopyEvent( src, dest ) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

        if ( dest.nodeType !== 1 ) {
            return;
        }

        // 1. Copy private data: events, handlers, etc.
        if ( data_priv.hasData( src ) ) {
            pdataOld = data_priv.access( src );
            pdataCur = data_priv.set( dest, pdataOld );
            events = pdataOld.events;

            if ( events ) {
                delete pdataCur.handle;
                pdataCur.events = {};

                for ( type in events ) {
                    for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                        jQuery.event.add( dest, type, events[ type ][ i ] );
                    }
                }
            }
        }

        // 2. Copy user data
        if ( data_user.hasData( src ) ) {
            udataOld = data_user.access( src );
            udataCur = jQuery.extend( {}, udataOld );

            data_user.set( dest, udataCur );
        }
    }

    function getAll( context, tag ) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
            context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
                [];

        return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
            jQuery.merge( [ context ], ret ) :
            ret;
    }

// Support: IE >= 9
    function fixInput( src, dest ) {
        var nodeName = dest.nodeName.toLowerCase();

        // Fails to persist the checked state of a cloned checkbox or radio button.
        if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
            dest.checked = src.checked;

            // Fails to return the selected option to the default selected state when cloning options
        } else if ( nodeName === "input" || nodeName === "textarea" ) {
            dest.defaultValue = src.defaultValue;
        }
    }

    jQuery.extend({
        clone: function( elem, dataAndEvents, deepDataAndEvents ) {
            var i, l, srcElements, destElements,
                clone = elem.cloneNode( true ),
                inPage = jQuery.contains( elem.ownerDocument, elem );

            // Support: IE >= 9
            // Fix Cloning issues
            if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
                !jQuery.isXMLDoc( elem ) ) {

                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                destElements = getAll( clone );
                srcElements = getAll( elem );

                for ( i = 0, l = srcElements.length; i < l; i++ ) {
                    fixInput( srcElements[ i ], destElements[ i ] );
                }
            }

            // Copy the events from the original to the clone
            if ( dataAndEvents ) {
                if ( deepDataAndEvents ) {
                    srcElements = srcElements || getAll( elem );
                    destElements = destElements || getAll( clone );

                    for ( i = 0, l = srcElements.length; i < l; i++ ) {
                        cloneCopyEvent( srcElements[ i ], destElements[ i ] );
                    }
                } else {
                    cloneCopyEvent( elem, clone );
                }
            }

            // Preserve script evaluation history
            destElements = getAll( clone, "script" );
            if ( destElements.length > 0 ) {
                setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
            }

            // Return the cloned set
            return clone;
        },

        buildFragment: function( elems, context, scripts, selection ) {
            var elem, tmp, tag, wrap, contains, j,
                fragment = context.createDocumentFragment(),
                nodes = [],
                i = 0,
                l = elems.length;

            for ( ; i < l; i++ ) {
                elem = elems[ i ];

                if ( elem || elem === 0 ) {

                    // Add nodes directly
                    if ( jQuery.type( elem ) === "object" ) {
                        // Support: QtWebKit
                        // jQuery.merge because push.apply(_, arraylike) throws
                        jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                        // Convert non-html into a text node
                    } else if ( !rhtml.test( elem ) ) {
                        nodes.push( context.createTextNode( elem ) );

                        // Convert html into DOM nodes
                    } else {
                        tmp = tmp || fragment.appendChild( context.createElement("div") );

                        // Deserialize a standard representation
                        tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
                        wrap = wrapMap[ tag ] || wrapMap._default;
                        tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

                        // Descend through wrappers to the right content
                        j = wrap[ 0 ];
                        while ( j-- ) {
                            tmp = tmp.lastChild;
                        }

                        // Support: QtWebKit
                        // jQuery.merge because push.apply(_, arraylike) throws
                        jQuery.merge( nodes, tmp.childNodes );

                        // Remember the top-level container
                        tmp = fragment.firstChild;

                        // Fixes #12346
                        // Support: Webkit, IE
                        tmp.textContent = "";
                    }
                }
            }

            // Remove wrapper from fragment
            fragment.textContent = "";

            i = 0;
            while ( (elem = nodes[ i++ ]) ) {

                // #4087 - If origin and destination elements are the same, and this is
                // that element, do not do anything
                if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
                    continue;
                }

                contains = jQuery.contains( elem.ownerDocument, elem );

                // Append to fragment
                tmp = getAll( fragment.appendChild( elem ), "script" );

                // Preserve script evaluation history
                if ( contains ) {
                    setGlobalEval( tmp );
                }

                // Capture executables
                if ( scripts ) {
                    j = 0;
                    while ( (elem = tmp[ j++ ]) ) {
                        if ( rscriptType.test( elem.type || "" ) ) {
                            scripts.push( elem );
                        }
                    }
                }
            }

            return fragment;
        },

        cleanData: function( elems ) {
            var data, elem, type, key,
                special = jQuery.event.special,
                i = 0;

            for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
                if ( jQuery.acceptData( elem ) ) {
                    key = elem[ data_priv.expando ];

                    if ( key && (data = data_priv.cache[ key ]) ) {
                        if ( data.events ) {
                            for ( type in data.events ) {
                                if ( special[ type ] ) {
                                    jQuery.event.remove( elem, type );

                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                } else {
                                    jQuery.removeEvent( elem, type, data.handle );
                                }
                            }
                        }
                        if ( data_priv.cache[ key ] ) {
                            // Discard any remaining `private` data
                            delete data_priv.cache[ key ];
                        }
                    }
                }
                // Discard any remaining `user` data
                delete data_user.cache[ elem[ data_user.expando ] ];
            }
        }
    });

    jQuery.fn.extend({
        text: function( value ) {
            return access( this, function( value ) {
                return value === undefined ?
                    jQuery.text( this ) :
                    this.empty().each(function() {
                        if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                            this.textContent = value;
                        }
                    });
            }, null, value, arguments.length );
        },

        append: function() {
            return this.domManip( arguments, function( elem ) {
                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                    var target = manipulationTarget( this, elem );
                    target.appendChild( elem );
                }
            });
        },

        prepend: function() {
            return this.domManip( arguments, function( elem ) {
                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                    var target = manipulationTarget( this, elem );
                    target.insertBefore( elem, target.firstChild );
                }
            });
        },

        before: function() {
            return this.domManip( arguments, function( elem ) {
                if ( this.parentNode ) {
                    this.parentNode.insertBefore( elem, this );
                }
            });
        },

        after: function() {
            return this.domManip( arguments, function( elem ) {
                if ( this.parentNode ) {
                    this.parentNode.insertBefore( elem, this.nextSibling );
                }
            });
        },

        remove: function( selector, keepData /* Internal Use Only */ ) {
            var elem,
                elems = selector ? jQuery.filter( selector, this ) : this,
                i = 0;

            for ( ; (elem = elems[i]) != null; i++ ) {
                if ( !keepData && elem.nodeType === 1 ) {
                    jQuery.cleanData( getAll( elem ) );
                }

                if ( elem.parentNode ) {
                    if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
                        setGlobalEval( getAll( elem, "script" ) );
                    }
                    elem.parentNode.removeChild( elem );
                }
            }

            return this;
        },

        empty: function() {
            var elem,
                i = 0;

            for ( ; (elem = this[i]) != null; i++ ) {
                if ( elem.nodeType === 1 ) {

                    // Prevent memory leaks
                    jQuery.cleanData( getAll( elem, false ) );

                    // Remove any remaining nodes
                    elem.textContent = "";
                }
            }

            return this;
        },

        clone: function( dataAndEvents, deepDataAndEvents ) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function() {
                return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
            });
        },

        html: function( value ) {
            return access( this, function( value ) {
                var elem = this[ 0 ] || {},
                    i = 0,
                    l = this.length;

                if ( value === undefined && elem.nodeType === 1 ) {
                    return elem.innerHTML;
                }

                // See if we can take a shortcut and just use innerHTML
                if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                    !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

                    value = value.replace( rxhtmlTag, "<$1></$2>" );

                    try {
                        for ( ; i < l; i++ ) {
                            elem = this[ i ] || {};

                            // Remove element nodes and prevent memory leaks
                            if ( elem.nodeType === 1 ) {
                                jQuery.cleanData( getAll( elem, false ) );
                                elem.innerHTML = value;
                            }
                        }

                        elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                    } catch( e ) {}
                }

                if ( elem ) {
                    this.empty().append( value );
                }
            }, null, value, arguments.length );
        },

        replaceWith: function() {
            var arg = arguments[ 0 ];

            // Make the changes, replacing each context element with the new content
            this.domManip( arguments, function( elem ) {
                arg = this.parentNode;

                jQuery.cleanData( getAll( this ) );

                if ( arg ) {
                    arg.replaceChild( elem, this );
                }
            });

            // Force removal if there was no new content (e.g., from empty arguments)
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },

        detach: function( selector ) {
            return this.remove( selector, true );
        },

        domManip: function( args, callback ) {

            // Flatten any nested arrays
            args = concat.apply( [], args );

            var fragment, first, scripts, hasScripts, node, doc,
                i = 0,
                l = this.length,
                set = this,
                iNoClone = l - 1,
                value = args[ 0 ],
                isFunction = jQuery.isFunction( value );

            // We can't cloneNode fragments that contain checked, in WebKit
            if ( isFunction ||
                ( l > 1 && typeof value === "string" &&
                    !support.checkClone && rchecked.test( value ) ) ) {
                return this.each(function( index ) {
                    var self = set.eq( index );
                    if ( isFunction ) {
                        args[ 0 ] = value.call( this, index, self.html() );
                    }
                    self.domManip( args, callback );
                });
            }

            if ( l ) {
                fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
                first = fragment.firstChild;

                if ( fragment.childNodes.length === 1 ) {
                    fragment = first;
                }

                if ( first ) {
                    scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
                    hasScripts = scripts.length;

                    // Use the original fragment for the last item instead of the first because it can end up
                    // being emptied incorrectly in certain situations (#8070).
                    for ( ; i < l; i++ ) {
                        node = fragment;

                        if ( i !== iNoClone ) {
                            node = jQuery.clone( node, true, true );

                            // Keep references to cloned scripts for later restoration
                            if ( hasScripts ) {
                                // Support: QtWebKit
                                // jQuery.merge because push.apply(_, arraylike) throws
                                jQuery.merge( scripts, getAll( node, "script" ) );
                            }
                        }

                        callback.call( this[ i ], node, i );
                    }

                    if ( hasScripts ) {
                        doc = scripts[ scripts.length - 1 ].ownerDocument;

                        // Reenable scripts
                        jQuery.map( scripts, restoreScript );

                        // Evaluate executable scripts on first document insertion
                        for ( i = 0; i < hasScripts; i++ ) {
                            node = scripts[ i ];
                            if ( rscriptType.test( node.type || "" ) &&
                                !data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

                                if ( node.src ) {
                                    // Optional AJAX dependency, but won't run scripts if not present
                                    if ( jQuery._evalUrl ) {
                                        jQuery._evalUrl( node.src );
                                    }
                                } else {
                                    jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
                                }
                            }
                        }
                    }
                }
            }

            return this;
        }
    });

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function( name, original ) {
        jQuery.fn[ name ] = function( selector ) {
            var elems,
                ret = [],
                insert = jQuery( selector ),
                last = insert.length - 1,
                i = 0;

            for ( ; i <= last; i++ ) {
                elems = i === last ? this : this.clone( true );
                jQuery( insert[ i ] )[ original ]( elems );

                // Support: QtWebKit
                // .get() because push.apply(_, arraylike) throws
                push.apply( ret, elems.get() );
            }

            return this.pushStack( ret );
        };
    });


    var iframe,
        elemdisplay = {};

    /**
     * Retrieve the actual display of a element
     * @param {String} name nodeName of the element
     * @param {Object} doc Document object
     */
// Called only from within defaultDisplay
    function actualDisplay( name, doc ) {
        var style,
            elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

            // getDefaultComputedStyle might be reliably used only on attached element
            display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

                // Use of this method is a temporary fix (more like optmization) until something better comes along,
                // since it was removed from specification and supported only in FF
                style.display : jQuery.css( elem[ 0 ], "display" );

        // We don't have any data stored on the element,
        // so use "detach" method as fast way to get rid of the element
        elem.detach();

        return display;
    }

    /**
     * Try to determine the default display value of an element
     * @param {String} nodeName
     */
    function defaultDisplay( nodeName ) {
        var doc = document,
            display = elemdisplay[ nodeName ];

        if ( !display ) {
            display = actualDisplay( nodeName, doc );

            // If the simple way fails, read from inside an iframe
            if ( display === "none" || !display ) {

                // Use the already-created iframe if possible
                iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

                // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                doc = iframe[ 0 ].contentDocument;

                // Support: IE
                doc.write();
                doc.close();

                display = actualDisplay( nodeName, doc );
                iframe.detach();
            }

            // Store the correct default display
            elemdisplay[ nodeName ] = display;
        }

        return display;
    }
    var rmargin = (/^margin/);

    var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

    var getStyles = function( elem ) {
        return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
    };



    function curCSS( elem, name, computed ) {
        var width, minWidth, maxWidth, ret,
            style = elem.style;

        computed = computed || getStyles( elem );

        // Support: IE9
        // getPropertyValue is only needed for .css('filter') in IE9, see #12537
        if ( computed ) {
            ret = computed.getPropertyValue( name ) || computed[ name ];
        }

        if ( computed ) {

            if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
                ret = jQuery.style( elem, name );
            }

            // Support: iOS < 6
            // A tribute to the "awesome hack by Dean Edwards"
            // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
            // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
            if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;

                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;

                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }

        return ret !== undefined ?
            // Support: IE
            // IE returns zIndex value as an integer.
            ret + "" :
            ret;
    }


    function addGetHookIf( conditionFn, hookFn ) {
        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function() {
                if ( conditionFn() ) {
                    // Hook not needed (or it's not possible to use it due to missing dependency),
                    // remove it.
                    // Since there are no other hooks for marginRight, remove the whole object.
                    delete this.get;
                    return;
                }

                // Hook needed; redefine it so that the support test is not executed again.

                return (this.get = hookFn).apply( this, arguments );
            }
        };
    }


    (function() {
        var pixelPositionVal, boxSizingReliableVal,
            docElem = document.documentElement,
            container = document.createElement( "div" ),
            div = document.createElement( "div" );

        if ( !div.style ) {
            return;
        }

        div.style.backgroundClip = "content-box";
        div.cloneNode( true ).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";

        container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
            "position:absolute";
        container.appendChild( div );

        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computePixelPositionAndBoxSizingReliable() {
            div.style.cssText =
                // Support: Firefox<29, Android 2.3
                // Vendor-prefix box-sizing
                "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
                "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
                "border:1px;padding:1px;width:4px;position:absolute";
            div.innerHTML = "";
            docElem.appendChild( container );

            var divStyle = window.getComputedStyle( div, null );
            pixelPositionVal = divStyle.top !== "1%";
            boxSizingReliableVal = divStyle.width === "4px";

            docElem.removeChild( container );
        }

        // Support: node.js jsdom
        // Don't assume that getComputedStyle is a property of the global object
        if ( window.getComputedStyle ) {
            jQuery.extend( support, {
                pixelPosition: function() {
                    // This test is executed only once but we still do memoizing
                    // since we can use the boxSizingReliable pre-computing.
                    // No need to check if the test was already performed, though.
                    computePixelPositionAndBoxSizingReliable();
                    return pixelPositionVal;
                },
                boxSizingReliable: function() {
                    if ( boxSizingReliableVal == null ) {
                        computePixelPositionAndBoxSizingReliable();
                    }
                    return boxSizingReliableVal;
                },
                reliableMarginRight: function() {
                    // Support: Android 2.3
                    // Check if div with explicit width and no margin-right incorrectly
                    // gets computed margin-right based on width of container. (#3333)
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    // This support function is only executed once so no memoizing is needed.
                    var ret,
                        marginDiv = div.appendChild( document.createElement( "div" ) );

                    // Reset CSS: box-sizing; display; margin; border; padding
                    marginDiv.style.cssText = div.style.cssText =
                        // Support: Firefox<29, Android 2.3
                        // Vendor-prefix box-sizing
                        "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                        "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                    marginDiv.style.marginRight = marginDiv.style.width = "0";
                    div.style.width = "1px";
                    docElem.appendChild( container );

                    ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

                    docElem.removeChild( container );

                    return ret;
                }
            });
        }
    })();


// A method for quickly swapping in/out CSS properties to get correct calculations.
    jQuery.swap = function( elem, options, callback, args ) {
        var ret, name,
            old = {};

        // Remember the old values, and insert the new ones
        for ( name in options ) {
            old[ name ] = elem.style[ name ];
            elem.style[ name ] = options[ name ];
        }

        ret = callback.apply( elem, args || [] );

        // Revert the old values
        for ( name in options ) {
            elem.style[ name ] = old[ name ];
        }

        return ret;
    };


    var
        // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
        // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
        rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
        rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

        cssShow = { position: "absolute", visibility: "hidden", display: "block" },
        cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
        },

        cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// return a css property mapped to a potentially vendor prefixed property
    function vendorPropName( style, name ) {

        // shortcut for names that are not vendor prefixed
        if ( name in style ) {
            return name;
        }

        // check for vendor prefixed names
        var capName = name[0].toUpperCase() + name.slice(1),
            origName = name,
            i = cssPrefixes.length;

        while ( i-- ) {
            name = cssPrefixes[ i ] + capName;
            if ( name in style ) {
                return name;
            }
        }

        return origName;
    }

    function setPositiveNumber( elem, value, subtract ) {
        var matches = rnumsplit.exec( value );
        return matches ?
            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
            value;
    }

    function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
        var i = extra === ( isBorderBox ? "border" : "content" ) ?
            // If we already have the right measurement, avoid augmentation
            4 :
            // Otherwise initialize for horizontal or vertical properties
            name === "width" ? 1 : 0,

            val = 0;

        for ( ; i < 4; i += 2 ) {
            // both box models exclude margin, so add it if we want it
            if ( extra === "margin" ) {
                val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
            }

            if ( isBorderBox ) {
                // border-box includes padding, so remove it if we want content
                if ( extra === "content" ) {
                    val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
                }

                // at this point, extra isn't border nor margin, so remove border
                if ( extra !== "margin" ) {
                    val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                }
            } else {
                // at this point, extra isn't content, so add padding
                val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

                // at this point, extra isn't content nor padding, so add border
                if ( extra !== "padding" ) {
                    val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                }
            }
        }

        return val;
    }

    function getWidthOrHeight( elem, name, extra ) {

        // Start with offset property, which is equivalent to the border-box value
        var valueIsBorderBox = true,
            val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            styles = getStyles( elem ),
            isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

        // some non-html elements return undefined for offsetWidth, so check for null/undefined
        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
        if ( val <= 0 || val == null ) {
            // Fall back to computed then uncomputed css if necessary
            val = curCSS( elem, name, styles );
            if ( val < 0 || val == null ) {
                val = elem.style[ name ];
            }

            // Computed unit is not pixels. Stop here and return.
            if ( rnumnonpx.test(val) ) {
                return val;
            }

            // we need the check for style in case a browser which returns unreliable values
            // for getComputedStyle silently falls back to the reliable elem.style
            valueIsBorderBox = isBorderBox &&
                ( support.boxSizingReliable() || val === elem.style[ name ] );

            // Normalize "", auto, and prepare for extra
            val = parseFloat( val ) || 0;
        }

        // use the active box-sizing model to add/subtract irrelevant styles
        return ( val +
            augmentWidthOrHeight(
                elem,
                name,
                extra || ( isBorderBox ? "border" : "content" ),
                valueIsBorderBox,
                styles
            )
        ) + "px";
    }

    function showHide( elements, show ) {
        var display, elem, hidden,
            values = [],
            index = 0,
            length = elements.length;

        for ( ; index < length; index++ ) {
            elem = elements[ index ];
            if ( !elem.style ) {
                continue;
            }

            values[ index ] = data_priv.get( elem, "olddisplay" );
            display = elem.style.display;
            if ( show ) {
                // Reset the inline display of this element to learn if it is
                // being hidden by cascaded rules or not
                if ( !values[ index ] && display === "none" ) {
                    elem.style.display = "";
                }

                // Set elements which have been overridden with display: none
                // in a stylesheet to whatever the default browser style is
                // for such an element
                if ( elem.style.display === "" && isHidden( elem ) ) {
                    values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
                }
            } else {
                hidden = isHidden( elem );

                if ( display !== "none" || !hidden ) {
                    data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
                }
            }
        }

        // Set the display of most of the elements in a second loop
        // to avoid the constant reflow
        for ( index = 0; index < length; index++ ) {
            elem = elements[ index ];
            if ( !elem.style ) {
                continue;
            }
            if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
                elem.style.display = show ? values[ index ] || "" : "none";
            }
        }

        return elements;
    }

    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function( elem, computed ) {
                    if ( computed ) {
                        // We should always get a number back from opacity
                        var ret = curCSS( elem, "opacity" );
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },

        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": "cssFloat"
        },

        // Get and set the style property on a DOM Node
        style: function( elem, name, value, extra ) {
            // Don't set styles on text and comment nodes
            if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, hooks,
                origName = jQuery.camelCase( name ),
                style = elem.style;

            name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

            // gets hook for the prefixed version
            // followed by the unprefixed version
            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

            // Check if we're setting a value
            if ( value !== undefined ) {
                type = typeof value;

                // convert relative number strings (+= or -=) to relative numbers. #7345
                if ( type === "string" && (ret = rrelNum.exec( value )) ) {
                    value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that null and NaN values aren't set. See: #7116
                if ( value == null || value !== value ) {
                    return;
                }

                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
                    value += "px";
                }

                // Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
                // but it would mean to define eight (for every problematic property) identical functions
                if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
                    style[ name ] = "inherit";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
                    style[ name ] = value;
                }

            } else {
                // If a hook was provided get the non-computed value from there
                if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[ name ];
            }
        },

        css: function( elem, name, extra, styles ) {
            var val, num, hooks,
                origName = jQuery.camelCase( name );

            // Make sure that we're working with the right name
            name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

            // gets hook for the prefixed version
            // followed by the unprefixed version
            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

            // If a hook was provided get the computed value from there
            if ( hooks && "get" in hooks ) {
                val = hooks.get( elem, true, extra );
            }

            // Otherwise, if a way to get the computed value exists, use that
            if ( val === undefined ) {
                val = curCSS( elem, name, styles );
            }

            //convert "normal" to computed value
            if ( val === "normal" && name in cssNormalTransform ) {
                val = cssNormalTransform[ name ];
            }

            // Return, converting to number if forced or a qualifier was provided and val looks numeric
            if ( extra === "" || extra ) {
                num = parseFloat( val );
                return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
            }
            return val;
        }
    });

    jQuery.each([ "height", "width" ], function( i, name ) {
        jQuery.cssHooks[ name ] = {
            get: function( elem, computed, extra ) {
                if ( computed ) {
                    // certain elements can have dimension info if we invisibly show them
                    // however, it must have a current display style that would benefit from this
                    return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
                        jQuery.swap( elem, cssShow, function() {
                            return getWidthOrHeight( elem, name, extra );
                        }) :
                        getWidthOrHeight( elem, name, extra );
                }
            },

            set: function( elem, value, extra ) {
                var styles = extra && getStyles( elem );
                return setPositiveNumber( elem, value, extra ?
                    augmentWidthOrHeight(
                        elem,
                        name,
                        extra,
                        jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                        styles
                    ) : 0
                );
            }
        };
    });

// Support: Android 2.3
    jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
        function( elem, computed ) {
            if ( computed ) {
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                // Work around by temporarily setting element display to inline-block
                return jQuery.swap( elem, { "display": "inline-block" },
                    curCSS, [ elem, "marginRight" ] );
            }
        }
    );

// These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function( prefix, suffix ) {
        jQuery.cssHooks[ prefix + suffix ] = {
            expand: function( value ) {
                var i = 0,
                    expanded = {},

                    // assumes a single number if not a string
                    parts = typeof value === "string" ? value.split(" ") : [ value ];

                for ( ; i < 4; i++ ) {
                    expanded[ prefix + cssExpand[ i ] + suffix ] =
                        parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                }

                return expanded;
            }
        };

        if ( !rmargin.test( prefix ) ) {
            jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
        }
    });

    jQuery.fn.extend({
        css: function( name, value ) {
            return access( this, function( elem, name, value ) {
                var styles, len,
                    map = {},
                    i = 0;

                if ( jQuery.isArray( name ) ) {
                    styles = getStyles( elem );
                    len = name.length;

                    for ( ; i < len; i++ ) {
                        map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                    }

                    return map;
                }

                return value !== undefined ?
                    jQuery.style( elem, name, value ) :
                    jQuery.css( elem, name );
            }, name, value, arguments.length > 1 );
        },
        show: function() {
            return showHide( this, true );
        },
        hide: function() {
            return showHide( this );
        },
        toggle: function( state ) {
            if ( typeof state === "boolean" ) {
                return state ? this.show() : this.hide();
            }

            return this.each(function() {
                if ( isHidden( this ) ) {
                    jQuery( this ).show();
                } else {
                    jQuery( this ).hide();
                }
            });
        }
    });


    function Tween( elem, options, prop, end, easing ) {
        return new Tween.prototype.init( elem, options, prop, end, easing );
    }
    jQuery.Tween = Tween;

    Tween.prototype = {
        constructor: Tween,
        init: function( elem, options, prop, end, easing, unit ) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
        },
        cur: function() {
            var hooks = Tween.propHooks[ this.prop ];

            return hooks && hooks.get ?
                hooks.get( this ) :
                Tween.propHooks._default.get( this );
        },
        run: function( percent ) {
            var eased,
                hooks = Tween.propHooks[ this.prop ];

            if ( this.options.duration ) {
                this.pos = eased = jQuery.easing[ this.easing ](
                    percent, this.options.duration * percent, 0, 1, this.options.duration
                );
            } else {
                this.pos = eased = percent;
            }
            this.now = ( this.end - this.start ) * eased + this.start;

            if ( this.options.step ) {
                this.options.step.call( this.elem, this.now, this );
            }

            if ( hooks && hooks.set ) {
                hooks.set( this );
            } else {
                Tween.propHooks._default.set( this );
            }
            return this;
        }
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
        _default: {
            get: function( tween ) {
                var result;

                if ( tween.elem[ tween.prop ] != null &&
                    (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
                    return tween.elem[ tween.prop ];
                }

                // passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails
                // so, simple values such as "10px" are parsed to Float.
                // complex values such as "rotate(1rad)" are returned as is.
                result = jQuery.css( tween.elem, tween.prop, "" );
                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function( tween ) {
                // use step hook for back compat - use cssHook if its there - use .style if its
                // available and use plain properties where available
                if ( jQuery.fx.step[ tween.prop ] ) {
                    jQuery.fx.step[ tween.prop ]( tween );
                } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
                    jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
                } else {
                    tween.elem[ tween.prop ] = tween.now;
                }
            }
        }
    };

// Support: IE9
// Panic based approach to setting things on disconnected nodes

    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function( tween ) {
            if ( tween.elem.nodeType && tween.elem.parentNode ) {
                tween.elem[ tween.prop ] = tween.now;
            }
        }
    };

    jQuery.easing = {
        linear: function( p ) {
            return p;
        },
        swing: function( p ) {
            return 0.5 - Math.cos( p * Math.PI ) / 2;
        }
    };

    jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
    jQuery.fx.step = {};




    var
        fxNow, timerId,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
        rrun = /queueHooks$/,
        animationPrefilters = [ defaultPrefilter ],
        tweeners = {
            "*": [ function( prop, value ) {
                var tween = this.createTween( prop, value ),
                    target = tween.cur(),
                    parts = rfxnum.exec( value ),
                    unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

                    // Starting value computation is required for potential unit mismatches
                    start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
                        rfxnum.exec( jQuery.css( tween.elem, prop ) ),
                    scale = 1,
                    maxIterations = 20;

                if ( start && start[ 3 ] !== unit ) {
                    // Trust units reported by jQuery.css
                    unit = unit || start[ 3 ];

                    // Make sure we update the tween properties later on
                    parts = parts || [];

                    // Iteratively approximate from a nonzero starting point
                    start = +target || 1;

                    do {
                        // If previous iteration zeroed out, double until we get *something*
                        // Use a string for doubling factor so we don't accidentally see scale as unchanged below
                        scale = scale || ".5";

                        // Adjust and apply
                        start = start / scale;
                        jQuery.style( tween.elem, prop, start + unit );

                        // Update scale, tolerating zero or NaN from tween.cur()
                        // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
                    } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
                }

                // Update tween properties
                if ( parts ) {
                    start = tween.start = +start || +target || 0;
                    tween.unit = unit;
                    // If a +=/-= token was provided, we're doing a relative animation
                    tween.end = parts[ 1 ] ?
                        start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
                        +parts[ 2 ];
                }

                return tween;
            } ]
        };

// Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout(function() {
            fxNow = undefined;
        });
        return ( fxNow = jQuery.now() );
    }

// Generate parameters to create a standard animation
    function genFx( type, includeWidth ) {
        var which,
            i = 0,
            attrs = { height: type };

        // if we include width, step value is 1 to do all cssExpand values,
        // if we don't include width, step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for ( ; i < 4 ; i += 2 - includeWidth ) {
            which = cssExpand[ i ];
            attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
        }

        if ( includeWidth ) {
            attrs.opacity = attrs.width = type;
        }

        return attrs;
    }

    function createTween( value, prop, animation ) {
        var tween,
            collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
            index = 0,
            length = collection.length;
        for ( ; index < length; index++ ) {
            if ( (tween = collection[ index ].call( animation, prop, value )) ) {

                // we're done with this property
                return tween;
            }
        }
    }

    function defaultPrefilter( elem, props, opts ) {
        /* jshint validthis: true */
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
            anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHidden( elem ),
            dataShow = data_priv.get( elem, "fxshow" );

        // handle queue: false promises
        if ( !opts.queue ) {
            hooks = jQuery._queueHooks( elem, "fx" );
            if ( hooks.unqueued == null ) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if ( !hooks.unqueued ) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;

            anim.always(function() {
                // doing this makes sure that the complete handler will be called
                // before this completes
                anim.always(function() {
                    hooks.unqueued--;
                    if ( !jQuery.queue( elem, "fx" ).length ) {
                        hooks.empty.fire();
                    }
                });
            });
        }

        // height/width overflow pass
        if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
            // Make sure that nothing sneaks out
            // Record all 3 overflow attributes because IE9-10 do not
            // change the overflow attribute when overflowX and
            // overflowY are set to the same value
            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

            // Set display property to inline-block for height/width
            // animations on inline elements that are having width/height animated
            display = jQuery.css( elem, "display" );

            // Test default display if display is currently "none"
            checkDisplay = display === "none" ?
                data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

            if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
                style.display = "inline-block";
            }
        }

        if ( opts.overflow ) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[ 0 ];
                style.overflowX = opts.overflow[ 1 ];
                style.overflowY = opts.overflow[ 2 ];
            });
        }

        // show/hide pass
        for ( prop in props ) {
            value = props[ prop ];
            if ( rfxtypes.exec( value ) ) {
                delete props[ prop ];
                toggle = toggle || value === "toggle";
                if ( value === ( hidden ? "hide" : "show" ) ) {

                    // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                    if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

                // Any non-fx value stops us from restoring the original display value
            } else {
                display = undefined;
            }
        }

        if ( !jQuery.isEmptyObject( orig ) ) {
            if ( dataShow ) {
                if ( "hidden" in dataShow ) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = data_priv.access( elem, "fxshow", {} );
            }

            // store state if its toggle - enables .stop().toggle() to "reverse"
            if ( toggle ) {
                dataShow.hidden = !hidden;
            }
            if ( hidden ) {
                jQuery( elem ).show();
            } else {
                anim.done(function() {
                    jQuery( elem ).hide();
                });
            }
            anim.done(function() {
                var prop;

                data_priv.remove( elem, "fxshow" );
                for ( prop in orig ) {
                    jQuery.style( elem, prop, orig[ prop ] );
                }
            });
            for ( prop in orig ) {
                tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

                if ( !( prop in dataShow ) ) {
                    dataShow[ prop ] = tween.start;
                    if ( hidden ) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }

            // If this is a noop like .hide().hide(), restore an overwritten display value
        } else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
            style.display = display;
        }
    }

    function propFilter( props, specialEasing ) {
        var index, name, easing, value, hooks;

        // camelCase, specialEasing and expand cssHook pass
        for ( index in props ) {
            name = jQuery.camelCase( index );
            easing = specialEasing[ name ];
            value = props[ index ];
            if ( jQuery.isArray( value ) ) {
                easing = value[ 1 ];
                value = props[ index ] = value[ 0 ];
            }

            if ( index !== name ) {
                props[ name ] = value;
                delete props[ index ];
            }

            hooks = jQuery.cssHooks[ name ];
            if ( hooks && "expand" in hooks ) {
                value = hooks.expand( value );
                delete props[ name ];

                // not quite $.extend, this wont overwrite keys already present.
                // also - reusing 'index' from above because we have the correct "name"
                for ( index in value ) {
                    if ( !( index in props ) ) {
                        props[ index ] = value[ index ];
                        specialEasing[ index ] = easing;
                    }
                }
            } else {
                specialEasing[ name ] = easing;
            }
        }
    }

    function Animation( elem, properties, options ) {
        var result,
            stopped,
            index = 0,
            length = animationPrefilters.length,
            deferred = jQuery.Deferred().always( function() {
                // don't match elem in the :animated selector
                delete tick.elem;
            }),
            tick = function() {
                if ( stopped ) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
                    // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;

                for ( ; index < length ; index++ ) {
                    animation.tweens[ index ].run( percent );
                }

                deferred.notifyWith( elem, [ animation, percent, remaining ]);

                if ( percent < 1 && length ) {
                    return remaining;
                } else {
                    deferred.resolveWith( elem, [ animation ] );
                    return false;
                }
            },
            animation = deferred.promise({
                elem: elem,
                props: jQuery.extend( {}, properties ),
                opts: jQuery.extend( true, { specialEasing: {} }, options ),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function( prop, end ) {
                    var tween = jQuery.Tween( elem, animation.opts, prop, end,
                        animation.opts.specialEasing[ prop ] || animation.opts.easing );
                    animation.tweens.push( tween );
                    return tween;
                },
                stop: function( gotoEnd ) {
                    var index = 0,
                        // if we are going to the end, we want to run all the tweens
                        // otherwise we skip this part
                        length = gotoEnd ? animation.tweens.length : 0;
                    if ( stopped ) {
                        return this;
                    }
                    stopped = true;
                    for ( ; index < length ; index++ ) {
                        animation.tweens[ index ].run( 1 );
                    }

                    // resolve when we played the last frame
                    // otherwise, reject
                    if ( gotoEnd ) {
                        deferred.resolveWith( elem, [ animation, gotoEnd ] );
                    } else {
                        deferred.rejectWith( elem, [ animation, gotoEnd ] );
                    }
                    return this;
                }
            }),
            props = animation.props;

        propFilter( props, animation.opts.specialEasing );

        for ( ; index < length ; index++ ) {
            result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
            if ( result ) {
                return result;
            }
        }

        jQuery.map( props, createTween, animation );

        if ( jQuery.isFunction( animation.opts.start ) ) {
            animation.opts.start.call( elem, animation );
        }

        jQuery.fx.timer(
            jQuery.extend( tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            })
        );

        // attach callbacks from options
        return animation.progress( animation.opts.progress )
            .done( animation.opts.done, animation.opts.complete )
            .fail( animation.opts.fail )
            .always( animation.opts.always );
    }

    jQuery.Animation = jQuery.extend( Animation, {

        tweener: function( props, callback ) {
            if ( jQuery.isFunction( props ) ) {
                callback = props;
                props = [ "*" ];
            } else {
                props = props.split(" ");
            }

            var prop,
                index = 0,
                length = props.length;

            for ( ; index < length ; index++ ) {
                prop = props[ index ];
                tweeners[ prop ] = tweeners[ prop ] || [];
                tweeners[ prop ].unshift( callback );
            }
        },

        prefilter: function( callback, prepend ) {
            if ( prepend ) {
                animationPrefilters.unshift( callback );
            } else {
                animationPrefilters.push( callback );
            }
        }
    });

    jQuery.speed = function( speed, easing, fn ) {
        var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
            complete: fn || !fn && easing ||
            jQuery.isFunction( speed ) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
        };

        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
            opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

        // normalize opt.queue - true/undefined/null -> "fx"
        if ( opt.queue == null || opt.queue === true ) {
            opt.queue = "fx";
        }

        // Queueing
        opt.old = opt.complete;

        opt.complete = function() {
            if ( jQuery.isFunction( opt.old ) ) {
                opt.old.call( this );
            }

            if ( opt.queue ) {
                jQuery.dequeue( this, opt.queue );
            }
        };

        return opt;
    };

    jQuery.fn.extend({
        fadeTo: function( speed, to, easing, callback ) {

            // show any hidden elements after setting opacity to 0
            return this.filter( isHidden ).css( "opacity", 0 ).show()

            // animate to the value specified
                .end().animate({ opacity: to }, speed, easing, callback );
        },
        animate: function( prop, speed, easing, callback ) {
            var empty = jQuery.isEmptyObject( prop ),
                optall = jQuery.speed( speed, easing, callback ),
                doAnimation = function() {
                    // Operate on a copy of prop so per-property easing won't be lost
                    var anim = Animation( this, jQuery.extend( {}, prop ), optall );

                    // Empty animations, or finishing resolves immediately
                    if ( empty || data_priv.get( this, "finish" ) ) {
                        anim.stop( true );
                    }
                };
            doAnimation.finish = doAnimation;

            return empty || optall.queue === false ?
                this.each( doAnimation ) :
                this.queue( optall.queue, doAnimation );
        },
        stop: function( type, clearQueue, gotoEnd ) {
            var stopQueue = function( hooks ) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop( gotoEnd );
            };

            if ( typeof type !== "string" ) {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if ( clearQueue && type !== false ) {
                this.queue( type || "fx", [] );
            }

            return this.each(function() {
                var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = data_priv.get( this );

                if ( index ) {
                    if ( data[ index ] && data[ index ].stop ) {
                        stopQueue( data[ index ] );
                    }
                } else {
                    for ( index in data ) {
                        if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                            stopQueue( data[ index ] );
                        }
                    }
                }

                for ( index = timers.length; index--; ) {
                    if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
                        timers[ index ].anim.stop( gotoEnd );
                        dequeue = false;
                        timers.splice( index, 1 );
                    }
                }

                // start the next in the queue if the last step wasn't forced
                // timers currently will call their complete callbacks, which will dequeue
                // but only if they were gotoEnd
                if ( dequeue || !gotoEnd ) {
                    jQuery.dequeue( this, type );
                }
            });
        },
        finish: function( type ) {
            if ( type !== false ) {
                type = type || "fx";
            }
            return this.each(function() {
                var index,
                    data = data_priv.get( this ),
                    queue = data[ type + "queue" ],
                    hooks = data[ type + "queueHooks" ],
                    timers = jQuery.timers,
                    length = queue ? queue.length : 0;

                // enable finishing flag on private data
                data.finish = true;

                // empty the queue first
                jQuery.queue( this, type, [] );

                if ( hooks && hooks.stop ) {
                    hooks.stop.call( this, true );
                }

                // look for any active animations, and finish them
                for ( index = timers.length; index--; ) {
                    if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                        timers[ index ].anim.stop( true );
                        timers.splice( index, 1 );
                    }
                }

                // look for any animations in the old queue and finish them
                for ( index = 0; index < length; index++ ) {
                    if ( queue[ index ] && queue[ index ].finish ) {
                        queue[ index ].finish.call( this );
                    }
                }

                // turn off finishing flag
                delete data.finish;
            });
        }
    });

    jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
        var cssFn = jQuery.fn[ name ];
        jQuery.fn[ name ] = function( speed, easing, callback ) {
            return speed == null || typeof speed === "boolean" ?
                cssFn.apply( this, arguments ) :
                this.animate( genFx( name, true ), speed, easing, callback );
        };
    });

// Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function( name, props ) {
        jQuery.fn[ name ] = function( speed, easing, callback ) {
            return this.animate( props, speed, easing, callback );
        };
    });

    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer,
            i = 0,
            timers = jQuery.timers;

        fxNow = jQuery.now();

        for ( ; i < timers.length; i++ ) {
            timer = timers[ i ];
            // Checks the timer has not already been removed
            if ( !timer() && timers[ i ] === timer ) {
                timers.splice( i--, 1 );
            }
        }

        if ( !timers.length ) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };

    jQuery.fx.timer = function( timer ) {
        jQuery.timers.push( timer );
        if ( timer() ) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };

    jQuery.fx.interval = 13;

    jQuery.fx.start = function() {
        if ( !timerId ) {
            timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
        }
    };

    jQuery.fx.stop = function() {
        clearInterval( timerId );
        timerId = null;
    };

    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
    };


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function( time, type ) {
        time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
        type = type || "fx";

        return this.queue( type, function( next, hooks ) {
            var timeout = setTimeout( next, time );
            hooks.stop = function() {
                clearTimeout( timeout );
            };
        });
    };


    (function() {
        var input = document.createElement( "input" ),
            select = document.createElement( "select" ),
            opt = select.appendChild( document.createElement( "option" ) );

        input.type = "checkbox";

        // Support: iOS 5.1, Android 4.x, Android 2.3
        // Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)
        support.checkOn = input.value !== "";

        // Must access the parent to make an option select properly
        // Support: IE9, IE10
        support.optSelected = opt.selected;

        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as disabled)
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Check if an input maintains its value after becoming a radio
        // Support: IE9, IE10
        input = document.createElement( "input" );
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();


    var nodeHook, boolHook,
        attrHandle = jQuery.expr.attrHandle;

    jQuery.fn.extend({
        attr: function( name, value ) {
            return access( this, jQuery.attr, name, value, arguments.length > 1 );
        },

        removeAttr: function( name ) {
            return this.each(function() {
                jQuery.removeAttr( this, name );
            });
        }
    });

    jQuery.extend({
        attr: function( elem, name, value ) {
            var hooks, ret,
                nType = elem.nodeType;

            // don't get/set attributes on text, comment and attribute nodes
            if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                return;
            }

            // Fallback to prop when attributes are not supported
            if ( typeof elem.getAttribute === strundefined ) {
                return jQuery.prop( elem, name, value );
            }

            // All attributes are lowercase
            // Grab necessary hook if one is defined
            if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[ name ] ||
                    ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
            }

            if ( value !== undefined ) {

                if ( value === null ) {
                    jQuery.removeAttr( elem, name );

                } else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
                    return ret;

                } else {
                    elem.setAttribute( name, value + "" );
                    return value;
                }

            } else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
                return ret;

            } else {
                ret = jQuery.find.attr( elem, name );

                // Non-existent attributes return null, we normalize to undefined
                return ret == null ?
                    undefined :
                    ret;
            }
        },

        removeAttr: function( elem, value ) {
            var name, propName,
                i = 0,
                attrNames = value && value.match( rnotwhite );

            if ( attrNames && elem.nodeType === 1 ) {
                while ( (name = attrNames[i++]) ) {
                    propName = jQuery.propFix[ name ] || name;

                    // Boolean attributes get special treatment (#10870)
                    if ( jQuery.expr.match.bool.test( name ) ) {
                        // Set corresponding property to false
                        elem[ propName ] = false;
                    }

                    elem.removeAttribute( name );
                }
            }
        },

        attrHooks: {
            type: {
                set: function( elem, value ) {
                    if ( !support.radioValue && value === "radio" &&
                        jQuery.nodeName( elem, "input" ) ) {
                        // Setting the type on a radio button after the value resets the value in IE6-9
                        // Reset value to default in case type is set after value during creation
                        var val = elem.value;
                        elem.setAttribute( "type", value );
                        if ( val ) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        }
    });

// Hooks for boolean attributes
    boolHook = {
        set: function( elem, value, name ) {
            if ( value === false ) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr( elem, name );
            } else {
                elem.setAttribute( name, name );
            }
            return name;
        }
    };
    jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
        var getter = attrHandle[ name ] || jQuery.find.attr;

        attrHandle[ name ] = function( elem, name, isXML ) {
            var ret, handle;
            if ( !isXML ) {
                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[ name ];
                attrHandle[ name ] = ret;
                ret = getter( elem, name, isXML ) != null ?
                    name.toLowerCase() :
                    null;
                attrHandle[ name ] = handle;
            }
            return ret;
        };
    });




    var rfocusable = /^(?:input|select|textarea|button)$/i;

    jQuery.fn.extend({
        prop: function( name, value ) {
            return access( this, jQuery.prop, name, value, arguments.length > 1 );
        },

        removeProp: function( name ) {
            return this.each(function() {
                delete this[ jQuery.propFix[ name ] || name ];
            });
        }
    });

    jQuery.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },

        prop: function( elem, name, value ) {
            var ret, hooks, notxml,
                nType = elem.nodeType;

            // don't get/set properties on text, comment and attribute nodes
            if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                return;
            }

            notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

            if ( notxml ) {
                // Fix name and attach hooks
                name = jQuery.propFix[ name ] || name;
                hooks = jQuery.propHooks[ name ];
            }

            if ( value !== undefined ) {
                return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
                    ret :
                    ( elem[ name ] = value );

            } else {
                return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
                    ret :
                    elem[ name ];
            }
        },

        propHooks: {
            tabIndex: {
                get: function( elem ) {
                    return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
                        elem.tabIndex :
                        -1;
                }
            }
        }
    });

// Support: IE9+
// Selectedness for an option in an optgroup can be inaccurate
    if ( !support.optSelected ) {
        jQuery.propHooks.selected = {
            get: function( elem ) {
                var parent = elem.parentNode;
                if ( parent && parent.parentNode ) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            }
        };
    }

    jQuery.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
    ], function() {
        jQuery.propFix[ this.toLowerCase() ] = this;
    });




    var rclass = /[\t\r\n\f]/g;

    jQuery.fn.extend({
        addClass: function( value ) {
            var classes, elem, cur, clazz, j, finalValue,
                proceed = typeof value === "string" && value,
                i = 0,
                len = this.length;

            if ( jQuery.isFunction( value ) ) {
                return this.each(function( j ) {
                    jQuery( this ).addClass( value.call( this, j, this.className ) );
                });
            }

            if ( proceed ) {
                // The disjunction here is for better compressibility (see removeClass)
                classes = ( value || "" ).match( rnotwhite ) || [];

                for ( ; i < len; i++ ) {
                    elem = this[ i ];
                    cur = elem.nodeType === 1 && ( elem.className ?
                            ( " " + elem.className + " " ).replace( rclass, " " ) :
                            " "
                    );

                    if ( cur ) {
                        j = 0;
                        while ( (clazz = classes[j++]) ) {
                            if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                                cur += clazz + " ";
                            }
                        }

                        // only assign if different to avoid unneeded rendering.
                        finalValue = jQuery.trim( cur );
                        if ( elem.className !== finalValue ) {
                            elem.className = finalValue;
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function( value ) {
            var classes, elem, cur, clazz, j, finalValue,
                proceed = arguments.length === 0 || typeof value === "string" && value,
                i = 0,
                len = this.length;

            if ( jQuery.isFunction( value ) ) {
                return this.each(function( j ) {
                    jQuery( this ).removeClass( value.call( this, j, this.className ) );
                });
            }
            if ( proceed ) {
                classes = ( value || "" ).match( rnotwhite ) || [];

                for ( ; i < len; i++ ) {
                    elem = this[ i ];
                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 && ( elem.className ?
                            ( " " + elem.className + " " ).replace( rclass, " " ) :
                            ""
                    );

                    if ( cur ) {
                        j = 0;
                        while ( (clazz = classes[j++]) ) {
                            // Remove *all* instances
                            while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
                                cur = cur.replace( " " + clazz + " ", " " );
                            }
                        }

                        // only assign if different to avoid unneeded rendering.
                        finalValue = value ? jQuery.trim( cur ) : "";
                        if ( elem.className !== finalValue ) {
                            elem.className = finalValue;
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function( value, stateVal ) {
            var type = typeof value;

            if ( typeof stateVal === "boolean" && type === "string" ) {
                return stateVal ? this.addClass( value ) : this.removeClass( value );
            }

            if ( jQuery.isFunction( value ) ) {
                return this.each(function( i ) {
                    jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
                });
            }

            return this.each(function() {
                if ( type === "string" ) {
                    // toggle individual class names
                    var className,
                        i = 0,
                        self = jQuery( this ),
                        classNames = value.match( rnotwhite ) || [];

                    while ( (className = classNames[ i++ ]) ) {
                        // check each className given, space separated list
                        if ( self.hasClass( className ) ) {
                            self.removeClass( className );
                        } else {
                            self.addClass( className );
                        }
                    }

                    // Toggle whole class name
                } else if ( type === strundefined || type === "boolean" ) {
                    if ( this.className ) {
                        // store className if set
                        data_priv.set( this, "__className__", this.className );
                    }

                    // If the element has a class name or if we're passed "false",
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
                }
            });
        },

        hasClass: function( selector ) {
            var className = " " + selector + " ",
                i = 0,
                l = this.length;
            for ( ; i < l; i++ ) {
                if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
                    return true;
                }
            }

            return false;
        }
    });




    var rreturn = /\r/g;

    jQuery.fn.extend({
        val: function( value ) {
            var hooks, ret, isFunction,
                elem = this[0];

            if ( !arguments.length ) {
                if ( elem ) {
                    hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                    if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string" ?
                        // handle most common string cases
                        ret.replace(rreturn, "") :
                        // handle cases where value is null/undef or number
                        ret == null ? "" : ret;
                }

                return;
            }

            isFunction = jQuery.isFunction( value );

            return this.each(function( i ) {
                var val;

                if ( this.nodeType !== 1 ) {
                    return;
                }

                if ( isFunction ) {
                    val = value.call( this, i, jQuery( this ).val() );
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if ( val == null ) {
                    val = "";

                } else if ( typeof val === "number" ) {
                    val += "";

                } else if ( jQuery.isArray( val ) ) {
                    val = jQuery.map( val, function( value ) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

                // If set returns undefined, fall back to normal setting
                if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function( elem ) {
                    var val = jQuery.find.attr( elem, "value" );
                    return val != null ?
                        val :
                        // Support: IE10-11+
                        // option.text throws exceptions (#14686, #14858)
                        jQuery.trim( jQuery.text( elem ) );
                }
            },
            select: {
                get: function( elem ) {
                    var value, option,
                        options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === "select-one" || index < 0,
                        values = one ? null : [],
                        max = one ? index + 1 : options.length,
                        i = index < 0 ?
                            max :
                            one ? index : 0;

                    // Loop through all the selected options
                    for ( ; i < max; i++ ) {
                        option = options[ i ];

                        // IE6-9 doesn't update selected after form reset (#2551)
                        if ( ( option.selected || i === index ) &&
                            // Don't return options that are disabled or in a disabled optgroup
                            ( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
                            ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

                            // Get the specific value for the option
                            value = jQuery( option ).val();

                            // We don't need an array for one selects
                            if ( one ) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push( value );
                        }
                    }

                    return values;
                },

                set: function( elem, value ) {
                    var optionSet, option,
                        options = elem.options,
                        values = jQuery.makeArray( value ),
                        i = options.length;

                    while ( i-- ) {
                        option = options[ i ];
                        if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
                            optionSet = true;
                        }
                    }

                    // force browsers to behave consistently when non-matching value is set
                    if ( !optionSet ) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });

// Radios and checkboxes getter/setter
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[ this ] = {
            set: function( elem, value ) {
                if ( jQuery.isArray( value ) ) {
                    return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
                }
            }
        };
        if ( !support.checkOn ) {
            jQuery.valHooks[ this ].get = function( elem ) {
                // Support: Webkit
                // "" is returned instead of "on" if a value isn't specified
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });




// Return jQuery for attributes-only inclusion


    jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

        // Handle event binding
        jQuery.fn[ name ] = function( data, fn ) {
            return arguments.length > 0 ?
                this.on( name, null, data, fn ) :
                this.trigger( name );
        };
    });

    jQuery.fn.extend({
        hover: function( fnOver, fnOut ) {
            return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
        },

        bind: function( types, data, fn ) {
            return this.on( types, null, data, fn );
        },
        unbind: function( types, fn ) {
            return this.off( types, null, fn );
        },

        delegate: function( selector, types, data, fn ) {
            return this.on( types, selector, data, fn );
        },
        undelegate: function( selector, types, fn ) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
        }
    });


    var nonce = jQuery.now();

    var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
    jQuery.parseJSON = function( data ) {
        return JSON.parse( data + "" );
    };


// Cross-browser xml parsing
    jQuery.parseXML = function( data ) {
        var xml, tmp;
        if ( !data || typeof data !== "string" ) {
            return null;
        }

        // Support: IE9
        try {
            tmp = new DOMParser();
            xml = tmp.parseFromString( data, "text/xml" );
        } catch ( e ) {
            xml = undefined;
        }

        if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
            jQuery.error( "Invalid XML: " + data );
        }
        return xml;
    };


    var
        // Document location
        ajaxLocParts,
        ajaxLocation,

        rhash = /#.*$/,
        rts = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

        /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
        prefilters = {},

        /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
        transports = {},

        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch( e ) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement( "a" );
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }

// Segment location into parts
    ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports( structure ) {

        // dataTypeExpression is optional and defaults to "*"
        return function( dataTypeExpression, func ) {

            if ( typeof dataTypeExpression !== "string" ) {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

            if ( jQuery.isFunction( func ) ) {
                // For each dataType in the dataTypeExpression
                while ( (dataType = dataTypes[i++]) ) {
                    // Prepend if requested
                    if ( dataType[0] === "+" ) {
                        dataType = dataType.slice( 1 ) || "*";
                        (structure[ dataType ] = structure[ dataType ] || []).unshift( func );

                        // Otherwise append
                    } else {
                        (structure[ dataType ] = structure[ dataType ] || []).push( func );
                    }
                }
            }
        };
    }

// Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

        var inspected = {},
            seekingTransport = ( structure === transports );

        function inspect( dataType ) {
            var selected;
            inspected[ dataType ] = true;
            jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
                var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
                if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
                    options.dataTypes.unshift( dataTypeOrTransport );
                    inspect( dataTypeOrTransport );
                    return false;
                } else if ( seekingTransport ) {
                    return !( selected = dataTypeOrTransport );
                }
            });
            return selected;
        }

        return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
    }

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
    function ajaxExtend( target, src ) {
        var key, deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};

        for ( key in src ) {
            if ( src[ key ] !== undefined ) {
                ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
            }
        }
        if ( deep ) {
            jQuery.extend( true, target, deep );
        }

        return target;
    }

    /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
    function ajaxHandleResponses( s, jqXHR, responses ) {

        var ct, type, finalDataType, firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes;

        // Remove auto dataType and get content-type in the process
        while ( dataTypes[ 0 ] === "*" ) {
            dataTypes.shift();
            if ( ct === undefined ) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }

        // Check if we're dealing with a known content-type
        if ( ct ) {
            for ( type in contents ) {
                if ( contents[ type ] && contents[ type ].test( ct ) ) {
                    dataTypes.unshift( type );
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if ( dataTypes[ 0 ] in responses ) {
            finalDataType = dataTypes[ 0 ];
        } else {
            // Try convertible dataTypes
            for ( type in responses ) {
                if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
                    finalDataType = type;
                    break;
                }
                if ( !firstDataType ) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if ( finalDataType ) {
            if ( finalDataType !== dataTypes[ 0 ] ) {
                dataTypes.unshift( finalDataType );
            }
            return responses[ finalDataType ];
        }
    }

    /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
    function ajaxConvert( s, response, jqXHR, isSuccess ) {
        var conv2, current, conv, tmp, prev,
            converters = {},
            // Work with a copy of dataTypes in case we need to modify it for conversion
            dataTypes = s.dataTypes.slice();

        // Create converters map with lowercased keys
        if ( dataTypes[ 1 ] ) {
            for ( conv in s.converters ) {
                converters[ conv.toLowerCase() ] = s.converters[ conv ];
            }
        }

        current = dataTypes.shift();

        // Convert to each sequential dataType
        while ( current ) {

            if ( s.responseFields[ current ] ) {
                jqXHR[ s.responseFields[ current ] ] = response;
            }

            // Apply the dataFilter if provided
            if ( !prev && isSuccess && s.dataFilter ) {
                response = s.dataFilter( response, s.dataType );
            }

            prev = current;
            current = dataTypes.shift();

            if ( current ) {

                // There's only work to do if current dataType is non-auto
                if ( current === "*" ) {

                    current = prev;

                    // Convert response if prev dataType is non-auto and differs from current
                } else if ( prev !== "*" && prev !== current ) {

                    // Seek a direct converter
                    conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                    // If none found, seek a pair
                    if ( !conv ) {
                        for ( conv2 in converters ) {

                            // If conv2 outputs current
                            tmp = conv2.split( " " );
                            if ( tmp[ 1 ] === current ) {

                                // If prev can be converted to accepted input
                                conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                    converters[ "* " + tmp[ 0 ] ];
                                if ( conv ) {
                                    // Condense equivalence converters
                                    if ( conv === true ) {
                                        conv = converters[ conv2 ];

                                        // Otherwise, insert the intermediate dataType
                                    } else if ( converters[ conv2 ] !== true ) {
                                        current = tmp[ 0 ];
                                        dataTypes.unshift( tmp[ 1 ] );
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    // Apply converter (if not an equivalence)
                    if ( conv !== true ) {

                        // Unless errors are allowed to bubble, catch and return them
                        if ( conv && s[ "throws" ] ) {
                            response = conv( response );
                        } else {
                            try {
                                response = conv( response );
                            } catch ( e ) {
                                return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
                            }
                        }
                    }
                }
            }
        }

        return { state: "success", data: response };
    }

    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},

        ajaxSettings: {
            url: ajaxLocation,
            type: "GET",
            isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },

            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {

                // Convert anything to text
                "* text": String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function( target, settings ) {
            return settings ?

                // Building a settings object
                ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

                // Extending ajaxSettings
                ajaxExtend( jQuery.ajaxSettings, target );
        },

        ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
        ajaxTransport: addToPrefiltersOrTransports( transports ),

        // Main method
        ajax: function( url, options ) {

            // If url is an object, simulate pre-1.5 signature
            if ( typeof url === "object" ) {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var transport,
                // URL without anti-cache param
                cacheURL,
                // Response headers
                responseHeadersString,
                responseHeaders,
                // timeout handle
                timeoutTimer,
                // Cross-domain detection vars
                parts,
                // To know if global events are to be dispatched
                fireGlobals,
                // Loop variable
                i,
                // Create the final options object
                s = jQuery.ajaxSetup( {}, options ),
                // Callbacks context
                callbackContext = s.context || s,
                // Context for global events is callbackContext if it is a DOM node or jQuery collection
                globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
                    jQuery( callbackContext ) :
                    jQuery.event,
                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks("once memory"),
                // Status-dependent callbacks
                statusCode = s.statusCode || {},
                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},
                // The jqXHR state
                state = 0,
                // Default abort message
                strAbort = "canceled",
                // Fake xhr
                jqXHR = {
                    readyState: 0,

                    // Builds headers hashtable if needed
                    getResponseHeader: function( key ) {
                        var match;
                        if ( state === 2 ) {
                            if ( !responseHeaders ) {
                                responseHeaders = {};
                                while ( (match = rheaders.exec( responseHeadersString )) ) {
                                    responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                                }
                            }
                            match = responseHeaders[ key.toLowerCase() ];
                        }
                        return match == null ? null : match;
                    },

                    // Raw string
                    getAllResponseHeaders: function() {
                        return state === 2 ? responseHeadersString : null;
                    },

                    // Caches the header
                    setRequestHeader: function( name, value ) {
                        var lname = name.toLowerCase();
                        if ( !state ) {
                            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                            requestHeaders[ name ] = value;
                        }
                        return this;
                    },

                    // Overrides response content-type header
                    overrideMimeType: function( type ) {
                        if ( !state ) {
                            s.mimeType = type;
                        }
                        return this;
                    },

                    // Status-dependent callbacks
                    statusCode: function( map ) {
                        var code;
                        if ( map ) {
                            if ( state < 2 ) {
                                for ( code in map ) {
                                    // Lazy-add the new callback in a way that preserves old ones
                                    statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                                }
                            } else {
                                // Execute the appropriate callbacks
                                jqXHR.always( map[ jqXHR.status ] );
                            }
                        }
                        return this;
                    },

                    // Cancel the request
                    abort: function( statusText ) {
                        var finalText = statusText || strAbort;
                        if ( transport ) {
                            transport.abort( finalText );
                        }
                        done( 0, finalText );
                        return this;
                    }
                };

            // Attach deferreds
            deferred.promise( jqXHR ).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
                .replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;

            // Extract dataTypes list
            s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

            // A cross-domain request is in order when we have a protocol:host:port mismatch
            if ( s.crossDomain == null ) {
                parts = rurl.exec( s.url.toLowerCase() );
                s.crossDomain = !!( parts &&
                    ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                        ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
                );
            }

            // Convert data if not already a string
            if ( s.data && s.processData && typeof s.data !== "string" ) {
                s.data = jQuery.param( s.data, s.traditional );
            }

            // Apply prefilters
            inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

            // If request was aborted inside a prefilter, stop there
            if ( state === 2 ) {
                return jqXHR;
            }

            // We can fire global events as of now if asked to
            fireGlobals = s.global;

            // Watch for a new set of requests
            if ( fireGlobals && jQuery.active++ === 0 ) {
                jQuery.event.trigger("ajaxStart");
            }

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test( s.type );

            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            cacheURL = s.url;

            // More options handling for requests with no content
            if ( !s.hasContent ) {

                // If data is available, append data to url
                if ( s.data ) {
                    cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Add anti-cache in url if needed
                if ( s.cache === false ) {
                    s.url = rts.test( cacheURL ) ?

                        // If there is already a '_' parameter, set its value
                        cacheURL.replace( rts, "$1_=" + nonce++ ) :

                        // Otherwise add one to the end
                        cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
                }
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if ( s.ifModified ) {
                if ( jQuery.lastModified[ cacheURL ] ) {
                    jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
                }
                if ( jQuery.etag[ cacheURL ] ) {
                    jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
                }
            }

            // Set the correct header, if data is being sent
            if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                jqXHR.setRequestHeader( "Content-Type", s.contentType );
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                    s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                    s.accepts[ "*" ]
            );

            // Check for headers option
            for ( i in s.headers ) {
                jqXHR.setRequestHeader( i, s.headers[ i ] );
            }

            // Allow custom headers/mimetypes and early abort
            if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
                // Abort if not done already and return
                return jqXHR.abort();
            }

            // aborting is no longer a cancellation
            strAbort = "abort";

            // Install callbacks on deferreds
            for ( i in { success: 1, error: 1, complete: 1 } ) {
                jqXHR[ i ]( s[ i ] );
            }

            // Get transport
            transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

            // If no transport, we auto-abort
            if ( !transport ) {
                done( -1, "No Transport" );
            } else {
                jqXHR.readyState = 1;

                // Send global event
                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                }
                // Timeout
                if ( s.async && s.timeout > 0 ) {
                    timeoutTimer = setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout );
                }

                try {
                    state = 1;
                    transport.send( requestHeaders, done );
                } catch ( e ) {
                    // Propagate exception as error if not done
                    if ( state < 2 ) {
                        done( -1, e );
                        // Simply rethrow otherwise
                    } else {
                        throw e;
                    }
                }
            }

            // Callback for when everything is done
            function done( status, nativeStatusText, responses, headers ) {
                var isSuccess, success, error, response, modified,
                    statusText = nativeStatusText;

                // Called once
                if ( state === 2 ) {
                    return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if ( timeoutTimer ) {
                    clearTimeout( timeoutTimer );
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;

                // Get response data
                if ( responses ) {
                    response = ajaxHandleResponses( s, jqXHR, responses );
                }

                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert( s, response, jqXHR, isSuccess );

                // If successful, handle type chaining
                if ( isSuccess ) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if ( s.ifModified ) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if ( modified ) {
                            jQuery.lastModified[ cacheURL ] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if ( modified ) {
                            jQuery.etag[ cacheURL ] = modified;
                        }
                    }

                    // if no content
                    if ( status === 204 || s.type === "HEAD" ) {
                        statusText = "nocontent";

                        // if not modified
                    } else if ( status === 304 ) {
                        statusText = "notmodified";

                        // If we have data, let's convert it
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    // We extract error from statusText
                    // then normalize statusText and status for non-aborts
                    error = statusText;
                    if ( status || !statusText ) {
                        statusText = "error";
                        if ( status < 0 ) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = ( nativeStatusText || statusText ) + "";

                // Success/Error
                if ( isSuccess ) {
                    deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                } else {
                    deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                }

                // Status-dependent callbacks
                jqXHR.statusCode( statusCode );
                statusCode = undefined;

                if ( fireGlobals ) {
                    globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                        [ jqXHR, s, isSuccess ? success : error ] );
                }

                // Complete
                completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
                    // Handle the global AJAX counter
                    if ( !( --jQuery.active ) ) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }

            return jqXHR;
        },

        getJSON: function( url, data, callback ) {
            return jQuery.get( url, data, callback, "json" );
        },

        getScript: function( url, callback ) {
            return jQuery.get( url, undefined, callback, "script" );
        }
    });

    jQuery.each( [ "get", "post" ], function( i, method ) {
        jQuery[ method ] = function( url, data, callback, type ) {
            // shift arguments if data argument was omitted
            if ( jQuery.isFunction( data ) ) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    });

// Attach a bunch of functions for handling common AJAX events
    jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
        jQuery.fn[ type ] = function( fn ) {
            return this.on( type, fn );
        };
    });


    jQuery._evalUrl = function( url ) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
        });
    };


    jQuery.fn.extend({
        wrapAll: function( html ) {
            var wrap;

            if ( jQuery.isFunction( html ) ) {
                return this.each(function( i ) {
                    jQuery( this ).wrapAll( html.call(this, i) );
                });
            }

            if ( this[ 0 ] ) {

                // The elements to wrap the target around
                wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

                if ( this[ 0 ].parentNode ) {
                    wrap.insertBefore( this[ 0 ] );
                }

                wrap.map(function() {
                    var elem = this;

                    while ( elem.firstElementChild ) {
                        elem = elem.firstElementChild;
                    }

                    return elem;
                }).append( this );
            }

            return this;
        },

        wrapInner: function( html ) {
            if ( jQuery.isFunction( html ) ) {
                return this.each(function( i ) {
                    jQuery( this ).wrapInner( html.call(this, i) );
                });
            }

            return this.each(function() {
                var self = jQuery( this ),
                    contents = self.contents();

                if ( contents.length ) {
                    contents.wrapAll( html );

                } else {
                    self.append( html );
                }
            });
        },

        wrap: function( html ) {
            var isFunction = jQuery.isFunction( html );

            return this.each(function( i ) {
                jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
            });
        },

        unwrap: function() {
            return this.parent().each(function() {
                if ( !jQuery.nodeName( this, "body" ) ) {
                    jQuery( this ).replaceWith( this.childNodes );
                }
            }).end();
        }
    });


    jQuery.expr.filters.hidden = function( elem ) {
        // Support: Opera <= 12.12
        // Opera reports offsetWidths and offsetHeights less than zero on some elements
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    };
    jQuery.expr.filters.visible = function( elem ) {
        return !jQuery.expr.filters.hidden( elem );
    };




    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams( prefix, obj, traditional, add ) {
        var name;

        if ( jQuery.isArray( obj ) ) {
            // Serialize array item.
            jQuery.each( obj, function( i, v ) {
                if ( traditional || rbracket.test( prefix ) ) {
                    // Treat each array item as a scalar.
                    add( prefix, v );

                } else {
                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
                }
            });

        } else if ( !traditional && jQuery.type( obj ) === "object" ) {
            // Serialize object item.
            for ( name in obj ) {
                buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
            }

        } else {
            // Serialize scalar item.
            add( prefix, obj );
        }
    }

// Serialize an array of form elements or a set of
// key/values into a query string
    jQuery.param = function( a, traditional ) {
        var prefix,
            s = [],
            add = function( key, value ) {
                // If value is a function, invoke it and return its value
                value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
                s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
            };

        // Set traditional to true for jQuery <= 1.3.2 behavior.
        if ( traditional === undefined ) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }

        // If an array was passed in, assume that it is an array of form elements.
        if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
            // Serialize the form elements
            jQuery.each( a, function() {
                add( this.name, this.value );
            });

        } else {
            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for ( prefix in a ) {
                buildParams( prefix, a[ prefix ], traditional, add );
            }
        }

        // Return the resulting serialization
        return s.join( "&" ).replace( r20, "+" );
    };

    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param( this.serializeArray() );
        },
        serializeArray: function() {
            return this.map(function() {
                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop( this, "elements" );
                return elements ? jQuery.makeArray( elements ) : this;
            })
                .filter(function() {
                    var type = this.type;

                    // Use .is( ":disabled" ) so that fieldset[disabled] works
                    return this.name && !jQuery( this ).is( ":disabled" ) &&
                        rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                        ( this.checked || !rcheckableType.test( type ) );
                })
                .map(function( i, elem ) {
                    var val = jQuery( this ).val();

                    return val == null ?
                        null :
                        jQuery.isArray( val ) ?
                            jQuery.map( val, function( val ) {
                                return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                            }) :
                            { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                }).get();
        }
    });


    jQuery.ajaxSettings.xhr = function() {
        try {
            return new XMLHttpRequest();
        } catch( e ) {}
    };

    var xhrId = 0,
        xhrCallbacks = {},
        xhrSuccessStatus = {
            // file protocol always yields status code 0, assume 200
            0: 200,
            // Support: IE9
            // #1450: sometimes IE returns 1223 when it should be 204
            1223: 204
        },
        xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
    if ( window.ActiveXObject ) {
        jQuery( window ).on( "unload", function() {
            for ( var key in xhrCallbacks ) {
                xhrCallbacks[ key ]();
            }
        });
    }

    support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
    support.ajax = xhrSupported = !!xhrSupported;

    jQuery.ajaxTransport(function( options ) {
        var callback;

        // Cross domain only allowed if supported through XMLHttpRequest
        if ( support.cors || xhrSupported && !options.crossDomain ) {
            return {
                send: function( headers, complete ) {
                    var i,
                        xhr = options.xhr(),
                        id = ++xhrId;

                    xhr.open( options.type, options.url, options.async, options.username, options.password );

                    // Apply custom fields if provided
                    if ( options.xhrFields ) {
                        for ( i in options.xhrFields ) {
                            xhr[ i ] = options.xhrFields[ i ];
                        }
                    }

                    // Override mime type if needed
                    if ( options.mimeType && xhr.overrideMimeType ) {
                        xhr.overrideMimeType( options.mimeType );
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if ( !options.crossDomain && !headers["X-Requested-With"] ) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }

                    // Set headers
                    for ( i in headers ) {
                        xhr.setRequestHeader( i, headers[ i ] );
                    }

                    // Callback
                    callback = function( type ) {
                        return function() {
                            if ( callback ) {
                                delete xhrCallbacks[ id ];
                                callback = xhr.onload = xhr.onerror = null;

                                if ( type === "abort" ) {
                                    xhr.abort();
                                } else if ( type === "error" ) {
                                    complete(
                                        // file: protocol always yields status 0; see #8605, #14207
                                        xhr.status,
                                        xhr.statusText
                                    );
                                } else {
                                    complete(
                                        xhrSuccessStatus[ xhr.status ] || xhr.status,
                                        xhr.statusText,
                                        // Support: IE9
                                        // Accessing binary-data responseText throws an exception
                                        // (#11426)
                                        typeof xhr.responseText === "string" ? {
                                            text: xhr.responseText
                                        } : undefined,
                                        xhr.getAllResponseHeaders()
                                    );
                                }
                            }
                        };
                    };

                    // Listen to events
                    xhr.onload = callback();
                    xhr.onerror = callback("error");

                    // Create the abort callback
                    callback = xhrCallbacks[ id ] = callback("abort");

                    try {
                        // Do send the request (this may raise an exception)
                        xhr.send( options.hasContent && options.data || null );
                    } catch ( e ) {
                        // #14683: Only rethrow if this hasn't been notified as an error yet
                        if ( callback ) {
                            throw e;
                        }
                    }
                },

                abort: function() {
                    if ( callback ) {
                        callback();
                    }
                }
            };
        }
    });




// Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function( text ) {
                jQuery.globalEval( text );
                return text;
            }
        }
    });

// Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter( "script", function( s ) {
        if ( s.cache === undefined ) {
            s.cache = false;
        }
        if ( s.crossDomain ) {
            s.type = "GET";
        }
    });

// Bind script tag hack transport
    jQuery.ajaxTransport( "script", function( s ) {
        // This transport only deals with cross domain requests
        if ( s.crossDomain ) {
            var script, callback;
            return {
                send: function( _, complete ) {
                    script = jQuery("<script>").prop({
                        async: true,
                        charset: s.scriptCharset,
                        src: s.url
                    }).on(
                        "load error",
                        callback = function( evt ) {
                            script.remove();
                            callback = null;
                            if ( evt ) {
                                complete( evt.type === "error" ? 404 : 200, evt.type );
                            }
                        }
                    );
                    document.head.appendChild( script[ 0 ] );
                },
                abort: function() {
                    if ( callback ) {
                        callback();
                    }
                }
            };
        }
    });




    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
            this[ callback ] = true;
            return callback;
        }
    });

// Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

        var callbackName, overwritten, responseContainer,
            jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
                    "url" :
                    typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
            );

        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
                s.jsonpCallback() :
                s.jsonpCallback;

            // Insert callback into url or form data
            if ( jsonProp ) {
                s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
            } else if ( s.jsonp !== false ) {
                s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
            }

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function() {
                if ( !responseContainer ) {
                    jQuery.error( callbackName + " was not called" );
                }
                return responseContainer[ 0 ];
            };

            // force json dataType
            s.dataTypes[ 0 ] = "json";

            // Install callback
            overwritten = window[ callbackName ];
            window[ callbackName ] = function() {
                responseContainer = arguments;
            };

            // Clean-up function (fires after converters)
            jqXHR.always(function() {
                // Restore preexisting value
                window[ callbackName ] = overwritten;

                // Save back as free
                if ( s[ callbackName ] ) {
                    // make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    // save the callback name for future use
                    oldCallbacks.push( callbackName );
                }

                // Call if it was a function and we have a response
                if ( responseContainer && jQuery.isFunction( overwritten ) ) {
                    overwritten( responseContainer[ 0 ] );
                }

                responseContainer = overwritten = undefined;
            });

            // Delegate to script
            return "script";
        }
    });




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function( data, context, keepScripts ) {
        if ( !data || typeof data !== "string" ) {
            return null;
        }
        if ( typeof context === "boolean" ) {
            keepScripts = context;
            context = false;
        }
        context = context || document;

        var parsed = rsingleTag.exec( data ),
            scripts = !keepScripts && [];

        // Single tag
        if ( parsed ) {
            return [ context.createElement( parsed[1] ) ];
        }

        parsed = jQuery.buildFragment( [ data ], context, scripts );

        if ( scripts && scripts.length ) {
            jQuery( scripts ).remove();
        }

        return jQuery.merge( [], parsed.childNodes );
    };


// Keep a copy of the old load method
    var _load = jQuery.fn.load;

    /**
     * Load a url into a page
     */
    jQuery.fn.load = function( url, params, callback ) {
        if ( typeof url !== "string" && _load ) {
            return _load.apply( this, arguments );
        }

        var selector, type, response,
            self = this,
            off = url.indexOf(" ");

        if ( off >= 0 ) {
            selector = jQuery.trim( url.slice( off ) );
            url = url.slice( 0, off );
        }

        // If it's a function
        if ( jQuery.isFunction( params ) ) {

            // We assume that it's the callback
            callback = params;
            params = undefined;

            // Otherwise, build a param string
        } else if ( params && typeof params === "object" ) {
            type = "POST";
        }

        // If we have elements to modify, make the request
        if ( self.length > 0 ) {
            jQuery.ajax({
                url: url,

                // if "type" variable is undefined, then "GET" method will be used
                type: type,
                dataType: "html",
                data: params
            }).done(function( responseText ) {

                // Save response for use in complete callback
                response = arguments;

                self.html( selector ?

                    // If a selector was specified, locate the right elements in a dummy div
                    // Exclude scripts to avoid IE 'Permission Denied' errors
                    jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

                    // Otherwise use the full result
                    responseText );

            }).complete( callback && function( jqXHR, status ) {
                self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
            });
        }

        return this;
    };




    jQuery.expr.filters.animated = function( elem ) {
        return jQuery.grep(jQuery.timers, function( fn ) {
            return elem === fn.elem;
        }).length;
    };




    var docElem = window.document.documentElement;

    /**
     * Gets a window from an element
     */
    function getWindow( elem ) {
        return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
    }

    jQuery.offset = {
        setOffset: function( elem, options, i ) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                position = jQuery.css( elem, "position" ),
                curElem = jQuery( elem ),
                props = {};

            // Set position first, in-case top/left are set even on static elem
            if ( position === "static" ) {
                elem.style.position = "relative";
            }

            curOffset = curElem.offset();
            curCSSTop = jQuery.css( elem, "top" );
            curCSSLeft = jQuery.css( elem, "left" );
            calculatePosition = ( position === "absolute" || position === "fixed" ) &&
                ( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

            // Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
            if ( calculatePosition ) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;

            } else {
                curTop = parseFloat( curCSSTop ) || 0;
                curLeft = parseFloat( curCSSLeft ) || 0;
            }

            if ( jQuery.isFunction( options ) ) {
                options = options.call( elem, i, curOffset );
            }

            if ( options.top != null ) {
                props.top = ( options.top - curOffset.top ) + curTop;
            }
            if ( options.left != null ) {
                props.left = ( options.left - curOffset.left ) + curLeft;
            }

            if ( "using" in options ) {
                options.using.call( elem, props );

            } else {
                curElem.css( props );
            }
        }
    };

    jQuery.fn.extend({
        offset: function( options ) {
            if ( arguments.length ) {
                return options === undefined ?
                    this :
                    this.each(function( i ) {
                        jQuery.offset.setOffset( this, options, i );
                    });
            }

            var docElem, win,
                elem = this[ 0 ],
                box = { top: 0, left: 0 },
                doc = elem && elem.ownerDocument;

            if ( !doc ) {
                return;
            }

            docElem = doc.documentElement;

            // Make sure it's not a disconnected DOM node
            if ( !jQuery.contains( docElem, elem ) ) {
                return box;
            }

            // If we don't have gBCR, just use 0,0 rather than error
            // BlackBerry 5, iOS 3 (original iPhone)
            if ( typeof elem.getBoundingClientRect !== strundefined ) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow( doc );
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },

        position: function() {
            if ( !this[ 0 ] ) {
                return;
            }

            var offsetParent, offset,
                elem = this[ 0 ],
                parentOffset = { top: 0, left: 0 };

            // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
            if ( jQuery.css( elem, "position" ) === "fixed" ) {
                // We assume that getBoundingClientRect is available when computed position is fixed
                offset = elem.getBoundingClientRect();

            } else {
                // Get *real* offsetParent
                offsetParent = this.offsetParent();

                // Get correct offsets
                offset = this.offset();
                if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
                    parentOffset = offsetParent.offset();
                }

                // Add offsetParent borders
                parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
                parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
            }

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
                left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
            };
        },

        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || docElem;

                while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
                    offsetParent = offsetParent.offsetParent;
                }

                return offsetParent || docElem;
            });
        }
    });

// Create scrollLeft and scrollTop methods
    jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
        var top = "pageYOffset" === prop;

        jQuery.fn[ method ] = function( val ) {
            return access( this, function( elem, method, val ) {
                var win = getWindow( elem );

                if ( val === undefined ) {
                    return win ? win[ prop ] : elem[ method ];
                }

                if ( win ) {
                    win.scrollTo(
                        !top ? val : window.pageXOffset,
                        top ? val : window.pageYOffset
                    );

                } else {
                    elem[ method ] = val;
                }
            }, method, val, arguments.length, null );
        };
    });

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
    jQuery.each( [ "top", "left" ], function( i, prop ) {
        jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
            function( elem, computed ) {
                if ( computed ) {
                    computed = curCSS( elem, prop );
                    // if curCSS returns percentage, fallback to offset
                    return rnumnonpx.test( computed ) ?
                        jQuery( elem ).position()[ prop ] + "px" :
                        computed;
                }
            }
        );
    });


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
        jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
            // margin is only for outerHeight, outerWidth
            jQuery.fn[ funcName ] = function( margin, value ) {
                var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                    extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

                return access( this, function( elem, type, value ) {
                    var doc;

                    if ( jQuery.isWindow( elem ) ) {
                        // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                        // isn't a whole lot we can do. See pull request at this URL for discussion:
                        // https://github.com/jquery/jquery/pull/764
                        return elem.document.documentElement[ "client" + name ];
                    }

                    // Get document width or height
                    if ( elem.nodeType === 9 ) {
                        doc = elem.documentElement;

                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                        // whichever is greatest
                        return Math.max(
                            elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                            elem.body[ "offset" + name ], doc[ "offset" + name ],
                            doc[ "client" + name ]
                        );
                    }

                    return value === undefined ?
                        // Get width or height on the element, requesting but not forcing parseFloat
                        jQuery.css( elem, type, extra ) :

                        // Set width or height on the element
                        jQuery.style( elem, type, value, extra );
                }, type, chainable ? margin : undefined, chainable, null );
            };
        });
    });


// The number of elements contained in the matched element set
    jQuery.fn.size = function() {
        return this.length;
    };

    jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

    if ( typeof define === "function" && define.amd ) {
        define( "jquery", [], function() {
            return jQuery;
        });
    }




    var
        // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,

        // Map over the $ in case of overwrite
        _$ = window.$;

    jQuery.noConflict = function( deep ) {
        if ( window.$ === jQuery ) {
            window.$ = _$;
        }

        if ( deep && window.jQuery === jQuery ) {
            window.jQuery = _jQuery;
        }

        return jQuery;
    };

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
    if ( typeof noGlobal === strundefined ) {
        window.jQuery = window.$ = jQuery;
    }




    return jQuery;

}));

/*! jQuery UI - v1.12.1 - 2017-03-27
* http://jqueryui.com
* Includes: widget.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function(t){"function"==typeof define&&define.amd?define(["jquery"],t):t(jQuery)})(function(t){t.ui=t.ui||{},t.ui.version="1.12.1";var e=0,i=Array.prototype.slice;t.cleanData=function(e){return function(i){var s,n,o;for(o=0;null!=(n=i[o]);o++)try{s=t._data(n,"events"),s&&s.remove&&t(n).triggerHandler("remove")}catch(a){}e(i)}}(t.cleanData),t.widget=function(e,i,s){var n,o,a,r={},l=e.split(".")[0];e=e.split(".")[1];var h=l+"-"+e;return s||(s=i,i=t.Widget),t.isArray(s)&&(s=t.extend.apply(null,[{}].concat(s))),t.expr[":"][h.toLowerCase()]=function(e){return!!t.data(e,h)},t[l]=t[l]||{},n=t[l][e],o=t[l][e]=function(t,e){return this._createWidget?(arguments.length&&this._createWidget(t,e),void 0):new o(t,e)},t.extend(o,n,{version:s.version,_proto:t.extend({},s),_childConstructors:[]}),a=new i,a.options=t.widget.extend({},a.options),t.each(s,function(e,s){return t.isFunction(s)?(r[e]=function(){function t(){return i.prototype[e].apply(this,arguments)}function n(t){return i.prototype[e].apply(this,t)}return function(){var e,i=this._super,o=this._superApply;return this._super=t,this._superApply=n,e=s.apply(this,arguments),this._super=i,this._superApply=o,e}}(),void 0):(r[e]=s,void 0)}),o.prototype=t.widget.extend(a,{widgetEventPrefix:n?a.widgetEventPrefix||e:e},r,{constructor:o,namespace:l,widgetName:e,widgetFullName:h}),n?(t.each(n._childConstructors,function(e,i){var s=i.prototype;t.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete n._childConstructors):i._childConstructors.push(o),t.widget.bridge(e,o),o},t.widget.extend=function(e){for(var s,n,o=i.call(arguments,1),a=0,r=o.length;r>a;a++)for(s in o[a])n=o[a][s],o[a].hasOwnProperty(s)&&void 0!==n&&(e[s]=t.isPlainObject(n)?t.isPlainObject(e[s])?t.widget.extend({},e[s],n):t.widget.extend({},n):n);return e},t.widget.bridge=function(e,s){var n=s.prototype.widgetFullName||e;t.fn[e]=function(o){var a="string"==typeof o,r=i.call(arguments,1),l=this;return a?this.length||"instance"!==o?this.each(function(){var i,s=t.data(this,n);return"instance"===o?(l=s,!1):s?t.isFunction(s[o])&&"_"!==o.charAt(0)?(i=s[o].apply(s,r),i!==s&&void 0!==i?(l=i&&i.jquery?l.pushStack(i.get()):i,!1):void 0):t.error("no such method '"+o+"' for "+e+" widget instance"):t.error("cannot call methods on "+e+" prior to initialization; "+"attempted to call method '"+o+"'")}):l=void 0:(r.length&&(o=t.widget.extend.apply(null,[o].concat(r))),this.each(function(){var e=t.data(this,n);e?(e.option(o||{}),e._init&&e._init()):t.data(this,n,new s(o,this))})),l}},t.Widget=function(){},t.Widget._childConstructors=[],t.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!1,create:null},_createWidget:function(i,s){s=t(s||this.defaultElement||this)[0],this.element=t(s),this.uuid=e++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=t(),this.hoverable=t(),this.focusable=t(),this.classesElementLookup={},s!==this&&(t.data(s,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===s&&this.destroy()}}),this.document=t(s.style?s.ownerDocument:s.document||s),this.window=t(this.document[0].defaultView||this.document[0].parentWindow)),this.options=t.widget.extend({},this.options,this._getCreateOptions(),i),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:t.noop,_create:t.noop,_init:t.noop,destroy:function(){var e=this;this._destroy(),t.each(this.classesElementLookup,function(t,i){e._removeClass(i,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:t.noop,widget:function(){return this.element},option:function(e,i){var s,n,o,a=e;if(0===arguments.length)return t.widget.extend({},this.options);if("string"==typeof e)if(a={},s=e.split("."),e=s.shift(),s.length){for(n=a[e]=t.widget.extend({},this.options[e]),o=0;s.length-1>o;o++)n[s[o]]=n[s[o]]||{},n=n[s[o]];if(e=s.pop(),1===arguments.length)return void 0===n[e]?null:n[e];n[e]=i}else{if(1===arguments.length)return void 0===this.options[e]?null:this.options[e];a[e]=i}return this._setOptions(a),this},_setOptions:function(t){var e;for(e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return"classes"===t&&this._setOptionClasses(e),this.options[t]=e,"disabled"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(e){var i,s,n;for(i in e)n=this.classesElementLookup[i],e[i]!==this.options.classes[i]&&n&&n.length&&(s=t(n.get()),this._removeClass(n,i),s.addClass(this._classes({element:s,keys:i,classes:e,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!t),t&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(e){function i(i,o){var a,r;for(r=0;i.length>r;r++)a=n.classesElementLookup[i[r]]||t(),a=e.add?t(t.unique(a.get().concat(e.element.get()))):t(a.not(e.element).get()),n.classesElementLookup[i[r]]=a,s.push(i[r]),o&&e.classes[i[r]]&&s.push(e.classes[i[r]])}var s=[],n=this;return e=t.extend({element:this.element,classes:this.options.classes||{}},e),this._on(e.element,{remove:"_untrackClassesElement"}),e.keys&&i(e.keys.match(/\S+/g)||[],!0),e.extra&&i(e.extra.match(/\S+/g)||[]),s.join(" ")},_untrackClassesElement:function(e){var i=this;t.each(i.classesElementLookup,function(s,n){-1!==t.inArray(e.target,n)&&(i.classesElementLookup[s]=t(n.not(e.target).get()))})},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){s="boolean"==typeof s?s:i;var n="string"==typeof t||null===t,o={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s};return o.element.toggleClass(this._classes(o),s),this},_on:function(e,i,s){var n,o=this;"boolean"!=typeof e&&(s=i,i=e,e=!1),s?(i=n=t(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),t.each(s,function(s,a){function r(){return e||o.options.disabled!==!0&&!t(this).hasClass("ui-state-disabled")?("string"==typeof a?o[a]:a).apply(o,arguments):void 0}"string"!=typeof a&&(r.guid=a.guid=a.guid||r.guid||t.guid++);var l=s.match(/^([\w:-]*)\s*(.*)$/),h=l[1]+o.eventNamespace,c=l[2];c?n.on(h,c,r):i.on(h,r)})},_off:function(e,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.off(i).off(i),this.bindings=t(this.bindings.not(e).get()),this.focusable=t(this.focusable.not(e).get()),this.hoverable=t(this.hoverable.not(e).get())},_delay:function(t,e){function i(){return("string"==typeof t?s[t]:t).apply(s,arguments)}var s=this;return setTimeout(i,e||0)},_hoverable:function(e){this.hoverable=this.hoverable.add(e),this._on(e,{mouseenter:function(e){this._addClass(t(e.currentTarget),null,"ui-state-hover")},mouseleave:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-hover")}})},_focusable:function(e){this.focusable=this.focusable.add(e),this._on(e,{focusin:function(e){this._addClass(t(e.currentTarget),null,"ui-state-focus")},focusout:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-focus")}})},_trigger:function(e,i,s){var n,o,a=this.options[e];if(s=s||{},i=t.Event(i),i.type=(e===this.widgetEventPrefix?e:this.widgetEventPrefix+e).toLowerCase(),i.target=this.element[0],o=i.originalEvent)for(n in o)n in i||(i[n]=o[n]);return this.element.trigger(i,s),!(t.isFunction(a)&&a.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},t.each({show:"fadeIn",hide:"fadeOut"},function(e,i){t.Widget.prototype["_"+e]=function(s,n,o){"string"==typeof n&&(n={effect:n});var a,r=n?n===!0||"number"==typeof n?i:n.effect||i:e;n=n||{},"number"==typeof n&&(n={duration:n}),a=!t.isEmptyObject(n),n.complete=o,n.delay&&s.delay(n.delay),a&&t.effects&&t.effects.effect[r]?s[e](n):r!==e&&s[r]?s[r](n.duration,n.easing,o):s.queue(function(i){t(this)[e](),o&&o.call(s[0]),i()})}}),t.widget});
/*
 * # Semantic UI - 2.2.7
 * https://github.com/Semantic-Org/Semantic-UI
 * http://www.semantic-ui.com/
 *
 * Copyright 2014 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
/*!
 * # Semantic UI 2.2.7 - Site
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    $.site = $.fn.site = function(parameters) {
        var
            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),

            settings        = ( $.isPlainObject(parameters) )
                ? $.extend(true, {}, $.site.settings, parameters)
                : $.extend({}, $.site.settings),

            namespace       = settings.namespace,
            error           = settings.error,

            eventNamespace  = '.' + namespace,
            moduleNamespace = 'module-' + namespace,

            $document       = $(document),
            $module         = $document,
            element         = this,
            instance        = $module.data(moduleNamespace),

            module,
            returnedValue
        ;
        module = {

            initialize: function() {
                module.instantiate();
            },

            instantiate: function() {
                module.verbose('Storing instance of site', module);
                instance = module;
                $module
                    .data(moduleNamespace, module)
                ;
            },

            normalize: function() {
                module.fix.console();
                module.fix.requestAnimationFrame();
            },

            fix: {
                console: function() {
                    module.debug('Normalizing window.console');
                    if (console === undefined || console.log === undefined) {
                        module.verbose('Console not available, normalizing events');
                        module.disable.console();
                    }
                    if (typeof console.group == 'undefined' || typeof console.groupEnd == 'undefined' || typeof console.groupCollapsed == 'undefined') {
                        module.verbose('Console group not available, normalizing events');
                        window.console.group = function() {};
                        window.console.groupEnd = function() {};
                        window.console.groupCollapsed = function() {};
                    }
                    if (typeof console.markTimeline == 'undefined') {
                        module.verbose('Mark timeline not available, normalizing events');
                        window.console.markTimeline = function() {};
                    }
                },
                consoleClear: function() {
                    module.debug('Disabling programmatic console clearing');
                    window.console.clear = function() {};
                },
                requestAnimationFrame: function() {
                    module.debug('Normalizing requestAnimationFrame');
                    if(window.requestAnimationFrame === undefined) {
                        module.debug('RequestAnimationFrame not available, normalizing event');
                        window.requestAnimationFrame = window.requestAnimationFrame
                            || window.mozRequestAnimationFrame
                            || window.webkitRequestAnimationFrame
                            || window.msRequestAnimationFrame
                            || function(callback) { setTimeout(callback, 0); }
                        ;
                    }
                }
            },

            moduleExists: function(name) {
                return ($.fn[name] !== undefined && $.fn[name].settings !== undefined);
            },

            enabled: {
                modules: function(modules) {
                    var
                        enabledModules = []
                    ;
                    modules = modules || settings.modules;
                    $.each(modules, function(index, name) {
                        if(module.moduleExists(name)) {
                            enabledModules.push(name);
                        }
                    });
                    return enabledModules;
                }
            },

            disabled: {
                modules: function(modules) {
                    var
                        disabledModules = []
                    ;
                    modules = modules || settings.modules;
                    $.each(modules, function(index, name) {
                        if(!module.moduleExists(name)) {
                            disabledModules.push(name);
                        }
                    });
                    return disabledModules;
                }
            },

            change: {
                setting: function(setting, value, modules, modifyExisting) {
                    modules = (typeof modules === 'string')
                        ? (modules === 'all')
                            ? settings.modules
                            : [modules]
                        : modules || settings.modules
                    ;
                    modifyExisting = (modifyExisting !== undefined)
                        ? modifyExisting
                        : true
                    ;
                    $.each(modules, function(index, name) {
                        var
                            namespace = (module.moduleExists(name))
                                ? $.fn[name].settings.namespace || false
                                : true,
                            $existingModules
                        ;
                        if(module.moduleExists(name)) {
                            module.verbose('Changing default setting', setting, value, name);
                            $.fn[name].settings[setting] = value;
                            if(modifyExisting && namespace) {
                                $existingModules = $(':data(module-' + namespace + ')');
                                if($existingModules.length > 0) {
                                    module.verbose('Modifying existing settings', $existingModules);
                                    $existingModules[name]('setting', setting, value);
                                }
                            }
                        }
                    });
                },
                settings: function(newSettings, modules, modifyExisting) {
                    modules = (typeof modules === 'string')
                        ? [modules]
                        : modules || settings.modules
                    ;
                    modifyExisting = (modifyExisting !== undefined)
                        ? modifyExisting
                        : true
                    ;
                    $.each(modules, function(index, name) {
                        var
                            $existingModules
                        ;
                        if(module.moduleExists(name)) {
                            module.verbose('Changing default setting', newSettings, name);
                            $.extend(true, $.fn[name].settings, newSettings);
                            if(modifyExisting && namespace) {
                                $existingModules = $(':data(module-' + namespace + ')');
                                if($existingModules.length > 0) {
                                    module.verbose('Modifying existing settings', $existingModules);
                                    $existingModules[name]('setting', newSettings);
                                }
                            }
                        }
                    });
                }
            },

            enable: {
                console: function() {
                    module.console(true);
                },
                debug: function(modules, modifyExisting) {
                    modules = modules || settings.modules;
                    module.debug('Enabling debug for modules', modules);
                    module.change.setting('debug', true, modules, modifyExisting);
                },
                verbose: function(modules, modifyExisting) {
                    modules = modules || settings.modules;
                    module.debug('Enabling verbose debug for modules', modules);
                    module.change.setting('verbose', true, modules, modifyExisting);
                }
            },
            disable: {
                console: function() {
                    module.console(false);
                },
                debug: function(modules, modifyExisting) {
                    modules = modules || settings.modules;
                    module.debug('Disabling debug for modules', modules);
                    module.change.setting('debug', false, modules, modifyExisting);
                },
                verbose: function(modules, modifyExisting) {
                    modules = modules || settings.modules;
                    module.debug('Disabling verbose debug for modules', modules);
                    module.change.setting('verbose', false, modules, modifyExisting);
                }
            },

            console: function(enable) {
                if(enable) {
                    if(instance.cache.console === undefined) {
                        module.error(error.console);
                        return;
                    }
                    module.debug('Restoring console function');
                    window.console = instance.cache.console;
                }
                else {
                    module.debug('Disabling console function');
                    instance.cache.console = window.console;
                    window.console = {
                        clear          : function(){},
                        error          : function(){},
                        group          : function(){},
                        groupCollapsed : function(){},
                        groupEnd       : function(){},
                        info           : function(){},
                        log            : function(){},
                        markTimeline   : function(){},
                        warn           : function(){}
                    };
                }
            },

            destroy: function() {
                module.verbose('Destroying previous site for', $module);
                $module
                    .removeData(moduleNamespace)
                ;
            },

            cache: {},

            setting: function(name, value) {
                if( $.isPlainObject(name) ) {
                    $.extend(true, settings, name);
                }
                else if(value !== undefined) {
                    settings[name] = value;
                }
                else {
                    return settings[name];
                }
            },
            internal: function(name, value) {
                if( $.isPlainObject(name) ) {
                    $.extend(true, module, name);
                }
                else if(value !== undefined) {
                    module[name] = value;
                }
                else {
                    return module[name];
                }
            },
            debug: function() {
                if(settings.debug) {
                    if(settings.performance) {
                        module.performance.log(arguments);
                    }
                    else {
                        module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                        module.debug.apply(console, arguments);
                    }
                }
            },
            verbose: function() {
                if(settings.verbose && settings.debug) {
                    if(settings.performance) {
                        module.performance.log(arguments);
                    }
                    else {
                        module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                        module.verbose.apply(console, arguments);
                    }
                }
            },
            error: function() {
                module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                module.error.apply(console, arguments);
            },
            performance: {
                log: function(message) {
                    var
                        currentTime,
                        executionTime,
                        previousTime
                    ;
                    if(settings.performance) {
                        currentTime   = new Date().getTime();
                        previousTime  = time || currentTime;
                        executionTime = currentTime - previousTime;
                        time          = currentTime;
                        performance.push({
                            'Element'        : element,
                            'Name'           : message[0],
                            'Arguments'      : [].slice.call(message, 1) || '',
                            'Execution Time' : executionTime
                        });
                    }
                    clearTimeout(module.performance.timer);
                    module.performance.timer = setTimeout(module.performance.display, 500);
                },
                display: function() {
                    var
                        title = settings.name + ':',
                        totalTime = 0
                    ;
                    time = false;
                    clearTimeout(module.performance.timer);
                    $.each(performance, function(index, data) {
                        totalTime += data['Execution Time'];
                    });
                    title += ' ' + totalTime + 'ms';
                    if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                        console.groupCollapsed(title);
                        if(console.table) {
                            console.table(performance);
                        }
                        else {
                            $.each(performance, function(index, data) {
                                console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                            });
                        }
                        console.groupEnd();
                    }
                    performance = [];
                }
            },
            invoke: function(query, passedArguments, context) {
                var
                    object = instance,
                    maxDepth,
                    found,
                    response
                ;
                passedArguments = passedArguments || queryArguments;
                context         = element         || context;
                if(typeof query == 'string' && object !== undefined) {
                    query    = query.split(/[\. ]/);
                    maxDepth = query.length - 1;
                    $.each(query, function(depth, value) {
                        var camelCaseValue = (depth != maxDepth)
                            ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                            : query
                        ;
                        if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                            object = object[camelCaseValue];
                        }
                        else if( object[camelCaseValue] !== undefined ) {
                            found = object[camelCaseValue];
                            return false;
                        }
                        else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                            object = object[value];
                        }
                        else if( object[value] !== undefined ) {
                            found = object[value];
                            return false;
                        }
                        else {
                            module.error(error.method, query);
                            return false;
                        }
                    });
                }
                if ( $.isFunction( found ) ) {
                    response = found.apply(context, passedArguments);
                }
                else if(found !== undefined) {
                    response = found;
                }
                if($.isArray(returnedValue)) {
                    returnedValue.push(response);
                }
                else if(returnedValue !== undefined) {
                    returnedValue = [returnedValue, response];
                }
                else if(response !== undefined) {
                    returnedValue = response;
                }
                return found;
            }
        };

        if(methodInvoked) {
            if(instance === undefined) {
                module.initialize();
            }
            module.invoke(query);
        }
        else {
            if(instance !== undefined) {
                module.destroy();
            }
            module.initialize();
        }
        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.site.settings = {

        name        : 'Site',
        namespace   : 'site',

        error : {
            console : 'Console cannot be restored, most likely it was overwritten outside of module',
            method : 'The method you called is not defined.'
        },

        debug       : false,
        verbose     : false,
        performance : true,

        modules: [
            'accordion',
            'api',
            'checkbox',
            'dimmer',
            'dropdown',
            'embed',
            'form',
            'modal',
            'nag',
            'popup',
            'rating',
            'shape',
            'sidebar',
            'state',
            'sticky',
            'tab',
            'transition',
            'visit',
            'visibility'
        ],

        siteNamespace   : 'site',
        namespaceStub   : {
            cache     : {},
            config    : {},
            sections  : {},
            section   : {},
            utilities : {}
        }

    };

// allows for selection of elements with data attributes
    $.extend($.expr[ ":" ], {
        data: ($.expr.createPseudo)
            ? $.expr.createPseudo(function(dataName) {
                return function(elem) {
                    return !!$.data(elem, dataName);
                };
            })
            : function(elem, i, match) {
                // support: jQuery < 1.8
                return !!$.data(elem, match[ 3 ]);
            }
    });


})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Form Validation
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.form = function(parameters) {
        var
            $allModules      = $(this),
            moduleSelector   = $allModules.selector || '',

            time             = new Date().getTime(),
            performance      = [],

            query            = arguments[0],
            legacyParameters = arguments[1],
            methodInvoked    = (typeof query == 'string'),
            queryArguments   = [].slice.call(arguments, 1),
            returnedValue
        ;
        $allModules
            .each(function() {
                var
                    $module     = $(this),
                    element     = this,

                    formErrors  = [],
                    keyHeldDown = false,

                    // set at run-time
                    $field,
                    $group,
                    $message,
                    $prompt,
                    $submit,
                    $clear,
                    $reset,

                    settings,
                    validation,

                    metadata,
                    selector,
                    className,
                    error,

                    namespace,
                    moduleNamespace,
                    eventNamespace,

                    instance,
                    module
                ;

                module      = {

                    initialize: function() {

                        // settings grabbed at run time
                        module.get.settings();
                        if(methodInvoked) {
                            if(instance === undefined) {
                                module.instantiate();
                            }
                            module.invoke(query);
                        }
                        else {
                            if(instance !== undefined) {
                                instance.invoke('destroy');
                            }
                            module.verbose('Initializing form validation', $module, settings);
                            module.bindEvents();
                            module.set.defaults();
                            module.instantiate();
                        }
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module', instance);
                        module.removeEvents();
                        $module
                            .removeData(moduleNamespace)
                        ;
                    },

                    refresh: function() {
                        module.verbose('Refreshing selector cache');
                        $field      = $module.find(selector.field);
                        $group      = $module.find(selector.group);
                        $message    = $module.find(selector.message);
                        $prompt     = $module.find(selector.prompt);

                        $submit     = $module.find(selector.submit);
                        $clear      = $module.find(selector.clear);
                        $reset      = $module.find(selector.reset);
                    },

                    submit: function() {
                        module.verbose('Submitting form', $module);
                        $module
                            .submit()
                        ;
                    },

                    attachEvents: function(selector, action) {
                        action = action || 'submit';
                        $(selector)
                            .on('click' + eventNamespace, function(event) {
                                module[action]();
                                event.preventDefault();
                            })
                        ;
                    },

                    bindEvents: function() {
                        module.verbose('Attaching form events');
                        $module
                            .on('submit' + eventNamespace, module.validate.form)
                            .on('blur'   + eventNamespace, selector.field, module.event.field.blur)
                            .on('click'  + eventNamespace, selector.submit, module.submit)
                            .on('click'  + eventNamespace, selector.reset, module.reset)
                            .on('click'  + eventNamespace, selector.clear, module.clear)
                        ;
                        if(settings.keyboardShortcuts) {
                            $module
                                .on('keydown' + eventNamespace, selector.field, module.event.field.keydown)
                            ;
                        }
                        $field
                            .each(function() {
                                var
                                    $input     = $(this),
                                    type       = $input.prop('type'),
                                    inputEvent = module.get.changeEvent(type, $input)
                                ;
                                $(this)
                                    .on(inputEvent + eventNamespace, module.event.field.change)
                                ;
                            })
                        ;
                    },

                    clear: function() {
                        $field
                            .each(function () {
                                var
                                    $field       = $(this),
                                    $element     = $field.parent(),
                                    $fieldGroup  = $field.closest($group),
                                    $prompt      = $fieldGroup.find(selector.prompt),
                                    defaultValue = $field.data(metadata.defaultValue) || '',
                                    isCheckbox   = $element.is(selector.uiCheckbox),
                                    isDropdown   = $element.is(selector.uiDropdown),
                                    isErrored    = $fieldGroup.hasClass(className.error)
                                ;
                                if(isErrored) {
                                    module.verbose('Resetting error on field', $fieldGroup);
                                    $fieldGroup.removeClass(className.error);
                                    $prompt.remove();
                                }
                                if(isDropdown) {
                                    module.verbose('Resetting dropdown value', $element, defaultValue);
                                    $element.dropdown('clear');
                                }
                                else if(isCheckbox) {
                                    $field.prop('checked', false);
                                }
                                else {
                                    module.verbose('Resetting field value', $field, defaultValue);
                                    $field.val('');
                                }
                            })
                        ;
                    },

                    reset: function() {
                        $field
                            .each(function () {
                                var
                                    $field       = $(this),
                                    $element     = $field.parent(),
                                    $fieldGroup  = $field.closest($group),
                                    $prompt      = $fieldGroup.find(selector.prompt),
                                    defaultValue = $field.data(metadata.defaultValue),
                                    isCheckbox   = $element.is(selector.uiCheckbox),
                                    isDropdown   = $element.is(selector.uiDropdown),
                                    isErrored    = $fieldGroup.hasClass(className.error)
                                ;
                                if(defaultValue === undefined) {
                                    return;
                                }
                                if(isErrored) {
                                    module.verbose('Resetting error on field', $fieldGroup);
                                    $fieldGroup.removeClass(className.error);
                                    $prompt.remove();
                                }
                                if(isDropdown) {
                                    module.verbose('Resetting dropdown value', $element, defaultValue);
                                    $element.dropdown('restore defaults');
                                }
                                else if(isCheckbox) {
                                    module.verbose('Resetting checkbox value', $element, defaultValue);
                                    $field.prop('checked', defaultValue);
                                }
                                else {
                                    module.verbose('Resetting field value', $field, defaultValue);
                                    $field.val(defaultValue);
                                }
                            })
                        ;
                    },

                    is: {
                        bracketedRule: function(rule) {
                            return (rule.type && rule.type.match(settings.regExp.bracket));
                        },
                        empty: function($field) {
                            if(!$field || $field.length === 0) {
                                return true;
                            }
                            else if($field.is('input[type="checkbox"]')) {
                                return !$field.is(':checked');
                            }
                            else {
                                return module.is.blank($field);
                            }
                        },
                        blank: function($field) {
                            return $.trim($field.val()) === '';
                        },
                        valid: function() {
                            var
                                allValid = true
                            ;
                            module.verbose('Checking if form is valid');
                            $.each(validation, function(fieldName, field) {
                                if( !( module.validate.field(field, fieldName) ) ) {
                                    allValid = false;
                                }
                            });
                            return allValid;
                        }
                    },

                    removeEvents: function() {
                        $module
                            .off(eventNamespace)
                        ;
                        $field
                            .off(eventNamespace)
                        ;
                        $submit
                            .off(eventNamespace)
                        ;
                        $field
                            .off(eventNamespace)
                        ;
                    },

                    event: {
                        field: {
                            keydown: function(event) {
                                var
                                    $field       = $(this),
                                    key          = event.which,
                                    isInput      = $field.is(selector.input),
                                    isCheckbox   = $field.is(selector.checkbox),
                                    isInDropdown = ($field.closest(selector.uiDropdown).length > 0),
                                    keyCode      = {
                                        enter  : 13,
                                        escape : 27
                                    }
                                ;
                                if( key == keyCode.escape) {
                                    module.verbose('Escape key pressed blurring field');
                                    $field
                                        .blur()
                                    ;
                                }
                                if(!event.ctrlKey && key == keyCode.enter && isInput && !isInDropdown && !isCheckbox) {
                                    if(!keyHeldDown) {
                                        $field
                                            .one('keyup' + eventNamespace, module.event.field.keyup)
                                        ;
                                        module.submit();
                                        module.debug('Enter pressed on input submitting form');
                                    }
                                    keyHeldDown = true;
                                }
                            },
                            keyup: function() {
                                keyHeldDown = false;
                            },
                            blur: function(event) {
                                var
                                    $field          = $(this),
                                    $fieldGroup     = $field.closest($group),
                                    validationRules = module.get.validation($field)
                                ;
                                if( $fieldGroup.hasClass(className.error) ) {
                                    module.debug('Revalidating field', $field, validationRules);
                                    if(validationRules) {
                                        module.validate.field( validationRules );
                                    }
                                }
                                else if(settings.on == 'blur' || settings.on == 'change') {
                                    if(validationRules) {
                                        module.validate.field( validationRules );
                                    }
                                }
                            },
                            change: function(event) {
                                var
                                    $field      = $(this),
                                    $fieldGroup = $field.closest($group),
                                    validationRules = module.get.validation($field)
                                ;
                                if(settings.on == 'change' || ( $fieldGroup.hasClass(className.error) && settings.revalidate) ) {
                                    clearTimeout(module.timer);
                                    module.timer = setTimeout(function() {
                                        module.debug('Revalidating field', $field,  module.get.validation($field));
                                        module.validate.field( validationRules );
                                    }, settings.delay);
                                }
                            }
                        }

                    },

                    get: {
                        ancillaryValue: function(rule) {
                            if(!rule.type || (!rule.value && !module.is.bracketedRule(rule))) {
                                return false;
                            }
                            return (rule.value !== undefined)
                                ? rule.value
                                : rule.type.match(settings.regExp.bracket)[1] + ''
                                ;
                        },
                        ruleName: function(rule) {
                            if( module.is.bracketedRule(rule) ) {
                                return rule.type.replace(rule.type.match(settings.regExp.bracket)[0], '');
                            }
                            return rule.type;
                        },
                        changeEvent: function(type, $input) {
                            if(type == 'checkbox' || type == 'radio' || type == 'hidden' || $input.is('select')) {
                                return 'change';
                            }
                            else {
                                return module.get.inputEvent();
                            }
                        },
                        inputEvent: function() {
                            return (document.createElement('input').oninput !== undefined)
                                ? 'input'
                                : (document.createElement('input').onpropertychange !== undefined)
                                    ? 'propertychange'
                                    : 'keyup'
                                ;
                        },
                        prompt: function(rule, field) {
                            var
                                ruleName      = module.get.ruleName(rule),
                                ancillary     = module.get.ancillaryValue(rule),
                                prompt        = rule.prompt || settings.prompt[ruleName] || settings.text.unspecifiedRule,
                                requiresValue = (prompt.search('{value}') !== -1),
                                requiresName  = (prompt.search('{name}') !== -1),
                                $label,
                                $field,
                                name
                            ;
                            if(requiresName || requiresValue) {
                                $field = module.get.field(field.identifier);
                            }
                            if(requiresValue) {
                                prompt = prompt.replace('{value}', $field.val());
                            }
                            if(requiresName) {
                                $label = $field.closest(selector.group).find('label').eq(0);
                                name = ($label.length == 1)
                                    ? $label.text()
                                    : $field.prop('placeholder') || settings.text.unspecifiedField
                                ;
                                prompt = prompt.replace('{name}', name);
                            }
                            prompt = prompt.replace('{identifier}', field.identifier);
                            prompt = prompt.replace('{ruleValue}', ancillary);
                            if(!rule.prompt) {
                                module.verbose('Using default validation prompt for type', prompt, ruleName);
                            }
                            return prompt;
                        },
                        settings: function() {
                            if($.isPlainObject(parameters)) {
                                var
                                    keys     = Object.keys(parameters),
                                    isLegacySettings = (keys.length > 0)
                                        ? (parameters[keys[0]].identifier !== undefined && parameters[keys[0]].rules !== undefined)
                                        : false,
                                    ruleKeys
                                ;
                                if(isLegacySettings) {
                                    // 1.x (ducktyped)
                                    settings   = $.extend(true, {}, $.fn.form.settings, legacyParameters);
                                    validation = $.extend({}, $.fn.form.settings.defaults, parameters);
                                    module.error(settings.error.oldSyntax, element);
                                    module.verbose('Extending settings from legacy parameters', validation, settings);
                                }
                                else {
                                    // 2.x
                                    if(parameters.fields) {
                                        ruleKeys = Object.keys(parameters.fields);
                                        if( typeof parameters.fields[ruleKeys[0]] == 'string' || $.isArray(parameters.fields[ruleKeys[0]]) ) {
                                            $.each(parameters.fields, function(name, rules) {
                                                if(typeof rules == 'string') {
                                                    rules = [rules];
                                                }
                                                parameters.fields[name] = {
                                                    rules: []
                                                };
                                                $.each(rules, function(index, rule) {
                                                    parameters.fields[name].rules.push({ type: rule });
                                                });
                                            });
                                        }
                                    }

                                    settings   = $.extend(true, {}, $.fn.form.settings, parameters);
                                    validation = $.extend({}, $.fn.form.settings.defaults, settings.fields);
                                    module.verbose('Extending settings', validation, settings);
                                }
                            }
                            else {
                                settings   = $.fn.form.settings;
                                validation = $.fn.form.settings.defaults;
                                module.verbose('Using default form validation', validation, settings);
                            }

                            // shorthand
                            namespace       = settings.namespace;
                            metadata        = settings.metadata;
                            selector        = settings.selector;
                            className       = settings.className;
                            error           = settings.error;
                            moduleNamespace = 'module-' + namespace;
                            eventNamespace  = '.' + namespace;

                            // grab instance
                            instance = $module.data(moduleNamespace);

                            // refresh selector cache
                            module.refresh();
                        },
                        field: function(identifier) {
                            module.verbose('Finding field with identifier', identifier);
                            if( $field.filter('#' + identifier).length > 0 ) {
                                return $field.filter('#' + identifier);
                            }
                            else if( $field.filter('[name="' + identifier +'"]').length > 0 ) {
                                return $field.filter('[name="' + identifier +'"]');
                            }
                            else if( $field.filter('[name="' + identifier +'[]"]').length > 0 ) {
                                return $field.filter('[name="' + identifier +'[]"]');
                            }
                            else if( $field.filter('[data-' + metadata.validate + '="'+ identifier +'"]').length > 0 ) {
                                return $field.filter('[data-' + metadata.validate + '="'+ identifier +'"]');
                            }
                            return $('<input/>');
                        },
                        fields: function(fields) {
                            var
                                $fields = $()
                            ;
                            $.each(fields, function(index, name) {
                                $fields = $fields.add( module.get.field(name) );
                            });
                            return $fields;
                        },
                        validation: function($field) {
                            var
                                fieldValidation,
                                identifier
                            ;
                            if(!validation) {
                                return false;
                            }
                            $.each(validation, function(fieldName, field) {
                                identifier = field.identifier || fieldName;
                                if( module.get.field(identifier)[0] == $field[0] ) {
                                    field.identifier = identifier;
                                    fieldValidation = field;
                                }
                            });
                            return fieldValidation || false;
                        },
                        value: function (field) {
                            var
                                fields = [],
                                results
                            ;
                            fields.push(field);
                            results = module.get.values.call(element, fields);
                            return results[field];
                        },
                        values: function (fields) {
                            var
                                $fields = $.isArray(fields)
                                    ? module.get.fields(fields)
                                    : $field,
                                values = {}
                            ;
                            $fields.each(function(index, field) {
                                var
                                    $field     = $(field),
                                    type       = $field.prop('type'),
                                    name       = $field.prop('name'),
                                    value      = $field.val(),
                                    isCheckbox = $field.is(selector.checkbox),
                                    isRadio    = $field.is(selector.radio),
                                    isMultiple = (name.indexOf('[]') !== -1),
                                    isChecked  = (isCheckbox)
                                        ? $field.is(':checked')
                                        : false
                                ;
                                if(name) {
                                    if(isMultiple) {
                                        name = name.replace('[]', '');
                                        if(!values[name]) {
                                            values[name] = [];
                                        }
                                        if(isCheckbox) {
                                            if(isChecked) {
                                                values[name].push(value || true);
                                            }
                                            else {
                                                values[name].push(false);
                                            }
                                        }
                                        else {
                                            values[name].push(value);
                                        }
                                    }
                                    else {
                                        if(isRadio) {
                                            if(isChecked) {
                                                values[name] = value;
                                            }
                                        }
                                        else if(isCheckbox) {
                                            if(isChecked) {
                                                values[name] = value || true;
                                            }
                                            else {
                                                values[name] = false;
                                            }
                                        }
                                        else {
                                            values[name] = value;
                                        }
                                    }
                                }
                            });
                            return values;
                        }
                    },

                    has: {

                        field: function(identifier) {
                            module.verbose('Checking for existence of a field with identifier', identifier);
                            if(typeof identifier !== 'string') {
                                module.error(error.identifier, identifier);
                            }
                            if( $field.filter('#' + identifier).length > 0 ) {
                                return true;
                            }
                            else if( $field.filter('[name="' + identifier +'"]').length > 0 ) {
                                return true;
                            }
                            else if( $field.filter('[data-' + metadata.validate + '="'+ identifier +'"]').length > 0 ) {
                                return true;
                            }
                            return false;
                        }

                    },

                    add: {
                        prompt: function(identifier, errors) {
                            var
                                $field       = module.get.field(identifier),
                                $fieldGroup  = $field.closest($group),
                                $prompt      = $fieldGroup.children(selector.prompt),
                                promptExists = ($prompt.length !== 0)
                            ;
                            errors = (typeof errors == 'string')
                                ? [errors]
                                : errors
                            ;
                            module.verbose('Adding field error state', identifier);
                            $fieldGroup
                                .addClass(className.error)
                            ;
                            if(settings.inline) {
                                if(!promptExists) {
                                    $prompt = settings.templates.prompt(errors);
                                    $prompt
                                        .appendTo($fieldGroup)
                                    ;
                                }
                                $prompt
                                    .html(errors[0])
                                ;
                                if(!promptExists) {
                                    if(settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
                                        module.verbose('Displaying error with css transition', settings.transition);
                                        $prompt.transition(settings.transition + ' in', settings.duration);
                                    }
                                    else {
                                        module.verbose('Displaying error with fallback javascript animation');
                                        $prompt
                                            .fadeIn(settings.duration)
                                        ;
                                    }
                                }
                                else {
                                    module.verbose('Inline errors are disabled, no inline error added', identifier);
                                }
                            }
                        },
                        errors: function(errors) {
                            module.debug('Adding form error messages', errors);
                            module.set.error();
                            $message
                                .html( settings.templates.error(errors) )
                            ;
                        }
                    },

                    remove: {
                        prompt: function(identifier) {
                            var
                                $field      = module.get.field(identifier),
                                $fieldGroup = $field.closest($group),
                                $prompt     = $fieldGroup.children(selector.prompt)
                            ;
                            $fieldGroup
                                .removeClass(className.error)
                            ;
                            if(settings.inline && $prompt.is(':visible')) {
                                module.verbose('Removing prompt for field', identifier);
                                if(settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
                                    $prompt.transition(settings.transition + ' out', settings.duration, function() {
                                        $prompt.remove();
                                    });
                                }
                                else {
                                    $prompt
                                        .fadeOut(settings.duration, function(){
                                            $prompt.remove();
                                        })
                                    ;
                                }
                            }
                        }
                    },

                    set: {
                        success: function() {
                            $module
                                .removeClass(className.error)
                                .addClass(className.success)
                            ;
                        },
                        defaults: function () {
                            $field
                                .each(function () {
                                    var
                                        $field     = $(this),
                                        isCheckbox = ($field.filter(selector.checkbox).length > 0),
                                        value      = (isCheckbox)
                                            ? $field.is(':checked')
                                            : $field.val()
                                    ;
                                    $field.data(metadata.defaultValue, value);
                                })
                            ;
                        },
                        error: function() {
                            $module
                                .removeClass(className.success)
                                .addClass(className.error)
                            ;
                        },
                        value: function (field, value) {
                            var
                                fields = {}
                            ;
                            fields[field] = value;
                            return module.set.values.call(element, fields);
                        },
                        values: function (fields) {
                            if($.isEmptyObject(fields)) {
                                return;
                            }
                            $.each(fields, function(key, value) {
                                var
                                    $field      = module.get.field(key),
                                    $element    = $field.parent(),
                                    isMultiple  = $.isArray(value),
                                    isCheckbox  = $element.is(selector.uiCheckbox),
                                    isDropdown  = $element.is(selector.uiDropdown),
                                    isRadio     = ($field.is(selector.radio) && isCheckbox),
                                    fieldExists = ($field.length > 0),
                                    $multipleField
                                ;
                                if(fieldExists) {
                                    if(isMultiple && isCheckbox) {
                                        module.verbose('Selecting multiple', value, $field);
                                        $element.checkbox('uncheck');
                                        $.each(value, function(index, value) {
                                            $multipleField = $field.filter('[value="' + value + '"]');
                                            $element       = $multipleField.parent();
                                            if($multipleField.length > 0) {
                                                $element.checkbox('check');
                                            }
                                        });
                                    }
                                    else if(isRadio) {
                                        module.verbose('Selecting radio value', value, $field);
                                        $field.filter('[value="' + value + '"]')
                                            .parent(selector.uiCheckbox)
                                            .checkbox('check')
                                        ;
                                    }
                                    else if(isCheckbox) {
                                        module.verbose('Setting checkbox value', value, $element);
                                        if(value === true) {
                                            $element.checkbox('check');
                                        }
                                        else {
                                            $element.checkbox('uncheck');
                                        }
                                    }
                                    else if(isDropdown) {
                                        module.verbose('Setting dropdown value', value, $element);
                                        $element.dropdown('set selected', value);
                                    }
                                    else {
                                        module.verbose('Setting field value', value, $field);
                                        $field.val(value);
                                    }
                                }
                            });
                        }
                    },

                    validate: {

                        form: function(event, ignoreCallbacks) {
                            var
                                values = module.get.values(),
                                apiRequest
                            ;

                            // input keydown event will fire submit repeatedly by browser default
                            if(keyHeldDown) {
                                return false;
                            }

                            // reset errors
                            formErrors = [];
                            if( module.is.valid() ) {
                                module.debug('Form has no validation errors, submitting');
                                module.set.success();
                                if(ignoreCallbacks !== true) {
                                    return settings.onSuccess.call(element, event, values);
                                }
                            }
                            else {
                                module.debug('Form has errors');
                                module.set.error();
                                if(!settings.inline) {
                                    module.add.errors(formErrors);
                                }
                                // prevent ajax submit
                                if($module.data('moduleApi') !== undefined) {
                                    event.stopImmediatePropagation();
                                }
                                if(ignoreCallbacks !== true) {
                                    return settings.onFailure.call(element, formErrors, values);
                                }
                            }
                        },

                        // takes a validation object and returns whether field passes validation
                        field: function(field, fieldName) {
                            var
                                identifier    = field.identifier || fieldName,
                                $field        = module.get.field(identifier),
                                $dependsField = (field.depends)
                                    ? module.get.field(field.depends)
                                    : false,
                                fieldValid  = true,
                                fieldErrors = []
                            ;
                            if(!field.identifier) {
                                module.debug('Using field name as identifier', identifier);
                                field.identifier = identifier;
                            }
                            if($field.prop('disabled')) {
                                module.debug('Field is disabled. Skipping', identifier);
                                fieldValid = true;
                            }
                            else if(field.optional && module.is.blank($field)){
                                module.debug('Field is optional and blank. Skipping', identifier);
                                fieldValid = true;
                            }
                            else if(field.depends && module.is.empty($dependsField)) {
                                module.debug('Field depends on another value that is not present or empty. Skipping', $dependsField);
                                fieldValid = true;
                            }
                            else if(field.rules !== undefined) {
                                $.each(field.rules, function(index, rule) {
                                    if( module.has.field(identifier) && !( module.validate.rule(field, rule) ) ) {
                                        module.debug('Field is invalid', identifier, rule.type);
                                        fieldErrors.push(module.get.prompt(rule, field));
                                        fieldValid = false;
                                    }
                                });
                            }
                            if(fieldValid) {
                                module.remove.prompt(identifier, fieldErrors);
                                settings.onValid.call($field);
                            }
                            else {
                                formErrors = formErrors.concat(fieldErrors);
                                module.add.prompt(identifier, fieldErrors);
                                settings.onInvalid.call($field, fieldErrors);
                                return false;
                            }
                            return true;
                        },

                        // takes validation rule and returns whether field passes rule
                        rule: function(field, rule) {
                            var
                                $field       = module.get.field(field.identifier),
                                type         = rule.type,
                                value        = $field.val(),
                                isValid      = true,
                                ancillary    = module.get.ancillaryValue(rule),
                                ruleName     = module.get.ruleName(rule),
                                ruleFunction = settings.rules[ruleName]
                            ;
                            if( !$.isFunction(ruleFunction) ) {
                                module.error(error.noRule, ruleName);
                                return;
                            }
                            // cast to string avoiding encoding special values
                            value = (value === undefined || value === '' || value === null)
                                ? ''
                                : $.trim(value + '')
                            ;
                            return ruleFunction.call($field, value, ancillary);
                        }
                    },

                    setting: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if($allModules.length > 1) {
                                title += ' ' + '(' + $allModules.length + ')';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };
                module.initialize();
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.form.settings = {

        name              : 'Form',
        namespace         : 'form',

        debug             : false,
        verbose           : false,
        performance       : true,

        fields            : false,

        keyboardShortcuts : true,
        on                : 'submit',
        inline            : false,

        delay             : 200,
        revalidate        : true,

        transition        : 'scale',
        duration          : 200,

        onValid           : function() {},
        onInvalid         : function() {},
        onSuccess         : function() { return true; },
        onFailure         : function() { return false; },

        metadata : {
            defaultValue : 'default',
            validate     : 'validate'
        },

        regExp: {
            bracket : /\[(.*)\]/i,
            decimal : /^\d*(\.)\d+/,
            email   : /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i,
            escape  : /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,
            flags   : /^\/(.*)\/(.*)?/,
            integer : /^\-?\d+$/,
            number  : /^\-?\d*(\.\d+)?$/,
            url     : /(https?:\/\/(?:www\.|(?!www))[^\s\.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/i
        },

        text: {
            unspecifiedRule  : 'Please enter a valid value',
            unspecifiedField : 'This field'
        },

        prompt: {
            empty                : '{name} must have a value',
            checked              : '{name} must be checked',
            email                : '{name} must be a valid e-mail',
            url                  : '{name} must be a valid url',
            regExp               : '{name} is not formatted correctly',
            integer              : '{name} must be an integer',
            decimal              : '{name} must be a decimal number',
            number               : '{name} must be set to a number',
            is                   : '{name} must be "{ruleValue}"',
            isExactly            : '{name} must be exactly "{ruleValue}"',
            not                  : '{name} cannot be set to "{ruleValue}"',
            notExactly           : '{name} cannot be set to exactly "{ruleValue}"',
            contain              : '{name} cannot contain "{ruleValue}"',
            containExactly       : '{name} cannot contain exactly "{ruleValue}"',
            doesntContain        : '{name} must contain  "{ruleValue}"',
            doesntContainExactly : '{name} must contain exactly "{ruleValue}"',
            minLength            : '{name} must be at least {ruleValue} characters',
            length               : '{name} must be at least {ruleValue} characters',
            exactLength          : '{name} must be exactly {ruleValue} characters',
            maxLength            : '{name} cannot be longer than {ruleValue} characters',
            match                : '{name} must match {ruleValue} field',
            different            : '{name} must have a different value than {ruleValue} field',
            creditCard           : '{name} must be a valid credit card number',
            minCount             : '{name} must have at least {ruleValue} choices',
            exactCount           : '{name} must have exactly {ruleValue} choices',
            maxCount             : '{name} must have {ruleValue} or less choices'
        },

        selector : {
            checkbox   : 'input[type="checkbox"], input[type="radio"]',
            clear      : '.clear',
            field      : 'input, textarea, select',
            group      : '.field',
            input      : 'input',
            message    : '.error.message',
            prompt     : '.prompt.label',
            radio      : 'input[type="radio"]',
            reset      : '.reset:not([type="reset"])',
            submit     : '.submit:not([type="submit"])',
            uiCheckbox : '.ui.checkbox',
            uiDropdown : '.ui.dropdown'
        },

        className : {
            error   : 'error',
            label   : 'ui prompt label',
            pressed : 'down',
            success : 'success'
        },

        error: {
            identifier : 'You must specify a string identifier for each field',
            method     : 'The method you called is not defined.',
            noRule     : 'There is no rule matching the one you specified',
            oldSyntax  : 'Starting in 2.0 forms now only take a single settings object. Validation settings converted to new syntax automatically.'
        },

        templates: {

            // template that produces error message
            error: function(errors) {
                var
                    html = '<ul class="list">'
                ;
                $.each(errors, function(index, value) {
                    html += '<li>' + value + '</li>';
                });
                html += '</ul>';
                return $(html);
            },

            // template that produces label
            prompt: function(errors) {
                return $('<div/>')
                    .addClass('ui basic red pointing prompt label')
                    .html(errors[0])
                    ;
            }
        },

        rules: {

            // is not empty or blank string
            empty: function(value) {
                return !(value === undefined || '' === value || $.isArray(value) && value.length === 0);
            },

            // checkbox checked
            checked: function() {
                return ($(this).filter(':checked').length > 0);
            },

            // is most likely an email
            email: function(value){
                return $.fn.form.settings.regExp.email.test(value);
            },

            // value is most likely url
            url: function(value) {
                return $.fn.form.settings.regExp.url.test(value);
            },

            // matches specified regExp
            regExp: function(value, regExp) {
                if(regExp instanceof RegExp) {
                    return value.match(regExp);
                }
                var
                    regExpParts = regExp.match($.fn.form.settings.regExp.flags),
                    flags
                ;
                // regular expression specified as /baz/gi (flags)
                if(regExpParts) {
                    regExp = (regExpParts.length >= 2)
                        ? regExpParts[1]
                        : regExp
                    ;
                    flags = (regExpParts.length >= 3)
                        ? regExpParts[2]
                        : ''
                    ;
                }
                return value.match( new RegExp(regExp, flags) );
            },

            // is valid integer or matches range
            integer: function(value, range) {
                var
                    intRegExp = $.fn.form.settings.regExp.integer,
                    min,
                    max,
                    parts
                ;
                if( !range || ['', '..'].indexOf(range) !== -1) {
                    // do nothing
                }
                else if(range.indexOf('..') == -1) {
                    if(intRegExp.test(range)) {
                        min = max = range - 0;
                    }
                }
                else {
                    parts = range.split('..', 2);
                    if(intRegExp.test(parts[0])) {
                        min = parts[0] - 0;
                    }
                    if(intRegExp.test(parts[1])) {
                        max = parts[1] - 0;
                    }
                }
                return (
                    intRegExp.test(value) &&
                    (min === undefined || value >= min) &&
                    (max === undefined || value <= max)
                );
            },

            // is valid number (with decimal)
            decimal: function(value) {
                return $.fn.form.settings.regExp.decimal.test(value);
            },

            // is valid number
            number: function(value) {
                return $.fn.form.settings.regExp.number.test(value);
            },

            // is value (case insensitive)
            is: function(value, text) {
                text = (typeof text == 'string')
                    ? text.toLowerCase()
                    : text
                ;
                value = (typeof value == 'string')
                    ? value.toLowerCase()
                    : value
                ;
                return (value == text);
            },

            // is value
            isExactly: function(value, text) {
                return (value == text);
            },

            // value is not another value (case insensitive)
            not: function(value, notValue) {
                value = (typeof value == 'string')
                    ? value.toLowerCase()
                    : value
                ;
                notValue = (typeof notValue == 'string')
                    ? notValue.toLowerCase()
                    : notValue
                ;
                return (value != notValue);
            },

            // value is not another value (case sensitive)
            notExactly: function(value, notValue) {
                return (value != notValue);
            },

            // value contains text (insensitive)
            contains: function(value, text) {
                // escape regex characters
                text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
                return (value.search( new RegExp(text, 'i') ) !== -1);
            },

            // value contains text (case sensitive)
            containsExactly: function(value, text) {
                // escape regex characters
                text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
                return (value.search( new RegExp(text) ) !== -1);
            },

            // value contains text (insensitive)
            doesntContain: function(value, text) {
                // escape regex characters
                text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
                return (value.search( new RegExp(text, 'i') ) === -1);
            },

            // value contains text (case sensitive)
            doesntContainExactly: function(value, text) {
                // escape regex characters
                text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
                return (value.search( new RegExp(text) ) === -1);
            },

            // is at least string length
            minLength: function(value, requiredLength) {
                return (value !== undefined)
                    ? (value.length >= requiredLength)
                    : false
                    ;
            },

            // see rls notes for 2.0.6 (this is a duplicate of minLength)
            length: function(value, requiredLength) {
                return (value !== undefined)
                    ? (value.length >= requiredLength)
                    : false
                    ;
            },

            // is exactly length
            exactLength: function(value, requiredLength) {
                return (value !== undefined)
                    ? (value.length == requiredLength)
                    : false
                    ;
            },

            // is less than length
            maxLength: function(value, maxLength) {
                return (value !== undefined)
                    ? (value.length <= maxLength)
                    : false
                    ;
            },

            // matches another field
            match: function(value, identifier) {
                var
                    $form = $(this),
                    matchingValue
                ;
                if( $('[data-validate="'+ identifier +'"]').length > 0 ) {
                    matchingValue = $('[data-validate="'+ identifier +'"]').val();
                }
                else if($('#' + identifier).length > 0) {
                    matchingValue = $('#' + identifier).val();
                }
                else if($('[name="' + identifier +'"]').length > 0) {
                    matchingValue = $('[name="' + identifier + '"]').val();
                }
                else if( $('[name="' + identifier +'[]"]').length > 0 ) {
                    matchingValue = $('[name="' + identifier +'[]"]');
                }
                return (matchingValue !== undefined)
                    ? ( value.toString() == matchingValue.toString() )
                    : false
                    ;
            },

            // different than another field
            different: function(value, identifier) {
                // use either id or name of field
                var
                    $form = $(this),
                    matchingValue
                ;
                if( $('[data-validate="'+ identifier +'"]').length > 0 ) {
                    matchingValue = $('[data-validate="'+ identifier +'"]').val();
                }
                else if($('#' + identifier).length > 0) {
                    matchingValue = $('#' + identifier).val();
                }
                else if($('[name="' + identifier +'"]').length > 0) {
                    matchingValue = $('[name="' + identifier + '"]').val();
                }
                else if( $('[name="' + identifier +'[]"]').length > 0 ) {
                    matchingValue = $('[name="' + identifier +'[]"]');
                }
                return (matchingValue !== undefined)
                    ? ( value.toString() !== matchingValue.toString() )
                    : false
                    ;
            },

            creditCard: function(cardNumber, cardTypes) {
                var
                    cards = {
                        visa: {
                            pattern : /^4/,
                            length  : [16]
                        },
                        amex: {
                            pattern : /^3[47]/,
                            length  : [15]
                        },
                        mastercard: {
                            pattern : /^5[1-5]/,
                            length  : [16]
                        },
                        discover: {
                            pattern : /^(6011|622(12[6-9]|1[3-9][0-9]|[2-8][0-9]{2}|9[0-1][0-9]|92[0-5]|64[4-9])|65)/,
                            length  : [16]
                        },
                        unionPay: {
                            pattern : /^(62|88)/,
                            length  : [16, 17, 18, 19]
                        },
                        jcb: {
                            pattern : /^35(2[89]|[3-8][0-9])/,
                            length  : [16]
                        },
                        maestro: {
                            pattern : /^(5018|5020|5038|6304|6759|676[1-3])/,
                            length  : [12, 13, 14, 15, 16, 17, 18, 19]
                        },
                        dinersClub: {
                            pattern : /^(30[0-5]|^36)/,
                            length  : [14]
                        },
                        laser: {
                            pattern : /^(6304|670[69]|6771)/,
                            length  : [16, 17, 18, 19]
                        },
                        visaElectron: {
                            pattern : /^(4026|417500|4508|4844|491(3|7))/,
                            length  : [16]
                        }
                    },
                    valid         = {},
                    validCard     = false,
                    requiredTypes = (typeof cardTypes == 'string')
                        ? cardTypes.split(',')
                        : false,
                    unionPay,
                    validation
                ;

                if(typeof cardNumber !== 'string' || cardNumber.length === 0) {
                    return;
                }

                // verify card types
                if(requiredTypes) {
                    $.each(requiredTypes, function(index, type){
                        // verify each card type
                        validation = cards[type];
                        if(validation) {
                            valid = {
                                length  : ($.inArray(cardNumber.length, validation.length) !== -1),
                                pattern : (cardNumber.search(validation.pattern) !== -1)
                            };
                            if(valid.length && valid.pattern) {
                                validCard = true;
                            }
                        }
                    });

                    if(!validCard) {
                        return false;
                    }
                }

                // skip luhn for UnionPay
                unionPay = {
                    number  : ($.inArray(cardNumber.length, cards.unionPay.length) !== -1),
                    pattern : (cardNumber.search(cards.unionPay.pattern) !== -1)
                };
                if(unionPay.number && unionPay.pattern) {
                    return true;
                }

                // verify luhn, adapted from  <https://gist.github.com/2134376>
                var
                    length        = cardNumber.length,
                    multiple      = 0,
                    producedValue = [
                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                        [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]
                    ],
                    sum           = 0
                ;
                while (length--) {
                    sum += producedValue[multiple][parseInt(cardNumber.charAt(length), 10)];
                    multiple ^= 1;
                }
                return (sum % 10 === 0 && sum > 0);
            },

            minCount: function(value, minCount) {
                if(minCount == 0) {
                    return true;
                }
                if(minCount == 1) {
                    return (value !== '');
                }
                return (value.split(',').length >= minCount);
            },

            exactCount: function(value, exactCount) {
                if(exactCount == 0) {
                    return (value === '');
                }
                if(exactCount == 1) {
                    return (value !== '' && value.search(',') === -1);
                }
                return (value.split(',').length == exactCount);
            },

            maxCount: function(value, maxCount) {
                if(maxCount == 0) {
                    return false;
                }
                if(maxCount == 1) {
                    return (value.search(',') === -1);
                }
                return (value.split(',').length <= maxCount);
            }
        }

    };

})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Accordion
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.accordion = function(parameters) {
        var
            $allModules     = $(this),

            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),

            requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(callback) { setTimeout(callback, 0); },

            returnedValue
        ;
        $allModules
            .each(function() {
                var
                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.accordion.settings, parameters)
                        : $.extend({}, $.fn.accordion.settings),

                    className       = settings.className,
                    namespace       = settings.namespace,
                    selector        = settings.selector,
                    error           = settings.error,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,
                    moduleSelector  = $allModules.selector || '',

                    $module  = $(this),
                    $title   = $module.find(selector.title),
                    $content = $module.find(selector.content),

                    element  = this,
                    instance = $module.data(moduleNamespace),
                    observer,
                    module
                ;

                module = {

                    initialize: function() {
                        module.debug('Initializing', $module);
                        module.bind.events();
                        if(settings.observeChanges) {
                            module.observeChanges();
                        }
                        module.instantiate();
                    },

                    instantiate: function() {
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.debug('Destroying previous instance', $module);
                        $module
                            .off(eventNamespace)
                            .removeData(moduleNamespace)
                        ;
                    },

                    refresh: function() {
                        $title   = $module.find(selector.title);
                        $content = $module.find(selector.content);
                    },

                    observeChanges: function() {
                        if('MutationObserver' in window) {
                            observer = new MutationObserver(function(mutations) {
                                module.debug('DOM tree modified, updating selector cache');
                                module.refresh();
                            });
                            observer.observe(element, {
                                childList : true,
                                subtree   : true
                            });
                            module.debug('Setting up mutation observer', observer);
                        }
                    },

                    bind: {
                        events: function() {
                            module.debug('Binding delegated events');
                            $module
                                .on(settings.on + eventNamespace, selector.trigger, module.event.click)
                            ;
                        }
                    },

                    event: {
                        click: function() {
                            module.toggle.call(this);
                        }
                    },

                    toggle: function(query) {
                        var
                            $activeTitle = (query !== undefined)
                                ? (typeof query === 'number')
                                    ? $title.eq(query)
                                    : $(query).closest(selector.title)
                                : $(this).closest(selector.title),
                            $activeContent = $activeTitle.next($content),
                            isAnimating = $activeContent.hasClass(className.animating),
                            isActive    = $activeContent.hasClass(className.active),
                            isOpen      = (isActive && !isAnimating),
                            isOpening   = (!isActive && isAnimating)
                        ;
                        module.debug('Toggling visibility of content', $activeTitle);
                        if(isOpen || isOpening) {
                            if(settings.collapsible) {
                                module.close.call($activeTitle);
                            }
                            else {
                                module.debug('Cannot close accordion content collapsing is disabled');
                            }
                        }
                        else {
                            module.open.call($activeTitle);
                        }
                    },

                    open: function(query) {
                        var
                            $activeTitle = (query !== undefined)
                                ? (typeof query === 'number')
                                    ? $title.eq(query)
                                    : $(query).closest(selector.title)
                                : $(this).closest(selector.title),
                            $activeContent = $activeTitle.next($content),
                            isAnimating = $activeContent.hasClass(className.animating),
                            isActive    = $activeContent.hasClass(className.active),
                            isOpen      = (isActive || isAnimating)
                        ;
                        if(isOpen) {
                            module.debug('Accordion already open, skipping', $activeContent);
                            return;
                        }
                        module.debug('Opening accordion content', $activeTitle);
                        settings.onOpening.call($activeContent);
                        if(settings.exclusive) {
                            module.closeOthers.call($activeTitle);
                        }
                        $activeTitle
                            .addClass(className.active)
                        ;
                        $activeContent
                            .stop(true, true)
                            .addClass(className.animating)
                        ;
                        if(settings.animateChildren) {
                            if($.fn.transition !== undefined && $module.transition('is supported')) {
                                $activeContent
                                    .children()
                                    .transition({
                                        animation   : 'fade in',
                                        queue       : false,
                                        useFailSafe : true,
                                        debug       : settings.debug,
                                        verbose     : settings.verbose,
                                        duration    : settings.duration
                                    })
                                ;
                            }
                            else {
                                $activeContent
                                    .children()
                                    .stop(true, true)
                                    .animate({
                                        opacity: 1
                                    }, settings.duration, module.resetOpacity)
                                ;
                            }
                        }
                        $activeContent
                            .slideDown(settings.duration, settings.easing, function() {
                                $activeContent
                                    .removeClass(className.animating)
                                    .addClass(className.active)
                                ;
                                module.reset.display.call(this);
                                settings.onOpen.call(this);
                                settings.onChange.call(this);
                            })
                        ;
                    },

                    close: function(query) {
                        var
                            $activeTitle = (query !== undefined)
                                ? (typeof query === 'number')
                                    ? $title.eq(query)
                                    : $(query).closest(selector.title)
                                : $(this).closest(selector.title),
                            $activeContent = $activeTitle.next($content),
                            isAnimating    = $activeContent.hasClass(className.animating),
                            isActive       = $activeContent.hasClass(className.active),
                            isOpening      = (!isActive && isAnimating),
                            isClosing      = (isActive && isAnimating)
                        ;
                        if((isActive || isOpening) && !isClosing) {
                            module.debug('Closing accordion content', $activeContent);
                            settings.onClosing.call($activeContent);
                            $activeTitle
                                .removeClass(className.active)
                            ;
                            $activeContent
                                .stop(true, true)
                                .addClass(className.animating)
                            ;
                            if(settings.animateChildren) {
                                if($.fn.transition !== undefined && $module.transition('is supported')) {
                                    $activeContent
                                        .children()
                                        .transition({
                                            animation   : 'fade out',
                                            queue       : false,
                                            useFailSafe : true,
                                            debug       : settings.debug,
                                            verbose     : settings.verbose,
                                            duration    : settings.duration
                                        })
                                    ;
                                }
                                else {
                                    $activeContent
                                        .children()
                                        .stop(true, true)
                                        .animate({
                                            opacity: 0
                                        }, settings.duration, module.resetOpacity)
                                    ;
                                }
                            }
                            $activeContent
                                .slideUp(settings.duration, settings.easing, function() {
                                    $activeContent
                                        .removeClass(className.animating)
                                        .removeClass(className.active)
                                    ;
                                    module.reset.display.call(this);
                                    settings.onClose.call(this);
                                    settings.onChange.call(this);
                                })
                            ;
                        }
                    },

                    closeOthers: function(index) {
                        var
                            $activeTitle = (index !== undefined)
                                ? $title.eq(index)
                                : $(this).closest(selector.title),
                            $parentTitles    = $activeTitle.parents(selector.content).prev(selector.title),
                            $activeAccordion = $activeTitle.closest(selector.accordion),
                            activeSelector   = selector.title + '.' + className.active + ':visible',
                            activeContent    = selector.content + '.' + className.active + ':visible',
                            $openTitles,
                            $nestedTitles,
                            $openContents
                        ;
                        if(settings.closeNested) {
                            $openTitles   = $activeAccordion.find(activeSelector).not($parentTitles);
                            $openContents = $openTitles.next($content);
                        }
                        else {
                            $openTitles   = $activeAccordion.find(activeSelector).not($parentTitles);
                            $nestedTitles = $activeAccordion.find(activeContent).find(activeSelector).not($parentTitles);
                            $openTitles   = $openTitles.not($nestedTitles);
                            $openContents = $openTitles.next($content);
                        }
                        if( ($openTitles.length > 0) ) {
                            module.debug('Exclusive enabled, closing other content', $openTitles);
                            $openTitles
                                .removeClass(className.active)
                            ;
                            $openContents
                                .removeClass(className.animating)
                                .stop(true, true)
                            ;
                            if(settings.animateChildren) {
                                if($.fn.transition !== undefined && $module.transition('is supported')) {
                                    $openContents
                                        .children()
                                        .transition({
                                            animation   : 'fade out',
                                            useFailSafe : true,
                                            debug       : settings.debug,
                                            verbose     : settings.verbose,
                                            duration    : settings.duration
                                        })
                                    ;
                                }
                                else {
                                    $openContents
                                        .children()
                                        .stop(true, true)
                                        .animate({
                                            opacity: 0
                                        }, settings.duration, module.resetOpacity)
                                    ;
                                }
                            }
                            $openContents
                                .slideUp(settings.duration , settings.easing, function() {
                                    $(this).removeClass(className.active);
                                    module.reset.display.call(this);
                                })
                            ;
                        }
                    },

                    reset: {

                        display: function() {
                            module.verbose('Removing inline display from element', this);
                            $(this).css('display', '');
                            if( $(this).attr('style') === '') {
                                $(this)
                                    .attr('style', '')
                                    .removeAttr('style')
                                ;
                            }
                        },

                        opacity: function() {
                            module.verbose('Removing inline opacity from element', this);
                            $(this).css('opacity', '');
                            if( $(this).attr('style') === '') {
                                $(this)
                                    .attr('style', '')
                                    .removeAttr('style')
                                ;
                            }
                        },

                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            if($.isPlainObject(settings[name])) {
                                $.extend(true, settings[name], value);
                            }
                            else {
                                settings[name] = value;
                            }
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        module.debug('Changing internal', name, value);
                        if(value !== undefined) {
                            if( $.isPlainObject(name) ) {
                                $.extend(true, module, name);
                            }
                            else {
                                module[name] = value;
                            }
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };
                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;
        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.accordion.settings = {

        name            : 'Accordion',
        namespace       : 'accordion',

        silent          : false,
        debug           : false,
        verbose         : false,
        performance     : true,

        on              : 'click', // event on title that opens accordion

        observeChanges  : true,  // whether accordion should automatically refresh on DOM insertion

        exclusive       : true,  // whether a single accordion content panel should be open at once
        collapsible     : true,  // whether accordion content can be closed
        closeNested     : false, // whether nested content should be closed when a panel is closed
        animateChildren : true,  // whether children opacity should be animated

        duration        : 350, // duration of animation
        easing          : 'easeOutQuad', // easing equation for animation


        onOpening       : function(){}, // callback before open animation
        onOpen          : function(){}, // callback after open animation
        onClosing       : function(){}, // callback before closing animation
        onClose         : function(){}, // callback after closing animation
        onChange        : function(){}, // callback after closing or opening animation

        error: {
            method : 'The method you called is not defined'
        },

        className   : {
            active    : 'active',
            animating : 'animating'
        },

        selector    : {
            accordion : '.accordion',
            title     : '.title',
            trigger   : '.title',
            content   : '.content'
        }

    };

// Adds easing
    $.extend( $.easing, {
        easeOutQuad: function (x, t, b, c, d) {
            return -c *(t/=d)*(t-2) + b;
        }
    });

})( jQuery, window, document );


/*!
 * # Semantic UI 2.2.7 - Checkbox
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.checkbox = function(parameters) {
        var
            $allModules    = $(this),
            moduleSelector = $allModules.selector || '',

            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),
            returnedValue
        ;

        $allModules
            .each(function() {
                var
                    settings        = $.extend(true, {}, $.fn.checkbox.settings, parameters),

                    className       = settings.className,
                    namespace       = settings.namespace,
                    selector        = settings.selector,
                    error           = settings.error,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    $module         = $(this),
                    $label          = $(this).children(selector.label),
                    $input          = $(this).children(selector.input),
                    input           = $input[0],

                    initialLoad     = false,
                    shortcutPressed = false,
                    instance        = $module.data(moduleNamespace),

                    observer,
                    element         = this,
                    module
                ;

                module      = {

                    initialize: function() {
                        module.verbose('Initializing checkbox', settings);

                        module.create.label();
                        module.bind.events();

                        module.set.tabbable();
                        module.hide.input();

                        module.observeChanges();
                        module.instantiate();
                        module.setup();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying module');
                        module.unbind.events();
                        module.show.input();
                        $module.removeData(moduleNamespace);
                    },

                    fix: {
                        reference: function() {
                            if( $module.is(selector.input) ) {
                                module.debug('Behavior called on <input> adjusting invoked element');
                                $module = $module.closest(selector.checkbox);
                                module.refresh();
                            }
                        }
                    },

                    setup: function() {
                        module.set.initialLoad();
                        if( module.is.indeterminate() ) {
                            module.debug('Initial value is indeterminate');
                            module.indeterminate();
                        }
                        else if( module.is.checked() ) {
                            module.debug('Initial value is checked');
                            module.check();
                        }
                        else {
                            module.debug('Initial value is unchecked');
                            module.uncheck();
                        }
                        module.remove.initialLoad();
                    },

                    refresh: function() {
                        $label = $module.children(selector.label);
                        $input = $module.children(selector.input);
                        input  = $input[0];
                    },

                    hide: {
                        input: function() {
                            module.verbose('Modifying <input> z-index to be unselectable');
                            $input.addClass(className.hidden);
                        }
                    },
                    show: {
                        input: function() {
                            module.verbose('Modifying <input> z-index to be selectable');
                            $input.removeClass(className.hidden);
                        }
                    },

                    observeChanges: function() {
                        if('MutationObserver' in window) {
                            observer = new MutationObserver(function(mutations) {
                                module.debug('DOM tree modified, updating selector cache');
                                module.refresh();
                            });
                            observer.observe(element, {
                                childList : true,
                                subtree   : true
                            });
                            module.debug('Setting up mutation observer', observer);
                        }
                    },

                    attachEvents: function(selector, event) {
                        var
                            $element = $(selector)
                        ;
                        event = $.isFunction(module[event])
                            ? module[event]
                            : module.toggle
                        ;
                        if($element.length > 0) {
                            module.debug('Attaching checkbox events to element', selector, event);
                            $element
                                .on('click' + eventNamespace, event)
                            ;
                        }
                        else {
                            module.error(error.notFound);
                        }
                    },

                    event: {
                        click: function(event) {
                            var
                                $target = $(event.target)
                            ;
                            if( $target.is(selector.input) ) {
                                module.verbose('Using default check action on initialized checkbox');
                                return;
                            }
                            if( $target.is(selector.link) ) {
                                module.debug('Clicking link inside checkbox, skipping toggle');
                                return;
                            }
                            module.toggle();
                            $input.focus();
                            event.preventDefault();
                        },
                        keydown: function(event) {
                            var
                                key     = event.which,
                                keyCode = {
                                    enter  : 13,
                                    space  : 32,
                                    escape : 27
                                }
                            ;
                            if(key == keyCode.escape) {
                                module.verbose('Escape key pressed blurring field');
                                $input.blur();
                                shortcutPressed = true;
                            }
                            else if(!event.ctrlKey && ( key == keyCode.space || key == keyCode.enter) ) {
                                module.verbose('Enter/space key pressed, toggling checkbox');
                                module.toggle();
                                shortcutPressed = true;
                            }
                            else {
                                shortcutPressed = false;
                            }
                        },
                        keyup: function(event) {
                            if(shortcutPressed) {
                                event.preventDefault();
                            }
                        }
                    },

                    check: function() {
                        if( !module.should.allowCheck() ) {
                            return;
                        }
                        module.debug('Checking checkbox', $input);
                        module.set.checked();
                        if( !module.should.ignoreCallbacks() ) {
                            settings.onChecked.call(input);
                            settings.onChange.call(input);
                        }
                    },

                    uncheck: function() {
                        if( !module.should.allowUncheck() ) {
                            return;
                        }
                        module.debug('Unchecking checkbox');
                        module.set.unchecked();
                        if( !module.should.ignoreCallbacks() ) {
                            settings.onUnchecked.call(input);
                            settings.onChange.call(input);
                        }
                    },

                    indeterminate: function() {
                        if( module.should.allowIndeterminate() ) {
                            module.debug('Checkbox is already indeterminate');
                            return;
                        }
                        module.debug('Making checkbox indeterminate');
                        module.set.indeterminate();
                        if( !module.should.ignoreCallbacks() ) {
                            settings.onIndeterminate.call(input);
                            settings.onChange.call(input);
                        }
                    },

                    determinate: function() {
                        if( module.should.allowDeterminate() ) {
                            module.debug('Checkbox is already determinate');
                            return;
                        }
                        module.debug('Making checkbox determinate');
                        module.set.determinate();
                        if( !module.should.ignoreCallbacks() ) {
                            settings.onDeterminate.call(input);
                            settings.onChange.call(input);
                        }
                    },

                    enable: function() {
                        if( module.is.enabled() ) {
                            module.debug('Checkbox is already enabled');
                            return;
                        }
                        module.debug('Enabling checkbox');
                        module.set.enabled();
                        settings.onEnable.call(input);
                        // preserve legacy callbacks
                        settings.onEnabled.call(input);
                    },

                    disable: function() {
                        if( module.is.disabled() ) {
                            module.debug('Checkbox is already disabled');
                            return;
                        }
                        module.debug('Disabling checkbox');
                        module.set.disabled();
                        settings.onDisable.call(input);
                        // preserve legacy callbacks
                        settings.onDisabled.call(input);
                    },

                    get: {
                        radios: function() {
                            var
                                name = module.get.name()
                            ;
                            return $('input[name="' + name + '"]').closest(selector.checkbox);
                        },
                        otherRadios: function() {
                            return module.get.radios().not($module);
                        },
                        name: function() {
                            return $input.attr('name');
                        }
                    },

                    is: {
                        initialLoad: function() {
                            return initialLoad;
                        },
                        radio: function() {
                            return ($input.hasClass(className.radio) || $input.attr('type') == 'radio');
                        },
                        indeterminate: function() {
                            return $input.prop('indeterminate') !== undefined && $input.prop('indeterminate');
                        },
                        checked: function() {
                            return $input.prop('checked') !== undefined && $input.prop('checked');
                        },
                        disabled: function() {
                            return $input.prop('disabled') !== undefined && $input.prop('disabled');
                        },
                        enabled: function() {
                            return !module.is.disabled();
                        },
                        determinate: function() {
                            return !module.is.indeterminate();
                        },
                        unchecked: function() {
                            return !module.is.checked();
                        }
                    },

                    should: {
                        allowCheck: function() {
                            if(module.is.determinate() && module.is.checked() && !module.should.forceCallbacks() ) {
                                module.debug('Should not allow check, checkbox is already checked');
                                return false;
                            }
                            if(settings.beforeChecked.apply(input) === false) {
                                module.debug('Should not allow check, beforeChecked cancelled');
                                return false;
                            }
                            return true;
                        },
                        allowUncheck: function() {
                            if(module.is.determinate() && module.is.unchecked() && !module.should.forceCallbacks() ) {
                                module.debug('Should not allow uncheck, checkbox is already unchecked');
                                return false;
                            }
                            if(settings.beforeUnchecked.apply(input) === false) {
                                module.debug('Should not allow uncheck, beforeUnchecked cancelled');
                                return false;
                            }
                            return true;
                        },
                        allowIndeterminate: function() {
                            if(module.is.indeterminate() && !module.should.forceCallbacks() ) {
                                module.debug('Should not allow indeterminate, checkbox is already indeterminate');
                                return false;
                            }
                            if(settings.beforeIndeterminate.apply(input) === false) {
                                module.debug('Should not allow indeterminate, beforeIndeterminate cancelled');
                                return false;
                            }
                            return true;
                        },
                        allowDeterminate: function() {
                            if(module.is.determinate() && !module.should.forceCallbacks() ) {
                                module.debug('Should not allow determinate, checkbox is already determinate');
                                return false;
                            }
                            if(settings.beforeDeterminate.apply(input) === false) {
                                module.debug('Should not allow determinate, beforeDeterminate cancelled');
                                return false;
                            }
                            return true;
                        },
                        forceCallbacks: function() {
                            return (module.is.initialLoad() && settings.fireOnInit);
                        },
                        ignoreCallbacks: function() {
                            return (initialLoad && !settings.fireOnInit);
                        }
                    },

                    can: {
                        change: function() {
                            return !( $module.hasClass(className.disabled) || $module.hasClass(className.readOnly) || $input.prop('disabled') || $input.prop('readonly') );
                        },
                        uncheck: function() {
                            return (typeof settings.uncheckable === 'boolean')
                                ? settings.uncheckable
                                : !module.is.radio()
                                ;
                        }
                    },

                    set: {
                        initialLoad: function() {
                            initialLoad = true;
                        },
                        checked: function() {
                            module.verbose('Setting class to checked');
                            $module
                                .removeClass(className.indeterminate)
                                .addClass(className.checked)
                            ;
                            if( module.is.radio() ) {
                                module.uncheckOthers();
                            }
                            if(!module.is.indeterminate() && module.is.checked()) {
                                module.debug('Input is already checked, skipping input property change');
                                return;
                            }
                            module.verbose('Setting state to checked', input);
                            $input
                                .prop('indeterminate', false)
                                .prop('checked', true)
                            ;
                            module.trigger.change();
                        },
                        unchecked: function() {
                            module.verbose('Removing checked class');
                            $module
                                .removeClass(className.indeterminate)
                                .removeClass(className.checked)
                            ;
                            if(!module.is.indeterminate() &&  module.is.unchecked() ) {
                                module.debug('Input is already unchecked');
                                return;
                            }
                            module.debug('Setting state to unchecked');
                            $input
                                .prop('indeterminate', false)
                                .prop('checked', false)
                            ;
                            module.trigger.change();
                        },
                        indeterminate: function() {
                            module.verbose('Setting class to indeterminate');
                            $module
                                .addClass(className.indeterminate)
                            ;
                            if( module.is.indeterminate() ) {
                                module.debug('Input is already indeterminate, skipping input property change');
                                return;
                            }
                            module.debug('Setting state to indeterminate');
                            $input
                                .prop('indeterminate', true)
                            ;
                            module.trigger.change();
                        },
                        determinate: function() {
                            module.verbose('Removing indeterminate class');
                            $module
                                .removeClass(className.indeterminate)
                            ;
                            if( module.is.determinate() ) {
                                module.debug('Input is already determinate, skipping input property change');
                                return;
                            }
                            module.debug('Setting state to determinate');
                            $input
                                .prop('indeterminate', false)
                            ;
                        },
                        disabled: function() {
                            module.verbose('Setting class to disabled');
                            $module
                                .addClass(className.disabled)
                            ;
                            if( module.is.disabled() ) {
                                module.debug('Input is already disabled, skipping input property change');
                                return;
                            }
                            module.debug('Setting state to disabled');
                            $input
                                .prop('disabled', 'disabled')
                            ;
                            module.trigger.change();
                        },
                        enabled: function() {
                            module.verbose('Removing disabled class');
                            $module.removeClass(className.disabled);
                            if( module.is.enabled() ) {
                                module.debug('Input is already enabled, skipping input property change');
                                return;
                            }
                            module.debug('Setting state to enabled');
                            $input
                                .prop('disabled', false)
                            ;
                            module.trigger.change();
                        },
                        tabbable: function() {
                            module.verbose('Adding tabindex to checkbox');
                            if( $input.attr('tabindex') === undefined) {
                                $input.attr('tabindex', 0);
                            }
                        }
                    },

                    remove: {
                        initialLoad: function() {
                            initialLoad = false;
                        }
                    },

                    trigger: {
                        change: function() {
                            var
                                events       = document.createEvent('HTMLEvents'),
                                inputElement = $input[0]
                            ;
                            if(inputElement) {
                                module.verbose('Triggering native change event');
                                events.initEvent('change', true, false);
                                inputElement.dispatchEvent(events);
                            }
                        }
                    },


                    create: {
                        label: function() {
                            if($input.prevAll(selector.label).length > 0) {
                                $input.prev(selector.label).detach().insertAfter($input);
                                module.debug('Moving existing label', $label);
                            }
                            else if( !module.has.label() ) {
                                $label = $('<label>').insertAfter($input);
                                module.debug('Creating label', $label);
                            }
                        }
                    },

                    has: {
                        label: function() {
                            return ($label.length > 0);
                        }
                    },

                    bind: {
                        events: function() {
                            module.verbose('Attaching checkbox events');
                            $module
                                .on('click'   + eventNamespace, module.event.click)
                                .on('keydown' + eventNamespace, selector.input, module.event.keydown)
                                .on('keyup'   + eventNamespace, selector.input, module.event.keyup)
                            ;
                        }
                    },

                    unbind: {
                        events: function() {
                            module.debug('Removing events');
                            $module
                                .off(eventNamespace)
                            ;
                        }
                    },

                    uncheckOthers: function() {
                        var
                            $radios = module.get.otherRadios()
                        ;
                        module.debug('Unchecking other radios', $radios);
                        $radios.removeClass(className.checked);
                    },

                    toggle: function() {
                        if( !module.can.change() ) {
                            if(!module.is.radio()) {
                                module.debug('Checkbox is read-only or disabled, ignoring toggle');
                            }
                            return;
                        }
                        if( module.is.indeterminate() || module.is.unchecked() ) {
                            module.debug('Currently unchecked');
                            module.check();
                        }
                        else if( module.is.checked() && module.can.uncheck() ) {
                            module.debug('Currently checked');
                            module.uncheck();
                        }
                    },
                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            if($.isPlainObject(settings[name])) {
                                $.extend(true, settings[name], value);
                            }
                            else {
                                settings[name] = value;
                            }
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.checkbox.settings = {

        name                : 'Checkbox',
        namespace           : 'checkbox',

        silent              : false,
        debug               : false,
        verbose             : true,
        performance         : true,

        // delegated event context
        uncheckable         : 'auto',
        fireOnInit          : false,

        onChange            : function(){},

        beforeChecked       : function(){},
        beforeUnchecked     : function(){},
        beforeDeterminate   : function(){},
        beforeIndeterminate : function(){},

        onChecked           : function(){},
        onUnchecked         : function(){},

        onDeterminate       : function() {},
        onIndeterminate     : function() {},

        onEnable            : function(){},
        onDisable           : function(){},

        // preserve misspelled callbacks (will be removed in 3.0)
        onEnabled           : function(){},
        onDisabled          : function(){},

        className       : {
            checked       : 'checked',
            indeterminate : 'indeterminate',
            disabled      : 'disabled',
            hidden        : 'hidden',
            radio         : 'radio',
            readOnly      : 'read-only'
        },

        error     : {
            method       : 'The method you called is not defined'
        },

        selector : {
            checkbox : '.ui.checkbox',
            label    : 'label, .box',
            input    : 'input[type="checkbox"], input[type="radio"]',
            link     : 'a[href]'
        }

    };

})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Dimmer
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.dimmer = function(parameters) {
        var
            $allModules     = $(this),

            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),

            returnedValue
        ;

        $allModules
            .each(function() {
                var
                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.dimmer.settings, parameters)
                        : $.extend({}, $.fn.dimmer.settings),

                    selector        = settings.selector,
                    namespace       = settings.namespace,
                    className       = settings.className,
                    error           = settings.error,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,
                    moduleSelector  = $allModules.selector || '',

                    clickEvent      = ('ontouchstart' in document.documentElement)
                        ? 'touchstart'
                        : 'click',

                    $module = $(this),
                    $dimmer,
                    $dimmable,

                    element   = this,
                    instance  = $module.data(moduleNamespace),
                    module
                ;

                module = {

                    preinitialize: function() {
                        if( module.is.dimmer() ) {

                            $dimmable = $module.parent();
                            $dimmer   = $module;
                        }
                        else {
                            $dimmable = $module;
                            if( module.has.dimmer() ) {
                                if(settings.dimmerName) {
                                    $dimmer = $dimmable.find(selector.dimmer).filter('.' + settings.dimmerName);
                                }
                                else {
                                    $dimmer = $dimmable.find(selector.dimmer);
                                }
                            }
                            else {
                                $dimmer = module.create();
                            }
                            module.set.variation();
                        }
                    },

                    initialize: function() {
                        module.debug('Initializing dimmer', settings);

                        module.bind.events();
                        module.set.dimmable();
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, instance)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module', $dimmer);
                        module.unbind.events();
                        module.remove.variation();
                        $dimmable
                            .off(eventNamespace)
                        ;
                    },

                    bind: {
                        events: function() {
                            if(settings.on == 'hover') {
                                $dimmable
                                    .on('mouseenter' + eventNamespace, module.show)
                                    .on('mouseleave' + eventNamespace, module.hide)
                                ;
                            }
                            else if(settings.on == 'click') {
                                $dimmable
                                    .on(clickEvent + eventNamespace, module.toggle)
                                ;
                            }
                            if( module.is.page() ) {
                                module.debug('Setting as a page dimmer', $dimmable);
                                module.set.pageDimmer();
                            }

                            if( module.is.closable() ) {
                                module.verbose('Adding dimmer close event', $dimmer);
                                $dimmable
                                    .on(clickEvent + eventNamespace, selector.dimmer, module.event.click)
                                ;
                            }
                        }
                    },

                    unbind: {
                        events: function() {
                            $module
                                .removeData(moduleNamespace)
                            ;
                            $dimmable
                                .off(eventNamespace)
                            ;
                        }
                    },

                    event: {
                        click: function(event) {
                            module.verbose('Determining if event occured on dimmer', event);
                            if( $dimmer.find(event.target).length === 0 || $(event.target).is(selector.content) ) {
                                module.hide();
                                event.stopImmediatePropagation();
                            }
                        }
                    },

                    addContent: function(element) {
                        var
                            $content = $(element)
                        ;
                        module.debug('Add content to dimmer', $content);
                        if($content.parent()[0] !== $dimmer[0]) {
                            $content.detach().appendTo($dimmer);
                        }
                    },

                    create: function() {
                        var
                            $element = $( settings.template.dimmer() )
                        ;
                        if(settings.dimmerName) {
                            module.debug('Creating named dimmer', settings.dimmerName);
                            $element.addClass(settings.dimmerName);
                        }
                        $element
                            .appendTo($dimmable)
                        ;
                        return $element;
                    },

                    show: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        module.debug('Showing dimmer', $dimmer, settings);
                        if( (!module.is.dimmed() || module.is.animating()) && module.is.enabled() ) {
                            module.animate.show(callback);
                            settings.onShow.call(element);
                            settings.onChange.call(element);
                        }
                        else {
                            module.debug('Dimmer is already shown or disabled');
                        }
                    },

                    hide: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if( module.is.dimmed() || module.is.animating() ) {
                            module.debug('Hiding dimmer', $dimmer);
                            module.animate.hide(callback);
                            settings.onHide.call(element);
                            settings.onChange.call(element);
                        }
                        else {
                            module.debug('Dimmer is not visible');
                        }
                    },

                    toggle: function() {
                        module.verbose('Toggling dimmer visibility', $dimmer);
                        if( !module.is.dimmed() ) {
                            module.show();
                        }
                        else {
                            module.hide();
                        }
                    },

                    animate: {
                        show: function(callback) {
                            callback = $.isFunction(callback)
                                ? callback
                                : function(){}
                            ;
                            if(settings.useCSS && $.fn.transition !== undefined && $dimmer.transition('is supported')) {
                                if(settings.opacity !== 'auto') {
                                    module.set.opacity();
                                }
                                $dimmer
                                    .transition({
                                        animation   : settings.transition + ' in',
                                        queue       : false,
                                        duration    : module.get.duration(),
                                        useFailSafe : true,
                                        onStart     : function() {
                                            module.set.dimmed();
                                        },
                                        onComplete  : function() {
                                            module.set.active();
                                            callback();
                                        }
                                    })
                                ;
                            }
                            else {
                                module.verbose('Showing dimmer animation with javascript');
                                module.set.dimmed();
                                if(settings.opacity == 'auto') {
                                    settings.opacity = 0.8;
                                }
                                $dimmer
                                    .stop()
                                    .css({
                                        opacity : 0,
                                        width   : '100%',
                                        height  : '100%'
                                    })
                                    .fadeTo(module.get.duration(), settings.opacity, function() {
                                        $dimmer.removeAttr('style');
                                        module.set.active();
                                        callback();
                                    })
                                ;
                            }
                        },
                        hide: function(callback) {
                            callback = $.isFunction(callback)
                                ? callback
                                : function(){}
                            ;
                            if(settings.useCSS && $.fn.transition !== undefined && $dimmer.transition('is supported')) {
                                module.verbose('Hiding dimmer with css');
                                $dimmer
                                    .transition({
                                        animation   : settings.transition + ' out',
                                        queue       : false,
                                        duration    : module.get.duration(),
                                        useFailSafe : true,
                                        onStart     : function() {
                                            module.remove.dimmed();
                                        },
                                        onComplete  : function() {
                                            module.remove.active();
                                            callback();
                                        }
                                    })
                                ;
                            }
                            else {
                                module.verbose('Hiding dimmer with javascript');
                                module.remove.dimmed();
                                $dimmer
                                    .stop()
                                    .fadeOut(module.get.duration(), function() {
                                        module.remove.active();
                                        $dimmer.removeAttr('style');
                                        callback();
                                    })
                                ;
                            }
                        }
                    },

                    get: {
                        dimmer: function() {
                            return $dimmer;
                        },
                        duration: function() {
                            if(typeof settings.duration == 'object') {
                                if( module.is.active() ) {
                                    return settings.duration.hide;
                                }
                                else {
                                    return settings.duration.show;
                                }
                            }
                            return settings.duration;
                        }
                    },

                    has: {
                        dimmer: function() {
                            if(settings.dimmerName) {
                                return ($module.find(selector.dimmer).filter('.' + settings.dimmerName).length > 0);
                            }
                            else {
                                return ( $module.find(selector.dimmer).length > 0 );
                            }
                        }
                    },

                    is: {
                        active: function() {
                            return $dimmer.hasClass(className.active);
                        },
                        animating: function() {
                            return ( $dimmer.is(':animated') || $dimmer.hasClass(className.animating) );
                        },
                        closable: function() {
                            if(settings.closable == 'auto') {
                                if(settings.on == 'hover') {
                                    return false;
                                }
                                return true;
                            }
                            return settings.closable;
                        },
                        dimmer: function() {
                            return $module.hasClass(className.dimmer);
                        },
                        dimmable: function() {
                            return $module.hasClass(className.dimmable);
                        },
                        dimmed: function() {
                            return $dimmable.hasClass(className.dimmed);
                        },
                        disabled: function() {
                            return $dimmable.hasClass(className.disabled);
                        },
                        enabled: function() {
                            return !module.is.disabled();
                        },
                        page: function () {
                            return $dimmable.is('body');
                        },
                        pageDimmer: function() {
                            return $dimmer.hasClass(className.pageDimmer);
                        }
                    },

                    can: {
                        show: function() {
                            return !$dimmer.hasClass(className.disabled);
                        }
                    },

                    set: {
                        opacity: function(opacity) {
                            var
                                color      = $dimmer.css('background-color'),
                                colorArray = color.split(','),
                                isRGB      = (colorArray && colorArray.length == 3),
                                isRGBA     = (colorArray && colorArray.length == 4)
                            ;
                            opacity    = settings.opacity === 0 ? 0 : settings.opacity || opacity;
                            if(isRGB || isRGBA) {
                                colorArray[3] = opacity + ')';
                                color         = colorArray.join(',');
                            }
                            else {
                                color = 'rgba(0, 0, 0, ' + opacity + ')';
                            }
                            module.debug('Setting opacity to', opacity);
                            $dimmer.css('background-color', color);
                        },
                        active: function() {
                            $dimmer.addClass(className.active);
                        },
                        dimmable: function() {
                            $dimmable.addClass(className.dimmable);
                        },
                        dimmed: function() {
                            $dimmable.addClass(className.dimmed);
                        },
                        pageDimmer: function() {
                            $dimmer.addClass(className.pageDimmer);
                        },
                        disabled: function() {
                            $dimmer.addClass(className.disabled);
                        },
                        variation: function(variation) {
                            variation = variation || settings.variation;
                            if(variation) {
                                $dimmer.addClass(variation);
                            }
                        }
                    },

                    remove: {
                        active: function() {
                            $dimmer
                                .removeClass(className.active)
                            ;
                        },
                        dimmed: function() {
                            $dimmable.removeClass(className.dimmed);
                        },
                        disabled: function() {
                            $dimmer.removeClass(className.disabled);
                        },
                        variation: function(variation) {
                            variation = variation || settings.variation;
                            if(variation) {
                                $dimmer.removeClass(variation);
                            }
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            if($.isPlainObject(settings[name])) {
                                $.extend(true, settings[name], value);
                            }
                            else {
                                settings[name] = value;
                            }
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if($allModules.length > 1) {
                                title += ' ' + '(' + $allModules.length + ')';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                module.preinitialize();

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.dimmer.settings = {

        name        : 'Dimmer',
        namespace   : 'dimmer',

        silent      : false,
        debug       : false,
        verbose     : false,
        performance : true,

        // name to distinguish between multiple dimmers in context
        dimmerName  : false,

        // whether to add a variation type
        variation   : false,

        // whether to bind close events
        closable    : 'auto',

        // whether to use css animations
        useCSS      : true,

        // css animation to use
        transition  : 'fade',

        // event to bind to
        on          : false,

        // overriding opacity value
        opacity     : 'auto',

        // transition durations
        duration    : {
            show : 500,
            hide : 500
        },

        onChange    : function(){},
        onShow      : function(){},
        onHide      : function(){},

        error   : {
            method   : 'The method you called is not defined.'
        },

        className : {
            active     : 'active',
            animating  : 'animating',
            dimmable   : 'dimmable',
            dimmed     : 'dimmed',
            dimmer     : 'dimmer',
            disabled   : 'disabled',
            hide       : 'hide',
            pageDimmer : 'page',
            show       : 'show'
        },

        selector: {
            dimmer   : '> .ui.dimmer',
            content  : '.ui.dimmer > .content, .ui.dimmer > .content > .center'
        },

        template: {
            dimmer: function() {
                return $('<div />').attr('class', 'ui dimmer');
            }
        }

    };

})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Dropdown
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.dropdown = function(parameters) {
        var
            $allModules    = $(this),
            $document      = $(document),

            moduleSelector = $allModules.selector || '',

            hasTouch       = ('ontouchstart' in document.documentElement),
            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),
            returnedValue
        ;

        $allModules
            .each(function(elementIndex) {
                var
                    settings          = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.dropdown.settings, parameters)
                        : $.extend({}, $.fn.dropdown.settings),

                    className       = settings.className,
                    message         = settings.message,
                    fields          = settings.fields,
                    keys            = settings.keys,
                    metadata        = settings.metadata,
                    namespace       = settings.namespace,
                    regExp          = settings.regExp,
                    selector        = settings.selector,
                    error           = settings.error,
                    templates       = settings.templates,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    $module         = $(this),
                    $context        = $(settings.context),
                    $text           = $module.find(selector.text),
                    $search         = $module.find(selector.search),
                    $sizer          = $module.find(selector.sizer),
                    $input          = $module.find(selector.input),
                    $icon           = $module.find(selector.icon),

                    $combo = ($module.prev().find(selector.text).length > 0)
                        ? $module.prev().find(selector.text)
                        : $module.prev(),

                    $menu           = $module.children(selector.menu),
                    $item           = $menu.find(selector.item),

                    activated       = false,
                    itemActivated   = false,
                    internalChange  = false,
                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    initialLoad,
                    pageLostFocus,
                    willRefocus,
                    elementNamespace,
                    id,
                    selectObserver,
                    menuObserver,
                    module
                ;

                module = {

                    initialize: function() {
                        module.debug('Initializing dropdown', settings);

                        if( module.is.alreadySetup() ) {
                            module.setup.reference();
                        }
                        else {
                            module.setup.layout();
                            module.refreshData();

                            module.save.defaults();
                            module.restore.selected();

                            module.create.id();
                            module.bind.events();

                            module.observeChanges();
                            module.instantiate();
                        }

                    },

                    instantiate: function() {
                        module.verbose('Storing instance of dropdown', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous dropdown', $module);
                        module.remove.tabbable();
                        $module
                            .off(eventNamespace)
                            .removeData(moduleNamespace)
                        ;
                        $menu
                            .off(eventNamespace)
                        ;
                        $document
                            .off(elementNamespace)
                        ;
                        module.disconnect.menuObserver();
                        module.disconnect.selectObserver();
                    },

                    observeChanges: function() {
                        if('MutationObserver' in window) {
                            selectObserver = new MutationObserver(module.event.select.mutation);
                            menuObserver   = new MutationObserver(module.event.menu.mutation);
                            module.debug('Setting up mutation observer', selectObserver, menuObserver);
                            module.observe.select();
                            module.observe.menu();
                        }
                    },

                    disconnect: {
                        menuObserver: function() {
                            if(menuObserver) {
                                menuObserver.disconnect();
                            }
                        },
                        selectObserver: function() {
                            if(selectObserver) {
                                selectObserver.disconnect();
                            }
                        }
                    },
                    observe: {
                        select: function() {
                            if(module.has.input()) {
                                selectObserver.observe($input[0], {
                                    childList : true,
                                    subtree   : true
                                });
                            }
                        },
                        menu: function() {
                            if(module.has.menu()) {
                                menuObserver.observe($menu[0], {
                                    childList : true,
                                    subtree   : true
                                });
                            }
                        }
                    },

                    create: {
                        id: function() {
                            id = (Math.random().toString(16) + '000000000').substr(2, 8);
                            elementNamespace = '.' + id;
                            module.verbose('Creating unique id for element', id);
                        },
                        userChoice: function(values) {
                            var
                                $userChoices,
                                $userChoice,
                                isUserValue,
                                html
                            ;
                            values = values || module.get.userValues();
                            if(!values) {
                                return false;
                            }
                            values = $.isArray(values)
                                ? values
                                : [values]
                            ;
                            $.each(values, function(index, value) {
                                if(module.get.item(value) === false) {
                                    html         = settings.templates.addition( module.add.variables(message.addResult, value) );
                                    $userChoice  = $('<div />')
                                        .html(html)
                                        .attr('data-' + metadata.value, value)
                                        .attr('data-' + metadata.text, value)
                                        .addClass(className.addition)
                                        .addClass(className.item)
                                    ;
                                    if(settings.hideAdditions) {
                                        $userChoice.addClass(className.hidden);
                                    }
                                    $userChoices = ($userChoices === undefined)
                                        ? $userChoice
                                        : $userChoices.add($userChoice)
                                    ;
                                    module.verbose('Creating user choices for value', value, $userChoice);
                                }
                            });
                            return $userChoices;
                        },
                        userLabels: function(value) {
                            var
                                userValues = module.get.userValues()
                            ;
                            if(userValues) {
                                module.debug('Adding user labels', userValues);
                                $.each(userValues, function(index, value) {
                                    module.verbose('Adding custom user value');
                                    module.add.label(value, value);
                                });
                            }
                        },
                        menu: function() {
                            $menu = $('<div />')
                                .addClass(className.menu)
                                .appendTo($module)
                            ;
                        },
                        sizer: function() {
                            $sizer = $('<span />')
                                .addClass(className.sizer)
                                .insertAfter($search)
                            ;
                        }
                    },

                    search: function(query) {
                        query = (query !== undefined)
                            ? query
                            : module.get.query()
                        ;
                        module.verbose('Searching for query', query);
                        if(module.has.minCharacters(query)) {
                            module.filter(query);
                        }
                        else {
                            module.hide();
                        }
                    },

                    select: {
                        firstUnfiltered: function() {
                            module.verbose('Selecting first non-filtered element');
                            module.remove.selectedItem();
                            $item
                                .not(selector.unselectable)
                                .not(selector.addition + selector.hidden)
                                .eq(0)
                                .addClass(className.selected)
                            ;
                        },
                        nextAvailable: function($selected) {
                            $selected = $selected.eq(0);
                            var
                                $nextAvailable = $selected.nextAll(selector.item).not(selector.unselectable).eq(0),
                                $prevAvailable = $selected.prevAll(selector.item).not(selector.unselectable).eq(0),
                                hasNext        = ($nextAvailable.length > 0)
                            ;
                            if(hasNext) {
                                module.verbose('Moving selection to', $nextAvailable);
                                $nextAvailable.addClass(className.selected);
                            }
                            else {
                                module.verbose('Moving selection to', $prevAvailable);
                                $prevAvailable.addClass(className.selected);
                            }
                        }
                    },

                    setup: {
                        api: function() {
                            var
                                apiSettings = {
                                    debug   : settings.debug,
                                    urlData : {
                                        value : module.get.value(),
                                        query : module.get.query()
                                    },
                                    on    : false
                                }
                            ;
                            module.verbose('First request, initializing API');
                            $module
                                .api(apiSettings)
                            ;
                        },
                        layout: function() {
                            if( $module.is('select') ) {
                                module.setup.select();
                                module.setup.returnedObject();
                            }
                            if( !module.has.menu() ) {
                                module.create.menu();
                            }
                            if( module.is.search() && !module.has.search() ) {
                                module.verbose('Adding search input');
                                $search = $('<input />')
                                    .addClass(className.search)
                                    .prop('autocomplete', 'off')
                                    .insertBefore($text)
                                ;
                            }
                            if( module.is.multiple() && module.is.searchSelection() && !module.has.sizer()) {
                                module.create.sizer();
                            }
                            if(settings.allowTab) {
                                module.set.tabbable();
                            }
                        },
                        select: function() {
                            var
                                selectValues  = module.get.selectValues()
                            ;
                            module.debug('Dropdown initialized on a select', selectValues);
                            if( $module.is('select') ) {
                                $input = $module;
                            }
                            // see if select is placed correctly already
                            if($input.parent(selector.dropdown).length > 0) {
                                module.debug('UI dropdown already exists. Creating dropdown menu only');
                                $module = $input.closest(selector.dropdown);
                                if( !module.has.menu() ) {
                                    module.create.menu();
                                }
                                $menu = $module.children(selector.menu);
                                module.setup.menu(selectValues);
                            }
                            else {
                                module.debug('Creating entire dropdown from select');
                                $module = $('<div />')
                                    .attr('class', $input.attr('class') )
                                    .addClass(className.selection)
                                    .addClass(className.dropdown)
                                    .html( templates.dropdown(selectValues) )
                                    .insertBefore($input)
                                ;
                                if($input.hasClass(className.multiple) && $input.prop('multiple') === false) {
                                    module.error(error.missingMultiple);
                                    $input.prop('multiple', true);
                                }
                                if($input.is('[multiple]')) {
                                    module.set.multiple();
                                }
                                if ($input.prop('disabled')) {
                                    module.debug('Disabling dropdown');
                                    $module.addClass(className.disabled);
                                }
                                $input
                                    .removeAttr('class')
                                    .detach()
                                    .prependTo($module)
                                ;
                            }
                            module.refresh();
                        },
                        menu: function(values) {
                            $menu.html( templates.menu(values, fields));
                            $item = $menu.find(selector.item);
                        },
                        reference: function() {
                            module.debug('Dropdown behavior was called on select, replacing with closest dropdown');
                            // replace module reference
                            $module = $module.parent(selector.dropdown);
                            module.refresh();
                            module.setup.returnedObject();
                            // invoke method in context of current instance
                            if(methodInvoked) {
                                instance = module;
                                module.invoke(query);
                            }
                        },
                        returnedObject: function() {
                            var
                                $firstModules = $allModules.slice(0, elementIndex),
                                $lastModules = $allModules.slice(elementIndex + 1)
                            ;
                            // adjust all modules to use correct reference
                            $allModules = $firstModules.add($module).add($lastModules);
                        }
                    },

                    refresh: function() {
                        module.refreshSelectors();
                        module.refreshData();
                    },

                    refreshItems: function() {
                        $item = $menu.find(selector.item);
                    },

                    refreshSelectors: function() {
                        module.verbose('Refreshing selector cache');
                        $text   = $module.find(selector.text);
                        $search = $module.find(selector.search);
                        $input  = $module.find(selector.input);
                        $icon   = $module.find(selector.icon);
                        $combo  = ($module.prev().find(selector.text).length > 0)
                            ? $module.prev().find(selector.text)
                            : $module.prev()
                        ;
                        $menu    = $module.children(selector.menu);
                        $item    = $menu.find(selector.item);
                    },

                    refreshData: function() {
                        module.verbose('Refreshing cached metadata');
                        $item
                            .removeData(metadata.text)
                            .removeData(metadata.value)
                        ;
                    },

                    clearData: function() {
                        module.verbose('Clearing metadata');
                        $item
                            .removeData(metadata.text)
                            .removeData(metadata.value)
                        ;
                        $module
                            .removeData(metadata.defaultText)
                            .removeData(metadata.defaultValue)
                            .removeData(metadata.placeholderText)
                        ;
                    },

                    toggle: function() {
                        module.verbose('Toggling menu visibility');
                        if( !module.is.active() ) {
                            module.show();
                        }
                        else {
                            module.hide();
                        }
                    },

                    show: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if( module.can.show() && !module.is.active() ) {
                            module.debug('Showing dropdown');
                            if(module.has.message() && !(module.has.maxSelections() || module.has.allResultsFiltered()) ) {
                                module.remove.message();
                            }
                            if(module.is.allFiltered()) {
                                return true;
                            }
                            if(settings.onShow.call(element) !== false) {
                                module.animate.show(function() {
                                    if( module.can.click() ) {
                                        module.bind.intent();
                                    }
                                    if(module.has.menuSearch()) {
                                        module.focusSearch();
                                    }
                                    module.set.visible();
                                    callback.call(element);
                                });
                            }
                        }
                    },

                    hide: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if( module.is.active() ) {
                            module.debug('Hiding dropdown');
                            if(settings.onHide.call(element) !== false) {
                                module.animate.hide(function() {
                                    module.remove.visible();
                                    callback.call(element);
                                });
                            }
                        }
                    },

                    hideOthers: function() {
                        module.verbose('Finding other dropdowns to hide');
                        $allModules
                            .not($module)
                            .has(selector.menu + '.' + className.visible)
                            .dropdown('hide')
                        ;
                    },

                    hideMenu: function() {
                        module.verbose('Hiding menu  instantaneously');
                        module.remove.active();
                        module.remove.visible();
                        $menu.transition('hide');
                    },

                    hideSubMenus: function() {
                        var
                            $subMenus = $menu.children(selector.item).find(selector.menu)
                        ;
                        module.verbose('Hiding sub menus', $subMenus);
                        $subMenus.transition('hide');
                    },

                    bind: {
                        events: function() {
                            if(hasTouch) {
                                module.bind.touchEvents();
                            }
                            module.bind.keyboardEvents();
                            module.bind.inputEvents();
                            module.bind.mouseEvents();
                        },
                        touchEvents: function() {
                            module.debug('Touch device detected binding additional touch events');
                            if( module.is.searchSelection() ) {
                                // do nothing special yet
                            }
                            else if( module.is.single() ) {
                                $module
                                    .on('touchstart' + eventNamespace, module.event.test.toggle)
                                ;
                            }
                            $menu
                                .on('touchstart' + eventNamespace, selector.item, module.event.item.mouseenter)
                            ;
                        },
                        keyboardEvents: function() {
                            module.verbose('Binding keyboard events');
                            $module
                                .on('keydown' + eventNamespace, module.event.keydown)
                            ;
                            if( module.has.search() ) {
                                $module
                                    .on(module.get.inputEvent() + eventNamespace, selector.search, module.event.input)
                                ;
                            }
                            if( module.is.multiple() ) {
                                $document
                                    .on('keydown' + elementNamespace, module.event.document.keydown)
                                ;
                            }
                        },
                        inputEvents: function() {
                            module.verbose('Binding input change events');
                            $module
                                .on('change' + eventNamespace, selector.input, module.event.change)
                            ;
                        },
                        mouseEvents: function() {
                            module.verbose('Binding mouse events');
                            if(module.is.multiple()) {
                                $module
                                    .on('click'   + eventNamespace, selector.label,  module.event.label.click)
                                    .on('click'   + eventNamespace, selector.remove, module.event.remove.click)
                                ;
                            }
                            if( module.is.searchSelection() ) {
                                $module
                                    .on('mousedown' + eventNamespace, module.event.mousedown)
                                    .on('mouseup'   + eventNamespace, module.event.mouseup)
                                    .on('mousedown' + eventNamespace, selector.menu,   module.event.menu.mousedown)
                                    .on('mouseup'   + eventNamespace, selector.menu,   module.event.menu.mouseup)
                                    .on('click'     + eventNamespace, selector.icon,   module.event.icon.click)
                                    .on('focus'     + eventNamespace, selector.search, module.event.search.focus)
                                    .on('click'     + eventNamespace, selector.search, module.event.search.focus)
                                    .on('blur'      + eventNamespace, selector.search, module.event.search.blur)
                                    .on('click'     + eventNamespace, selector.text,   module.event.text.focus)
                                ;
                                if(module.is.multiple()) {
                                    $module
                                        .on('click' + eventNamespace, module.event.click)
                                    ;
                                }
                            }
                            else {
                                if(settings.on == 'click') {
                                    $module
                                        .on('click' + eventNamespace, selector.icon, module.event.icon.click)
                                        .on('click' + eventNamespace, module.event.test.toggle)
                                    ;
                                }
                                else if(settings.on == 'hover') {
                                    $module
                                        .on('mouseenter' + eventNamespace, module.delay.show)
                                        .on('mouseleave' + eventNamespace, module.delay.hide)
                                    ;
                                }
                                else {
                                    $module
                                        .on(settings.on + eventNamespace, module.toggle)
                                    ;
                                }
                                $module
                                    .on('mousedown' + eventNamespace, module.event.mousedown)
                                    .on('mouseup'   + eventNamespace, module.event.mouseup)
                                    .on('focus'     + eventNamespace, module.event.focus)
                                    .on('blur'      + eventNamespace, module.event.blur)
                                ;
                            }
                            $menu
                                .on('mouseenter' + eventNamespace, selector.item, module.event.item.mouseenter)
                                .on('mouseleave' + eventNamespace, selector.item, module.event.item.mouseleave)
                                .on('click'      + eventNamespace, selector.item, module.event.item.click)
                            ;
                        },
                        intent: function() {
                            module.verbose('Binding hide intent event to document');
                            if(hasTouch) {
                                $document
                                    .on('touchstart' + elementNamespace, module.event.test.touch)
                                    .on('touchmove'  + elementNamespace, module.event.test.touch)
                                ;
                            }
                            $document
                                .on('click' + elementNamespace, module.event.test.hide)
                            ;
                        }
                    },

                    unbind: {
                        intent: function() {
                            module.verbose('Removing hide intent event from document');
                            if(hasTouch) {
                                $document
                                    .off('touchstart' + elementNamespace)
                                    .off('touchmove' + elementNamespace)
                                ;
                            }
                            $document
                                .off('click' + elementNamespace)
                            ;
                        }
                    },

                    filter: function(query) {
                        var
                            searchTerm = (query !== undefined)
                                ? query
                                : module.get.query(),
                            afterFiltered = function() {
                                if(module.is.multiple()) {
                                    module.filterActive();
                                }
                                module.select.firstUnfiltered();
                                if( module.has.allResultsFiltered() ) {
                                    if( settings.onNoResults.call(element, searchTerm) ) {
                                        if(settings.allowAdditions) {
                                            if(settings.hideAdditions) {
                                                module.verbose('User addition with no menu, setting empty style');
                                                module.set.empty();
                                                module.hideMenu();
                                            }
                                        }
                                        else {
                                            module.verbose('All items filtered, showing message', searchTerm);
                                            module.add.message(message.noResults);
                                        }
                                    }
                                    else {
                                        module.verbose('All items filtered, hiding dropdown', searchTerm);
                                        module.hideMenu();
                                    }
                                }
                                else {
                                    module.remove.empty();
                                    module.remove.message();
                                }
                                if(settings.allowAdditions) {
                                    module.add.userSuggestion(query);
                                }
                                if(module.is.searchSelection() && module.can.show() && module.is.focusedOnSearch() ) {
                                    module.show();
                                }
                            }
                        ;
                        if(settings.useLabels && module.has.maxSelections()) {
                            return;
                        }
                        if(settings.apiSettings) {
                            if( module.can.useAPI() ) {
                                module.queryRemote(searchTerm, function() {
                                    afterFiltered();
                                });
                            }
                            else {
                                module.error(error.noAPI);
                            }
                        }
                        else {
                            module.filterItems(searchTerm);
                            afterFiltered();
                        }
                    },

                    queryRemote: function(query, callback) {
                        var
                            apiSettings = {
                                errorDuration : false,
                                cache         : 'local',
                                throttle      : settings.throttle,
                                urlData       : {
                                    query: query
                                },
                                onError: function() {
                                    module.add.message(message.serverError);
                                    callback();
                                },
                                onFailure: function() {
                                    module.add.message(message.serverError);
                                    callback();
                                },
                                onSuccess : function(response) {
                                    module.remove.message();
                                    module.setup.menu({
                                        values: response[fields.remoteValues]
                                    });
                                    callback();
                                }
                            }
                        ;
                        if( !$module.api('get request') ) {
                            module.setup.api();
                        }
                        apiSettings = $.extend(true, {}, apiSettings, settings.apiSettings);
                        $module
                            .api('setting', apiSettings)
                            .api('query')
                        ;
                    },

                    filterItems: function(query) {
                        var
                            searchTerm = (query !== undefined)
                                ? query
                                : module.get.query(),
                            results          =  null,
                            escapedTerm      = module.escape.regExp(searchTerm),
                            beginsWithRegExp = new RegExp('^' + escapedTerm, 'igm')
                        ;
                        // avoid loop if we're matching nothing
                        if( module.has.query() ) {
                            results = [];

                            module.verbose('Searching for matching values', searchTerm);
                            $item
                                .each(function(){
                                    var
                                        $choice = $(this),
                                        text,
                                        value
                                    ;
                                    if(settings.match == 'both' || settings.match == 'text') {
                                        text = String(module.get.choiceText($choice, false));
                                        if(text.search(beginsWithRegExp) !== -1) {
                                            results.push(this);
                                            return true;
                                        }
                                        else if (settings.fullTextSearch === 'exact' && module.exactSearch(searchTerm, text)) {
                                            results.push(this);
                                            return true;
                                        }
                                        else if (settings.fullTextSearch === true && module.fuzzySearch(searchTerm, text)) {
                                            results.push(this);
                                            return true;
                                        }
                                    }
                                    if(settings.match == 'both' || settings.match == 'value') {
                                        value = String(module.get.choiceValue($choice, text));

                                        if(value.search(beginsWithRegExp) !== -1) {
                                            results.push(this);
                                            return true;
                                        }
                                        else if(settings.fullTextSearch && module.fuzzySearch(searchTerm, value)) {
                                            results.push(this);
                                            return true;
                                        }
                                    }
                                })
                            ;
                        }
                        module.debug('Showing only matched items', searchTerm);
                        module.remove.filteredItem();
                        if(results) {
                            $item
                                .not(results)
                                .addClass(className.filtered)
                            ;
                        }
                    },

                    fuzzySearch: function(query, term) {
                        var
                            termLength  = term.length,
                            queryLength = query.length
                        ;
                        query = query.toLowerCase();
                        term  = term.toLowerCase();
                        if(queryLength > termLength) {
                            return false;
                        }
                        if(queryLength === termLength) {
                            return (query === term);
                        }
                        search: for (var characterIndex = 0, nextCharacterIndex = 0; characterIndex < queryLength; characterIndex++) {
                            var
                                queryCharacter = query.charCodeAt(characterIndex)
                            ;
                            while(nextCharacterIndex < termLength) {
                                if(term.charCodeAt(nextCharacterIndex++) === queryCharacter) {
                                    continue search;
                                }
                            }
                            return false;
                        }
                        return true;
                    },
                    exactSearch: function (query, term) {
                        query = query.toLowerCase();
                        term  = term.toLowerCase();
                        if(term.indexOf(query) > -1) {
                            return true;
                        }
                        return false;
                    },
                    filterActive: function() {
                        if(settings.useLabels) {
                            $item.filter('.' + className.active)
                                .addClass(className.filtered)
                            ;
                        }
                    },

                    focusSearch: function(skipHandler) {
                        if( module.has.search() && !module.is.focusedOnSearch() ) {
                            if(skipHandler) {
                                $module.off('focus' + eventNamespace, selector.search);
                                $search.focus();
                                $module.on('focus'  + eventNamespace, selector.search, module.event.search.focus);
                            }
                            else {
                                $search.focus();
                            }
                        }
                    },

                    forceSelection: function() {
                        var
                            $currentlySelected = $item.not(className.filtered).filter('.' + className.selected).eq(0),
                            $activeItem        = $item.not(className.filtered).filter('.' + className.active).eq(0),
                            $selectedItem      = ($currentlySelected.length > 0)
                                ? $currentlySelected
                                : $activeItem,
                            hasSelected = ($selectedItem.length > 0)
                        ;
                        if(hasSelected) {
                            module.debug('Forcing partial selection to selected item', $selectedItem);
                            module.event.item.click.call($selectedItem, {}, true);
                            return;
                        }
                        else {
                            if(settings.allowAdditions) {
                                module.set.selected(module.get.query());
                                module.remove.searchTerm();
                            }
                            else {
                                module.remove.searchTerm();
                            }
                        }
                    },

                    event: {
                        change: function() {
                            if(!internalChange) {
                                module.debug('Input changed, updating selection');
                                module.set.selected();
                            }
                        },
                        focus: function() {
                            if(settings.showOnFocus && !activated && module.is.hidden() && !pageLostFocus) {
                                module.show();
                            }
                        },
                        blur: function(event) {
                            pageLostFocus = (document.activeElement === this);
                            if(!activated && !pageLostFocus) {
                                module.remove.activeLabel();
                                module.hide();
                            }
                        },
                        mousedown: function() {
                            if(module.is.searchSelection()) {
                                // prevent menu hiding on immediate re-focus
                                willRefocus = true;
                            }
                            else {
                                // prevents focus callback from occurring on mousedown
                                activated = true;
                            }
                        },
                        mouseup: function() {
                            if(module.is.searchSelection()) {
                                // prevent menu hiding on immediate re-focus
                                willRefocus = false;
                            }
                            else {
                                activated = false;
                            }
                        },
                        click: function(event) {
                            var
                                $target = $(event.target)
                            ;
                            // focus search
                            if($target.is($module)) {
                                if(!module.is.focusedOnSearch()) {
                                    module.focusSearch();
                                }
                                else {
                                    module.show();
                                }
                            }
                        },
                        search: {
                            focus: function() {
                                activated = true;
                                if(module.is.multiple()) {
                                    module.remove.activeLabel();
                                }
                                if(settings.showOnFocus) {
                                    module.search();
                                }
                            },
                            blur: function(event) {
                                pageLostFocus = (document.activeElement === this);
                                if(!willRefocus) {
                                    if(!itemActivated && !pageLostFocus) {
                                        if(settings.forceSelection) {
                                            module.forceSelection();
                                        }
                                        module.hide();
                                    }
                                }
                                willRefocus = false;
                            }
                        },
                        icon: {
                            click: function(event) {
                                module.toggle();
                            }
                        },
                        text: {
                            focus: function(event) {
                                activated = true;
                                module.focusSearch();
                            }
                        },
                        input: function(event) {
                            if(module.is.multiple() || module.is.searchSelection()) {
                                module.set.filtered();
                            }
                            clearTimeout(module.timer);
                            module.timer = setTimeout(module.search, settings.delay.search);
                        },
                        label: {
                            click: function(event) {
                                var
                                    $label        = $(this),
                                    $labels       = $module.find(selector.label),
                                    $activeLabels = $labels.filter('.' + className.active),
                                    $nextActive   = $label.nextAll('.' + className.active),
                                    $prevActive   = $label.prevAll('.' + className.active),
                                    $range = ($nextActive.length > 0)
                                        ? $label.nextUntil($nextActive).add($activeLabels).add($label)
                                        : $label.prevUntil($prevActive).add($activeLabels).add($label)
                                ;
                                if(event.shiftKey) {
                                    $activeLabels.removeClass(className.active);
                                    $range.addClass(className.active);
                                }
                                else if(event.ctrlKey) {
                                    $label.toggleClass(className.active);
                                }
                                else {
                                    $activeLabels.removeClass(className.active);
                                    $label.addClass(className.active);
                                }
                                settings.onLabelSelect.apply(this, $labels.filter('.' + className.active));
                            }
                        },
                        remove: {
                            click: function() {
                                var
                                    $label = $(this).parent()
                                ;
                                if( $label.hasClass(className.active) ) {
                                    // remove all selected labels
                                    module.remove.activeLabels();
                                }
                                else {
                                    // remove this label only
                                    module.remove.activeLabels( $label );
                                }
                            }
                        },
                        test: {
                            toggle: function(event) {
                                var
                                    toggleBehavior = (module.is.multiple())
                                        ? module.show
                                        : module.toggle
                                ;
                                if(module.is.bubbledLabelClick(event) || module.is.bubbledIconClick(event)) {
                                    return;
                                }
                                if( module.determine.eventOnElement(event, toggleBehavior) ) {
                                    event.preventDefault();
                                }
                            },
                            touch: function(event) {
                                module.determine.eventOnElement(event, function() {
                                    if(event.type == 'touchstart') {
                                        module.timer = setTimeout(function() {
                                            module.hide();
                                        }, settings.delay.touch);
                                    }
                                    else if(event.type == 'touchmove') {
                                        clearTimeout(module.timer);
                                    }
                                });
                                event.stopPropagation();
                            },
                            hide: function(event) {
                                module.determine.eventInModule(event, module.hide);
                            }
                        },
                        select: {
                            mutation: function(mutations) {
                                module.debug('<select> modified, recreating menu');
                                module.setup.select();
                            }
                        },
                        menu: {
                            mutation: function(mutations) {
                                var
                                    mutation   = mutations[0],
                                    $addedNode = mutation.addedNodes
                                        ? $(mutation.addedNodes[0])
                                        : $(false),
                                    $removedNode = mutation.removedNodes
                                        ? $(mutation.removedNodes[0])
                                        : $(false),
                                    $changedNodes  = $addedNode.add($removedNode),
                                    isUserAddition = $changedNodes.is(selector.addition) || $changedNodes.closest(selector.addition).length > 0,
                                    isMessage      = $changedNodes.is(selector.message)  || $changedNodes.closest(selector.message).length > 0
                                ;
                                if(isUserAddition || isMessage) {
                                    module.debug('Updating item selector cache');
                                    module.refreshItems();
                                }
                                else {
                                    module.debug('Menu modified, updating selector cache');
                                    module.refresh();
                                }
                            },
                            mousedown: function() {
                                itemActivated = true;
                            },
                            mouseup: function() {
                                itemActivated = false;
                            }
                        },
                        item: {
                            mouseenter: function(event) {
                                var
                                    $target        = $(event.target),
                                    $item          = $(this),
                                    $subMenu       = $item.children(selector.menu),
                                    $otherMenus    = $item.siblings(selector.item).children(selector.menu),
                                    hasSubMenu     = ($subMenu.length > 0),
                                    isBubbledEvent = ($subMenu.find($target).length > 0)
                                ;
                                if( !isBubbledEvent && hasSubMenu ) {
                                    clearTimeout(module.itemTimer);
                                    module.itemTimer = setTimeout(function() {
                                        module.verbose('Showing sub-menu', $subMenu);
                                        $.each($otherMenus, function() {
                                            module.animate.hide(false, $(this));
                                        });
                                        module.animate.show(false, $subMenu);
                                    }, settings.delay.show);
                                    event.preventDefault();
                                }
                            },
                            mouseleave: function(event) {
                                var
                                    $subMenu = $(this).children(selector.menu)
                                ;
                                if($subMenu.length > 0) {
                                    clearTimeout(module.itemTimer);
                                    module.itemTimer = setTimeout(function() {
                                        module.verbose('Hiding sub-menu', $subMenu);
                                        module.animate.hide(false, $subMenu);
                                    }, settings.delay.hide);
                                }
                            },
                            click: function (event, skipRefocus) {
                                var
                                    $choice        = $(this),
                                    $target        = (event)
                                        ? $(event.target)
                                        : $(''),
                                    $subMenu       = $choice.find(selector.menu),
                                    text           = module.get.choiceText($choice),
                                    value          = module.get.choiceValue($choice, text),
                                    hasSubMenu     = ($subMenu.length > 0),
                                    isBubbledEvent = ($subMenu.find($target).length > 0)
                                ;
                                if(!isBubbledEvent && (!hasSubMenu || settings.allowCategorySelection)) {
                                    if(module.is.searchSelection()) {
                                        if(settings.allowAdditions) {
                                            module.remove.userAddition();
                                        }
                                        module.remove.searchTerm();
                                        if(!module.is.focusedOnSearch() && !(skipRefocus == true)) {
                                            module.focusSearch(true);
                                        }
                                    }
                                    if(!settings.useLabels) {
                                        module.remove.filteredItem();
                                        module.set.scrollPosition($choice);
                                    }
                                    module.determine.selectAction.call(this, text, value);
                                }
                            }
                        },

                        document: {
                            // label selection should occur even when element has no focus
                            keydown: function(event) {
                                var
                                    pressedKey    = event.which,
                                    isShortcutKey = module.is.inObject(pressedKey, keys)
                                ;
                                if(isShortcutKey) {
                                    var
                                        $label            = $module.find(selector.label),
                                        $activeLabel      = $label.filter('.' + className.active),
                                        activeValue       = $activeLabel.data(metadata.value),
                                        labelIndex        = $label.index($activeLabel),
                                        labelCount        = $label.length,
                                        hasActiveLabel    = ($activeLabel.length > 0),
                                        hasMultipleActive = ($activeLabel.length > 1),
                                        isFirstLabel      = (labelIndex === 0),
                                        isLastLabel       = (labelIndex + 1 == labelCount),
                                        isSearch          = module.is.searchSelection(),
                                        isFocusedOnSearch = module.is.focusedOnSearch(),
                                        isFocused         = module.is.focused(),
                                        caretAtStart      = (isFocusedOnSearch && module.get.caretPosition() === 0),
                                        $nextLabel
                                    ;
                                    if(isSearch && !hasActiveLabel && !isFocusedOnSearch) {
                                        return;
                                    }

                                    if(pressedKey == keys.leftArrow) {
                                        // activate previous label
                                        if((isFocused || caretAtStart) && !hasActiveLabel) {
                                            module.verbose('Selecting previous label');
                                            $label.last().addClass(className.active);
                                        }
                                        else if(hasActiveLabel) {
                                            if(!event.shiftKey) {
                                                module.verbose('Selecting previous label');
                                                $label.removeClass(className.active);
                                            }
                                            else {
                                                module.verbose('Adding previous label to selection');
                                            }
                                            if(isFirstLabel && !hasMultipleActive) {
                                                $activeLabel.addClass(className.active);
                                            }
                                            else {
                                                $activeLabel.prev(selector.siblingLabel)
                                                    .addClass(className.active)
                                                    .end()
                                                ;
                                            }
                                            event.preventDefault();
                                        }
                                    }
                                    else if(pressedKey == keys.rightArrow) {
                                        // activate first label
                                        if(isFocused && !hasActiveLabel) {
                                            $label.first().addClass(className.active);
                                        }
                                        // activate next label
                                        if(hasActiveLabel) {
                                            if(!event.shiftKey) {
                                                module.verbose('Selecting next label');
                                                $label.removeClass(className.active);
                                            }
                                            else {
                                                module.verbose('Adding next label to selection');
                                            }
                                            if(isLastLabel) {
                                                if(isSearch) {
                                                    if(!isFocusedOnSearch) {
                                                        module.focusSearch();
                                                    }
                                                    else {
                                                        $label.removeClass(className.active);
                                                    }
                                                }
                                                else if(hasMultipleActive) {
                                                    $activeLabel.next(selector.siblingLabel).addClass(className.active);
                                                }
                                                else {
                                                    $activeLabel.addClass(className.active);
                                                }
                                            }
                                            else {
                                                $activeLabel.next(selector.siblingLabel).addClass(className.active);
                                            }
                                            event.preventDefault();
                                        }
                                    }
                                    else if(pressedKey == keys.deleteKey || pressedKey == keys.backspace) {
                                        if(hasActiveLabel) {
                                            module.verbose('Removing active labels');
                                            if(isLastLabel) {
                                                if(isSearch && !isFocusedOnSearch) {
                                                    module.focusSearch();
                                                }
                                            }
                                            $activeLabel.last().next(selector.siblingLabel).addClass(className.active);
                                            module.remove.activeLabels($activeLabel);
                                            event.preventDefault();
                                        }
                                        else if(caretAtStart && !hasActiveLabel && pressedKey == keys.backspace) {
                                            module.verbose('Removing last label on input backspace');
                                            $activeLabel = $label.last().addClass(className.active);
                                            module.remove.activeLabels($activeLabel);
                                        }
                                    }
                                    else {
                                        $activeLabel.removeClass(className.active);
                                    }
                                }
                            }
                        },

                        keydown: function(event) {
                            var
                                pressedKey    = event.which,
                                isShortcutKey = module.is.inObject(pressedKey, keys)
                            ;
                            if(isShortcutKey) {
                                var
                                    $currentlySelected = $item.not(selector.unselectable).filter('.' + className.selected).eq(0),
                                    $activeItem        = $menu.children('.' + className.active).eq(0),
                                    $selectedItem      = ($currentlySelected.length > 0)
                                        ? $currentlySelected
                                        : $activeItem,
                                    $visibleItems = ($selectedItem.length > 0)
                                        ? $selectedItem.siblings(':not(.' + className.filtered +')').addBack()
                                        : $menu.children(':not(.' + className.filtered +')'),
                                    $subMenu              = $selectedItem.children(selector.menu),
                                    $parentMenu           = $selectedItem.closest(selector.menu),
                                    inVisibleMenu         = ($parentMenu.hasClass(className.visible) || $parentMenu.hasClass(className.animating) || $parentMenu.parent(selector.menu).length > 0),
                                    hasSubMenu            = ($subMenu.length> 0),
                                    hasSelectedItem       = ($selectedItem.length > 0),
                                    selectedIsSelectable  = ($selectedItem.not(selector.unselectable).length > 0),
                                    delimiterPressed      = (pressedKey == keys.delimiter && settings.allowAdditions && module.is.multiple()),
                                    isAdditionWithoutMenu = (settings.allowAdditions && settings.hideAdditions && (pressedKey == keys.enter || delimiterPressed) && selectedIsSelectable),
                                    $nextItem,
                                    isSubMenuItem,
                                    newIndex
                                ;
                                // allow selection with menu closed
                                if(isAdditionWithoutMenu) {
                                    module.verbose('Selecting item from keyboard shortcut', $selectedItem);
                                    module.event.item.click.call($selectedItem, event);
                                    if(module.is.searchSelection()) {
                                        module.remove.searchTerm();
                                    }
                                }

                                // visible menu keyboard shortcuts
                                if( module.is.visible() ) {

                                    // enter (select or open sub-menu)
                                    if(pressedKey == keys.enter || delimiterPressed) {
                                        if(pressedKey == keys.enter && hasSelectedItem && hasSubMenu && !settings.allowCategorySelection) {
                                            module.verbose('Pressed enter on unselectable category, opening sub menu');
                                            pressedKey = keys.rightArrow;
                                        }
                                        else if(selectedIsSelectable) {
                                            module.verbose('Selecting item from keyboard shortcut', $selectedItem);
                                            module.event.item.click.call($selectedItem, event);
                                            if(module.is.searchSelection()) {
                                                module.remove.searchTerm();
                                            }
                                        }
                                        event.preventDefault();
                                    }

                                    // sub-menu actions
                                    if(hasSelectedItem) {

                                        if(pressedKey == keys.leftArrow) {

                                            isSubMenuItem = ($parentMenu[0] !== $menu[0]);

                                            if(isSubMenuItem) {
                                                module.verbose('Left key pressed, closing sub-menu');
                                                module.animate.hide(false, $parentMenu);
                                                $selectedItem
                                                    .removeClass(className.selected)
                                                ;
                                                $parentMenu
                                                    .closest(selector.item)
                                                    .addClass(className.selected)
                                                ;
                                                event.preventDefault();
                                            }
                                        }

                                        // right arrow (show sub-menu)
                                        if(pressedKey == keys.rightArrow) {
                                            if(hasSubMenu) {
                                                module.verbose('Right key pressed, opening sub-menu');
                                                module.animate.show(false, $subMenu);
                                                $selectedItem
                                                    .removeClass(className.selected)
                                                ;
                                                $subMenu
                                                    .find(selector.item).eq(0)
                                                    .addClass(className.selected)
                                                ;
                                                event.preventDefault();
                                            }
                                        }
                                    }

                                    // up arrow (traverse menu up)
                                    if(pressedKey == keys.upArrow) {
                                        $nextItem = (hasSelectedItem && inVisibleMenu)
                                            ? $selectedItem.prevAll(selector.item + ':not(' + selector.unselectable + ')').eq(0)
                                            : $item.eq(0)
                                        ;
                                        if($visibleItems.index( $nextItem ) < 0) {
                                            module.verbose('Up key pressed but reached top of current menu');
                                            event.preventDefault();
                                            return;
                                        }
                                        else {
                                            module.verbose('Up key pressed, changing active item');
                                            $selectedItem
                                                .removeClass(className.selected)
                                            ;
                                            $nextItem
                                                .addClass(className.selected)
                                            ;
                                            module.set.scrollPosition($nextItem);
                                            if(settings.selectOnKeydown && module.is.single()) {
                                                module.set.selectedItem($nextItem);
                                            }
                                        }
                                        event.preventDefault();
                                    }

                                    // down arrow (traverse menu down)
                                    if(pressedKey == keys.downArrow) {
                                        $nextItem = (hasSelectedItem && inVisibleMenu)
                                            ? $nextItem = $selectedItem.nextAll(selector.item + ':not(' + selector.unselectable + ')').eq(0)
                                            : $item.eq(0)
                                        ;
                                        if($nextItem.length === 0) {
                                            module.verbose('Down key pressed but reached bottom of current menu');
                                            event.preventDefault();
                                            return;
                                        }
                                        else {
                                            module.verbose('Down key pressed, changing active item');
                                            $item
                                                .removeClass(className.selected)
                                            ;
                                            $nextItem
                                                .addClass(className.selected)
                                            ;
                                            module.set.scrollPosition($nextItem);
                                            if(settings.selectOnKeydown && module.is.single()) {
                                                module.set.selectedItem($nextItem);
                                            }
                                        }
                                        event.preventDefault();
                                    }

                                    // page down (show next page)
                                    if(pressedKey == keys.pageUp) {
                                        module.scrollPage('up');
                                        event.preventDefault();
                                    }
                                    if(pressedKey == keys.pageDown) {
                                        module.scrollPage('down');
                                        event.preventDefault();
                                    }

                                    // escape (close menu)
                                    if(pressedKey == keys.escape) {
                                        module.verbose('Escape key pressed, closing dropdown');
                                        module.hide();
                                    }

                                }
                                else {
                                    // delimiter key
                                    if(delimiterPressed) {
                                        event.preventDefault();
                                    }
                                    // down arrow (open menu)
                                    if(pressedKey == keys.downArrow && !module.is.visible()) {
                                        module.verbose('Down key pressed, showing dropdown');
                                        module.select.firstUnfiltered();
                                        module.show();
                                        event.preventDefault();
                                    }
                                }
                            }
                            else {
                                if( !module.has.search() ) {
                                    module.set.selectedLetter( String.fromCharCode(pressedKey) );
                                }
                            }
                        }
                    },

                    trigger: {
                        change: function() {
                            var
                                events       = document.createEvent('HTMLEvents'),
                                inputElement = $input[0]
                            ;
                            if(inputElement) {
                                module.verbose('Triggering native change event');
                                events.initEvent('change', true, false);
                                inputElement.dispatchEvent(events);
                            }
                        }
                    },

                    determine: {
                        selectAction: function(text, value) {
                            module.verbose('Determining action', settings.action);
                            if( $.isFunction( module.action[settings.action] ) ) {
                                module.verbose('Triggering preset action', settings.action, text, value);
                                module.action[ settings.action ].call(element, text, value, this);
                            }
                            else if( $.isFunction(settings.action) ) {
                                module.verbose('Triggering user action', settings.action, text, value);
                                settings.action.call(element, text, value, this);
                            }
                            else {
                                module.error(error.action, settings.action);
                            }
                        },
                        eventInModule: function(event, callback) {
                            var
                                $target    = $(event.target),
                                inDocument = ($target.closest(document.documentElement).length > 0),
                                inModule   = ($target.closest($module).length > 0)
                            ;
                            callback = $.isFunction(callback)
                                ? callback
                                : function(){}
                            ;
                            if(inDocument && !inModule) {
                                module.verbose('Triggering event', callback);
                                callback();
                                return true;
                            }
                            else {
                                module.verbose('Event occurred in dropdown, canceling callback');
                                return false;
                            }
                        },
                        eventOnElement: function(event, callback) {
                            var
                                $target      = $(event.target),
                                $label       = $target.closest(selector.siblingLabel),
                                inVisibleDOM = document.body.contains(event.target),
                                notOnLabel   = ($module.find($label).length === 0),
                                notInMenu    = ($target.closest($menu).length === 0)
                            ;
                            callback = $.isFunction(callback)
                                ? callback
                                : function(){}
                            ;
                            if(inVisibleDOM && notOnLabel && notInMenu) {
                                module.verbose('Triggering event', callback);
                                callback();
                                return true;
                            }
                            else {
                                module.verbose('Event occurred in dropdown menu, canceling callback');
                                return false;
                            }
                        }
                    },

                    action: {

                        nothing: function() {},

                        activate: function(text, value, element) {
                            value = (value !== undefined)
                                ? value
                                : text
                            ;
                            if( module.can.activate( $(element) ) ) {
                                module.set.selected(value, $(element));
                                if(module.is.multiple() && !module.is.allFiltered()) {
                                    return;
                                }
                                else {
                                    module.hideAndClear();
                                }
                            }
                        },

                        select: function(text, value, element) {
                            value = (value !== undefined)
                                ? value
                                : text
                            ;
                            if( module.can.activate( $(element) ) ) {
                                module.set.value(value, $(element));
                                if(module.is.multiple() && !module.is.allFiltered()) {
                                    return;
                                }
                                else {
                                    module.hideAndClear();
                                }
                            }
                        },

                        combo: function(text, value, element) {
                            value = (value !== undefined)
                                ? value
                                : text
                            ;
                            module.set.selected(value, $(element));
                            module.hideAndClear();
                        },

                        hide: function(text, value, element) {
                            module.set.value(value, text);
                            module.hideAndClear();
                        }

                    },

                    get: {
                        id: function() {
                            return id;
                        },
                        defaultText: function() {
                            return $module.data(metadata.defaultText);
                        },
                        defaultValue: function() {
                            return $module.data(metadata.defaultValue);
                        },
                        placeholderText: function() {
                            return $module.data(metadata.placeholderText) || '';
                        },
                        text: function() {
                            return $text.text();
                        },
                        query: function() {
                            return $.trim($search.val());
                        },
                        searchWidth: function(value) {
                            value = (value !== undefined)
                                ? value
                                : $search.val()
                            ;
                            $sizer.text(value);
                            // prevent rounding issues
                            return Math.ceil( $sizer.width() + 1);
                        },
                        selectionCount: function() {
                            var
                                values = module.get.values(),
                                count
                            ;
                            count = ( module.is.multiple() )
                                ? $.isArray(values)
                                    ? values.length
                                    : 0
                                : (module.get.value() !== '')
                                    ? 1
                                    : 0
                            ;
                            return count;
                        },
                        transition: function($subMenu) {
                            return (settings.transition == 'auto')
                                ? module.is.upward($subMenu)
                                    ? 'slide up'
                                    : 'slide down'
                                : settings.transition
                                ;
                        },
                        userValues: function() {
                            var
                                values = module.get.values()
                            ;
                            if(!values) {
                                return false;
                            }
                            values = $.isArray(values)
                                ? values
                                : [values]
                            ;
                            return $.grep(values, function(value) {
                                return (module.get.item(value) === false);
                            });
                        },
                        uniqueArray: function(array) {
                            return $.grep(array, function (value, index) {
                                return $.inArray(value, array) === index;
                            });
                        },
                        caretPosition: function() {
                            var
                                input = $search.get(0),
                                range,
                                rangeLength
                            ;
                            if('selectionStart' in input) {
                                return input.selectionStart;
                            }
                            else if (document.selection) {
                                input.focus();
                                range       = document.selection.createRange();
                                rangeLength = range.text.length;
                                range.moveStart('character', -input.value.length);
                                return range.text.length - rangeLength;
                            }
                        },
                        value: function() {
                            var
                                value = ($input.length > 0)
                                    ? $input.val()
                                    : $module.data(metadata.value),
                                isEmptyMultiselect = ($.isArray(value) && value.length === 1 && value[0] === '')
                            ;
                            // prevents placeholder element from being selected when multiple
                            return (value === undefined || isEmptyMultiselect)
                                ? ''
                                : value
                                ;
                        },
                        values: function() {
                            var
                                value = module.get.value()
                            ;
                            if(value === '') {
                                return '';
                            }
                            return ( !module.has.selectInput() && module.is.multiple() )
                                ? (typeof value == 'string') // delimited string
                                    ? value.split(settings.delimiter)
                                    : ''
                                : value
                                ;
                        },
                        remoteValues: function() {
                            var
                                values = module.get.values(),
                                remoteValues = false
                            ;
                            if(values) {
                                if(typeof values == 'string') {
                                    values = [values];
                                }
                                $.each(values, function(index, value) {
                                    var
                                        name = module.read.remoteData(value)
                                    ;
                                    module.verbose('Restoring value from session data', name, value);
                                    if(name) {
                                        if(!remoteValues) {
                                            remoteValues = {};
                                        }
                                        remoteValues[value] = name;
                                    }
                                });
                            }
                            return remoteValues;
                        },
                        choiceText: function($choice, preserveHTML) {
                            preserveHTML = (preserveHTML !== undefined)
                                ? preserveHTML
                                : settings.preserveHTML
                            ;
                            if($choice) {
                                if($choice.find(selector.menu).length > 0) {
                                    module.verbose('Retrieving text of element with sub-menu');
                                    $choice = $choice.clone();
                                    $choice.find(selector.menu).remove();
                                    $choice.find(selector.menuIcon).remove();
                                }
                                return ($choice.data(metadata.text) !== undefined)
                                    ? $choice.data(metadata.text)
                                    : (preserveHTML)
                                        ? $.trim($choice.html())
                                        : $.trim($choice.text())
                                    ;
                            }
                        },
                        choiceValue: function($choice, choiceText) {
                            choiceText = choiceText || module.get.choiceText($choice);
                            if(!$choice) {
                                return false;
                            }
                            return ($choice.data(metadata.value) !== undefined)
                                ? String( $choice.data(metadata.value) )
                                : (typeof choiceText === 'string')
                                    ? $.trim(choiceText.toLowerCase())
                                    : String(choiceText)
                                ;
                        },
                        inputEvent: function() {
                            var
                                input = $search[0]
                            ;
                            if(input) {
                                return (input.oninput !== undefined)
                                    ? 'input'
                                    : (input.onpropertychange !== undefined)
                                        ? 'propertychange'
                                        : 'keyup'
                                    ;
                            }
                            return false;
                        },
                        selectValues: function() {
                            var
                                select = {}
                            ;
                            select.values = [];
                            $module
                                .find('option')
                                .each(function() {
                                    var
                                        $option  = $(this),
                                        name     = $option.html(),
                                        disabled = $option.attr('disabled'),
                                        value    = ( $option.attr('value') !== undefined )
                                            ? $option.attr('value')
                                            : name
                                    ;
                                    if(settings.placeholder === 'auto' && value === '') {
                                        select.placeholder = name;
                                    }
                                    else {
                                        select.values.push({
                                            name     : name,
                                            value    : value,
                                            disabled : disabled
                                        });
                                    }
                                })
                            ;
                            if(settings.placeholder && settings.placeholder !== 'auto') {
                                module.debug('Setting placeholder value to', settings.placeholder);
                                select.placeholder = settings.placeholder;
                            }
                            if(settings.sortSelect) {
                                select.values.sort(function(a, b) {
                                    return (a.name > b.name)
                                        ? 1
                                        : -1
                                        ;
                                });
                                module.debug('Retrieved and sorted values from select', select);
                            }
                            else {
                                module.debug('Retrieved values from select', select);
                            }
                            return select;
                        },
                        activeItem: function() {
                            return $item.filter('.'  + className.active);
                        },
                        selectedItem: function() {
                            var
                                $selectedItem = $item.not(selector.unselectable).filter('.'  + className.selected)
                            ;
                            return ($selectedItem.length > 0)
                                ? $selectedItem
                                : $item.eq(0)
                                ;
                        },
                        itemWithAdditions: function(value) {
                            var
                                $items       = module.get.item(value),
                                $userItems   = module.create.userChoice(value),
                                hasUserItems = ($userItems && $userItems.length > 0)
                            ;
                            if(hasUserItems) {
                                $items = ($items.length > 0)
                                    ? $items.add($userItems)
                                    : $userItems
                                ;
                            }
                            return $items;
                        },
                        item: function(value, strict) {
                            var
                                $selectedItem = false,
                                shouldSearch,
                                isMultiple
                            ;
                            value = (value !== undefined)
                                ? value
                                : ( module.get.values() !== undefined)
                                    ? module.get.values()
                                    : module.get.text()
                            ;
                            shouldSearch = (isMultiple)
                                ? (value.length > 0)
                                : (value !== undefined && value !== null)
                            ;
                            isMultiple = (module.is.multiple() && $.isArray(value));
                            strict     = (value === '' || value === 0)
                                ? true
                                : strict || false
                            ;
                            if(shouldSearch) {
                                $item
                                    .each(function() {
                                        var
                                            $choice       = $(this),
                                            optionText    = module.get.choiceText($choice),
                                            optionValue   = module.get.choiceValue($choice, optionText)
                                        ;
                                        // safe early exit
                                        if(optionValue === null || optionValue === undefined) {
                                            return;
                                        }
                                        if(isMultiple) {
                                            if($.inArray( String(optionValue), value) !== -1 || $.inArray(optionText, value) !== -1) {
                                                $selectedItem = ($selectedItem)
                                                    ? $selectedItem.add($choice)
                                                    : $choice
                                                ;
                                            }
                                        }
                                        else if(strict) {
                                            module.verbose('Ambiguous dropdown value using strict type check', $choice, value);
                                            if( optionValue === value || optionText === value) {
                                                $selectedItem = $choice;
                                                return true;
                                            }
                                        }
                                        else {
                                            if( String(optionValue) == String(value) || optionText == value) {
                                                module.verbose('Found select item by value', optionValue, value);
                                                $selectedItem = $choice;
                                                return true;
                                            }
                                        }
                                    })
                                ;
                            }
                            return $selectedItem;
                        }
                    },

                    check: {
                        maxSelections: function(selectionCount) {
                            if(settings.maxSelections) {
                                selectionCount = (selectionCount !== undefined)
                                    ? selectionCount
                                    : module.get.selectionCount()
                                ;
                                if(selectionCount >= settings.maxSelections) {
                                    module.debug('Maximum selection count reached');
                                    if(settings.useLabels) {
                                        $item.addClass(className.filtered);
                                        module.add.message(message.maxSelections);
                                    }
                                    return true;
                                }
                                else {
                                    module.verbose('No longer at maximum selection count');
                                    module.remove.message();
                                    module.remove.filteredItem();
                                    if(module.is.searchSelection()) {
                                        module.filterItems();
                                    }
                                    return false;
                                }
                            }
                            return true;
                        }
                    },

                    restore: {
                        defaults: function() {
                            module.clear();
                            module.restore.defaultText();
                            module.restore.defaultValue();
                        },
                        defaultText: function() {
                            var
                                defaultText     = module.get.defaultText(),
                                placeholderText = module.get.placeholderText
                            ;
                            if(defaultText === placeholderText) {
                                module.debug('Restoring default placeholder text', defaultText);
                                module.set.placeholderText(defaultText);
                            }
                            else {
                                module.debug('Restoring default text', defaultText);
                                module.set.text(defaultText);
                            }
                        },
                        placeholderText: function() {
                            module.set.placeholderText();
                        },
                        defaultValue: function() {
                            var
                                defaultValue = module.get.defaultValue()
                            ;
                            if(defaultValue !== undefined) {
                                module.debug('Restoring default value', defaultValue);
                                if(defaultValue !== '') {
                                    module.set.value(defaultValue);
                                    module.set.selected();
                                }
                                else {
                                    module.remove.activeItem();
                                    module.remove.selectedItem();
                                }
                            }
                        },
                        labels: function() {
                            if(settings.allowAdditions) {
                                if(!settings.useLabels) {
                                    module.error(error.labels);
                                    settings.useLabels = true;
                                }
                                module.debug('Restoring selected values');
                                module.create.userLabels();
                            }
                            module.check.maxSelections();
                        },
                        selected: function() {
                            module.restore.values();
                            if(module.is.multiple()) {
                                module.debug('Restoring previously selected values and labels');
                                module.restore.labels();
                            }
                            else {
                                module.debug('Restoring previously selected values');
                            }
                        },
                        values: function() {
                            // prevents callbacks from occurring on initial load
                            module.set.initialLoad();
                            if(settings.apiSettings && settings.saveRemoteData && module.get.remoteValues()) {
                                module.restore.remoteValues();
                            }
                            else {
                                module.set.selected();
                            }
                            module.remove.initialLoad();
                        },
                        remoteValues: function() {
                            var
                                values = module.get.remoteValues()
                            ;
                            module.debug('Recreating selected from session data', values);
                            if(values) {
                                if( module.is.single() ) {
                                    $.each(values, function(value, name) {
                                        module.set.text(name);
                                    });
                                }
                                else {
                                    $.each(values, function(value, name) {
                                        module.add.label(value, name);
                                    });
                                }
                            }
                        }
                    },

                    read: {
                        remoteData: function(value) {
                            var
                                name
                            ;
                            if(window.Storage === undefined) {
                                module.error(error.noStorage);
                                return;
                            }
                            name = sessionStorage.getItem(value);
                            return (name !== undefined)
                                ? name
                                : false
                                ;
                        }
                    },

                    save: {
                        defaults: function() {
                            module.save.defaultText();
                            module.save.placeholderText();
                            module.save.defaultValue();
                        },
                        defaultValue: function() {
                            var
                                value = module.get.value()
                            ;
                            module.verbose('Saving default value as', value);
                            $module.data(metadata.defaultValue, value);
                        },
                        defaultText: function() {
                            var
                                text = module.get.text()
                            ;
                            module.verbose('Saving default text as', text);
                            $module.data(metadata.defaultText, text);
                        },
                        placeholderText: function() {
                            var
                                text
                            ;
                            if(settings.placeholder !== false && $text.hasClass(className.placeholder)) {
                                text = module.get.text();
                                module.verbose('Saving placeholder text as', text);
                                $module.data(metadata.placeholderText, text);
                            }
                        },
                        remoteData: function(name, value) {
                            if(window.Storage === undefined) {
                                module.error(error.noStorage);
                                return;
                            }
                            module.verbose('Saving remote data to session storage', value, name);
                            sessionStorage.setItem(value, name);
                        }
                    },

                    clear: function() {
                        if(module.is.multiple() && settings.useLabels) {
                            module.remove.labels();
                        }
                        else {
                            module.remove.activeItem();
                            module.remove.selectedItem();
                        }
                        module.set.placeholderText();
                        module.clearValue();
                    },

                    clearValue: function() {
                        module.set.value('');
                    },

                    scrollPage: function(direction, $selectedItem) {
                        var
                            $currentItem  = $selectedItem || module.get.selectedItem(),
                            $menu         = $currentItem.closest(selector.menu),
                            menuHeight    = $menu.outerHeight(),
                            currentScroll = $menu.scrollTop(),
                            itemHeight    = $item.eq(0).outerHeight(),
                            itemsPerPage  = Math.floor(menuHeight / itemHeight),
                            maxScroll     = $menu.prop('scrollHeight'),
                            newScroll     = (direction == 'up')
                                ? currentScroll - (itemHeight * itemsPerPage)
                                : currentScroll + (itemHeight * itemsPerPage),
                            $selectableItem = $item.not(selector.unselectable),
                            isWithinRange,
                            $nextSelectedItem,
                            elementIndex
                        ;
                        elementIndex      = (direction == 'up')
                            ? $selectableItem.index($currentItem) - itemsPerPage
                            : $selectableItem.index($currentItem) + itemsPerPage
                        ;
                        isWithinRange = (direction == 'up')
                            ? (elementIndex >= 0)
                            : (elementIndex < $selectableItem.length)
                        ;
                        $nextSelectedItem = (isWithinRange)
                            ? $selectableItem.eq(elementIndex)
                            : (direction == 'up')
                                ? $selectableItem.first()
                                : $selectableItem.last()
                        ;
                        if($nextSelectedItem.length > 0) {
                            module.debug('Scrolling page', direction, $nextSelectedItem);
                            $currentItem
                                .removeClass(className.selected)
                            ;
                            $nextSelectedItem
                                .addClass(className.selected)
                            ;
                            if(settings.selectOnKeydown && module.is.single()) {
                                module.set.selectedItem($nextSelectedItem);
                            }
                            $menu
                                .scrollTop(newScroll)
                            ;
                        }
                    },

                    set: {
                        filtered: function() {
                            var
                                isMultiple       = module.is.multiple(),
                                isSearch         = module.is.searchSelection(),
                                isSearchMultiple = (isMultiple && isSearch),
                                searchValue      = (isSearch)
                                    ? module.get.query()
                                    : '',
                                hasSearchValue   = (typeof searchValue === 'string' && searchValue.length > 0),
                                searchWidth      = module.get.searchWidth(),
                                valueIsSet       = searchValue !== ''
                            ;
                            if(isMultiple && hasSearchValue) {
                                module.verbose('Adjusting input width', searchWidth, settings.glyphWidth);
                                $search.css('width', searchWidth);
                            }
                            if(hasSearchValue || (isSearchMultiple && valueIsSet)) {
                                module.verbose('Hiding placeholder text');
                                $text.addClass(className.filtered);
                            }
                            else if(!isMultiple || (isSearchMultiple && !valueIsSet)) {
                                module.verbose('Showing placeholder text');
                                $text.removeClass(className.filtered);
                            }
                        },
                        empty: function() {
                            $module.addClass(className.empty);
                        },
                        loading: function() {
                            $module.addClass(className.loading);
                        },
                        placeholderText: function(text) {
                            text = text || module.get.placeholderText();
                            module.debug('Setting placeholder text', text);
                            module.set.text(text);
                            $text.addClass(className.placeholder);
                        },
                        tabbable: function() {
                            if( module.has.search() ) {
                                module.debug('Added tabindex to searchable dropdown');
                                $search
                                    .val('')
                                    .attr('tabindex', 0)
                                ;
                                $menu
                                    .attr('tabindex', -1)
                                ;
                            }
                            else {
                                module.debug('Added tabindex to dropdown');
                                if( $module.attr('tabindex') === undefined) {
                                    $module
                                        .attr('tabindex', 0)
                                    ;
                                    $menu
                                        .attr('tabindex', -1)
                                    ;
                                }
                            }
                        },
                        initialLoad: function() {
                            module.verbose('Setting initial load');
                            initialLoad = true;
                        },
                        activeItem: function($item) {
                            if( settings.allowAdditions && $item.filter(selector.addition).length > 0 ) {
                                $item.addClass(className.filtered);
                            }
                            else {
                                $item.addClass(className.active);
                            }
                        },
                        partialSearch: function(text) {
                            var
                                length = module.get.query().length
                            ;
                            $search.val( text.substr(0 , length));
                        },
                        scrollPosition: function($item, forceScroll) {
                            var
                                edgeTolerance = 5,
                                $menu,
                                hasActive,
                                offset,
                                itemHeight,
                                itemOffset,
                                menuOffset,
                                menuScroll,
                                menuHeight,
                                abovePage,
                                belowPage
                            ;

                            $item       = $item || module.get.selectedItem();
                            $menu       = $item.closest(selector.menu);
                            hasActive   = ($item && $item.length > 0);
                            forceScroll = (forceScroll !== undefined)
                                ? forceScroll
                                : false
                            ;
                            if($item && $menu.length > 0 && hasActive) {
                                itemOffset = $item.position().top;

                                $menu.addClass(className.loading);
                                menuScroll = $menu.scrollTop();
                                menuOffset = $menu.offset().top;
                                itemOffset = $item.offset().top;
                                offset     = menuScroll - menuOffset + itemOffset;
                                if(!forceScroll) {
                                    menuHeight = $menu.height();
                                    belowPage  = menuScroll + menuHeight < (offset + edgeTolerance);
                                    abovePage  = ((offset - edgeTolerance) < menuScroll);
                                }
                                module.debug('Scrolling to active item', offset);
                                if(forceScroll || abovePage || belowPage) {
                                    $menu.scrollTop(offset);
                                }
                                $menu.removeClass(className.loading);
                            }
                        },
                        text: function(text) {
                            if(settings.action !== 'select') {
                                if(settings.action == 'combo') {
                                    module.debug('Changing combo button text', text, $combo);
                                    if(settings.preserveHTML) {
                                        $combo.html(text);
                                    }
                                    else {
                                        $combo.text(text);
                                    }
                                }
                                else {
                                    if(text !== module.get.placeholderText()) {
                                        $text.removeClass(className.placeholder);
                                    }
                                    module.debug('Changing text', text, $text);
                                    $text
                                        .removeClass(className.filtered)
                                    ;
                                    if(settings.preserveHTML) {
                                        $text.html(text);
                                    }
                                    else {
                                        $text.text(text);
                                    }
                                }
                            }
                        },
                        selectedItem: function($item) {
                            var
                                value = module.get.choiceValue($item),
                                text  = module.get.choiceText($item, false)
                            ;
                            module.debug('Setting user selection to item', $item);
                            module.remove.activeItem();
                            module.set.partialSearch(text);
                            module.set.activeItem($item);
                            module.set.selected(value, $item);
                            module.set.text(text);
                        },
                        selectedLetter: function(letter) {
                            var
                                $selectedItem         = $item.filter('.' + className.selected),
                                alreadySelectedLetter = $selectedItem.length > 0 && module.has.firstLetter($selectedItem, letter),
                                $nextValue            = false,
                                $nextItem
                            ;
                            // check next of same letter
                            if(alreadySelectedLetter) {
                                $nextItem = $selectedItem.nextAll($item).eq(0);
                                if( module.has.firstLetter($nextItem, letter) ) {
                                    $nextValue  = $nextItem;
                                }
                            }
                            // check all values
                            if(!$nextValue) {
                                $item
                                    .each(function(){
                                        if(module.has.firstLetter($(this), letter)) {
                                            $nextValue = $(this);
                                            return false;
                                        }
                                    })
                                ;
                            }
                            // set next value
                            if($nextValue) {
                                module.verbose('Scrolling to next value with letter', letter);
                                module.set.scrollPosition($nextValue);
                                $selectedItem.removeClass(className.selected);
                                $nextValue.addClass(className.selected);
                                if(settings.selectOnKeydown && module.is.single()) {
                                    module.set.selectedItem($nextValue);
                                }
                            }
                        },
                        direction: function($menu) {
                            if(settings.direction == 'auto') {
                                if(module.is.onScreen($menu)) {
                                    module.remove.upward($menu);
                                }
                                else {
                                    module.set.upward($menu);
                                }
                            }
                            else if(settings.direction == 'upward') {
                                module.set.upward($menu);
                            }
                        },
                        upward: function($menu) {
                            var $element = $menu || $module;
                            $element.addClass(className.upward);
                        },
                        value: function(value, text, $selected) {
                            var
                                escapedValue = module.escape.value(value),
                                hasInput     = ($input.length > 0),
                                isAddition   = !module.has.value(value),
                                currentValue = module.get.values(),
                                stringValue  = (value !== undefined)
                                    ? String(value)
                                    : value,
                                newValue
                            ;
                            if(hasInput) {
                                if(!settings.allowReselection && stringValue == currentValue) {
                                    module.verbose('Skipping value update already same value', value, currentValue);
                                    if(!module.is.initialLoad()) {
                                        return;
                                    }
                                }

                                if( module.is.single() && module.has.selectInput() && module.can.extendSelect() ) {
                                    module.debug('Adding user option', value);
                                    module.add.optionValue(value);
                                }
                                module.debug('Updating input value', escapedValue, currentValue);
                                internalChange = true;
                                $input
                                    .val(escapedValue)
                                ;
                                if(settings.fireOnInit === false && module.is.initialLoad()) {
                                    module.debug('Input native change event ignored on initial load');
                                }
                                else {
                                    module.trigger.change();
                                }
                                internalChange = false;
                            }
                            else {
                                module.verbose('Storing value in metadata', escapedValue, $input);
                                if(escapedValue !== currentValue) {
                                    $module.data(metadata.value, stringValue);
                                }
                            }
                            if(settings.fireOnInit === false && module.is.initialLoad()) {
                                module.verbose('No callback on initial load', settings.onChange);
                            }
                            else {
                                settings.onChange.call(element, value, text, $selected);
                            }
                        },
                        active: function() {
                            $module
                                .addClass(className.active)
                            ;
                        },
                        multiple: function() {
                            $module.addClass(className.multiple);
                        },
                        visible: function() {
                            $module.addClass(className.visible);
                        },
                        exactly: function(value, $selectedItem) {
                            module.debug('Setting selected to exact values');
                            module.clear();
                            module.set.selected(value, $selectedItem);
                        },
                        selected: function(value, $selectedItem) {
                            var
                                isMultiple = module.is.multiple(),
                                $userSelectedItem
                            ;
                            $selectedItem = (settings.allowAdditions)
                                ? $selectedItem || module.get.itemWithAdditions(value)
                                : $selectedItem || module.get.item(value)
                            ;
                            if(!$selectedItem) {
                                return;
                            }
                            module.debug('Setting selected menu item to', $selectedItem);
                            if(module.is.multiple()) {
                                module.remove.searchWidth();
                            }
                            if(module.is.single()) {
                                module.remove.activeItem();
                                module.remove.selectedItem();
                            }
                            else if(settings.useLabels) {
                                module.remove.selectedItem();
                            }
                            // select each item
                            $selectedItem
                                .each(function() {
                                    var
                                        $selected      = $(this),
                                        selectedText   = module.get.choiceText($selected),
                                        selectedValue  = module.get.choiceValue($selected, selectedText),

                                        isFiltered     = $selected.hasClass(className.filtered),
                                        isActive       = $selected.hasClass(className.active),
                                        isUserValue    = $selected.hasClass(className.addition),
                                        shouldAnimate  = (isMultiple && $selectedItem.length == 1)
                                    ;
                                    if(isMultiple) {
                                        if(!isActive || isUserValue) {
                                            if(settings.apiSettings && settings.saveRemoteData) {
                                                module.save.remoteData(selectedText, selectedValue);
                                            }
                                            if(settings.useLabels) {
                                                module.add.value(selectedValue, selectedText, $selected);
                                                module.add.label(selectedValue, selectedText, shouldAnimate);
                                                module.set.activeItem($selected);
                                                module.filterActive();
                                                module.select.nextAvailable($selectedItem);
                                            }
                                            else {
                                                module.add.value(selectedValue, selectedText, $selected);
                                                module.set.text(module.add.variables(message.count));
                                                module.set.activeItem($selected);
                                            }
                                        }
                                        else if(!isFiltered) {
                                            module.debug('Selected active value, removing label');
                                            module.remove.selected(selectedValue);
                                        }
                                    }
                                    else {
                                        if(settings.apiSettings && settings.saveRemoteData) {
                                            module.save.remoteData(selectedText, selectedValue);
                                        }
                                        module.set.text(selectedText);
                                        module.set.value(selectedValue, selectedText, $selected);
                                        $selected
                                            .addClass(className.active)
                                            .addClass(className.selected)
                                        ;
                                    }
                                })
                            ;
                        }
                    },

                    add: {
                        label: function(value, text, shouldAnimate) {
                            var
                                $next  = module.is.searchSelection()
                                    ? $search
                                    : $text,
                                escapedValue = module.escape.value(value),
                                $label
                            ;
                            $label =  $('<a />')
                                .addClass(className.label)
                                .attr('data-value', escapedValue)
                                .html(templates.label(escapedValue, text))
                            ;
                            $label = settings.onLabelCreate.call($label, escapedValue, text);

                            if(module.has.label(value)) {
                                module.debug('Label already exists, skipping', escapedValue);
                                return;
                            }
                            if(settings.label.variation) {
                                $label.addClass(settings.label.variation);
                            }
                            if(shouldAnimate === true) {
                                module.debug('Animating in label', $label);
                                $label
                                    .addClass(className.hidden)
                                    .insertBefore($next)
                                    .transition(settings.label.transition, settings.label.duration)
                                ;
                            }
                            else {
                                module.debug('Adding selection label', $label);
                                $label
                                    .insertBefore($next)
                                ;
                            }
                        },
                        message: function(message) {
                            var
                                $message = $menu.children(selector.message),
                                html     = settings.templates.message(module.add.variables(message))
                            ;
                            if($message.length > 0) {
                                $message
                                    .html(html)
                                ;
                            }
                            else {
                                $message = $('<div/>')
                                    .html(html)
                                    .addClass(className.message)
                                    .appendTo($menu)
                                ;
                            }
                        },
                        optionValue: function(value) {
                            var
                                escapedValue = module.escape.value(value),
                                $option      = $input.find('option[value="' + escapedValue + '"]'),
                                hasOption    = ($option.length > 0)
                            ;
                            if(hasOption) {
                                return;
                            }
                            // temporarily disconnect observer
                            module.disconnect.selectObserver();
                            if( module.is.single() ) {
                                module.verbose('Removing previous user addition');
                                $input.find('option.' + className.addition).remove();
                            }
                            $('<option/>')
                                .prop('value', escapedValue)
                                .addClass(className.addition)
                                .html(value)
                                .appendTo($input)
                            ;
                            module.verbose('Adding user addition as an <option>', value);
                            module.observe.select();
                        },
                        userSuggestion: function(value) {
                            var
                                $addition         = $menu.children(selector.addition),
                                $existingItem     = module.get.item(value),
                                alreadyHasValue   = $existingItem && $existingItem.not(selector.addition).length,
                                hasUserSuggestion = $addition.length > 0,
                                html
                            ;
                            if(settings.useLabels && module.has.maxSelections()) {
                                return;
                            }
                            if(value === '' || alreadyHasValue) {
                                $addition.remove();
                                return;
                            }
                            if(hasUserSuggestion) {
                                $addition
                                    .data(metadata.value, value)
                                    .data(metadata.text, value)
                                    .attr('data-' + metadata.value, value)
                                    .attr('data-' + metadata.text, value)
                                    .removeClass(className.filtered)
                                ;
                                if(!settings.hideAdditions) {
                                    html = settings.templates.addition( module.add.variables(message.addResult, value) );
                                    $addition
                                        .html(html)
                                    ;
                                }
                                module.verbose('Replacing user suggestion with new value', $addition);
                            }
                            else {
                                $addition = module.create.userChoice(value);
                                $addition
                                    .prependTo($menu)
                                ;
                                module.verbose('Adding item choice to menu corresponding with user choice addition', $addition);
                            }
                            if(!settings.hideAdditions || module.is.allFiltered()) {
                                $addition
                                    .addClass(className.selected)
                                    .siblings()
                                    .removeClass(className.selected)
                                ;
                            }
                            module.refreshItems();
                        },
                        variables: function(message, term) {
                            var
                                hasCount    = (message.search('{count}') !== -1),
                                hasMaxCount = (message.search('{maxCount}') !== -1),
                                hasTerm     = (message.search('{term}') !== -1),
                                values,
                                count,
                                query
                            ;
                            module.verbose('Adding templated variables to message', message);
                            if(hasCount) {
                                count  = module.get.selectionCount();
                                message = message.replace('{count}', count);
                            }
                            if(hasMaxCount) {
                                count  = module.get.selectionCount();
                                message = message.replace('{maxCount}', settings.maxSelections);
                            }
                            if(hasTerm) {
                                query   = term || module.get.query();
                                message = message.replace('{term}', query);
                            }
                            return message;
                        },
                        value: function(addedValue, addedText, $selectedItem) {
                            var
                                currentValue = module.get.values(),
                                newValue
                            ;
                            if(addedValue === '') {
                                module.debug('Cannot select blank values from multiselect');
                                return;
                            }
                            // extend current array
                            if($.isArray(currentValue)) {
                                newValue = currentValue.concat([addedValue]);
                                newValue = module.get.uniqueArray(newValue);
                            }
                            else {
                                newValue = [addedValue];
                            }
                            // add values
                            if( module.has.selectInput() ) {
                                if(module.can.extendSelect()) {
                                    module.debug('Adding value to select', addedValue, newValue, $input);
                                    module.add.optionValue(addedValue);
                                }
                            }
                            else {
                                newValue = newValue.join(settings.delimiter);
                                module.debug('Setting hidden input to delimited value', newValue, $input);
                            }

                            if(settings.fireOnInit === false && module.is.initialLoad()) {
                                module.verbose('Skipping onadd callback on initial load', settings.onAdd);
                            }
                            else {
                                settings.onAdd.call(element, addedValue, addedText, $selectedItem);
                            }
                            module.set.value(newValue, addedValue, addedText, $selectedItem);
                            module.check.maxSelections();
                        }
                    },

                    remove: {
                        active: function() {
                            $module.removeClass(className.active);
                        },
                        activeLabel: function() {
                            $module.find(selector.label).removeClass(className.active);
                        },
                        empty: function() {
                            $module.removeClass(className.empty);
                        },
                        loading: function() {
                            $module.removeClass(className.loading);
                        },
                        initialLoad: function() {
                            initialLoad = false;
                        },
                        upward: function($menu) {
                            var $element = $menu || $module;
                            $element.removeClass(className.upward);
                        },
                        visible: function() {
                            $module.removeClass(className.visible);
                        },
                        activeItem: function() {
                            $item.removeClass(className.active);
                        },
                        filteredItem: function() {
                            if(settings.useLabels && module.has.maxSelections() ) {
                                return;
                            }
                            if(settings.useLabels && module.is.multiple()) {
                                $item.not('.' + className.active).removeClass(className.filtered);
                            }
                            else {
                                $item.removeClass(className.filtered);
                            }
                            module.remove.empty();
                        },
                        optionValue: function(value) {
                            var
                                escapedValue = module.escape.value(value),
                                $option      = $input.find('option[value="' + escapedValue + '"]'),
                                hasOption    = ($option.length > 0)
                            ;
                            if(!hasOption || !$option.hasClass(className.addition)) {
                                return;
                            }
                            // temporarily disconnect observer
                            if(selectObserver) {
                                selectObserver.disconnect();
                                module.verbose('Temporarily disconnecting mutation observer');
                            }
                            $option.remove();
                            module.verbose('Removing user addition as an <option>', escapedValue);
                            if(selectObserver) {
                                selectObserver.observe($input[0], {
                                    childList : true,
                                    subtree   : true
                                });
                            }
                        },
                        message: function() {
                            $menu.children(selector.message).remove();
                        },
                        searchWidth: function() {
                            $search.css('width', '');
                        },
                        searchTerm: function() {
                            module.verbose('Cleared search term');
                            $search.val('');
                            module.set.filtered();
                        },
                        userAddition: function() {
                            $item.filter(selector.addition).remove();
                        },
                        selected: function(value, $selectedItem) {
                            $selectedItem = (settings.allowAdditions)
                                ? $selectedItem || module.get.itemWithAdditions(value)
                                : $selectedItem || module.get.item(value)
                            ;

                            if(!$selectedItem) {
                                return false;
                            }

                            $selectedItem
                                .each(function() {
                                    var
                                        $selected     = $(this),
                                        selectedText  = module.get.choiceText($selected),
                                        selectedValue = module.get.choiceValue($selected, selectedText)
                                    ;
                                    if(module.is.multiple()) {
                                        if(settings.useLabels) {
                                            module.remove.value(selectedValue, selectedText, $selected);
                                            module.remove.label(selectedValue);
                                        }
                                        else {
                                            module.remove.value(selectedValue, selectedText, $selected);
                                            if(module.get.selectionCount() === 0) {
                                                module.set.placeholderText();
                                            }
                                            else {
                                                module.set.text(module.add.variables(message.count));
                                            }
                                        }
                                    }
                                    else {
                                        module.remove.value(selectedValue, selectedText, $selected);
                                    }
                                    $selected
                                        .removeClass(className.filtered)
                                        .removeClass(className.active)
                                    ;
                                    if(settings.useLabels) {
                                        $selected.removeClass(className.selected);
                                    }
                                })
                            ;
                        },
                        selectedItem: function() {
                            $item.removeClass(className.selected);
                        },
                        value: function(removedValue, removedText, $removedItem) {
                            var
                                values = module.get.values(),
                                newValue
                            ;
                            if( module.has.selectInput() ) {
                                module.verbose('Input is <select> removing selected option', removedValue);
                                newValue = module.remove.arrayValue(removedValue, values);
                                module.remove.optionValue(removedValue);
                            }
                            else {
                                module.verbose('Removing from delimited values', removedValue);
                                newValue = module.remove.arrayValue(removedValue, values);
                                newValue = newValue.join(settings.delimiter);
                            }
                            if(settings.fireOnInit === false && module.is.initialLoad()) {
                                module.verbose('No callback on initial load', settings.onRemove);
                            }
                            else {
                                settings.onRemove.call(element, removedValue, removedText, $removedItem);
                            }
                            module.set.value(newValue, removedText, $removedItem);
                            module.check.maxSelections();
                        },
                        arrayValue: function(removedValue, values) {
                            if( !$.isArray(values) ) {
                                values = [values];
                            }
                            values = $.grep(values, function(value){
                                return (removedValue != value);
                            });
                            module.verbose('Removed value from delimited string', removedValue, values);
                            return values;
                        },
                        label: function(value, shouldAnimate) {
                            var
                                $labels       = $module.find(selector.label),
                                $removedLabel = $labels.filter('[data-value="' + value +'"]')
                            ;
                            module.verbose('Removing label', $removedLabel);
                            $removedLabel.remove();
                        },
                        activeLabels: function($activeLabels) {
                            $activeLabels = $activeLabels || $module.find(selector.label).filter('.' + className.active);
                            module.verbose('Removing active label selections', $activeLabels);
                            module.remove.labels($activeLabels);
                        },
                        labels: function($labels) {
                            $labels = $labels || $module.find(selector.label);
                            module.verbose('Removing labels', $labels);
                            $labels
                                .each(function(){
                                    var
                                        $label      = $(this),
                                        value       = $label.data(metadata.value),
                                        stringValue = (value !== undefined)
                                            ? String(value)
                                            : value,
                                        isUserValue = module.is.userValue(stringValue)
                                    ;
                                    if(settings.onLabelRemove.call($label, value) === false) {
                                        module.debug('Label remove callback cancelled removal');
                                        return;
                                    }
                                    module.remove.message();
                                    if(isUserValue) {
                                        module.remove.value(stringValue);
                                        module.remove.label(stringValue);
                                    }
                                    else {
                                        // selected will also remove label
                                        module.remove.selected(stringValue);
                                    }
                                })
                            ;
                        },
                        tabbable: function() {
                            if( module.has.search() ) {
                                module.debug('Searchable dropdown initialized');
                                $search
                                    .removeAttr('tabindex')
                                ;
                                $menu
                                    .removeAttr('tabindex')
                                ;
                            }
                            else {
                                module.debug('Simple selection dropdown initialized');
                                $module
                                    .removeAttr('tabindex')
                                ;
                                $menu
                                    .removeAttr('tabindex')
                                ;
                            }
                        }
                    },

                    has: {
                        menuSearch: function() {
                            return (module.has.search() && $search.closest($menu).length > 0);
                        },
                        search: function() {
                            return ($search.length > 0);
                        },
                        sizer: function() {
                            return ($sizer.length > 0);
                        },
                        selectInput: function() {
                            return ( $input.is('select') );
                        },
                        minCharacters: function(searchTerm) {
                            if(settings.minCharacters) {
                                searchTerm = (searchTerm !== undefined)
                                    ? String(searchTerm)
                                    : String(module.get.query())
                                ;
                                return (searchTerm.length >= settings.minCharacters);
                            }
                            return true;
                        },
                        firstLetter: function($item, letter) {
                            var
                                text,
                                firstLetter
                            ;
                            if(!$item || $item.length === 0 || typeof letter !== 'string') {
                                return false;
                            }
                            text        = module.get.choiceText($item, false);
                            letter      = letter.toLowerCase();
                            firstLetter = String(text).charAt(0).toLowerCase();
                            return (letter == firstLetter);
                        },
                        input: function() {
                            return ($input.length > 0);
                        },
                        items: function() {
                            return ($item.length > 0);
                        },
                        menu: function() {
                            return ($menu.length > 0);
                        },
                        message: function() {
                            return ($menu.children(selector.message).length !== 0);
                        },
                        label: function(value) {
                            var
                                escapedValue = module.escape.value(value),
                                $labels      = $module.find(selector.label)
                            ;
                            return ($labels.filter('[data-value="' + escapedValue +'"]').length > 0);
                        },
                        maxSelections: function() {
                            return (settings.maxSelections && module.get.selectionCount() >= settings.maxSelections);
                        },
                        allResultsFiltered: function() {
                            var
                                $normalResults = $item.not(selector.addition)
                            ;
                            return ($normalResults.filter(selector.unselectable).length === $normalResults.length);
                        },
                        userSuggestion: function() {
                            return ($menu.children(selector.addition).length > 0);
                        },
                        query: function() {
                            return (module.get.query() !== '');
                        },
                        value: function(value) {
                            var
                                values   = module.get.values(),
                                hasValue = $.isArray(values)
                                    ? values && ($.inArray(value, values) !== -1)
                                    : (values == value)
                            ;
                            return (hasValue)
                                ? true
                                : false
                                ;
                        }
                    },

                    is: {
                        active: function() {
                            return $module.hasClass(className.active);
                        },
                        bubbledLabelClick: function(event) {
                            return $(event.target).is('select, input') && $module.closest('label').length > 0;
                        },
                        bubbledIconClick: function(event) {
                            return $(event.target).closest($icon).length > 0;
                        },
                        alreadySetup: function() {
                            return ($module.is('select') && $module.parent(selector.dropdown).length > 0  && $module.prev().length === 0);
                        },
                        animating: function($subMenu) {
                            return ($subMenu)
                                ? $subMenu.transition && $subMenu.transition('is animating')
                                : $menu.transition    && $menu.transition('is animating')
                                ;
                        },
                        disabled: function() {
                            return $module.hasClass(className.disabled);
                        },
                        focused: function() {
                            return (document.activeElement === $module[0]);
                        },
                        focusedOnSearch: function() {
                            return (document.activeElement === $search[0]);
                        },
                        allFiltered: function() {
                            return( (module.is.multiple() || module.has.search()) && !(settings.hideAdditions == false && module.has.userSuggestion()) && !module.has.message() && module.has.allResultsFiltered() );
                        },
                        hidden: function($subMenu) {
                            return !module.is.visible($subMenu);
                        },
                        initialLoad: function() {
                            return initialLoad;
                        },
                        onScreen: function($subMenu) {
                            var
                                $currentMenu   = $subMenu || $menu,
                                canOpenDownward = true,
                                onScreen = {},
                                calculations
                            ;
                            $currentMenu.addClass(className.loading);
                            calculations = {
                                context: {
                                    scrollTop : $context.scrollTop(),
                                    height    : $context.outerHeight()
                                },
                                menu : {
                                    offset: $currentMenu.offset(),
                                    height: $currentMenu.outerHeight()
                                }
                            };
                            onScreen = {
                                above : (calculations.context.scrollTop) <= calculations.menu.offset.top - calculations.menu.height,
                                below : (calculations.context.scrollTop + calculations.context.height) >= calculations.menu.offset.top + calculations.menu.height
                            };
                            if(onScreen.below) {
                                module.verbose('Dropdown can fit in context downward', onScreen);
                                canOpenDownward = true;
                            }
                            else if(!onScreen.below && !onScreen.above) {
                                module.verbose('Dropdown cannot fit in either direction, favoring downward', onScreen);
                                canOpenDownward = true;
                            }
                            else {
                                module.verbose('Dropdown cannot fit below, opening upward', onScreen);
                                canOpenDownward = false;
                            }
                            $currentMenu.removeClass(className.loading);
                            return canOpenDownward;
                        },
                        inObject: function(needle, object) {
                            var
                                found = false
                            ;
                            $.each(object, function(index, property) {
                                if(property == needle) {
                                    found = true;
                                    return true;
                                }
                            });
                            return found;
                        },
                        multiple: function() {
                            return $module.hasClass(className.multiple);
                        },
                        single: function() {
                            return !module.is.multiple();
                        },
                        selectMutation: function(mutations) {
                            var
                                selectChanged = false
                            ;
                            $.each(mutations, function(index, mutation) {
                                if(mutation.target && $(mutation.target).is('select')) {
                                    selectChanged = true;
                                    return true;
                                }
                            });
                            return selectChanged;
                        },
                        search: function() {
                            return $module.hasClass(className.search);
                        },
                        searchSelection: function() {
                            return ( module.has.search() && $search.parent(selector.dropdown).length === 1 );
                        },
                        selection: function() {
                            return $module.hasClass(className.selection);
                        },
                        userValue: function(value) {
                            return ($.inArray(value, module.get.userValues()) !== -1);
                        },
                        upward: function($menu) {
                            var $element = $menu || $module;
                            return $element.hasClass(className.upward);
                        },
                        visible: function($subMenu) {
                            return ($subMenu)
                                ? $subMenu.hasClass(className.visible)
                                : $menu.hasClass(className.visible)
                                ;
                        }
                    },

                    can: {
                        activate: function($item) {
                            if(settings.useLabels) {
                                return true;
                            }
                            if(!module.has.maxSelections()) {
                                return true;
                            }
                            if(module.has.maxSelections() && $item.hasClass(className.active)) {
                                return true;
                            }
                            return false;
                        },
                        click: function() {
                            return (hasTouch || settings.on == 'click');
                        },
                        extendSelect: function() {
                            return settings.allowAdditions || settings.apiSettings;
                        },
                        show: function() {
                            return !module.is.disabled() && (module.has.items() || module.has.message());
                        },
                        useAPI: function() {
                            return $.fn.api !== undefined;
                        }
                    },

                    animate: {
                        show: function(callback, $subMenu) {
                            var
                                $currentMenu = $subMenu || $menu,
                                start = ($subMenu)
                                    ? function() {}
                                    : function() {
                                        module.hideSubMenus();
                                        module.hideOthers();
                                        module.set.active();
                                    },
                                transition
                            ;
                            callback = $.isFunction(callback)
                                ? callback
                                : function(){}
                            ;
                            module.verbose('Doing menu show animation', $currentMenu);
                            module.set.direction($subMenu);
                            transition = module.get.transition($subMenu);
                            if( module.is.selection() ) {
                                module.set.scrollPosition(module.get.selectedItem(), true);
                            }
                            if( module.is.hidden($currentMenu) || module.is.animating($currentMenu) ) {
                                if(transition == 'none') {
                                    start();
                                    $currentMenu.transition('show');
                                    callback.call(element);
                                }
                                else if($.fn.transition !== undefined && $module.transition('is supported')) {
                                    $currentMenu
                                        .transition({
                                            animation  : transition + ' in',
                                            debug      : settings.debug,
                                            verbose    : settings.verbose,
                                            duration   : settings.duration,
                                            queue      : true,
                                            onStart    : start,
                                            onComplete : function() {
                                                callback.call(element);
                                            }
                                        })
                                    ;
                                }
                                else {
                                    module.error(error.noTransition, transition);
                                }
                            }
                        },
                        hide: function(callback, $subMenu) {
                            var
                                $currentMenu = $subMenu || $menu,
                                duration = ($subMenu)
                                    ? (settings.duration * 0.9)
                                    : settings.duration,
                                start = ($subMenu)
                                    ? function() {}
                                    : function() {
                                        if( module.can.click() ) {
                                            module.unbind.intent();
                                        }
                                        module.remove.active();
                                    },
                                transition = module.get.transition($subMenu)
                            ;
                            callback = $.isFunction(callback)
                                ? callback
                                : function(){}
                            ;
                            if( module.is.visible($currentMenu) || module.is.animating($currentMenu) ) {
                                module.verbose('Doing menu hide animation', $currentMenu);

                                if(transition == 'none') {
                                    start();
                                    $currentMenu.transition('hide');
                                    callback.call(element);
                                }
                                else if($.fn.transition !== undefined && $module.transition('is supported')) {
                                    $currentMenu
                                        .transition({
                                            animation  : transition + ' out',
                                            duration   : settings.duration,
                                            debug      : settings.debug,
                                            verbose    : settings.verbose,
                                            queue      : true,
                                            onStart    : start,
                                            onComplete : function() {
                                                if(settings.direction == 'auto') {
                                                    module.remove.upward($subMenu);
                                                }
                                                callback.call(element);
                                            }
                                        })
                                    ;
                                }
                                else {
                                    module.error(error.transition);
                                }
                            }
                        }
                    },

                    hideAndClear: function() {
                        module.remove.searchTerm();
                        if( module.has.maxSelections() ) {
                            return;
                        }
                        if(module.has.search()) {
                            module.hide(function() {
                                module.remove.filteredItem();
                            });
                        }
                        else {
                            module.hide();
                        }
                    },

                    delay: {
                        show: function() {
                            module.verbose('Delaying show event to ensure user intent');
                            clearTimeout(module.timer);
                            module.timer = setTimeout(module.show, settings.delay.show);
                        },
                        hide: function() {
                            module.verbose('Delaying hide event to ensure user intent');
                            clearTimeout(module.timer);
                            module.timer = setTimeout(module.hide, settings.delay.hide);
                        }
                    },

                    escape: {
                        value: function(value) {
                            var
                                multipleValues = $.isArray(value),
                                stringValue    = (typeof value === 'string'),
                                isUnparsable   = (!stringValue && !multipleValues),
                                hasQuotes      = (stringValue && value.search(regExp.quote) !== -1),
                                values         = []
                            ;
                            if(!module.has.selectInput() || isUnparsable || !hasQuotes) {
                                return value;
                            }
                            module.debug('Encoding quote values for use in select', value);
                            if(multipleValues) {
                                $.each(value, function(index, value){
                                    values.push(value.replace(regExp.quote, '&quot;'));
                                });
                                return values;
                            }
                            return value.replace(regExp.quote, '&quot;');
                        },
                        regExp: function(text) {
                            text =  String(text);
                            return text.replace(regExp.escape, '\\$&');
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            if($.isPlainObject(settings[name])) {
                                $.extend(true, settings[name], value);
                            }
                            else {
                                settings[name] = value;
                            }
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;
        return (returnedValue !== undefined)
            ? returnedValue
            : $allModules
            ;
    };

    $.fn.dropdown.settings = {

        silent                 : false,
        debug                  : false,
        verbose                : false,
        performance            : true,

        on                     : 'click',    // what event should show menu action on item selection
        action                 : 'activate', // action on item selection (nothing, activate, select, combo, hide, function(){})


        apiSettings            : false,
        selectOnKeydown        : true,       // Whether selection should occur automatically when keyboard shortcuts used
        minCharacters          : 0,          // Minimum characters required to trigger API call
        saveRemoteData         : true,       // Whether remote name/value pairs should be stored in sessionStorage to allow remote data to be restored on page refresh
        throttle               : 200,        // How long to wait after last user input to search remotely

        context                : window,     // Context to use when determining if on screen
        direction              : 'auto',     // Whether dropdown should always open in one direction
        keepOnScreen           : true,       // Whether dropdown should check whether it is on screen before showing

        match                  : 'both',     // what to match against with search selection (both, text, or label)
        fullTextSearch         : false,      // search anywhere in value (set to 'exact' to require exact matches)

        placeholder            : 'auto',     // whether to convert blank <select> values to placeholder text
        preserveHTML           : true,       // preserve html when selecting value
        sortSelect             : false,      // sort selection on init

        forceSelection         : true,       // force a choice on blur with search selection

        allowAdditions         : false,      // whether multiple select should allow user added values
        hideAdditions          : true,      // whether or not to hide special message prompting a user they can enter a value

        maxSelections          : false,      // When set to a number limits the number of selections to this count
        useLabels              : true,       // whether multiple select should filter currently active selections from choices
        delimiter              : ',',        // when multiselect uses normal <input> the values will be delimited with this character

        showOnFocus            : true,       // show menu on focus
        allowReselection       : false,      // whether current value should trigger callbacks when reselected
        allowTab               : true,       // add tabindex to element
        allowCategorySelection : false,      // allow elements with sub-menus to be selected

        fireOnInit             : false,      // Whether callbacks should fire when initializing dropdown values

        transition             : 'auto',     // auto transition will slide down or up based on direction
        duration               : 200,        // duration of transition

        glyphWidth             : 1.037,      // widest glyph width in em (W is 1.037 em) used to calculate multiselect input width

        // label settings on multi-select
        label: {
            transition : 'scale',
            duration   : 200,
            variation  : false
        },

        // delay before event
        delay : {
            hide   : 300,
            show   : 200,
            search : 20,
            touch  : 50
        },

        /* Callbacks */
        onChange      : function(value, text, $selected){},
        onAdd         : function(value, text, $selected){},
        onRemove      : function(value, text, $selected){},

        onLabelSelect : function($selectedLabels){},
        onLabelCreate : function(value, text) { return $(this); },
        onLabelRemove : function(value) { return true; },
        onNoResults   : function(searchTerm) { return true; },
        onShow        : function(){},
        onHide        : function(){},

        /* Component */
        name           : 'Dropdown',
        namespace      : 'dropdown',

        message: {
            addResult     : 'Add <b>{term}</b>',
            count         : '{count} selected',
            maxSelections : 'Max {maxCount} selections',
            noResults     : 'No results found.',
            serverError   : 'There was an error contacting the server'
        },

        error : {
            action          : 'You called a dropdown action that was not defined',
            alreadySetup    : 'Once a select has been initialized behaviors must be called on the created ui dropdown',
            labels          : 'Allowing user additions currently requires the use of labels.',
            missingMultiple : '<select> requires multiple property to be set to correctly preserve multiple values',
            method          : 'The method you called is not defined.',
            noAPI           : 'The API module is required to load resources remotely',
            noStorage       : 'Saving remote data requires session storage',
            noTransition    : 'This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>'
        },

        regExp : {
            escape   : /[-[\]{}()*+?.,\\^$|#\s]/g,
            quote    : /"/g
        },

        metadata : {
            defaultText     : 'defaultText',
            defaultValue    : 'defaultValue',
            placeholderText : 'placeholder',
            text            : 'text',
            value           : 'value'
        },

        // property names for remote query
        fields: {
            remoteValues : 'results',  // grouping for api results
            values       : 'values',   // grouping for all dropdown values
            disabled     : 'disabled', // whether value should be disabled
            name         : 'name',     // displayed dropdown text
            value        : 'value',    // actual dropdown value
            text         : 'text'      // displayed text when selected
        },

        keys : {
            backspace  : 8,
            delimiter  : 188, // comma
            deleteKey  : 46,
            enter      : 13,
            escape     : 27,
            pageUp     : 33,
            pageDown   : 34,
            leftArrow  : 37,
            upArrow    : 38,
            rightArrow : 39,
            downArrow  : 40
        },

        selector : {
            addition     : '.addition',
            dropdown     : '.ui.dropdown',
            hidden       : '.hidden',
            icon         : '> .dropdown.icon',
            input        : '> input[type="hidden"], > select',
            item         : '.item',
            label        : '> .label',
            remove       : '> .label > .delete.icon',
            siblingLabel : '.label',
            menu         : '.menu',
            message      : '.message',
            menuIcon     : '.dropdown.icon',
            search       : 'input.search, .menu > .search > input, .menu input.search',
            sizer        : '> input.sizer',
            text         : '> .text:not(.icon)',
            unselectable : '.disabled, .filtered'
        },

        className : {
            active      : 'active',
            addition    : 'addition',
            animating   : 'animating',
            disabled    : 'disabled',
            empty       : 'empty',
            dropdown    : 'ui dropdown',
            filtered    : 'filtered',
            hidden      : 'hidden transition',
            item        : 'item',
            label       : 'ui label',
            loading     : 'loading',
            menu        : 'menu',
            message     : 'message',
            multiple    : 'multiple',
            placeholder : 'default',
            sizer       : 'sizer',
            search      : 'search',
            selected    : 'selected',
            selection   : 'selection',
            upward      : 'upward',
            visible     : 'visible'
        }

    };

    /* Templates */
    $.fn.dropdown.settings.templates = {

        // generates dropdown from select values
        dropdown: function(select) {
            var
                placeholder = select.placeholder || false,
                values      = select.values || {},
                html        = ''
            ;
            html +=  '<i class="dropdown icon"></i>';
            if(select.placeholder) {
                html += '<div class="default text">' + placeholder + '</div>';
            }
            else {
                html += '<div class="text"></div>';
            }
            html += '<div class="menu">';
            $.each(select.values, function(index, option) {
                html += (option.disabled)
                    ? '<div class="disabled item" data-value="' + option.value + '">' + option.name + '</div>'
                    : '<div class="item" data-value="' + option.value + '">' + option.name + '</div>'
                ;
            });
            html += '</div>';
            return html;
        },

        // generates just menu from select
        menu: function(response, fields) {
            var
                values = response[fields.values] || {},
                html   = ''
            ;
            $.each(values, function(index, option) {
                var
                    maybeText = (option[fields.text])
                        ? 'data-text="' + option[fields.text] + '"'
                        : '',
                    maybeDisabled = (option[fields.disabled])
                        ? 'disabled '
                        : ''
                ;
                html += '<div class="'+ maybeDisabled +'item" data-value="' + option[fields.value] + '"' + maybeText + '>'
                html +=   option[fields.name];
                html += '</div>';
            });
            return html;
        },

        // generates label for multiselect
        label: function(value, text) {
            return text + '<i class="delete icon"></i>';
        },


        // generates messages like "No results"
        message: function(message) {
            return message;
        },

        // generates user addition to selection menu
        addition: function(choice) {
            return choice;
        }

    };

})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Embed
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.embed = function(parameters) {

        var
            $allModules     = $(this),

            moduleSelector  = $allModules.selector || '',

            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),

            returnedValue
        ;

        $allModules
            .each(function() {
                var
                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.embed.settings, parameters)
                        : $.extend({}, $.fn.embed.settings),

                    selector        = settings.selector,
                    className       = settings.className,
                    sources         = settings.sources,
                    error           = settings.error,
                    metadata        = settings.metadata,
                    namespace       = settings.namespace,
                    templates       = settings.templates,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    $window         = $(window),
                    $module         = $(this),
                    $placeholder    = $module.find(selector.placeholder),
                    $icon           = $module.find(selector.icon),
                    $embed          = $module.find(selector.embed),

                    element         = this,
                    instance        = $module.data(moduleNamespace),
                    module
                ;

                module = {

                    initialize: function() {
                        module.debug('Initializing embed');
                        module.determine.autoplay();
                        module.create();
                        module.bind.events();
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous instance of embed');
                        module.reset();
                        $module
                            .removeData(moduleNamespace)
                            .off(eventNamespace)
                        ;
                    },

                    refresh: function() {
                        module.verbose('Refreshing selector cache');
                        $placeholder = $module.find(selector.placeholder);
                        $icon        = $module.find(selector.icon);
                        $embed       = $module.find(selector.embed);
                    },

                    bind: {
                        events: function() {
                            if( module.has.placeholder() ) {
                                module.debug('Adding placeholder events');
                                $module
                                    .on('click' + eventNamespace, selector.placeholder, module.createAndShow)
                                    .on('click' + eventNamespace, selector.icon, module.createAndShow)
                                ;
                            }
                        }
                    },

                    create: function() {
                        var
                            placeholder = module.get.placeholder()
                        ;
                        if(placeholder) {
                            module.createPlaceholder();
                        }
                        else {
                            module.createAndShow();
                        }
                    },

                    createPlaceholder: function(placeholder) {
                        var
                            icon  = module.get.icon(),
                            url   = module.get.url(),
                            embed = module.generate.embed(url)
                        ;
                        placeholder = placeholder || module.get.placeholder();
                        $module.html( templates.placeholder(placeholder, icon) );
                        module.debug('Creating placeholder for embed', placeholder, icon);
                    },

                    createEmbed: function(url) {
                        module.refresh();
                        url = url || module.get.url();
                        $embed = $('<div/>')
                            .addClass(className.embed)
                            .html( module.generate.embed(url) )
                            .appendTo($module)
                        ;
                        settings.onCreate.call(element, url);
                        module.debug('Creating embed object', $embed);
                    },

                    changeEmbed: function(url) {
                        $embed
                            .html( module.generate.embed(url) )
                        ;
                    },

                    createAndShow: function() {
                        module.createEmbed();
                        module.show();
                    },

                    // sets new embed
                    change: function(source, id, url) {
                        module.debug('Changing video to ', source, id, url);
                        $module
                            .data(metadata.source, source)
                            .data(metadata.id, id)
                        ;
                        if(url) {
                            $module.data(metadata.url, url);
                        }
                        else {
                            $module.removeData(metadata.url);
                        }
                        if(module.has.embed()) {
                            module.changeEmbed();
                        }
                        else {
                            module.create();
                        }
                    },

                    // clears embed
                    reset: function() {
                        module.debug('Clearing embed and showing placeholder');
                        module.remove.active();
                        module.remove.embed();
                        module.showPlaceholder();
                        settings.onReset.call(element);
                    },

                    // shows current embed
                    show: function() {
                        module.debug('Showing embed');
                        module.set.active();
                        settings.onDisplay.call(element);
                    },

                    hide: function() {
                        module.debug('Hiding embed');
                        module.showPlaceholder();
                    },

                    showPlaceholder: function() {
                        module.debug('Showing placeholder image');
                        module.remove.active();
                        settings.onPlaceholderDisplay.call(element);
                    },

                    get: {
                        id: function() {
                            return settings.id || $module.data(metadata.id);
                        },
                        placeholder: function() {
                            return settings.placeholder || $module.data(metadata.placeholder);
                        },
                        icon: function() {
                            return (settings.icon)
                                ? settings.icon
                                : ($module.data(metadata.icon) !== undefined)
                                    ? $module.data(metadata.icon)
                                    : module.determine.icon()
                                ;
                        },
                        source: function(url) {
                            return (settings.source)
                                ? settings.source
                                : ($module.data(metadata.source) !== undefined)
                                    ? $module.data(metadata.source)
                                    : module.determine.source()
                                ;
                        },
                        type: function() {
                            var source = module.get.source();
                            return (sources[source] !== undefined)
                                ? sources[source].type
                                : false
                                ;
                        },
                        url: function() {
                            return (settings.url)
                                ? settings.url
                                : ($module.data(metadata.url) !== undefined)
                                    ? $module.data(metadata.url)
                                    : module.determine.url()
                                ;
                        }
                    },

                    determine: {
                        autoplay: function() {
                            if(module.should.autoplay()) {
                                settings.autoplay = true;
                            }
                        },
                        source: function(url) {
                            var
                                matchedSource = false
                            ;
                            url = url || module.get.url();
                            if(url) {
                                $.each(sources, function(name, source) {
                                    if(url.search(source.domain) !== -1) {
                                        matchedSource = name;
                                        return false;
                                    }
                                });
                            }
                            return matchedSource;
                        },
                        icon: function() {
                            var
                                source = module.get.source()
                            ;
                            return (sources[source] !== undefined)
                                ? sources[source].icon
                                : false
                                ;
                        },
                        url: function() {
                            var
                                id     = settings.id     || $module.data(metadata.id),
                                source = settings.source || $module.data(metadata.source),
                                url
                            ;
                            url = (sources[source] !== undefined)
                                ? sources[source].url.replace('{id}', id)
                                : false
                            ;
                            if(url) {
                                $module.data(metadata.url, url);
                            }
                            return url;
                        }
                    },


                    set: {
                        active: function() {
                            $module.addClass(className.active);
                        }
                    },

                    remove: {
                        active: function() {
                            $module.removeClass(className.active);
                        },
                        embed: function() {
                            $embed.empty();
                        }
                    },

                    encode: {
                        parameters: function(parameters) {
                            var
                                urlString = [],
                                index
                            ;
                            for (index in parameters) {
                                urlString.push( encodeURIComponent(index) + '=' + encodeURIComponent( parameters[index] ) );
                            }
                            return urlString.join('&amp;');
                        }
                    },

                    generate: {
                        embed: function(url) {
                            module.debug('Generating embed html');
                            var
                                source = module.get.source(),
                                html,
                                parameters
                            ;
                            url = module.get.url(url);
                            if(url) {
                                parameters = module.generate.parameters(source);
                                html       = templates.iframe(url, parameters);
                            }
                            else {
                                module.error(error.noURL, $module);
                            }
                            return html;
                        },
                        parameters: function(source, extraParameters) {
                            var
                                parameters = (sources[source] && sources[source].parameters !== undefined)
                                    ? sources[source].parameters(settings)
                                    : {}
                            ;
                            extraParameters = extraParameters || settings.parameters;
                            if(extraParameters) {
                                parameters = $.extend({}, parameters, extraParameters);
                            }
                            parameters = settings.onEmbed(parameters);
                            return module.encode.parameters(parameters);
                        }
                    },

                    has: {
                        embed: function() {
                            return ($embed.length > 0);
                        },
                        placeholder: function() {
                            return settings.placeholder || $module.data(metadata.placeholder);
                        }
                    },

                    should: {
                        autoplay: function() {
                            return (settings.autoplay === 'auto')
                                ? (settings.placeholder || $module.data(metadata.placeholder) !== undefined)
                                : settings.autoplay
                                ;
                        }
                    },

                    is: {
                        video: function() {
                            return module.get.type() == 'video';
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            if($.isPlainObject(settings[name])) {
                                $.extend(true, settings[name], value);
                            }
                            else {
                                settings[name] = value;
                            }
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if($allModules.length > 1) {
                                title += ' ' + '(' + $allModules.length + ')';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;
        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.embed.settings = {

        name        : 'Embed',
        namespace   : 'embed',

        silent      : false,
        debug       : false,
        verbose     : false,
        performance : true,

        icon     : false,
        source   : false,
        url      : false,
        id       : false,

        // standard video settings
        autoplay  : 'auto',
        color     : '#444444',
        hd        : true,
        brandedUI : false,

        // additional parameters to include with the embed
        parameters: false,

        onDisplay            : function() {},
        onPlaceholderDisplay : function() {},
        onReset              : function() {},
        onCreate             : function(url) {},
        onEmbed              : function(parameters) {
            return parameters;
        },

        metadata    : {
            id          : 'id',
            icon        : 'icon',
            placeholder : 'placeholder',
            source      : 'source',
            url         : 'url'
        },

        error : {
            noURL  : 'No URL specified',
            method : 'The method you called is not defined'
        },

        className : {
            active : 'active',
            embed  : 'embed'
        },

        selector : {
            embed       : '.embed',
            placeholder : '.placeholder',
            icon        : '.icon'
        },

        sources: {
            youtube: {
                name   : 'youtube',
                type   : 'video',
                icon   : 'video play',
                domain : 'youtube.com',
                url    : '//www.youtube.com/embed/{id}',
                parameters: function(settings) {
                    return {
                        autohide       : !settings.brandedUI,
                        autoplay       : settings.autoplay,
                        color          : settings.color || undefined,
                        hq             : settings.hd,
                        jsapi          : settings.api,
                        modestbranding : !settings.brandedUI
                    };
                }
            },
            vimeo: {
                name   : 'vimeo',
                type   : 'video',
                icon   : 'video play',
                domain : 'vimeo.com',
                url    : '//player.vimeo.com/video/{id}',
                parameters: function(settings) {
                    return {
                        api      : settings.api,
                        autoplay : settings.autoplay,
                        byline   : settings.brandedUI,
                        color    : settings.color || undefined,
                        portrait : settings.brandedUI,
                        title    : settings.brandedUI
                    };
                }
            }
        },

        templates: {
            iframe : function(url, parameters) {
                var src = url;
                if (parameters) {
                    src += '?' + parameters;
                }
                return ''
                    + '<iframe src="' + src + '"'
                    + ' width="100%" height="100%"'
                    + ' frameborder="0" scrolling="no" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>'
                    ;
            },
            placeholder : function(image, icon) {
                var
                    html = ''
                ;
                if(icon) {
                    html += '<i class="' + icon + ' icon"></i>';
                }
                if(image) {
                    html += '<img class="placeholder" src="' + image + '">';
                }
                return html;
            }
        },

        // NOT YET IMPLEMENTED
        api     : false,
        onPause : function() {},
        onPlay  : function() {},
        onStop  : function() {}

    };



})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Modal
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.modal = function(parameters) {
        var
            $allModules    = $(this),
            $window        = $(window),
            $document      = $(document),
            $body          = $('body'),

            moduleSelector = $allModules.selector || '',

            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),

            requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(callback) { setTimeout(callback, 0); },

            returnedValue
        ;

        $allModules
            .each(function() {
                var
                    settings    = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.modal.settings, parameters)
                        : $.extend({}, $.fn.modal.settings),

                    selector        = settings.selector,
                    className       = settings.className,
                    namespace       = settings.namespace,
                    error           = settings.error,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    $module         = $(this),
                    $context        = $(settings.context),
                    $close          = $module.find(selector.close),

                    $allModals,
                    $otherModals,
                    $focusedElement,
                    $dimmable,
                    $dimmer,

                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    elementEventNamespace,
                    id,
                    observer,
                    module
                ;
                module  = {

                    initialize: function() {
                        module.verbose('Initializing dimmer', $context);

                        module.create.id();
                        module.create.dimmer();
                        module.refreshModals();

                        module.bind.events();
                        if(settings.observeChanges) {
                            module.observeChanges();
                        }
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of modal');
                        instance = module;
                        $module
                            .data(moduleNamespace, instance)
                        ;
                    },

                    create: {
                        dimmer: function() {
                            var
                                defaultSettings = {
                                    debug      : settings.debug,
                                    dimmerName : 'modals',
                                    duration   : {
                                        show     : settings.duration,
                                        hide     : settings.duration
                                    }
                                },
                                dimmerSettings = $.extend(true, defaultSettings, settings.dimmerSettings)
                            ;
                            if(settings.inverted) {
                                dimmerSettings.variation = (dimmerSettings.variation !== undefined)
                                    ? dimmerSettings.variation + ' inverted'
                                    : 'inverted'
                                ;
                            }
                            if($.fn.dimmer === undefined) {
                                module.error(error.dimmer);
                                return;
                            }
                            module.debug('Creating dimmer with settings', dimmerSettings);
                            $dimmable = $context.dimmer(dimmerSettings);
                            if(settings.detachable) {
                                module.verbose('Modal is detachable, moving content into dimmer');
                                $dimmable.dimmer('add content', $module);
                            }
                            else {
                                module.set.undetached();
                            }
                            if(settings.blurring) {
                                $dimmable.addClass(className.blurring);
                            }
                            $dimmer = $dimmable.dimmer('get dimmer');
                        },
                        id: function() {
                            id = (Math.random().toString(16) + '000000000').substr(2,8);
                            elementEventNamespace = '.' + id;
                            module.verbose('Creating unique id for element', id);
                        }
                    },

                    destroy: function() {
                        module.verbose('Destroying previous modal');
                        $module
                            .removeData(moduleNamespace)
                            .off(eventNamespace)
                        ;
                        $window.off(elementEventNamespace);
                        $dimmer.off(elementEventNamespace);
                        $close.off(eventNamespace);
                        $context.dimmer('destroy');
                    },

                    observeChanges: function() {
                        if('MutationObserver' in window) {
                            observer = new MutationObserver(function(mutations) {
                                module.debug('DOM tree modified, refreshing');
                                module.refresh();
                            });
                            observer.observe(element, {
                                childList : true,
                                subtree   : true
                            });
                            module.debug('Setting up mutation observer', observer);
                        }
                    },

                    refresh: function() {
                        module.remove.scrolling();
                        module.cacheSizes();
                        module.set.screenHeight();
                        module.set.type();
                        module.set.position();
                    },

                    refreshModals: function() {
                        $otherModals = $module.siblings(selector.modal);
                        $allModals   = $otherModals.add($module);
                    },

                    attachEvents: function(selector, event) {
                        var
                            $toggle = $(selector)
                        ;
                        event = $.isFunction(module[event])
                            ? module[event]
                            : module.toggle
                        ;
                        if($toggle.length > 0) {
                            module.debug('Attaching modal events to element', selector, event);
                            $toggle
                                .off(eventNamespace)
                                .on('click' + eventNamespace, event)
                            ;
                        }
                        else {
                            module.error(error.notFound, selector);
                        }
                    },

                    bind: {
                        events: function() {
                            module.verbose('Attaching events');
                            $module
                                .on('click' + eventNamespace, selector.close, module.event.close)
                                .on('click' + eventNamespace, selector.approve, module.event.approve)
                                .on('click' + eventNamespace, selector.deny, module.event.deny)
                            ;
                            $window
                                .on('resize' + elementEventNamespace, module.event.resize)
                            ;
                        }
                    },

                    get: {
                        id: function() {
                            return (Math.random().toString(16) + '000000000').substr(2,8);
                        }
                    },

                    event: {
                        approve: function() {
                            if(settings.onApprove.call(element, $(this)) === false) {
                                module.verbose('Approve callback returned false cancelling hide');
                                return;
                            }
                            module.hide();
                        },
                        deny: function() {
                            if(settings.onDeny.call(element, $(this)) === false) {
                                module.verbose('Deny callback returned false cancelling hide');
                                return;
                            }
                            module.hide();
                        },
                        close: function() {
                            module.hide();
                        },
                        click: function(event) {
                            var
                                $target   = $(event.target),
                                isInModal = ($target.closest(selector.modal).length > 0),
                                isInDOM   = $.contains(document.documentElement, event.target)
                            ;
                            if(!isInModal && isInDOM) {
                                module.debug('Dimmer clicked, hiding all modals');
                                if( module.is.active() ) {
                                    module.remove.clickaway();
                                    if(settings.allowMultiple) {
                                        module.hide();
                                    }
                                    else {
                                        module.hideAll();
                                    }
                                }
                            }
                        },
                        debounce: function(method, delay) {
                            clearTimeout(module.timer);
                            module.timer = setTimeout(method, delay);
                        },
                        keyboard: function(event) {
                            var
                                keyCode   = event.which,
                                escapeKey = 27
                            ;
                            if(keyCode == escapeKey) {
                                if(settings.closable) {
                                    module.debug('Escape key pressed hiding modal');
                                    module.hide();
                                }
                                else {
                                    module.debug('Escape key pressed, but closable is set to false');
                                }
                                event.preventDefault();
                            }
                        },
                        resize: function() {
                            if( $dimmable.dimmer('is active') ) {
                                requestAnimationFrame(module.refresh);
                            }
                        }
                    },

                    toggle: function() {
                        if( module.is.active() || module.is.animating() ) {
                            module.hide();
                        }
                        else {
                            module.show();
                        }
                    },

                    show: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        module.refreshModals();
                        module.showModal(callback);
                    },

                    hide: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        module.refreshModals();
                        module.hideModal(callback);
                    },

                    showModal: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if( module.is.animating() || !module.is.active() ) {

                            module.showDimmer();
                            module.cacheSizes();
                            module.set.position();
                            module.set.screenHeight();
                            module.set.type();
                            module.set.clickaway();

                            if( !settings.allowMultiple && module.others.active() ) {
                                module.hideOthers(module.showModal);
                            }
                            else {
                                settings.onShow.call(element);
                                if(settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
                                    module.debug('Showing modal with css animations');
                                    $module
                                        .transition({
                                            debug       : settings.debug,
                                            animation   : settings.transition + ' in',
                                            queue       : settings.queue,
                                            duration    : settings.duration,
                                            useFailSafe : true,
                                            onComplete : function() {
                                                settings.onVisible.apply(element);
                                                if(settings.keyboardShortcuts) {
                                                    module.add.keyboardShortcuts();
                                                }
                                                module.save.focus();
                                                module.set.active();
                                                if(settings.autofocus) {
                                                    module.set.autofocus();
                                                }
                                                callback();
                                            }
                                        })
                                    ;
                                }
                                else {
                                    module.error(error.noTransition);
                                }
                            }
                        }
                        else {
                            module.debug('Modal is already visible');
                        }
                    },

                    hideModal: function(callback, keepDimmed) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        module.debug('Hiding modal');
                        if(settings.onHide.call(element, $(this)) === false) {
                            module.verbose('Hide callback returned false cancelling hide');
                            return;
                        }

                        if( module.is.animating() || module.is.active() ) {
                            if(settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
                                module.remove.active();
                                $module
                                    .transition({
                                        debug       : settings.debug,
                                        animation   : settings.transition + ' out',
                                        queue       : settings.queue,
                                        duration    : settings.duration,
                                        useFailSafe : true,
                                        onStart     : function() {
                                            if(!module.others.active() && !keepDimmed) {
                                                module.hideDimmer();
                                            }
                                            if(settings.keyboardShortcuts) {
                                                module.remove.keyboardShortcuts();
                                            }
                                        },
                                        onComplete : function() {
                                            settings.onHidden.call(element);
                                            module.restore.focus();
                                            callback();
                                        }
                                    })
                                ;
                            }
                            else {
                                module.error(error.noTransition);
                            }
                        }
                    },

                    showDimmer: function() {
                        if($dimmable.dimmer('is animating') || !$dimmable.dimmer('is active') ) {
                            module.debug('Showing dimmer');
                            $dimmable.dimmer('show');
                        }
                        else {
                            module.debug('Dimmer already visible');
                        }
                    },

                    hideDimmer: function() {
                        if( $dimmable.dimmer('is animating') || ($dimmable.dimmer('is active')) ) {
                            $dimmable.dimmer('hide', function() {
                                module.remove.clickaway();
                                module.remove.screenHeight();
                            });
                        }
                        else {
                            module.debug('Dimmer is not visible cannot hide');
                            return;
                        }
                    },

                    hideAll: function(callback) {
                        var
                            $visibleModals = $allModals.filter('.' + className.active + ', .' + className.animating)
                        ;
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if( $visibleModals.length > 0 ) {
                            module.debug('Hiding all visible modals');
                            module.hideDimmer();
                            $visibleModals
                                .modal('hide modal', callback)
                            ;
                        }
                    },

                    hideOthers: function(callback) {
                        var
                            $visibleModals = $otherModals.filter('.' + className.active + ', .' + className.animating)
                        ;
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if( $visibleModals.length > 0 ) {
                            module.debug('Hiding other modals', $otherModals);
                            $visibleModals
                                .modal('hide modal', callback, true)
                            ;
                        }
                    },

                    others: {
                        active: function() {
                            return ($otherModals.filter('.' + className.active).length > 0);
                        },
                        animating: function() {
                            return ($otherModals.filter('.' + className.animating).length > 0);
                        }
                    },


                    add: {
                        keyboardShortcuts: function() {
                            module.verbose('Adding keyboard shortcuts');
                            $document
                                .on('keyup' + eventNamespace, module.event.keyboard)
                            ;
                        }
                    },

                    save: {
                        focus: function() {
                            $focusedElement = $(document.activeElement).blur();
                        }
                    },

                    restore: {
                        focus: function() {
                            if($focusedElement && $focusedElement.length > 0) {
                                $focusedElement.focus();
                            }
                        }
                    },

                    remove: {
                        active: function() {
                            $module.removeClass(className.active);
                        },
                        clickaway: function() {
                            if(settings.closable) {
                                $dimmer
                                    .off('click' + elementEventNamespace)
                                ;
                            }
                        },
                        bodyStyle: function() {
                            if($body.attr('style') === '') {
                                module.verbose('Removing style attribute');
                                $body.removeAttr('style');
                            }
                        },
                        screenHeight: function() {
                            module.debug('Removing page height');
                            $body
                                .css('height', '')
                            ;
                        },
                        keyboardShortcuts: function() {
                            module.verbose('Removing keyboard shortcuts');
                            $document
                                .off('keyup' + eventNamespace)
                            ;
                        },
                        scrolling: function() {
                            $dimmable.removeClass(className.scrolling);
                            $module.removeClass(className.scrolling);
                        }
                    },

                    cacheSizes: function() {
                        var
                            modalHeight = $module.outerHeight()
                        ;
                        if(module.cache === undefined || modalHeight !== 0) {
                            module.cache = {
                                pageHeight    : $(document).outerHeight(),
                                height        : modalHeight + settings.offset,
                                contextHeight : (settings.context == 'body')
                                    ? $(window).height()
                                    : $dimmable.height()
                            };
                        }
                        module.debug('Caching modal and container sizes', module.cache);
                    },

                    can: {
                        fit: function() {
                            return ( ( module.cache.height + (settings.padding * 2) ) < module.cache.contextHeight);
                        }
                    },

                    is: {
                        active: function() {
                            return $module.hasClass(className.active);
                        },
                        animating: function() {
                            return $module.transition('is supported')
                                ? $module.transition('is animating')
                                : $module.is(':visible')
                                ;
                        },
                        scrolling: function() {
                            return $dimmable.hasClass(className.scrolling);
                        },
                        modernBrowser: function() {
                            // appName for IE11 reports 'Netscape' can no longer use
                            return !(window.ActiveXObject || "ActiveXObject" in window);
                        }
                    },

                    set: {
                        autofocus: function() {
                            var
                                $inputs    = $module.find('[tabindex], :input').filter(':visible'),
                                $autofocus = $inputs.filter('[autofocus]'),
                                $input     = ($autofocus.length > 0)
                                    ? $autofocus.first()
                                    : $inputs.first()
                            ;
                            if($input.length > 0) {
                                $input.focus();
                            }
                        },
                        clickaway: function() {
                            if(settings.closable) {
                                $dimmer
                                    .on('click' + elementEventNamespace, module.event.click)
                                ;
                            }
                        },
                        screenHeight: function() {
                            if( module.can.fit() ) {
                                $body.css('height', '');
                            }
                            else {
                                module.debug('Modal is taller than page content, resizing page height');
                                $body
                                    .css('height', module.cache.height + (settings.padding * 2) )
                                ;
                            }
                        },
                        active: function() {
                            $module.addClass(className.active);
                        },
                        scrolling: function() {
                            $dimmable.addClass(className.scrolling);
                            $module.addClass(className.scrolling);
                        },
                        type: function() {
                            if(module.can.fit()) {
                                module.verbose('Modal fits on screen');
                                if(!module.others.active() && !module.others.animating()) {
                                    module.remove.scrolling();
                                }
                            }
                            else {
                                module.verbose('Modal cannot fit on screen setting to scrolling');
                                module.set.scrolling();
                            }
                        },
                        position: function() {
                            module.verbose('Centering modal on page', module.cache);
                            if(module.can.fit()) {
                                $module
                                    .css({
                                        top: '',
                                        marginTop: -(module.cache.height / 2)
                                    })
                                ;
                            }
                            else {
                                $module
                                    .css({
                                        marginTop : '',
                                        top       : $document.scrollTop()
                                    })
                                ;
                            }
                        },
                        undetached: function() {
                            $dimmable.addClass(className.undetached);
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            if($.isPlainObject(settings[name])) {
                                $.extend(true, settings[name], value);
                            }
                            else {
                                settings[name] = value;
                            }
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.modal.settings = {

        name           : 'Modal',
        namespace      : 'modal',

        silent         : false,
        debug          : false,
        verbose        : false,
        performance    : true,

        observeChanges : false,

        allowMultiple  : false,
        detachable     : true,
        closable       : true,
        autofocus      : true,

        inverted       : false,
        blurring       : false,

        dimmerSettings : {
            closable : false,
            useCSS   : true
        },

        // whether to use keyboard shortcuts
        keyboardShortcuts: true,

        context    : 'body',

        queue      : false,
        duration   : 500,
        offset     : 0,
        transition : 'scale',

        // padding with edge of page
        padding    : 50,

        // called before show animation
        onShow     : function(){},

        // called after show animation
        onVisible  : function(){},

        // called before hide animation
        onHide     : function(){ return true; },

        // called after hide animation
        onHidden   : function(){},

        // called after approve selector match
        onApprove  : function(){ return true; },

        // called after deny selector match
        onDeny     : function(){ return true; },

        selector    : {
            close    : '> .close',
            approve  : '.actions .positive, .actions .approve, .actions .ok',
            deny     : '.actions .negative, .actions .deny, .actions .cancel',
            modal    : '.ui.modal'
        },
        error : {
            dimmer    : 'UI Dimmer, a required component is not included in this page',
            method    : 'The method you called is not defined.',
            notFound  : 'The element you specified could not be found'
        },
        className : {
            active     : 'active',
            animating  : 'animating',
            blurring   : 'blurring',
            scrolling  : 'scrolling',
            undetached : 'undetached'
        }
    };


})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Nag
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.nag = function(parameters) {
        var
            $allModules    = $(this),
            moduleSelector = $allModules.selector || '',

            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),
            returnedValue
        ;
        $allModules
            .each(function() {
                var
                    settings          = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.nag.settings, parameters)
                        : $.extend({}, $.fn.nag.settings),

                    className       = settings.className,
                    selector        = settings.selector,
                    error           = settings.error,
                    namespace       = settings.namespace,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = namespace + '-module',

                    $module         = $(this),

                    $close          = $module.find(selector.close),
                    $context        = (settings.context)
                        ? $(settings.context)
                        : $('body'),

                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    moduleOffset,
                    moduleHeight,

                    contextWidth,
                    contextHeight,
                    contextOffset,

                    yOffset,
                    yPosition,

                    timer,
                    module,

                    requestAnimationFrame = window.requestAnimationFrame
                        || window.mozRequestAnimationFrame
                        || window.webkitRequestAnimationFrame
                        || window.msRequestAnimationFrame
                        || function(callback) { setTimeout(callback, 0); }
                ;
                module = {

                    initialize: function() {
                        module.verbose('Initializing element');

                        $module
                            .on('click' + eventNamespace, selector.close, module.dismiss)
                            .data(moduleNamespace, module)
                        ;

                        if(settings.detachable && $module.parent()[0] !== $context[0]) {
                            $module
                                .detach()
                                .prependTo($context)
                            ;
                        }

                        if(settings.displayTime > 0) {
                            setTimeout(module.hide, settings.displayTime);
                        }
                        module.show();
                    },

                    destroy: function() {
                        module.verbose('Destroying instance');
                        $module
                            .removeData(moduleNamespace)
                            .off(eventNamespace)
                        ;
                    },

                    show: function() {
                        if( module.should.show() && !$module.is(':visible') ) {
                            module.debug('Showing nag', settings.animation.show);
                            if(settings.animation.show == 'fade') {
                                $module
                                    .fadeIn(settings.duration, settings.easing)
                                ;
                            }
                            else {
                                $module
                                    .slideDown(settings.duration, settings.easing)
                                ;
                            }
                        }
                    },

                    hide: function() {
                        module.debug('Showing nag', settings.animation.hide);
                        if(settings.animation.show == 'fade') {
                            $module
                                .fadeIn(settings.duration, settings.easing)
                            ;
                        }
                        else {
                            $module
                                .slideUp(settings.duration, settings.easing)
                            ;
                        }
                    },

                    onHide: function() {
                        module.debug('Removing nag', settings.animation.hide);
                        $module.remove();
                        if (settings.onHide) {
                            settings.onHide();
                        }
                    },

                    dismiss: function(event) {
                        if(settings.storageMethod) {
                            module.storage.set(settings.key, settings.value);
                        }
                        module.hide();
                        event.stopImmediatePropagation();
                        event.preventDefault();
                    },

                    should: {
                        show: function() {
                            if(settings.persist) {
                                module.debug('Persistent nag is set, can show nag');
                                return true;
                            }
                            if( module.storage.get(settings.key) != settings.value.toString() ) {
                                module.debug('Stored value is not set, can show nag', module.storage.get(settings.key));
                                return true;
                            }
                            module.debug('Stored value is set, cannot show nag', module.storage.get(settings.key));
                            return false;
                        }
                    },

                    get: {
                        storageOptions: function() {
                            var
                                options = {}
                            ;
                            if(settings.expires) {
                                options.expires = settings.expires;
                            }
                            if(settings.domain) {
                                options.domain = settings.domain;
                            }
                            if(settings.path) {
                                options.path = settings.path;
                            }
                            return options;
                        }
                    },

                    clear: function() {
                        module.storage.remove(settings.key);
                    },

                    storage: {
                        set: function(key, value) {
                            var
                                options = module.get.storageOptions()
                            ;
                            if(settings.storageMethod == 'localstorage' && window.localStorage !== undefined) {
                                window.localStorage.setItem(key, value);
                                module.debug('Value stored using local storage', key, value);
                            }
                            else if(settings.storageMethod == 'sessionstorage' && window.sessionStorage !== undefined) {
                                window.sessionStorage.setItem(key, value);
                                module.debug('Value stored using session storage', key, value);
                            }
                            else if($.cookie !== undefined) {
                                $.cookie(key, value, options);
                                module.debug('Value stored using cookie', key, value, options);
                            }
                            else {
                                module.error(error.noCookieStorage);
                                return;
                            }
                        },
                        get: function(key, value) {
                            var
                                storedValue
                            ;
                            if(settings.storageMethod == 'localstorage' && window.localStorage !== undefined) {
                                storedValue = window.localStorage.getItem(key);
                            }
                            else if(settings.storageMethod == 'sessionstorage' && window.sessionStorage !== undefined) {
                                storedValue = window.sessionStorage.getItem(key);
                            }
                            // get by cookie
                            else if($.cookie !== undefined) {
                                storedValue = $.cookie(key);
                            }
                            else {
                                module.error(error.noCookieStorage);
                            }
                            if(storedValue == 'undefined' || storedValue == 'null' || storedValue === undefined || storedValue === null) {
                                storedValue = undefined;
                            }
                            return storedValue;
                        },
                        remove: function(key) {
                            var
                                options = module.get.storageOptions()
                            ;
                            if(settings.storageMethod == 'localstorage' && window.localStorage !== undefined) {
                                window.localStorage.removeItem(key);
                            }
                            else if(settings.storageMethod == 'sessionstorage' && window.sessionStorage !== undefined) {
                                window.sessionStorage.removeItem(key);
                            }
                            // store by cookie
                            else if($.cookie !== undefined) {
                                $.removeCookie(key, options);
                            }
                            else {
                                module.error(error.noStorage);
                            }
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            if($.isPlainObject(settings[name])) {
                                $.extend(true, settings[name], value);
                            }
                            else {
                                settings[name] = value;
                            }
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.nag.settings = {

        name        : 'Nag',

        silent      : false,
        debug       : false,
        verbose     : false,
        performance : true,

        namespace   : 'Nag',

        // allows cookie to be overridden
        persist     : false,

        // set to zero to require manually dismissal, otherwise hides on its own
        displayTime : 0,

        animation   : {
            show : 'slide',
            hide : 'slide'
        },

        context       : false,
        detachable    : false,

        expires       : 30,
        domain        : false,
        path          : '/',

        // type of storage to use
        storageMethod : 'cookie',

        // value to store in dismissed localstorage/cookie
        key           : 'nag',
        value         : 'dismiss',

        error: {
            noCookieStorage : '$.cookie is not included. A storage solution is required.',
            noStorage       : 'Neither $.cookie or store is defined. A storage solution is required for storing state',
            method          : 'The method you called is not defined.'
        },

        className     : {
            bottom : 'bottom',
            fixed  : 'fixed'
        },

        selector      : {
            close : '.close.icon'
        },

        speed         : 500,
        easing        : 'easeOutQuad',

        onHide: function() {}

    };

// Adds easing
    $.extend( $.easing, {
        easeOutQuad: function (x, t, b, c, d) {
            return -c *(t/=d)*(t-2) + b;
        }
    });

})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Popup
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.popup = function(parameters) {
        var
            $allModules    = $(this),
            $document      = $(document),
            $window        = $(window),
            $body          = $('body'),

            moduleSelector = $allModules.selector || '',

            hasTouch       = (true),
            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),

            returnedValue
        ;
        $allModules
            .each(function() {
                var
                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.popup.settings, parameters)
                        : $.extend({}, $.fn.popup.settings),

                    selector           = settings.selector,
                    className          = settings.className,
                    error              = settings.error,
                    metadata           = settings.metadata,
                    namespace          = settings.namespace,

                    eventNamespace     = '.' + settings.namespace,
                    moduleNamespace    = 'module-' + namespace,

                    $module            = $(this),
                    $context           = $(settings.context),
                    $scrollContext     = $(settings.scrollContext),
                    $boundary          = $(settings.boundary),
                    $target            = (settings.target)
                        ? $(settings.target)
                        : $module,

                    $popup,
                    $offsetParent,

                    searchDepth        = 0,
                    triedPositions     = false,
                    openedWithTouch    = false,

                    element            = this,
                    instance           = $module.data(moduleNamespace),

                    documentObserver,
                    elementNamespace,
                    id,
                    module
                ;

                module = {

                    // binds events
                    initialize: function() {
                        module.debug('Initializing', $module);
                        module.createID();
                        module.bind.events();
                        if(!module.exists() && settings.preserve) {
                            module.create();
                        }
                        if(settings.observeChanges) {
                            module.observeChanges();
                        }
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, instance)
                        ;
                    },

                    observeChanges: function() {
                        if('MutationObserver' in window) {
                            documentObserver = new MutationObserver(module.event.documentChanged);
                            documentObserver.observe(document, {
                                childList : true,
                                subtree   : true
                            });
                            module.debug('Setting up mutation observer', documentObserver);
                        }
                    },

                    refresh: function() {
                        if(settings.popup) {
                            $popup = $(settings.popup).eq(0);
                        }
                        else {
                            if(settings.inline) {
                                $popup = $target.nextAll(selector.popup).eq(0);
                                settings.popup = $popup;
                            }
                        }
                        if(settings.popup) {
                            $popup.addClass(className.loading);
                            $offsetParent = module.get.offsetParent();
                            $popup.removeClass(className.loading);
                            if(settings.movePopup && module.has.popup() && module.get.offsetParent($popup)[0] !== $offsetParent[0]) {
                                module.debug('Moving popup to the same offset parent as activating element');
                                $popup
                                    .detach()
                                    .appendTo($offsetParent)
                                ;
                            }
                        }
                        else {
                            $offsetParent = (settings.inline)
                                ? module.get.offsetParent($target)
                                : module.has.popup()
                                    ? module.get.offsetParent($popup)
                                    : $body
                            ;
                        }
                        if( $offsetParent.is('html') && $offsetParent[0] !== $body[0] ) {
                            module.debug('Setting page as offset parent');
                            $offsetParent = $body;
                        }
                        if( module.get.variation() ) {
                            module.set.variation();
                        }
                    },

                    reposition: function() {
                        module.refresh();
                        module.set.position();
                    },

                    destroy: function() {
                        module.debug('Destroying previous module');
                        if(documentObserver) {
                            documentObserver.disconnect();
                        }
                        // remove element only if was created dynamically
                        if($popup && !settings.preserve) {
                            module.removePopup();
                        }
                        // clear all timeouts
                        clearTimeout(module.hideTimer);
                        clearTimeout(module.showTimer);
                        // remove events
                        module.unbind.close();
                        module.unbind.events();
                        $module
                            .removeData(moduleNamespace)
                        ;
                    },

                    event: {
                        start:  function(event) {
                            var
                                delay = ($.isPlainObject(settings.delay))
                                    ? settings.delay.show
                                    : settings.delay
                            ;
                            clearTimeout(module.hideTimer);
                            if(!openedWithTouch) {
                                module.showTimer = setTimeout(module.show, delay);
                            }
                        },
                        end:  function() {
                            var
                                delay = ($.isPlainObject(settings.delay))
                                    ? settings.delay.hide
                                    : settings.delay
                            ;
                            clearTimeout(module.showTimer);
                            module.hideTimer = setTimeout(module.hide, delay);
                        },
                        touchstart: function(event) {
                            openedWithTouch = true;
                            module.show();
                        },
                        resize: function() {
                            if( module.is.visible() ) {
                                module.set.position();
                            }
                        },
                        documentChanged: function(mutations) {
                            [].forEach.call(mutations, function(mutation) {
                                if(mutation.removedNodes) {
                                    [].forEach.call(mutation.removedNodes, function(node) {
                                        if(node == element || $(node).find(element).length > 0) {
                                            module.debug('Element removed from DOM, tearing down events');
                                            module.destroy();
                                        }
                                    });
                                }
                            });
                        },
                        hideGracefully: function(event) {
                            var
                                $target = $(event.target),
                                isInDOM = $.contains(document.documentElement, event.target),
                                inPopup = ($target.closest(selector.popup).length > 0)
                            ;
                            // don't close on clicks inside popup
                            if(event && !inPopup && isInDOM) {
                                module.debug('Click occurred outside popup hiding popup');
                                module.hide();
                            }
                            else {
                                module.debug('Click was inside popup, keeping popup open');
                            }
                        }
                    },

                    // generates popup html from metadata
                    create: function() {
                        var
                            html      = module.get.html(),
                            title     = module.get.title(),
                            content   = module.get.content()
                        ;

                        if(html || content || title) {
                            module.debug('Creating pop-up html');
                            if(!html) {
                                html = settings.templates.popup({
                                    title   : title,
                                    content : content
                                });
                            }
                            $popup = $('<div/>')
                                .addClass(className.popup)
                                .data(metadata.activator, $module)
                                .html(html)
                            ;
                            if(settings.inline) {
                                module.verbose('Inserting popup element inline', $popup);
                                $popup
                                    .insertAfter($module)
                                ;
                            }
                            else {
                                module.verbose('Appending popup element to body', $popup);
                                $popup
                                    .appendTo( $context )
                                ;
                            }
                            module.refresh();
                            module.set.variation();

                            if(settings.hoverable) {
                                module.bind.popup();
                            }
                            settings.onCreate.call($popup, element);
                        }
                        else if($target.next(selector.popup).length !== 0) {
                            module.verbose('Pre-existing popup found');
                            settings.inline = true;
                            settings.popup  = $target.next(selector.popup).data(metadata.activator, $module);
                            module.refresh();
                            if(settings.hoverable) {
                                module.bind.popup();
                            }
                        }
                        else if(settings.popup) {
                            $(settings.popup).data(metadata.activator, $module);
                            module.verbose('Used popup specified in settings');
                            module.refresh();
                            if(settings.hoverable) {
                                module.bind.popup();
                            }
                        }
                        else {
                            module.debug('No content specified skipping display', element);
                        }
                    },

                    createID: function() {
                        id = (Math.random().toString(16) + '000000000').substr(2, 8);
                        elementNamespace = '.' + id;
                        module.verbose('Creating unique id for element', id);
                    },

                    // determines popup state
                    toggle: function() {
                        module.debug('Toggling pop-up');
                        if( module.is.hidden() ) {
                            module.debug('Popup is hidden, showing pop-up');
                            module.unbind.close();
                            module.show();
                        }
                        else {
                            module.debug('Popup is visible, hiding pop-up');
                            module.hide();
                        }
                    },

                    show: function(callback) {
                        callback = callback || function(){};
                        module.debug('Showing pop-up', settings.transition);
                        if(module.is.hidden() && !( module.is.active() && module.is.dropdown()) ) {
                            if( !module.exists() ) {
                                module.create();
                            }
                            if(settings.onShow.call($popup, element) === false) {
                                module.debug('onShow callback returned false, cancelling popup animation');
                                return;
                            }
                            else if(!settings.preserve && !settings.popup) {
                                module.refresh();
                            }
                            if( $popup && module.set.position() ) {
                                module.save.conditions();
                                if(settings.exclusive) {
                                    module.hideAll();
                                }
                                module.animate.show(callback);
                            }
                        }
                    },


                    hide: function(callback) {
                        callback = callback || function(){};
                        if( module.is.visible() || module.is.animating() ) {
                            if(settings.onHide.call($popup, element) === false) {
                                module.debug('onHide callback returned false, cancelling popup animation');
                                return;
                            }
                            module.remove.visible();
                            module.unbind.close();
                            module.restore.conditions();
                            module.animate.hide(callback);
                        }
                    },

                    hideAll: function() {
                        $(selector.popup)
                            .filter('.' + className.visible)
                            .each(function() {
                                $(this)
                                    .data(metadata.activator)
                                    .popup('hide')
                                ;
                            })
                        ;
                    },
                    exists: function() {
                        if(!$popup) {
                            return false;
                        }
                        if(settings.inline || settings.popup) {
                            return ( module.has.popup() );
                        }
                        else {
                            return ( $popup.closest($context).length >= 1 )
                                ? true
                                : false
                                ;
                        }
                    },

                    removePopup: function() {
                        if( module.has.popup() && !settings.popup) {
                            module.debug('Removing popup', $popup);
                            $popup.remove();
                            $popup = undefined;
                            settings.onRemove.call($popup, element);
                        }
                    },

                    save: {
                        conditions: function() {
                            module.cache = {
                                title: $module.attr('title')
                            };
                            if (module.cache.title) {
                                $module.removeAttr('title');
                            }
                            module.verbose('Saving original attributes', module.cache.title);
                        }
                    },
                    restore: {
                        conditions: function() {
                            if(module.cache && module.cache.title) {
                                $module.attr('title', module.cache.title);
                                module.verbose('Restoring original attributes', module.cache.title);
                            }
                            return true;
                        }
                    },
                    supports: {
                        svg: function() {
                            return (typeof SVGGraphicsElement === undefined);
                        }
                    },
                    animate: {
                        show: function(callback) {
                            callback = $.isFunction(callback) ? callback : function(){};
                            if(settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
                                module.set.visible();
                                $popup
                                    .transition({
                                        animation  : settings.transition + ' in',
                                        queue      : false,
                                        debug      : settings.debug,
                                        verbose    : settings.verbose,
                                        duration   : settings.duration,
                                        onComplete : function() {
                                            module.bind.close();
                                            callback.call($popup, element);
                                            settings.onVisible.call($popup, element);
                                        }
                                    })
                                ;
                            }
                            else {
                                module.error(error.noTransition);
                            }
                        },
                        hide: function(callback) {
                            callback = $.isFunction(callback) ? callback : function(){};
                            module.debug('Hiding pop-up');
                            if(settings.onHide.call($popup, element) === false) {
                                module.debug('onHide callback returned false, cancelling popup animation');
                                return;
                            }
                            if(settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {
                                $popup
                                    .transition({
                                        animation  : settings.transition + ' out',
                                        queue      : false,
                                        duration   : settings.duration,
                                        debug      : settings.debug,
                                        verbose    : settings.verbose,
                                        onComplete : function() {
                                            module.reset();
                                            callback.call($popup, element);
                                            settings.onHidden.call($popup, element);
                                        }
                                    })
                                ;
                            }
                            else {
                                module.error(error.noTransition);
                            }
                        }
                    },

                    change: {
                        content: function(html) {
                            $popup.html(html);
                        }
                    },

                    get: {
                        html: function() {
                            $module.removeData(metadata.html);
                            return $module.data(metadata.html) || settings.html;
                        },
                        title: function() {
                            $module.removeData(metadata.title);
                            return $module.data(metadata.title) || settings.title;
                        },
                        content: function() {
                            $module.removeData(metadata.content);
                            return $module.data(metadata.content) || $module.attr('title') || settings.content;
                        },
                        variation: function() {
                            $module.removeData(metadata.variation);
                            return $module.data(metadata.variation) || settings.variation;
                        },
                        popup: function() {
                            return $popup;
                        },
                        popupOffset: function() {
                            return $popup.offset();
                        },
                        calculations: function() {
                            var
                                targetElement    = $target[0],
                                isWindow         = ($boundary[0] == window),
                                targetPosition   = (settings.inline || (settings.popup && settings.movePopup))
                                    ? $target.position()
                                    : $target.offset(),
                                screenPosition = (isWindow)
                                    ? { top: 0, left: 0 }
                                    : $boundary.offset(),
                                calculations   = {},
                                scroll = (isWindow)
                                    ? { top: $window.scrollTop(), left: $window.scrollLeft() }
                                    : { top: 0, left: 0},
                                screen
                            ;
                            calculations = {
                                // element which is launching popup
                                target : {
                                    element : $target[0],
                                    width   : $target.outerWidth(),
                                    height  : $target.outerHeight(),
                                    top     : targetPosition.top,
                                    left    : targetPosition.left,
                                    margin  : {}
                                },
                                // popup itself
                                popup : {
                                    width  : $popup.outerWidth(),
                                    height : $popup.outerHeight()
                                },
                                // offset container (or 3d context)
                                parent : {
                                    width  : $offsetParent.outerWidth(),
                                    height : $offsetParent.outerHeight()
                                },
                                // screen boundaries
                                screen : {
                                    top  : screenPosition.top,
                                    left : screenPosition.left,
                                    scroll: {
                                        top  : scroll.top,
                                        left : scroll.left
                                    },
                                    width  : $boundary.width(),
                                    height : $boundary.height()
                                }
                            };

                            // add in container calcs if fluid
                            if( settings.setFluidWidth && module.is.fluid() ) {
                                calculations.container = {
                                    width: $popup.parent().outerWidth()
                                };
                                calculations.popup.width = calculations.container.width;
                            }

                            // add in margins if inline
                            calculations.target.margin.top = (settings.inline)
                                ? parseInt( window.getComputedStyle(targetElement).getPropertyValue('margin-top'), 10)
                                : 0
                            ;
                            calculations.target.margin.left = (settings.inline)
                                ? module.is.rtl()
                                    ? parseInt( window.getComputedStyle(targetElement).getPropertyValue('margin-right'), 10)
                                    : parseInt( window.getComputedStyle(targetElement).getPropertyValue('margin-left'), 10)
                                : 0
                            ;
                            // calculate screen boundaries
                            screen = calculations.screen;
                            calculations.boundary = {
                                top    : screen.top + screen.scroll.top,
                                bottom : screen.top + screen.scroll.top + screen.height,
                                left   : screen.left + screen.scroll.left,
                                right  : screen.left + screen.scroll.left + screen.width
                            };
                            return calculations;
                        },
                        id: function() {
                            return id;
                        },
                        startEvent: function() {
                            if(settings.on == 'hover') {
                                return 'mouseenter';
                            }
                            else if(settings.on == 'focus') {
                                return 'focus';
                            }
                            return false;
                        },
                        scrollEvent: function() {
                            return 'scroll';
                        },
                        endEvent: function() {
                            if(settings.on == 'hover') {
                                return 'mouseleave';
                            }
                            else if(settings.on == 'focus') {
                                return 'blur';
                            }
                            return false;
                        },
                        distanceFromBoundary: function(offset, calculations) {
                            var
                                distanceFromBoundary = {},
                                popup,
                                boundary
                            ;
                            calculations = calculations || module.get.calculations();

                            // shorthand
                            popup        = calculations.popup;
                            boundary     = calculations.boundary;

                            if(offset) {
                                distanceFromBoundary = {
                                    top    : (offset.top - boundary.top),
                                    left   : (offset.left - boundary.left),
                                    right  : (boundary.right - (offset.left + popup.width) ),
                                    bottom : (boundary.bottom - (offset.top + popup.height) )
                                };
                                module.verbose('Distance from boundaries determined', offset, distanceFromBoundary);
                            }
                            return distanceFromBoundary;
                        },
                        offsetParent: function($target) {
                            var
                                element = ($target !== undefined)
                                    ? $target[0]
                                    : $module[0],
                                parentNode = element.parentNode,
                                $node    = $(parentNode)
                            ;
                            if(parentNode) {
                                var
                                    is2D     = ($node.css('transform') === 'none'),
                                    isStatic = ($node.css('position') === 'static'),
                                    isHTML   = $node.is('html')
                                ;
                                while(parentNode && !isHTML && isStatic && is2D) {
                                    parentNode = parentNode.parentNode;
                                    $node    = $(parentNode);
                                    is2D     = ($node.css('transform') === 'none');
                                    isStatic = ($node.css('position') === 'static');
                                    isHTML   = $node.is('html');
                                }
                            }
                            return ($node && $node.length > 0)
                                ? $node
                                : $()
                                ;
                        },
                        positions: function() {
                            return {
                                'top left'      : false,
                                'top center'    : false,
                                'top right'     : false,
                                'bottom left'   : false,
                                'bottom center' : false,
                                'bottom right'  : false,
                                'left center'   : false,
                                'right center'  : false
                            };
                        },
                        nextPosition: function(position) {
                            var
                                positions          = position.split(' '),
                                verticalPosition   = positions[0],
                                horizontalPosition = positions[1],
                                opposite = {
                                    top    : 'bottom',
                                    bottom : 'top',
                                    left   : 'right',
                                    right  : 'left'
                                },
                                adjacent = {
                                    left   : 'center',
                                    center : 'right',
                                    right  : 'left'
                                },
                                backup = {
                                    'top left'      : 'top center',
                                    'top center'    : 'top right',
                                    'top right'     : 'right center',
                                    'right center'  : 'bottom right',
                                    'bottom right'  : 'bottom center',
                                    'bottom center' : 'bottom left',
                                    'bottom left'   : 'left center',
                                    'left center'   : 'top left'
                                },
                                adjacentsAvailable = (verticalPosition == 'top' || verticalPosition == 'bottom'),
                                oppositeTried = false,
                                adjacentTried = false,
                                nextPosition  = false
                            ;
                            if(!triedPositions) {
                                module.verbose('All available positions available');
                                triedPositions = module.get.positions();
                            }

                            module.debug('Recording last position tried', position);
                            triedPositions[position] = true;

                            if(settings.prefer === 'opposite') {
                                nextPosition  = [opposite[verticalPosition], horizontalPosition];
                                nextPosition  = nextPosition.join(' ');
                                oppositeTried = (triedPositions[nextPosition] === true);
                                module.debug('Trying opposite strategy', nextPosition);
                            }
                            if((settings.prefer === 'adjacent') && adjacentsAvailable ) {
                                nextPosition  = [verticalPosition, adjacent[horizontalPosition]];
                                nextPosition  = nextPosition.join(' ');
                                adjacentTried = (triedPositions[nextPosition] === true);
                                module.debug('Trying adjacent strategy', nextPosition);
                            }
                            if(adjacentTried || oppositeTried) {
                                module.debug('Using backup position', nextPosition);
                                nextPosition = backup[position];
                            }
                            return nextPosition;
                        }
                    },

                    set: {
                        position: function(position, calculations) {

                            // exit conditions
                            if($target.length === 0 || $popup.length === 0) {
                                module.error(error.notFound);
                                return;
                            }
                            var
                                offset,
                                distanceAway,
                                target,
                                popup,
                                parent,
                                positioning,
                                popupOffset,
                                distanceFromBoundary
                            ;

                            calculations = calculations || module.get.calculations();
                            position     = position     || $module.data(metadata.position) || settings.position;

                            offset       = $module.data(metadata.offset) || settings.offset;
                            distanceAway = settings.distanceAway;

                            // shorthand
                            target = calculations.target;
                            popup  = calculations.popup;
                            parent = calculations.parent;

                            if(target.width === 0 && target.height === 0 && !module.is.svg(target.element)) {
                                module.debug('Popup target is hidden, no action taken');
                                return false;
                            }

                            if(settings.inline) {
                                module.debug('Adding margin to calculation', target.margin);
                                if(position == 'left center' || position == 'right center') {
                                    offset       +=  target.margin.top;
                                    distanceAway += -target.margin.left;
                                }
                                else if (position == 'top left' || position == 'top center' || position == 'top right') {
                                    offset       += target.margin.left;
                                    distanceAway -= target.margin.top;
                                }
                                else {
                                    offset       += target.margin.left;
                                    distanceAway += target.margin.top;
                                }
                            }

                            module.debug('Determining popup position from calculations', position, calculations);

                            if (module.is.rtl()) {
                                position = position.replace(/left|right/g, function (match) {
                                    return (match == 'left')
                                        ? 'right'
                                        : 'left'
                                        ;
                                });
                                module.debug('RTL: Popup position updated', position);
                            }

                            // if last attempt use specified last resort position
                            if(searchDepth == settings.maxSearchDepth && typeof settings.lastResort === 'string') {
                                position = settings.lastResort;
                            }

                            switch (position) {
                                case 'top left':
                                    positioning = {
                                        top    : 'auto',
                                        bottom : parent.height - target.top + distanceAway,
                                        left   : target.left + offset,
                                        right  : 'auto'
                                    };
                                    break;
                                case 'top center':
                                    positioning = {
                                        bottom : parent.height - target.top + distanceAway,
                                        left   : target.left + (target.width / 2) - (popup.width / 2) + offset,
                                        top    : 'auto',
                                        right  : 'auto'
                                    };
                                    break;
                                case 'top right':
                                    positioning = {
                                        bottom :  parent.height - target.top + distanceAway,
                                        right  :  parent.width - target.left - target.width - offset,
                                        top    : 'auto',
                                        left   : 'auto'
                                    };
                                    break;
                                case 'left center':
                                    positioning = {
                                        top    : target.top + (target.height / 2) - (popup.height / 2) + offset,
                                        right  : parent.width - target.left + distanceAway,
                                        left   : 'auto',
                                        bottom : 'auto'
                                    };
                                    break;
                                case 'right center':
                                    positioning = {
                                        top    : target.top + (target.height / 2) - (popup.height / 2) + offset,
                                        left   : target.left + target.width + distanceAway,
                                        bottom : 'auto',
                                        right  : 'auto'
                                    };
                                    break;
                                case 'bottom left':
                                    positioning = {
                                        top    : target.top + target.height + distanceAway,
                                        left   : target.left + offset,
                                        bottom : 'auto',
                                        right  : 'auto'
                                    };
                                    break;
                                case 'bottom center':
                                    positioning = {
                                        top    : target.top + target.height + distanceAway,
                                        left   : target.left + (target.width / 2) - (popup.width / 2) + offset,
                                        bottom : 'auto',
                                        right  : 'auto'
                                    };
                                    break;
                                case 'bottom right':
                                    positioning = {
                                        top    : target.top + target.height + distanceAway,
                                        right  : parent.width - target.left  - target.width - offset,
                                        left   : 'auto',
                                        bottom : 'auto'
                                    };
                                    break;
                            }
                            if(positioning === undefined) {
                                module.error(error.invalidPosition, position);
                            }

                            module.debug('Calculated popup positioning values', positioning);

                            // tentatively place on stage
                            $popup
                                .css(positioning)
                                .removeClass(className.position)
                                .addClass(position)
                                .addClass(className.loading)
                            ;

                            popupOffset = module.get.popupOffset();

                            // see if any boundaries are surpassed with this tentative position
                            distanceFromBoundary = module.get.distanceFromBoundary(popupOffset, calculations);

                            if( module.is.offstage(distanceFromBoundary, position) ) {
                                module.debug('Position is outside viewport', position);
                                if(searchDepth < settings.maxSearchDepth) {
                                    searchDepth++;
                                    position = module.get.nextPosition(position);
                                    module.debug('Trying new position', position);
                                    return ($popup)
                                        ? module.set.position(position, calculations)
                                        : false
                                        ;
                                }
                                else {
                                    if(settings.lastResort) {
                                        module.debug('No position found, showing with last position');
                                    }
                                    else {
                                        module.debug('Popup could not find a position to display', $popup);
                                        module.error(error.cannotPlace, element);
                                        module.remove.attempts();
                                        module.remove.loading();
                                        module.reset();
                                        settings.onUnplaceable.call($popup, element);
                                        return false;
                                    }
                                }
                            }
                            module.debug('Position is on stage', position);
                            module.remove.attempts();
                            module.remove.loading();
                            if( settings.setFluidWidth && module.is.fluid() ) {
                                module.set.fluidWidth(calculations);
                            }
                            return true;
                        },

                        fluidWidth: function(calculations) {
                            calculations = calculations || module.get.calculations();
                            module.debug('Automatically setting element width to parent width', calculations.parent.width);
                            $popup.css('width', calculations.container.width);
                        },

                        variation: function(variation) {
                            variation = variation || module.get.variation();
                            if(variation && module.has.popup() ) {
                                module.verbose('Adding variation to popup', variation);
                                $popup.addClass(variation);
                            }
                        },

                        visible: function() {
                            $module.addClass(className.visible);
                        }
                    },

                    remove: {
                        loading: function() {
                            $popup.removeClass(className.loading);
                        },
                        variation: function(variation) {
                            variation = variation || module.get.variation();
                            if(variation) {
                                module.verbose('Removing variation', variation);
                                $popup.removeClass(variation);
                            }
                        },
                        visible: function() {
                            $module.removeClass(className.visible);
                        },
                        attempts: function() {
                            module.verbose('Resetting all searched positions');
                            searchDepth    = 0;
                            triedPositions = false;
                        }
                    },

                    bind: {
                        events: function() {
                            module.debug('Binding popup events to module');
                            if(settings.on == 'click') {
                                $module
                                    .on('click' + eventNamespace, module.toggle)
                                ;
                            }
                            if(settings.on == 'hover' && hasTouch) {
                                $module
                                    .on('touchstart' + eventNamespace, module.event.touchstart)
                                ;
                            }
                            if( module.get.startEvent() ) {
                                $module
                                    .on(module.get.startEvent() + eventNamespace, module.event.start)
                                    .on(module.get.endEvent() + eventNamespace, module.event.end)
                                ;
                            }
                            if(settings.target) {
                                module.debug('Target set to element', $target);
                            }
                            $window.on('resize' + elementNamespace, module.event.resize);
                        },
                        popup: function() {
                            module.verbose('Allowing hover events on popup to prevent closing');
                            if( $popup && module.has.popup() ) {
                                $popup
                                    .on('mouseenter' + eventNamespace, module.event.start)
                                    .on('mouseleave' + eventNamespace, module.event.end)
                                ;
                            }
                        },
                        close: function() {
                            if(settings.hideOnScroll === true || (settings.hideOnScroll == 'auto' && settings.on != 'click')) {
                                $scrollContext
                                    .one(module.get.scrollEvent() + elementNamespace, module.event.hideGracefully)
                                ;
                            }
                            if(settings.on == 'hover' && openedWithTouch) {
                                module.verbose('Binding popup close event to document');
                                $document
                                    .on('touchstart' + elementNamespace, function(event) {
                                        module.verbose('Touched away from popup');
                                        module.event.hideGracefully.call(element, event);
                                    })
                                ;
                            }
                            if(settings.on == 'click' && settings.closable) {
                                module.verbose('Binding popup close event to document');
                                $document
                                    .on('click' + elementNamespace, function(event) {
                                        module.verbose('Clicked away from popup');
                                        module.event.hideGracefully.call(element, event);
                                    })
                                ;
                            }
                        }
                    },

                    unbind: {
                        events: function() {
                            $window
                                .off(elementNamespace)
                            ;
                            $module
                                .off(eventNamespace)
                            ;
                        },
                        close: function() {
                            $document
                                .off(elementNamespace)
                            ;
                            $scrollContext
                                .off(elementNamespace)
                            ;
                        },
                    },

                    has: {
                        popup: function() {
                            return ($popup && $popup.length > 0);
                        }
                    },

                    is: {
                        offstage: function(distanceFromBoundary, position) {
                            var
                                offstage = []
                            ;
                            // return boundaries that have been surpassed
                            $.each(distanceFromBoundary, function(direction, distance) {
                                if(distance < -settings.jitter) {
                                    module.debug('Position exceeds allowable distance from edge', direction, distance, position);
                                    offstage.push(direction);
                                }
                            });
                            if(offstage.length > 0) {
                                return true;
                            }
                            else {
                                return false;
                            }
                        },
                        svg: function(element) {
                            return module.supports.svg() && (element instanceof SVGGraphicsElement);
                        },
                        active: function() {
                            return $module.hasClass(className.active);
                        },
                        animating: function() {
                            return ($popup !== undefined && $popup.hasClass(className.animating) );
                        },
                        fluid: function() {
                            return ($popup !== undefined && $popup.hasClass(className.fluid));
                        },
                        visible: function() {
                            return ($popup !== undefined && $popup.hasClass(className.visible));
                        },
                        dropdown: function() {
                            return $module.hasClass(className.dropdown);
                        },
                        hidden: function() {
                            return !module.is.visible();
                        },
                        rtl: function () {
                            return $module.css('direction') == 'rtl';
                        }
                    },

                    reset: function() {
                        module.remove.visible();
                        if(settings.preserve) {
                            if($.fn.transition !== undefined) {
                                $popup
                                    .transition('remove transition')
                                ;
                            }
                        }
                        else {
                            module.removePopup();
                        }
                    },

                    setting: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.popup.settings = {

        name           : 'Popup',

        // module settings
        silent         : false,
        debug          : false,
        verbose        : false,
        performance    : true,
        namespace      : 'popup',

        // whether it should use dom mutation observers
        observeChanges : true,

        // callback only when element added to dom
        onCreate       : function(){},

        // callback before element removed from dom
        onRemove       : function(){},

        // callback before show animation
        onShow         : function(){},

        // callback after show animation
        onVisible      : function(){},

        // callback before hide animation
        onHide         : function(){},

        // callback when popup cannot be positioned in visible screen
        onUnplaceable  : function(){},

        // callback after hide animation
        onHidden       : function(){},

        // when to show popup
        on             : 'hover',

        // element to use to determine if popup is out of boundary
        boundary       : window,

        // whether to add touchstart events when using hover
        addTouchEvents : true,

        // default position relative to element
        position       : 'top left',

        // name of variation to use
        variation      : '',

        // whether popup should be moved to context
        movePopup      : true,

        // element which popup should be relative to
        target         : false,

        // jq selector or element that should be used as popup
        popup          : false,

        // popup should remain inline next to activator
        inline         : false,

        // popup should be removed from page on hide
        preserve       : false,

        // popup should not close when being hovered on
        hoverable      : false,

        // explicitly set content
        content        : false,

        // explicitly set html
        html           : false,

        // explicitly set title
        title          : false,

        // whether automatically close on clickaway when on click
        closable       : true,

        // automatically hide on scroll
        hideOnScroll   : 'auto',

        // hide other popups on show
        exclusive      : false,

        // context to attach popups
        context        : 'body',

        // context for binding scroll events
        scrollContext  : window,

        // position to prefer when calculating new position
        prefer         : 'opposite',

        // specify position to appear even if it doesn't fit
        lastResort     : false,

        // delay used to prevent accidental refiring of animations due to user error
        delay        : {
            show : 50,
            hide : 70
        },

        // whether fluid variation should assign width explicitly
        setFluidWidth  : true,

        // transition settings
        duration       : 200,
        transition     : 'scale',

        // distance away from activating element in px
        distanceAway   : 0,

        // number of pixels an element is allowed to be "offstage" for a position to be chosen (allows for rounding)
        jitter         : 2,

        // offset on aligning axis from calculated position
        offset         : 0,

        // maximum times to look for a position before failing (9 positions total)
        maxSearchDepth : 15,

        error: {
            invalidPosition : 'The position you specified is not a valid position',
            cannotPlace     : 'Popup does not fit within the boundaries of the viewport',
            method          : 'The method you called is not defined.',
            noTransition    : 'This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>',
            notFound        : 'The target or popup you specified does not exist on the page'
        },

        metadata: {
            activator : 'activator',
            content   : 'content',
            html      : 'html',
            offset    : 'offset',
            position  : 'position',
            title     : 'title',
            variation : 'variation'
        },

        className   : {
            active    : 'active',
            animating : 'animating',
            dropdown  : 'dropdown',
            fluid     : 'fluid',
            loading   : 'loading',
            popup     : 'ui popup',
            position  : 'top left center bottom right',
            visible   : 'visible'
        },

        selector    : {
            popup    : '.ui.popup'
        },

        templates: {
            escape: function(string) {
                var
                    badChars     = /[&<>"'`]/g,
                    shouldEscape = /[&<>"'`]/,
                    escape       = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#x27;",
                        "`": "&#x60;"
                    },
                    escapedChar  = function(chr) {
                        return escape[chr];
                    }
                ;
                if(shouldEscape.test(string)) {
                    return string.replace(badChars, escapedChar);
                }
                return string;
            },
            popup: function(text) {
                var
                    html   = '',
                    escape = $.fn.popup.settings.templates.escape
                ;
                if(typeof text !== undefined) {
                    if(typeof text.title !== undefined && text.title) {
                        text.title = escape(text.title);
                        html += '<div class="header">' + text.title + '</div>';
                    }
                    if(typeof text.content !== undefined && text.content) {
                        text.content = escape(text.content);
                        html += '<div class="content">' + text.content + '</div>';
                    }
                }
                return html;
            }
        }

    };


})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Progress
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    var
        global = (typeof window != 'undefined' && window.Math == Math)
            ? window
            : (typeof self != 'undefined' && self.Math == Math)
                ? self
                : Function('return this')()
    ;

    $.fn.progress = function(parameters) {
        var
            $allModules    = $(this),

            moduleSelector = $allModules.selector || '',

            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),

            returnedValue
        ;

        $allModules
            .each(function() {
                var
                    settings          = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.progress.settings, parameters)
                        : $.extend({}, $.fn.progress.settings),

                    className       = settings.className,
                    metadata        = settings.metadata,
                    namespace       = settings.namespace,
                    selector        = settings.selector,
                    error           = settings.error,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    $module         = $(this),
                    $bar            = $(this).find(selector.bar),
                    $progress       = $(this).find(selector.progress),
                    $label          = $(this).find(selector.label),

                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    animating = false,
                    transitionEnd,
                    module
                ;

                module = {

                    initialize: function() {
                        module.debug('Initializing progress bar', settings);

                        module.set.duration();
                        module.set.transitionEvent();

                        module.read.metadata();
                        module.read.settings();

                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of progress', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },
                    destroy: function() {
                        module.verbose('Destroying previous progress for', $module);
                        clearInterval(instance.interval);
                        module.remove.state();
                        $module.removeData(moduleNamespace);
                        instance = undefined;
                    },

                    reset: function() {
                        module.remove.nextValue();
                        module.update.progress(0);
                    },

                    complete: function() {
                        if(module.percent === undefined || module.percent < 100) {
                            module.remove.progressPoll();
                            module.set.percent(100);
                        }
                    },

                    read: {
                        metadata: function() {
                            var
                                data = {
                                    percent : $module.data(metadata.percent),
                                    total   : $module.data(metadata.total),
                                    value   : $module.data(metadata.value)
                                }
                            ;
                            if(data.percent) {
                                module.debug('Current percent value set from metadata', data.percent);
                                module.set.percent(data.percent);
                            }
                            if(data.total) {
                                module.debug('Total value set from metadata', data.total);
                                module.set.total(data.total);
                            }
                            if(data.value) {
                                module.debug('Current value set from metadata', data.value);
                                module.set.value(data.value);
                                module.set.progress(data.value);
                            }
                        },
                        settings: function() {
                            if(settings.total !== false) {
                                module.debug('Current total set in settings', settings.total);
                                module.set.total(settings.total);
                            }
                            if(settings.value !== false) {
                                module.debug('Current value set in settings', settings.value);
                                module.set.value(settings.value);
                                module.set.progress(module.value);
                            }
                            if(settings.percent !== false) {
                                module.debug('Current percent set in settings', settings.percent);
                                module.set.percent(settings.percent);
                            }
                        }
                    },

                    bind: {
                        transitionEnd: function(callback) {
                            var
                                transitionEnd = module.get.transitionEnd()
                            ;
                            $bar
                                .one(transitionEnd + eventNamespace, function(event) {
                                    clearTimeout(module.failSafeTimer);
                                    callback.call(this, event);
                                })
                            ;
                            module.failSafeTimer = setTimeout(function() {
                                $bar.triggerHandler(transitionEnd);
                            }, settings.duration + settings.failSafeDelay);
                            module.verbose('Adding fail safe timer', module.timer);
                        }
                    },

                    increment: function(incrementValue) {
                        var
                            maxValue,
                            startValue,
                            newValue
                        ;
                        if( module.has.total() ) {
                            startValue     = module.get.value();
                            incrementValue = incrementValue || 1;
                            newValue       = startValue + incrementValue;
                        }
                        else {
                            startValue     = module.get.percent();
                            incrementValue = incrementValue || module.get.randomValue();

                            newValue       = startValue + incrementValue;
                            maxValue       = 100;
                            module.debug('Incrementing percentage by', startValue, newValue);
                        }
                        newValue = module.get.normalizedValue(newValue);
                        module.set.progress(newValue);
                    },
                    decrement: function(decrementValue) {
                        var
                            total     = module.get.total(),
                            startValue,
                            newValue
                        ;
                        if(total) {
                            startValue     =  module.get.value();
                            decrementValue =  decrementValue || 1;
                            newValue       =  startValue - decrementValue;
                            module.debug('Decrementing value by', decrementValue, startValue);
                        }
                        else {
                            startValue     =  module.get.percent();
                            decrementValue =  decrementValue || module.get.randomValue();
                            newValue       =  startValue - decrementValue;
                            module.debug('Decrementing percentage by', decrementValue, startValue);
                        }
                        newValue = module.get.normalizedValue(newValue);
                        module.set.progress(newValue);
                    },

                    has: {
                        progressPoll: function() {
                            return module.progressPoll;
                        },
                        total: function() {
                            return (module.get.total() !== false);
                        }
                    },

                    get: {
                        text: function(templateText) {
                            var
                                value   = module.value                || 0,
                                total   = module.total                || 0,
                                percent = (animating)
                                    ? module.get.displayPercent()
                                    : module.percent || 0,
                                left = (module.total > 0)
                                    ? (total - value)
                                    : (100 - percent)
                            ;
                            templateText = templateText || '';
                            templateText = templateText
                                .replace('{value}', value)
                                .replace('{total}', total)
                                .replace('{left}', left)
                                .replace('{percent}', percent)
                            ;
                            module.verbose('Adding variables to progress bar text', templateText);
                            return templateText;
                        },

                        normalizedValue: function(value) {
                            if(value < 0) {
                                module.debug('Value cannot decrement below 0');
                                return 0;
                            }
                            if(module.has.total()) {
                                if(value > module.total) {
                                    module.debug('Value cannot increment above total', module.total);
                                    return module.total;
                                }
                            }
                            else if(value > 100 ) {
                                module.debug('Value cannot increment above 100 percent');
                                return 100;
                            }
                            return value;
                        },

                        updateInterval: function() {
                            if(settings.updateInterval == 'auto') {
                                return settings.duration;
                            }
                            return settings.updateInterval;
                        },

                        randomValue: function() {
                            module.debug('Generating random increment percentage');
                            return Math.floor((Math.random() * settings.random.max) + settings.random.min);
                        },

                        numericValue: function(value) {
                            return (typeof value === 'string')
                                ? (value.replace(/[^\d.]/g, '') !== '')
                                    ? +(value.replace(/[^\d.]/g, ''))
                                    : false
                                : value
                                ;
                        },

                        transitionEnd: function() {
                            var
                                element     = document.createElement('element'),
                                transitions = {
                                    'transition'       :'transitionend',
                                    'OTransition'      :'oTransitionEnd',
                                    'MozTransition'    :'transitionend',
                                    'WebkitTransition' :'webkitTransitionEnd'
                                },
                                transition
                            ;
                            for(transition in transitions){
                                if( element.style[transition] !== undefined ){
                                    return transitions[transition];
                                }
                            }
                        },

                        // gets current displayed percentage (if animating values this is the intermediary value)
                        displayPercent: function() {
                            var
                                barWidth       = $bar.width(),
                                totalWidth     = $module.width(),
                                minDisplay     = parseInt($bar.css('min-width'), 10),
                                displayPercent = (barWidth > minDisplay)
                                    ? (barWidth / totalWidth * 100)
                                    : module.percent
                            ;
                            return (settings.precision > 0)
                                ? Math.round(displayPercent * (10 * settings.precision)) / (10 * settings.precision)
                                : Math.round(displayPercent)
                                ;
                        },

                        percent: function() {
                            return module.percent || 0;
                        },
                        value: function() {
                            return module.nextValue || module.value || 0;
                        },
                        total: function() {
                            return module.total || false;
                        }
                    },

                    create: {
                        progressPoll: function() {
                            module.progressPoll = setTimeout(function() {
                                module.update.toNextValue();
                                module.remove.progressPoll();
                            }, module.get.updateInterval());
                        },
                    },

                    is: {
                        complete: function() {
                            return module.is.success() || module.is.warning() || module.is.error();
                        },
                        success: function() {
                            return $module.hasClass(className.success);
                        },
                        warning: function() {
                            return $module.hasClass(className.warning);
                        },
                        error: function() {
                            return $module.hasClass(className.error);
                        },
                        active: function() {
                            return $module.hasClass(className.active);
                        },
                        visible: function() {
                            return $module.is(':visible');
                        }
                    },

                    remove: {
                        progressPoll: function() {
                            module.verbose('Removing progress poll timer');
                            if(module.progressPoll) {
                                clearTimeout(module.progressPoll);
                                delete module.progressPoll;
                            }
                        },
                        nextValue: function() {
                            module.verbose('Removing progress value stored for next update');
                            delete module.nextValue;
                        },
                        state: function() {
                            module.verbose('Removing stored state');
                            delete module.total;
                            delete module.percent;
                            delete module.value;
                        },
                        active: function() {
                            module.verbose('Removing active state');
                            $module.removeClass(className.active);
                        },
                        success: function() {
                            module.verbose('Removing success state');
                            $module.removeClass(className.success);
                        },
                        warning: function() {
                            module.verbose('Removing warning state');
                            $module.removeClass(className.warning);
                        },
                        error: function() {
                            module.verbose('Removing error state');
                            $module.removeClass(className.error);
                        }
                    },

                    set: {
                        barWidth: function(value) {
                            if(value > 100) {
                                module.error(error.tooHigh, value);
                            }
                            else if (value < 0) {
                                module.error(error.tooLow, value);
                            }
                            else {
                                $bar
                                    .css('width', value + '%')
                                ;
                                $module
                                    .attr('data-percent', parseInt(value, 10))
                                ;
                            }
                        },
                        duration: function(duration) {
                            duration = duration || settings.duration;
                            duration = (typeof duration == 'number')
                                ? duration + 'ms'
                                : duration
                            ;
                            module.verbose('Setting progress bar transition duration', duration);
                            $bar
                                .css({
                                    'transition-duration':  duration
                                })
                            ;
                        },
                        percent: function(percent) {
                            percent = (typeof percent == 'string')
                                ? +(percent.replace('%', ''))
                                : percent
                            ;
                            // round display percentage
                            percent = (settings.precision > 0)
                                ? Math.round(percent * (10 * settings.precision)) / (10 * settings.precision)
                                : Math.round(percent)
                            ;
                            module.percent = percent;
                            if( !module.has.total() ) {
                                module.value = (settings.precision > 0)
                                    ? Math.round( (percent / 100) * module.total * (10 * settings.precision)) / (10 * settings.precision)
                                    : Math.round( (percent / 100) * module.total * 10) / 10
                                ;
                                if(settings.limitValues) {
                                    module.value = (module.value > 100)
                                        ? 100
                                        : (module.value < 0)
                                            ? 0
                                            : module.value
                                    ;
                                }
                            }
                            module.set.barWidth(percent);
                            module.set.labelInterval();
                            module.set.labels();
                            settings.onChange.call(element, percent, module.value, module.total);
                        },
                        labelInterval: function() {
                            var
                                animationCallback = function() {
                                    module.verbose('Bar finished animating, removing continuous label updates');
                                    clearInterval(module.interval);
                                    animating = false;
                                    module.set.labels();
                                }
                            ;
                            clearInterval(module.interval);
                            module.bind.transitionEnd(animationCallback);
                            animating = true;
                            module.interval = setInterval(function() {
                                var
                                    isInDOM = $.contains(document.documentElement, element)
                                ;
                                if(!isInDOM) {
                                    clearInterval(module.interval);
                                    animating = false;
                                }
                                module.set.labels();
                            }, settings.framerate);
                        },
                        labels: function() {
                            module.verbose('Setting both bar progress and outer label text');
                            module.set.barLabel();
                            module.set.state();
                        },
                        label: function(text) {
                            text = text || '';
                            if(text) {
                                text = module.get.text(text);
                                module.verbose('Setting label to text', text);
                                $label.text(text);
                            }
                        },
                        state: function(percent) {
                            percent = (percent !== undefined)
                                ? percent
                                : module.percent
                            ;
                            if(percent === 100) {
                                if(settings.autoSuccess && !(module.is.warning() || module.is.error() || module.is.success())) {
                                    module.set.success();
                                    module.debug('Automatically triggering success at 100%');
                                }
                                else {
                                    module.verbose('Reached 100% removing active state');
                                    module.remove.active();
                                    module.remove.progressPoll();
                                }
                            }
                            else if(percent > 0) {
                                module.verbose('Adjusting active progress bar label', percent);
                                module.set.active();
                            }
                            else {
                                module.remove.active();
                                module.set.label(settings.text.active);
                            }
                        },
                        barLabel: function(text) {
                            if(text !== undefined) {
                                $progress.text( module.get.text(text) );
                            }
                            else if(settings.label == 'ratio' && module.total) {
                                module.verbose('Adding ratio to bar label');
                                $progress.text( module.get.text(settings.text.ratio) );
                            }
                            else if(settings.label == 'percent') {
                                module.verbose('Adding percentage to bar label');
                                $progress.text( module.get.text(settings.text.percent) );
                            }
                        },
                        active: function(text) {
                            text = text || settings.text.active;
                            module.debug('Setting active state');
                            if(settings.showActivity && !module.is.active() ) {
                                $module.addClass(className.active);
                            }
                            module.remove.warning();
                            module.remove.error();
                            module.remove.success();
                            text = settings.onLabelUpdate('active', text, module.value, module.total);
                            if(text) {
                                module.set.label(text);
                            }
                            module.bind.transitionEnd(function() {
                                settings.onActive.call(element, module.value, module.total);
                            });
                        },
                        success : function(text) {
                            text = text || settings.text.success || settings.text.active;
                            module.debug('Setting success state');
                            $module.addClass(className.success);
                            module.remove.active();
                            module.remove.warning();
                            module.remove.error();
                            module.complete();
                            if(settings.text.success) {
                                text = settings.onLabelUpdate('success', text, module.value, module.total);
                                module.set.label(text);
                            }
                            else {
                                text = settings.onLabelUpdate('active', text, module.value, module.total);
                                module.set.label(text);
                            }
                            module.bind.transitionEnd(function() {
                                settings.onSuccess.call(element, module.total);
                            });
                        },
                        warning : function(text) {
                            text = text || settings.text.warning;
                            module.debug('Setting warning state');
                            $module.addClass(className.warning);
                            module.remove.active();
                            module.remove.success();
                            module.remove.error();
                            module.complete();
                            text = settings.onLabelUpdate('warning', text, module.value, module.total);
                            if(text) {
                                module.set.label(text);
                            }
                            module.bind.transitionEnd(function() {
                                settings.onWarning.call(element, module.value, module.total);
                            });
                        },
                        error : function(text) {
                            text = text || settings.text.error;
                            module.debug('Setting error state');
                            $module.addClass(className.error);
                            module.remove.active();
                            module.remove.success();
                            module.remove.warning();
                            module.complete();
                            text = settings.onLabelUpdate('error', text, module.value, module.total);
                            if(text) {
                                module.set.label(text);
                            }
                            module.bind.transitionEnd(function() {
                                settings.onError.call(element, module.value, module.total);
                            });
                        },
                        transitionEvent: function() {
                            transitionEnd = module.get.transitionEnd();
                        },
                        total: function(totalValue) {
                            module.total = totalValue;
                        },
                        value: function(value) {
                            module.value = value;
                        },
                        progress: function(value) {
                            if(!module.has.progressPoll()) {
                                module.debug('First update in progress update interval, immediately updating', value);
                                module.update.progress(value);
                                module.create.progressPoll();
                            }
                            else {
                                module.debug('Updated within interval, setting next update to use new value', value);
                                module.set.nextValue(value);
                            }
                        },
                        nextValue: function(value) {
                            module.nextValue = value;
                        }
                    },

                    update: {
                        toNextValue: function() {
                            var
                                nextValue = module.nextValue
                            ;
                            if(nextValue) {
                                module.debug('Update interval complete using last updated value', nextValue);
                                module.update.progress(nextValue);
                                module.remove.nextValue();
                            }
                        },
                        progress: function(value) {
                            var
                                percentComplete
                            ;
                            value = module.get.numericValue(value);
                            if(value === false) {
                                module.error(error.nonNumeric, value);
                            }
                            value = module.get.normalizedValue(value);
                            if( module.has.total() ) {
                                module.set.value(value);
                                percentComplete = (value / module.total) * 100;
                                module.debug('Calculating percent complete from total', percentComplete);
                                module.set.percent( percentComplete );
                            }
                            else {
                                percentComplete = value;
                                module.debug('Setting value to exact percentage value', percentComplete);
                                module.set.percent( percentComplete );
                            }
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            if($.isPlainObject(settings[name])) {
                                $.extend(true, settings[name], value);
                            }
                            else {
                                settings[name] = value;
                            }
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.progress.settings = {

        name         : 'Progress',
        namespace    : 'progress',

        silent       : false,
        debug        : false,
        verbose      : false,
        performance  : true,

        random       : {
            min : 2,
            max : 5
        },

        duration       : 300,

        updateInterval : 'auto',

        autoSuccess    : true,
        showActivity   : true,
        limitValues    : true,

        label          : 'percent',
        precision      : 0,
        framerate      : (1000 / 30), /// 30 fps

        percent        : false,
        total          : false,
        value          : false,

        // delay in ms for fail safe animation callback
        failSafeDelay : 100,

        onLabelUpdate : function(state, text, value, total){
            return text;
        },
        onChange      : function(percent, value, total){},
        onSuccess     : function(total){},
        onActive      : function(value, total){},
        onError       : function(value, total){},
        onWarning     : function(value, total){},

        error    : {
            method     : 'The method you called is not defined.',
            nonNumeric : 'Progress value is non numeric',
            tooHigh    : 'Value specified is above 100%',
            tooLow     : 'Value specified is below 0%'
        },

        regExp: {
            variable: /\{\$*[A-z0-9]+\}/g
        },

        metadata: {
            percent : 'percent',
            total   : 'total',
            value   : 'value'
        },

        selector : {
            bar      : '> .bar',
            label    : '> .label',
            progress : '.bar > .progress'
        },

        text : {
            active  : false,
            error   : false,
            success : false,
            warning : false,
            percent : '{percent}%',
            ratio   : '{value} of {total}'
        },

        className : {
            active  : 'active',
            error   : 'error',
            success : 'success',
            warning : 'warning'
        }

    };


})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Rating
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.rating = function(parameters) {
        var
            $allModules     = $(this),
            moduleSelector  = $allModules.selector || '',

            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),
            returnedValue
        ;
        $allModules
            .each(function() {
                var
                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.rating.settings, parameters)
                        : $.extend({}, $.fn.rating.settings),

                    namespace       = settings.namespace,
                    className       = settings.className,
                    metadata        = settings.metadata,
                    selector        = settings.selector,
                    error           = settings.error,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    element         = this,
                    instance        = $(this).data(moduleNamespace),

                    $module         = $(this),
                    $icon           = $module.find(selector.icon),

                    initialLoad,
                    module
                ;

                module = {

                    initialize: function() {
                        module.verbose('Initializing rating module', settings);

                        if($icon.length === 0) {
                            module.setup.layout();
                        }

                        if(settings.interactive) {
                            module.enable();
                        }
                        else {
                            module.disable();
                        }
                        module.set.initialLoad();
                        module.set.rating( module.get.initialRating() );
                        module.remove.initialLoad();
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Instantiating module', settings);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous instance', instance);
                        module.remove.events();
                        $module
                            .removeData(moduleNamespace)
                        ;
                    },

                    refresh: function() {
                        $icon   = $module.find(selector.icon);
                    },

                    setup: {
                        layout: function() {
                            var
                                maxRating = module.get.maxRating(),
                                html      = $.fn.rating.settings.templates.icon(maxRating)
                            ;
                            module.debug('Generating icon html dynamically');
                            $module
                                .html(html)
                            ;
                            module.refresh();
                        }
                    },

                    event: {
                        mouseenter: function() {
                            var
                                $activeIcon = $(this)
                            ;
                            $activeIcon
                                .nextAll()
                                .removeClass(className.selected)
                            ;
                            $module
                                .addClass(className.selected)
                            ;
                            $activeIcon
                                .addClass(className.selected)
                                .prevAll()
                                .addClass(className.selected)
                            ;
                        },
                        mouseleave: function() {
                            $module
                                .removeClass(className.selected)
                            ;
                            $icon
                                .removeClass(className.selected)
                            ;
                        },
                        click: function() {
                            var
                                $activeIcon   = $(this),
                                currentRating = module.get.rating(),
                                rating        = $icon.index($activeIcon) + 1,
                                canClear      = (settings.clearable == 'auto')
                                    ? ($icon.length === 1)
                                    : settings.clearable
                            ;
                            if(canClear && currentRating == rating) {
                                module.clearRating();
                            }
                            else {
                                module.set.rating( rating );
                            }
                        }
                    },

                    clearRating: function() {
                        module.debug('Clearing current rating');
                        module.set.rating(0);
                    },

                    bind: {
                        events: function() {
                            module.verbose('Binding events');
                            $module
                                .on('mouseenter' + eventNamespace, selector.icon, module.event.mouseenter)
                                .on('mouseleave' + eventNamespace, selector.icon, module.event.mouseleave)
                                .on('click'      + eventNamespace, selector.icon, module.event.click)
                            ;
                        }
                    },

                    remove: {
                        events: function() {
                            module.verbose('Removing events');
                            $module
                                .off(eventNamespace)
                            ;
                        },
                        initialLoad: function() {
                            initialLoad = false;
                        }
                    },

                    enable: function() {
                        module.debug('Setting rating to interactive mode');
                        module.bind.events();
                        $module
                            .removeClass(className.disabled)
                        ;
                    },

                    disable: function() {
                        module.debug('Setting rating to read-only mode');
                        module.remove.events();
                        $module
                            .addClass(className.disabled)
                        ;
                    },

                    is: {
                        initialLoad: function() {
                            return initialLoad;
                        }
                    },

                    get: {
                        initialRating: function() {
                            if($module.data(metadata.rating) !== undefined) {
                                $module.removeData(metadata.rating);
                                return $module.data(metadata.rating);
                            }
                            return settings.initialRating;
                        },
                        maxRating: function() {
                            if($module.data(metadata.maxRating) !== undefined) {
                                $module.removeData(metadata.maxRating);
                                return $module.data(metadata.maxRating);
                            }
                            return settings.maxRating;
                        },
                        rating: function() {
                            var
                                currentRating = $icon.filter('.' + className.active).length
                            ;
                            module.verbose('Current rating retrieved', currentRating);
                            return currentRating;
                        }
                    },

                    set: {
                        rating: function(rating) {
                            var
                                ratingIndex = (rating - 1 >= 0)
                                    ? (rating - 1)
                                    : 0,
                                $activeIcon = $icon.eq(ratingIndex)
                            ;
                            $module
                                .removeClass(className.selected)
                            ;
                            $icon
                                .removeClass(className.selected)
                                .removeClass(className.active)
                            ;
                            if(rating > 0) {
                                module.verbose('Setting current rating to', rating);
                                $activeIcon
                                    .prevAll()
                                    .addBack()
                                    .addClass(className.active)
                                ;
                            }
                            if(!module.is.initialLoad()) {
                                settings.onRate.call(element, rating);
                            }
                        },
                        initialLoad: function() {
                            initialLoad = true;
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            if($.isPlainObject(settings[name])) {
                                $.extend(true, settings[name], value);
                            }
                            else {
                                settings[name] = value;
                            }
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if($allModules.length > 1) {
                                title += ' ' + '(' + $allModules.length + ')';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };
                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.rating.settings = {

        name          : 'Rating',
        namespace     : 'rating',

        slent         : false,
        debug         : false,
        verbose       : false,
        performance   : true,

        initialRating : 0,
        interactive   : true,
        maxRating     : 4,
        clearable     : 'auto',

        fireOnInit    : false,

        onRate        : function(rating){},

        error         : {
            method    : 'The method you called is not defined',
            noMaximum : 'No maximum rating specified. Cannot generate HTML automatically'
        },


        metadata: {
            rating    : 'rating',
            maxRating : 'maxRating'
        },

        className : {
            active   : 'active',
            disabled : 'disabled',
            selected : 'selected',
            loading  : 'loading'
        },

        selector  : {
            icon : '.icon'
        },

        templates: {
            icon: function(maxRating) {
                var
                    icon = 1,
                    html = ''
                ;
                while(icon <= maxRating) {
                    html += '<i class="icon"></i>';
                    icon++;
                }
                return html;
            }
        }

    };

})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Search
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.search = function(parameters) {
        var
            $allModules     = $(this),
            moduleSelector  = $allModules.selector || '',

            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),
            returnedValue
        ;
        $(this)
            .each(function() {
                var
                    settings          = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.search.settings, parameters)
                        : $.extend({}, $.fn.search.settings),

                    className       = settings.className,
                    metadata        = settings.metadata,
                    regExp          = settings.regExp,
                    fields          = settings.fields,
                    selector        = settings.selector,
                    error           = settings.error,
                    namespace       = settings.namespace,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = namespace + '-module',

                    $module         = $(this),
                    $prompt         = $module.find(selector.prompt),
                    $searchButton   = $module.find(selector.searchButton),
                    $results        = $module.find(selector.results),
                    $result         = $module.find(selector.result),
                    $category       = $module.find(selector.category),

                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    disabledBubbled = false,

                    module
                ;

                module = {

                    initialize: function() {
                        module.verbose('Initializing module');
                        module.determine.searchFields();
                        module.bind.events();
                        module.set.type();
                        module.create.results();
                        module.instantiate();
                    },
                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },
                    destroy: function() {
                        module.verbose('Destroying instance');
                        $module
                            .off(eventNamespace)
                            .removeData(moduleNamespace)
                        ;
                    },

                    refresh: function() {
                        module.debug('Refreshing selector cache');
                        $prompt         = $module.find(selector.prompt);
                        $searchButton   = $module.find(selector.searchButton);
                        $category       = $module.find(selector.category);
                        $results        = $module.find(selector.results);
                        $result         = $module.find(selector.result);
                    },

                    refreshResults: function() {
                        $results = $module.find(selector.results);
                        $result  = $module.find(selector.result);
                    },

                    bind: {
                        events: function() {
                            module.verbose('Binding events to search');
                            if(settings.automatic) {
                                $module
                                    .on(module.get.inputEvent() + eventNamespace, selector.prompt, module.event.input)
                                ;
                                $prompt
                                    .attr('autocomplete', 'off')
                                ;
                            }
                            $module
                            // prompt
                                .on('focus'     + eventNamespace, selector.prompt, module.event.focus)
                                .on('blur'      + eventNamespace, selector.prompt, module.event.blur)
                                .on('keydown'   + eventNamespace, selector.prompt, module.handleKeyboard)
                                // search button
                                .on('click'     + eventNamespace, selector.searchButton, module.query)
                                // results
                                .on('mousedown' + eventNamespace, selector.results, module.event.result.mousedown)
                                .on('mouseup'   + eventNamespace, selector.results, module.event.result.mouseup)
                                .on('click'     + eventNamespace, selector.result,  module.event.result.click)
                            ;
                        }
                    },

                    determine: {
                        searchFields: function() {
                            // this makes sure $.extend does not add specified search fields to default fields
                            // this is the only setting which should not extend defaults
                            if(parameters && parameters.searchFields !== undefined) {
                                settings.searchFields = parameters.searchFields;
                            }
                        }
                    },

                    event: {
                        input: function() {
                            clearTimeout(module.timer);
                            module.timer = setTimeout(module.query, settings.searchDelay);
                        },
                        focus: function() {
                            module.set.focus();
                            if( module.has.minimumCharacters() ) {
                                module.query();
                                if( module.can.show() ) {
                                    module.showResults();
                                }
                            }
                        },
                        blur: function(event) {
                            var
                                pageLostFocus = (document.activeElement === this),
                                callback      = function() {
                                    module.cancel.query();
                                    module.remove.focus();
                                    module.timer = setTimeout(module.hideResults, settings.hideDelay);
                                }
                            ;
                            if(pageLostFocus) {
                                return;
                            }
                            if(module.resultsClicked) {
                                module.debug('Determining if user action caused search to close');
                                $module
                                    .one('click.close' + eventNamespace, selector.results, function(event) {
                                        if(module.is.inMessage(event) || disabledBubbled) {
                                            $prompt.focus();
                                            return;
                                        }
                                        disabledBubbled = false;
                                        if( !module.is.animating() && !module.is.hidden()) {
                                            callback();
                                        }
                                    })
                                ;
                            }
                            else {
                                module.debug('Input blurred without user action, closing results');
                                callback();
                            }
                        },
                        result: {
                            mousedown: function() {
                                module.resultsClicked = true;
                            },
                            mouseup: function() {
                                module.resultsClicked = false;
                            },
                            click: function(event) {
                                module.debug('Search result selected');
                                var
                                    $result = $(this),
                                    $title  = $result.find(selector.title).eq(0),
                                    $link   = $result.is('a[href]')
                                        ? $result
                                        : $result.find('a[href]').eq(0),
                                    href    = $link.attr('href')   || false,
                                    target  = $link.attr('target') || false,
                                    title   = $title.html(),
                                    // title is used for result lookup
                                    value   = ($title.length > 0)
                                        ? $title.text()
                                        : false,
                                    results = module.get.results(),
                                    result  = $result.data(metadata.result) || module.get.result(value, results),
                                    returnedValue
                                ;
                                if( $.isFunction(settings.onSelect) ) {
                                    if(settings.onSelect.call(element, result, results) === false) {
                                        module.debug('Custom onSelect callback cancelled default select action');
                                        disabledBubbled = true;
                                        return;
                                    }
                                }
                                module.hideResults();
                                if(value) {
                                    module.set.value(value);
                                }
                                if(href) {
                                    module.verbose('Opening search link found in result', $link);
                                    if(target == '_blank' || event.ctrlKey) {
                                        window.open(href);
                                    }
                                    else {
                                        window.location.href = (href);
                                    }
                                }
                            }
                        }
                    },
                    handleKeyboard: function(event) {
                        var
                            // force selector refresh
                            $result         = $module.find(selector.result),
                            $category       = $module.find(selector.category),
                            $activeResult   = $result.filter('.' + className.active),
                            currentIndex    = $result.index( $activeResult ),
                            resultSize      = $result.length,
                            hasActiveResult = $activeResult.length > 0,

                            keyCode         = event.which,
                            keys            = {
                                backspace : 8,
                                enter     : 13,
                                escape    : 27,
                                upArrow   : 38,
                                downArrow : 40
                            },
                            newIndex
                        ;
                        // search shortcuts
                        if(keyCode == keys.escape) {
                            module.verbose('Escape key pressed, blurring search field');
                            module.trigger.blur();
                        }
                        if( module.is.visible() ) {
                            if(keyCode == keys.enter) {
                                module.verbose('Enter key pressed, selecting active result');
                                if( $result.filter('.' + className.active).length > 0 ) {
                                    module.event.result.click.call($result.filter('.' + className.active), event);
                                    event.preventDefault();
                                    return false;
                                }
                            }
                            else if(keyCode == keys.upArrow && hasActiveResult) {
                                module.verbose('Up key pressed, changing active result');
                                newIndex = (currentIndex - 1 < 0)
                                    ? currentIndex
                                    : currentIndex - 1
                                ;
                                $category
                                    .removeClass(className.active)
                                ;
                                $result
                                    .removeClass(className.active)
                                    .eq(newIndex)
                                    .addClass(className.active)
                                    .closest($category)
                                    .addClass(className.active)
                                ;
                                event.preventDefault();
                            }
                            else if(keyCode == keys.downArrow) {
                                module.verbose('Down key pressed, changing active result');
                                newIndex = (currentIndex + 1 >= resultSize)
                                    ? currentIndex
                                    : currentIndex + 1
                                ;
                                $category
                                    .removeClass(className.active)
                                ;
                                $result
                                    .removeClass(className.active)
                                    .eq(newIndex)
                                    .addClass(className.active)
                                    .closest($category)
                                    .addClass(className.active)
                                ;
                                event.preventDefault();
                            }
                        }
                        else {
                            // query shortcuts
                            if(keyCode == keys.enter) {
                                module.verbose('Enter key pressed, executing query');
                                module.query();
                                module.set.buttonPressed();
                                $prompt.one('keyup', module.remove.buttonFocus);
                            }
                        }
                    },

                    setup: {
                        api: function(searchTerm) {
                            var
                                apiSettings = {
                                    debug             : settings.debug,
                                    on                : false,
                                    cache             : true,
                                    action            : 'search',
                                    urlData           : {
                                        query : searchTerm
                                    },
                                    onSuccess         : function(response) {
                                        module.parse.response.call(element, response, searchTerm);
                                    },
                                    onAbort           : function(response) {
                                    },
                                    onFailure         : function() {
                                        module.displayMessage(error.serverError);
                                    },
                                    onError           : module.error
                                },
                                searchHTML
                            ;
                            $.extend(true, apiSettings, settings.apiSettings);
                            module.verbose('Setting up API request', apiSettings);
                            $module.api(apiSettings);
                        }
                    },

                    can: {
                        useAPI: function() {
                            return $.fn.api !== undefined;
                        },
                        show: function() {
                            return module.is.focused() && !module.is.visible() && !module.is.empty();
                        },
                        transition: function() {
                            return settings.transition && $.fn.transition !== undefined && $module.transition('is supported');
                        }
                    },

                    is: {
                        animating: function() {
                            return $results.hasClass(className.animating);
                        },
                        hidden: function() {
                            return $results.hasClass(className.hidden);
                        },
                        inMessage: function(event) {
                            if(!event.target) {
                                return;
                            }
                            var
                                $target = $(event.target),
                                isInDOM = $.contains(document.documentElement, event.target)
                            ;
                            return (isInDOM && $target.closest(selector.message).length > 0);
                        },
                        empty: function() {
                            return ($results.html() === '');
                        },
                        visible: function() {
                            return ($results.filter(':visible').length > 0);
                        },
                        focused: function() {
                            return ($prompt.filter(':focus').length > 0);
                        }
                    },

                    trigger: {
                        blur: function() {
                            var
                                events        = document.createEvent('HTMLEvents'),
                                promptElement = $prompt[0]
                            ;
                            if(promptElement) {
                                module.verbose('Triggering native blur event');
                                events.initEvent('blur', false, false);
                                promptElement.dispatchEvent(events);
                            }
                        }
                    },

                    get: {
                        inputEvent: function() {
                            var
                                prompt = $prompt[0],
                                inputEvent   = (prompt !== undefined && prompt.oninput !== undefined)
                                    ? 'input'
                                    : (prompt !== undefined && prompt.onpropertychange !== undefined)
                                        ? 'propertychange'
                                        : 'keyup'
                            ;
                            return inputEvent;
                        },
                        value: function() {
                            return $prompt.val();
                        },
                        results: function() {
                            var
                                results = $module.data(metadata.results)
                            ;
                            return results;
                        },
                        result: function(value, results) {
                            var
                                lookupFields = ['title', 'id'],
                                result       = false
                            ;
                            value = (value !== undefined)
                                ? value
                                : module.get.value()
                            ;
                            results = (results !== undefined)
                                ? results
                                : module.get.results()
                            ;
                            if(settings.type === 'category') {
                                module.debug('Finding result that matches', value);
                                $.each(results, function(index, category) {
                                    if($.isArray(category.results)) {
                                        result = module.search.object(value, category.results, lookupFields)[0];
                                        // don't continue searching if a result is found
                                        if(result) {
                                            return false;
                                        }
                                    }
                                });
                            }
                            else {
                                module.debug('Finding result in results object', value);
                                result = module.search.object(value, results, lookupFields)[0];
                            }
                            return result || false;
                        },
                    },

                    select: {
                        firstResult: function() {
                            module.verbose('Selecting first result');
                            $result.first().addClass(className.active);
                        }
                    },

                    set: {
                        focus: function() {
                            $module.addClass(className.focus);
                        },
                        loading: function() {
                            $module.addClass(className.loading);
                        },
                        value: function(value) {
                            module.verbose('Setting search input value', value);
                            $prompt
                                .val(value)
                            ;
                        },
                        type: function(type) {
                            type = type || settings.type;
                            if(settings.type == 'category') {
                                $module.addClass(settings.type);
                            }
                        },
                        buttonPressed: function() {
                            $searchButton.addClass(className.pressed);
                        }
                    },

                    remove: {
                        loading: function() {
                            $module.removeClass(className.loading);
                        },
                        focus: function() {
                            $module.removeClass(className.focus);
                        },
                        buttonPressed: function() {
                            $searchButton.removeClass(className.pressed);
                        }
                    },

                    query: function() {
                        var
                            searchTerm = module.get.value(),
                            cache = module.read.cache(searchTerm)
                        ;
                        if( module.has.minimumCharacters() )  {
                            if(cache) {
                                module.debug('Reading result from cache', searchTerm);
                                module.save.results(cache.results);
                                module.addResults(cache.html);
                                module.inject.id(cache.results);
                            }
                            else {
                                module.debug('Querying for', searchTerm);
                                if($.isPlainObject(settings.source) || $.isArray(settings.source)) {
                                    module.search.local(searchTerm);
                                }
                                else if( module.can.useAPI() ) {
                                    module.search.remote(searchTerm);
                                }
                                else {
                                    module.error(error.source);
                                }
                            }
                            settings.onSearchQuery.call(element, searchTerm);
                        }
                        else {
                            module.hideResults();
                        }
                    },

                    search: {
                        local: function(searchTerm) {
                            var
                                results = module.search.object(searchTerm, settings.content),
                                searchHTML
                            ;
                            module.set.loading();
                            module.save.results(results);
                            module.debug('Returned local search results', results);

                            searchHTML = module.generateResults({
                                results: results
                            });
                            module.remove.loading();
                            module.addResults(searchHTML);
                            module.inject.id(results);
                            module.write.cache(searchTerm, {
                                html    : searchHTML,
                                results : results
                            });
                        },
                        remote: function(searchTerm) {
                            if($module.api('is loading')) {
                                $module.api('abort');
                            }
                            module.setup.api(searchTerm);
                            $module
                                .api('query')
                            ;
                        },
                        object: function(searchTerm, source, searchFields) {
                            var
                                results      = [],
                                fuzzyResults = [],
                                searchExp    = searchTerm.toString().replace(regExp.escape, '\\$&'),
                                matchRegExp  = new RegExp(regExp.beginsWith + searchExp, 'i'),

                                // avoid duplicates when pushing results
                                addResult = function(array, result) {
                                    var
                                        notResult      = ($.inArray(result, results) == -1),
                                        notFuzzyResult = ($.inArray(result, fuzzyResults) == -1)
                                    ;
                                    if(notResult && notFuzzyResult) {
                                        array.push(result);
                                    }
                                }
                            ;
                            source = source || settings.source;
                            searchFields = (searchFields !== undefined)
                                ? searchFields
                                : settings.searchFields
                            ;

                            // search fields should be array to loop correctly
                            if(!$.isArray(searchFields)) {
                                searchFields = [searchFields];
                            }

                            // exit conditions if no source
                            if(source === undefined || source === false) {
                                module.error(error.source);
                                return [];
                            }

                            // iterate through search fields looking for matches
                            $.each(searchFields, function(index, field) {
                                $.each(source, function(label, content) {
                                    var
                                        fieldExists = (typeof content[field] == 'string')
                                    ;
                                    if(fieldExists) {
                                        if( content[field].search(matchRegExp) !== -1) {
                                            // content starts with value (first in results)
                                            addResult(results, content);
                                        }
                                        else if(settings.searchFullText && module.fuzzySearch(searchTerm, content[field]) ) {
                                            // content fuzzy matches (last in results)
                                            addResult(fuzzyResults, content);
                                        }
                                    }
                                });
                            });
                            return $.merge(results, fuzzyResults);
                        }
                    },

                    fuzzySearch: function(query, term) {
                        var
                            termLength  = term.length,
                            queryLength = query.length
                        ;
                        if(typeof query !== 'string') {
                            return false;
                        }
                        query = query.toLowerCase();
                        term  = term.toLowerCase();
                        if(queryLength > termLength) {
                            return false;
                        }
                        if(queryLength === termLength) {
                            return (query === term);
                        }
                        search: for (var characterIndex = 0, nextCharacterIndex = 0; characterIndex < queryLength; characterIndex++) {
                            var
                                queryCharacter = query.charCodeAt(characterIndex)
                            ;
                            while(nextCharacterIndex < termLength) {
                                if(term.charCodeAt(nextCharacterIndex++) === queryCharacter) {
                                    continue search;
                                }
                            }
                            return false;
                        }
                        return true;
                    },

                    parse: {
                        response: function(response, searchTerm) {
                            var
                                searchHTML = module.generateResults(response)
                            ;
                            module.verbose('Parsing server response', response);
                            if(response !== undefined) {
                                if(searchTerm !== undefined && response[fields.results] !== undefined) {
                                    module.addResults(searchHTML);
                                    module.inject.id(response[fields.results]);
                                    module.write.cache(searchTerm, {
                                        html    : searchHTML,
                                        results : response[fields.results]
                                    });
                                    module.save.results(response[fields.results]);
                                }
                            }
                        }
                    },

                    cancel: {
                        query: function() {
                            if( module.can.useAPI() ) {
                                $module.api('abort');
                            }
                        }
                    },

                    has: {
                        minimumCharacters: function() {
                            var
                                searchTerm    = module.get.value(),
                                numCharacters = searchTerm.length
                            ;
                            return (numCharacters >= settings.minCharacters);
                        }
                    },

                    clear: {
                        cache: function(value) {
                            var
                                cache = $module.data(metadata.cache)
                            ;
                            if(!value) {
                                module.debug('Clearing cache', value);
                                $module.removeData(metadata.cache);
                            }
                            else if(value && cache && cache[value]) {
                                module.debug('Removing value from cache', value);
                                delete cache[value];
                                $module.data(metadata.cache, cache);
                            }
                        }
                    },

                    read: {
                        cache: function(name) {
                            var
                                cache = $module.data(metadata.cache)
                            ;
                            if(settings.cache) {
                                module.verbose('Checking cache for generated html for query', name);
                                return (typeof cache == 'object') && (cache[name] !== undefined)
                                    ? cache[name]
                                    : false
                                    ;
                            }
                            return false;
                        }
                    },

                    create: {
                        id: function(resultIndex, categoryIndex) {
                            var
                                resultID      = (resultIndex + 1), // not zero indexed
                                categoryID    = (categoryIndex + 1),
                                firstCharCode,
                                letterID,
                                id
                            ;
                            if(categoryIndex !== undefined) {
                                // start char code for "A"
                                letterID = String.fromCharCode(97 + categoryIndex);
                                id          = letterID + resultID;
                                module.verbose('Creating category result id', id);
                            }
                            else {
                                id = resultID;
                                module.verbose('Creating result id', id);
                            }
                            return id;
                        },
                        results: function() {
                            if($results.length === 0) {
                                $results = $('<div />')
                                    .addClass(className.results)
                                    .appendTo($module)
                                ;
                            }
                        }
                    },

                    inject: {
                        result: function(result, resultIndex, categoryIndex) {
                            module.verbose('Injecting result into results');
                            var
                                $selectedResult = (categoryIndex !== undefined)
                                    ? $results
                                        .children().eq(categoryIndex)
                                        .children(selector.result).eq(resultIndex)
                                    : $results
                                        .children(selector.result).eq(resultIndex)
                            ;
                            module.verbose('Injecting results metadata', $selectedResult);
                            $selectedResult
                                .data(metadata.result, result)
                            ;
                        },
                        id: function(results) {
                            module.debug('Injecting unique ids into results');
                            var
                                // since results may be object, we must use counters
                                categoryIndex = 0,
                                resultIndex   = 0
                            ;
                            if(settings.type === 'category') {
                                // iterate through each category result
                                $.each(results, function(index, category) {
                                    resultIndex = 0;
                                    $.each(category.results, function(index, value) {
                                        var
                                            result = category.results[index]
                                        ;
                                        if(result.id === undefined) {
                                            result.id = module.create.id(resultIndex, categoryIndex);
                                        }
                                        module.inject.result(result, resultIndex, categoryIndex);
                                        resultIndex++;
                                    });
                                    categoryIndex++;
                                });
                            }
                            else {
                                // top level
                                $.each(results, function(index, value) {
                                    var
                                        result = results[index]
                                    ;
                                    if(result.id === undefined) {
                                        result.id = module.create.id(resultIndex);
                                    }
                                    module.inject.result(result, resultIndex);
                                    resultIndex++;
                                });
                            }
                            return results;
                        }
                    },

                    save: {
                        results: function(results) {
                            module.verbose('Saving current search results to metadata', results);
                            $module.data(metadata.results, results);
                        }
                    },

                    write: {
                        cache: function(name, value) {
                            var
                                cache = ($module.data(metadata.cache) !== undefined)
                                    ? $module.data(metadata.cache)
                                    : {}
                            ;
                            if(settings.cache) {
                                module.verbose('Writing generated html to cache', name, value);
                                cache[name] = value;
                                $module
                                    .data(metadata.cache, cache)
                                ;
                            }
                        }
                    },

                    addResults: function(html) {
                        if( $.isFunction(settings.onResultsAdd) ) {
                            if( settings.onResultsAdd.call($results, html) === false ) {
                                module.debug('onResultsAdd callback cancelled default action');
                                return false;
                            }
                        }
                        if(html) {
                            $results
                                .html(html)
                            ;
                            module.refreshResults();
                            if(settings.selectFirstResult) {
                                module.select.firstResult();
                            }
                            module.showResults();
                        }
                        else {
                            module.hideResults();
                        }
                    },

                    showResults: function() {
                        if(!module.is.visible()) {
                            if( module.can.transition() ) {
                                module.debug('Showing results with css animations');
                                $results
                                    .transition({
                                        animation  : settings.transition + ' in',
                                        debug      : settings.debug,
                                        verbose    : settings.verbose,
                                        duration   : settings.duration,
                                        queue      : true
                                    })
                                ;
                            }
                            else {
                                module.debug('Showing results with javascript');
                                $results
                                    .stop()
                                    .fadeIn(settings.duration, settings.easing)
                                ;
                            }
                            settings.onResultsOpen.call($results);
                        }
                    },
                    hideResults: function() {
                        if( module.is.visible() ) {
                            if( module.can.transition() ) {
                                module.debug('Hiding results with css animations');
                                $results
                                    .transition({
                                        animation  : settings.transition + ' out',
                                        debug      : settings.debug,
                                        verbose    : settings.verbose,
                                        duration   : settings.duration,
                                        queue      : true
                                    })
                                ;
                            }
                            else {
                                module.debug('Hiding results with javascript');
                                $results
                                    .stop()
                                    .fadeOut(settings.duration, settings.easing)
                                ;
                            }
                            settings.onResultsClose.call($results);
                        }
                    },

                    generateResults: function(response) {
                        module.debug('Generating html from response', response);
                        var
                            template       = settings.templates[settings.type],
                            isProperObject = ($.isPlainObject(response[fields.results]) && !$.isEmptyObject(response[fields.results])),
                            isProperArray  = ($.isArray(response[fields.results]) && response[fields.results].length > 0),
                            html           = ''
                        ;
                        if(isProperObject || isProperArray ) {
                            if(settings.maxResults > 0) {
                                if(isProperObject) {
                                    if(settings.type == 'standard') {
                                        module.error(error.maxResults);
                                    }
                                }
                                else {
                                    response[fields.results] = response[fields.results].slice(0, settings.maxResults);
                                }
                            }
                            if($.isFunction(template)) {
                                html = template(response, fields);
                            }
                            else {
                                module.error(error.noTemplate, false);
                            }
                        }
                        else if(settings.showNoResults) {
                            html = module.displayMessage(error.noResults, 'empty');
                        }
                        settings.onResults.call(element, response);
                        return html;
                    },

                    displayMessage: function(text, type) {
                        type = type || 'standard';
                        module.debug('Displaying message', text, type);
                        module.addResults( settings.templates.message(text, type) );
                        return settings.templates.message(text, type);
                    },

                    setting: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if($allModules.length > 1) {
                                title += ' ' + '(' + $allModules.length + ')';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };
                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }

            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.search.settings = {

        name              : 'Search',
        namespace         : 'search',

        silent            : false,
        debug             : false,
        verbose           : false,
        performance       : true,

        // template to use (specified in settings.templates)
        type              : 'standard',

        // minimum characters required to search
        minCharacters     : 1,

        // whether to select first result after searching automatically
        selectFirstResult : false,

        // API config
        apiSettings       : false,

        // object to search
        source            : false,

        // fields to search
        searchFields   : [
            'title',
            'description'
        ],

        // field to display in standard results template
        displayField   : '',

        // whether to include fuzzy results in local search
        searchFullText : true,

        // whether to add events to prompt automatically
        automatic      : true,

        // delay before hiding menu after blur
        hideDelay      : 0,

        // delay before searching
        searchDelay    : 200,

        // maximum results returned from local
        maxResults     : 7,

        // whether to store lookups in local cache
        cache          : true,

        // whether no results errors should be shown
        showNoResults  : true,

        // transition settings
        transition     : 'scale',
        duration       : 200,
        easing         : 'easeOutExpo',

        // callbacks
        onSelect       : false,
        onResultsAdd   : false,

        onSearchQuery  : function(query){},
        onResults      : function(response){},

        onResultsOpen  : function(){},
        onResultsClose : function(){},

        className: {
            animating : 'animating',
            active    : 'active',
            empty     : 'empty',
            focus     : 'focus',
            hidden    : 'hidden',
            loading   : 'loading',
            results   : 'results',
            pressed   : 'down'
        },

        error : {
            source      : 'Cannot search. No source used, and Semantic API module was not included',
            noResults   : 'Your search returned no results',
            logging     : 'Error in debug logging, exiting.',
            noEndpoint  : 'No search endpoint was specified',
            noTemplate  : 'A valid template name was not specified.',
            serverError : 'There was an issue querying the server.',
            maxResults  : 'Results must be an array to use maxResults setting',
            method      : 'The method you called is not defined.'
        },

        metadata: {
            cache   : 'cache',
            results : 'results',
            result  : 'result'
        },

        regExp: {
            escape     : /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,
            beginsWith : '(?:\s|^)'
        },

        // maps api response attributes to internal representation
        fields: {
            categories      : 'results',     // array of categories (category view)
            categoryName    : 'name',        // name of category (category view)
            categoryResults : 'results',     // array of results (category view)
            description     : 'description', // result description
            image           : 'image',       // result image
            price           : 'price',       // result price
            results         : 'results',     // array of results (standard)
            title           : 'title',       // result title
            url             : 'url',         // result url
            action          : 'action',      // "view more" object name
            actionText      : 'text',        // "view more" text
            actionURL       : 'url'          // "view more" url
        },

        selector : {
            prompt       : '.prompt',
            searchButton : '.search.button',
            results      : '.results',
            message      : '.results > .message',
            category     : '.category',
            result       : '.result',
            title        : '.title, .name'
        },

        templates: {
            escape: function(string) {
                var
                    badChars     = /[&<>"'`]/g,
                    shouldEscape = /[&<>"'`]/,
                    escape       = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#x27;",
                        "`": "&#x60;"
                    },
                    escapedChar  = function(chr) {
                        return escape[chr];
                    }
                ;
                if(shouldEscape.test(string)) {
                    return string.replace(badChars, escapedChar);
                }
                return string;
            },
            message: function(message, type) {
                var
                    html = ''
                ;
                if(message !== undefined && type !== undefined) {
                    html +=  ''
                        + '<div class="message ' + type + '">'
                    ;
                    // message type
                    if(type == 'empty') {
                        html += ''
                            + '<div class="header">No Results</div class="header">'
                            + '<div class="description">' + message + '</div class="description">'
                        ;
                    }
                    else {
                        html += ' <div class="description">' + message + '</div>';
                    }
                    html += '</div>';
                }
                return html;
            },
            category: function(response, fields) {
                var
                    html = '',
                    escape = $.fn.search.settings.templates.escape
                ;
                if(response[fields.categoryResults] !== undefined) {

                    // each category
                    $.each(response[fields.categoryResults], function(index, category) {
                        if(category[fields.results] !== undefined && category.results.length > 0) {

                            html  += '<div class="category">';

                            if(category[fields.categoryName] !== undefined) {
                                html += '<div class="name">' + category[fields.categoryName] + '</div>';
                            }

                            // each item inside category
                            $.each(category.results, function(index, result) {
                                if(result[fields.url]) {
                                    html  += '<a class="result" href="' + result[fields.url] + '">';
                                }
                                else {
                                    html  += '<a class="result">';
                                }
                                if(result[fields.image] !== undefined) {
                                    html += ''
                                        + '<div class="image">'
                                        + ' <img src="' + result[fields.image] + '">'
                                        + '</div>'
                                    ;
                                }
                                html += '<div class="content">';
                                if(result[fields.price] !== undefined) {
                                    html += '<div class="price">' + result[fields.price] + '</div>';
                                }
                                if(result[fields.title] !== undefined) {
                                    html += '<div class="title">' + result[fields.title] + '</div>';
                                }
                                if(result[fields.description] !== undefined) {
                                    html += '<div class="description">' + result[fields.description] + '</div>';
                                }
                                html  += ''
                                    + '</div>'
                                ;
                                html += '</a>';
                            });
                            html  += ''
                                + '</div>'
                            ;
                        }
                    });
                    if(response[fields.action]) {
                        html += ''
                            + '<a href="' + response[fields.action][fields.actionURL] + '" class="action">'
                            +   response[fields.action][fields.actionText]
                            + '</a>';
                    }
                    return html;
                }
                return false;
            },
            standard: function(response, fields) {
                var
                    html = ''
                ;
                if(response[fields.results] !== undefined) {

                    // each result
                    $.each(response[fields.results], function(index, result) {
                        if(result[fields.url]) {
                            html  += '<a class="result" href="' + result[fields.url] + '">';
                        }
                        else {
                            html  += '<a class="result">';
                        }
                        if(result[fields.image] !== undefined) {
                            html += ''
                                + '<div class="image">'
                                + ' <img src="' + result[fields.image] + '">'
                                + '</div>'
                            ;
                        }
                        html += '<div class="content">';
                        if(result[fields.price] !== undefined) {
                            html += '<div class="price">' + result[fields.price] + '</div>';
                        }
                        if(result[fields.title] !== undefined) {
                            html += '<div class="title">' + result[fields.title] + '</div>';
                        }
                        if(result[fields.description] !== undefined) {
                            html += '<div class="description">' + result[fields.description] + '</div>';
                        }
                        html  += ''
                            + '</div>'
                        ;
                        html += '</a>';
                    });

                    if(response[fields.action]) {
                        html += ''
                            + '<a href="' + response[fields.action][fields.actionURL] + '" class="action">'
                            +   response[fields.action][fields.actionText]
                            + '</a>';
                    }
                    return html;
                }
                return false;
            }
        }
    };

})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Shape
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.shape = function(parameters) {
        var
            $allModules     = $(this),
            $body           = $('body'),

            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),

            requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(callback) { setTimeout(callback, 0); },

            returnedValue
        ;

        $allModules
            .each(function() {
                var
                    moduleSelector = $allModules.selector || '',
                    settings       = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.shape.settings, parameters)
                        : $.extend({}, $.fn.shape.settings),

                    // internal aliases
                    namespace     = settings.namespace,
                    selector      = settings.selector,
                    error         = settings.error,
                    className     = settings.className,

                    // define namespaces for modules
                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    // selector cache
                    $module       = $(this),
                    $sides        = $module.find(selector.sides),
                    $side         = $module.find(selector.side),

                    // private variables
                    nextIndex = false,
                    $activeSide,
                    $nextSide,

                    // standard module
                    element       = this,
                    instance      = $module.data(moduleNamespace),
                    module
                ;

                module = {

                    initialize: function() {
                        module.verbose('Initializing module for', element);
                        module.set.defaultSide();
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, instance)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module for', element);
                        $module
                            .removeData(moduleNamespace)
                            .off(eventNamespace)
                        ;
                    },

                    refresh: function() {
                        module.verbose('Refreshing selector cache for', element);
                        $module = $(element);
                        $sides  = $(this).find(selector.shape);
                        $side   = $(this).find(selector.side);
                    },

                    repaint: function() {
                        module.verbose('Forcing repaint event');
                        var
                            shape          = $sides[0] || document.createElement('div'),
                            fakeAssignment = shape.offsetWidth
                        ;
                    },

                    animate: function(propertyObject, callback) {
                        module.verbose('Animating box with properties', propertyObject);
                        callback = callback || function(event) {
                            module.verbose('Executing animation callback');
                            if(event !== undefined) {
                                event.stopPropagation();
                            }
                            module.reset();
                            module.set.active();
                        };
                        settings.beforeChange.call($nextSide[0]);
                        if(module.get.transitionEvent()) {
                            module.verbose('Starting CSS animation');
                            $module
                                .addClass(className.animating)
                            ;
                            $sides
                                .css(propertyObject)
                                .one(module.get.transitionEvent(), callback)
                            ;
                            module.set.duration(settings.duration);
                            requestAnimationFrame(function() {
                                $module
                                    .addClass(className.animating)
                                ;
                                $activeSide
                                    .addClass(className.hidden)
                                ;
                            });
                        }
                        else {
                            callback();
                        }
                    },

                    queue: function(method) {
                        module.debug('Queueing animation of', method);
                        $sides
                            .one(module.get.transitionEvent(), function() {
                                module.debug('Executing queued animation');
                                setTimeout(function(){
                                    $module.shape(method);
                                }, 0);
                            })
                        ;
                    },

                    reset: function() {
                        module.verbose('Animating states reset');
                        $module
                            .removeClass(className.animating)
                            .attr('style', '')
                            .removeAttr('style')
                        ;
                        // removeAttr style does not consistently work in safari
                        $sides
                            .attr('style', '')
                            .removeAttr('style')
                        ;
                        $side
                            .attr('style', '')
                            .removeAttr('style')
                            .removeClass(className.hidden)
                        ;
                        $nextSide
                            .removeClass(className.animating)
                            .attr('style', '')
                            .removeAttr('style')
                        ;
                    },

                    is: {
                        complete: function() {
                            return ($side.filter('.' + className.active)[0] == $nextSide[0]);
                        },
                        animating: function() {
                            return $module.hasClass(className.animating);
                        }
                    },

                    set: {

                        defaultSide: function() {
                            $activeSide = $module.find('.' + settings.className.active);
                            $nextSide   = ( $activeSide.next(selector.side).length > 0 )
                                ? $activeSide.next(selector.side)
                                : $module.find(selector.side).first()
                            ;
                            nextIndex = false;
                            module.verbose('Active side set to', $activeSide);
                            module.verbose('Next side set to', $nextSide);
                        },

                        duration: function(duration) {
                            duration = duration || settings.duration;
                            duration = (typeof duration == 'number')
                                ? duration + 'ms'
                                : duration
                            ;
                            module.verbose('Setting animation duration', duration);
                            if(settings.duration || settings.duration === 0) {
                                $sides.add($side)
                                    .css({
                                        '-webkit-transition-duration': duration,
                                        '-moz-transition-duration': duration,
                                        '-ms-transition-duration': duration,
                                        '-o-transition-duration': duration,
                                        'transition-duration': duration
                                    })
                                ;
                            }
                        },

                        currentStageSize: function() {
                            var
                                $activeSide = $module.find('.' + settings.className.active),
                                width       = $activeSide.outerWidth(true),
                                height      = $activeSide.outerHeight(true)
                            ;
                            $module
                                .css({
                                    width: width,
                                    height: height
                                })
                            ;
                        },

                        stageSize: function() {
                            var
                                $clone      = $module.clone().addClass(className.loading),
                                $activeSide = $clone.find('.' + settings.className.active),
                                $nextSide   = (nextIndex)
                                    ? $clone.find(selector.side).eq(nextIndex)
                                    : ( $activeSide.next(selector.side).length > 0 )
                                        ? $activeSide.next(selector.side)
                                        : $clone.find(selector.side).first(),
                                newWidth    = (settings.width == 'next')
                                    ? $nextSide.outerWidth(true)
                                    : (settings.width == 'initial')
                                        ? $module.width()
                                        : settings.width,
                                newHeight    = (settings.height == 'next')
                                    ? $nextSide.outerHeight(true)
                                    : (settings.height == 'initial')
                                        ? $module.height()
                                        : settings.height
                            ;
                            $activeSide.removeClass(className.active);
                            $nextSide.addClass(className.active);
                            $clone.insertAfter($module);
                            $clone.remove();
                            if(settings.width != 'auto') {
                                $module.css('width', newWidth + settings.jitter);
                                module.verbose('Specifying width during animation', newWidth);
                            }
                            if(settings.height != 'auto') {
                                $module.css('height', newHeight + settings.jitter);
                                module.verbose('Specifying height during animation', newHeight);
                            }
                        },

                        nextSide: function(selector) {
                            nextIndex = selector;
                            $nextSide = $side.filter(selector);
                            nextIndex = $side.index($nextSide);
                            if($nextSide.length === 0) {
                                module.set.defaultSide();
                                module.error(error.side);
                            }
                            module.verbose('Next side manually set to', $nextSide);
                        },

                        active: function() {
                            module.verbose('Setting new side to active', $nextSide);
                            $side
                                .removeClass(className.active)
                            ;
                            $nextSide
                                .addClass(className.active)
                            ;
                            settings.onChange.call($nextSide[0]);
                            module.set.defaultSide();
                        }
                    },

                    flip: {

                        up: function() {
                            if(module.is.complete() && !module.is.animating() && !settings.allowRepeats) {
                                module.debug('Side already visible', $nextSide);
                                return;
                            }
                            if( !module.is.animating()) {
                                module.debug('Flipping up', $nextSide);
                                var
                                    transform = module.get.transform.up()
                                ;
                                module.set.stageSize();
                                module.stage.above();
                                module.animate(transform);
                            }
                            else {
                                module.queue('flip up');
                            }
                        },

                        down: function() {
                            if(module.is.complete() && !module.is.animating() && !settings.allowRepeats) {
                                module.debug('Side already visible', $nextSide);
                                return;
                            }
                            if( !module.is.animating()) {
                                module.debug('Flipping down', $nextSide);
                                var
                                    transform = module.get.transform.down()
                                ;
                                module.set.stageSize();
                                module.stage.below();
                                module.animate(transform);
                            }
                            else {
                                module.queue('flip down');
                            }
                        },

                        left: function() {
                            if(module.is.complete() && !module.is.animating() && !settings.allowRepeats) {
                                module.debug('Side already visible', $nextSide);
                                return;
                            }
                            if( !module.is.animating()) {
                                module.debug('Flipping left', $nextSide);
                                var
                                    transform = module.get.transform.left()
                                ;
                                module.set.stageSize();
                                module.stage.left();
                                module.animate(transform);
                            }
                            else {
                                module.queue('flip left');
                            }
                        },

                        right: function() {
                            if(module.is.complete() && !module.is.animating() && !settings.allowRepeats) {
                                module.debug('Side already visible', $nextSide);
                                return;
                            }
                            if( !module.is.animating()) {
                                module.debug('Flipping right', $nextSide);
                                var
                                    transform = module.get.transform.right()
                                ;
                                module.set.stageSize();
                                module.stage.right();
                                module.animate(transform);
                            }
                            else {
                                module.queue('flip right');
                            }
                        },

                        over: function() {
                            if(module.is.complete() && !module.is.animating() && !settings.allowRepeats) {
                                module.debug('Side already visible', $nextSide);
                                return;
                            }
                            if( !module.is.animating()) {
                                module.debug('Flipping over', $nextSide);
                                module.set.stageSize();
                                module.stage.behind();
                                module.animate(module.get.transform.over() );
                            }
                            else {
                                module.queue('flip over');
                            }
                        },

                        back: function() {
                            if(module.is.complete() && !module.is.animating() && !settings.allowRepeats) {
                                module.debug('Side already visible', $nextSide);
                                return;
                            }
                            if( !module.is.animating()) {
                                module.debug('Flipping back', $nextSide);
                                module.set.stageSize();
                                module.stage.behind();
                                module.animate(module.get.transform.back() );
                            }
                            else {
                                module.queue('flip back');
                            }
                        }

                    },

                    get: {

                        transform: {
                            up: function() {
                                var
                                    translate = {
                                        y: -(($activeSide.outerHeight(true) - $nextSide.outerHeight(true)) / 2),
                                        z: -($activeSide.outerHeight(true) / 2)
                                    }
                                ;
                                return {
                                    transform: 'translateY(' + translate.y + 'px) translateZ('+ translate.z + 'px) rotateX(-90deg)'
                                };
                            },

                            down: function() {
                                var
                                    translate = {
                                        y: -(($activeSide.outerHeight(true) - $nextSide.outerHeight(true)) / 2),
                                        z: -($activeSide.outerHeight(true) / 2)
                                    }
                                ;
                                return {
                                    transform: 'translateY(' + translate.y + 'px) translateZ('+ translate.z + 'px) rotateX(90deg)'
                                };
                            },

                            left: function() {
                                var
                                    translate = {
                                        x : -(($activeSide.outerWidth(true) - $nextSide.outerWidth(true)) / 2),
                                        z : -($activeSide.outerWidth(true) / 2)
                                    }
                                ;
                                return {
                                    transform: 'translateX(' + translate.x + 'px) translateZ(' + translate.z + 'px) rotateY(90deg)'
                                };
                            },

                            right: function() {
                                var
                                    translate = {
                                        x : -(($activeSide.outerWidth(true) - $nextSide.outerWidth(true)) / 2),
                                        z : -($activeSide.outerWidth(true) / 2)
                                    }
                                ;
                                return {
                                    transform: 'translateX(' + translate.x + 'px) translateZ(' + translate.z + 'px) rotateY(-90deg)'
                                };
                            },

                            over: function() {
                                var
                                    translate = {
                                        x : -(($activeSide.outerWidth(true) - $nextSide.outerWidth(true)) / 2)
                                    }
                                ;
                                return {
                                    transform: 'translateX(' + translate.x + 'px) rotateY(180deg)'
                                };
                            },

                            back: function() {
                                var
                                    translate = {
                                        x : -(($activeSide.outerWidth(true) - $nextSide.outerWidth(true)) / 2)
                                    }
                                ;
                                return {
                                    transform: 'translateX(' + translate.x + 'px) rotateY(-180deg)'
                                };
                            }
                        },

                        transitionEvent: function() {
                            var
                                element     = document.createElement('element'),
                                transitions = {
                                    'transition'       :'transitionend',
                                    'OTransition'      :'oTransitionEnd',
                                    'MozTransition'    :'transitionend',
                                    'WebkitTransition' :'webkitTransitionEnd'
                                },
                                transition
                            ;
                            for(transition in transitions){
                                if( element.style[transition] !== undefined ){
                                    return transitions[transition];
                                }
                            }
                        },

                        nextSide: function() {
                            return ( $activeSide.next(selector.side).length > 0 )
                                ? $activeSide.next(selector.side)
                                : $module.find(selector.side).first()
                                ;
                        }

                    },

                    stage: {

                        above: function() {
                            var
                                box = {
                                    origin : (($activeSide.outerHeight(true) - $nextSide.outerHeight(true)) / 2),
                                    depth  : {
                                        active : ($nextSide.outerHeight(true) / 2),
                                        next   : ($activeSide.outerHeight(true) / 2)
                                    }
                                }
                            ;
                            module.verbose('Setting the initial animation position as above', $nextSide, box);
                            $sides
                                .css({
                                    'transform' : 'translateZ(-' + box.depth.active + 'px)'
                                })
                            ;
                            $activeSide
                                .css({
                                    'transform' : 'rotateY(0deg) translateZ(' + box.depth.active + 'px)'
                                })
                            ;
                            $nextSide
                                .addClass(className.animating)
                                .css({
                                    'top'       : box.origin + 'px',
                                    'transform' : 'rotateX(90deg) translateZ(' + box.depth.next + 'px)'
                                })
                            ;
                        },

                        below: function() {
                            var
                                box = {
                                    origin : (($activeSide.outerHeight(true) - $nextSide.outerHeight(true)) / 2),
                                    depth  : {
                                        active : ($nextSide.outerHeight(true) / 2),
                                        next   : ($activeSide.outerHeight(true) / 2)
                                    }
                                }
                            ;
                            module.verbose('Setting the initial animation position as below', $nextSide, box);
                            $sides
                                .css({
                                    'transform' : 'translateZ(-' + box.depth.active + 'px)'
                                })
                            ;
                            $activeSide
                                .css({
                                    'transform' : 'rotateY(0deg) translateZ(' + box.depth.active + 'px)'
                                })
                            ;
                            $nextSide
                                .addClass(className.animating)
                                .css({
                                    'top'       : box.origin + 'px',
                                    'transform' : 'rotateX(-90deg) translateZ(' + box.depth.next + 'px)'
                                })
                            ;
                        },

                        left: function() {
                            var
                                height = {
                                    active : $activeSide.outerWidth(true),
                                    next   : $nextSide.outerWidth(true)
                                },
                                box = {
                                    origin : ( ( height.active - height.next ) / 2),
                                    depth  : {
                                        active : (height.next / 2),
                                        next   : (height.active / 2)
                                    }
                                }
                            ;
                            module.verbose('Setting the initial animation position as left', $nextSide, box);
                            $sides
                                .css({
                                    'transform' : 'translateZ(-' + box.depth.active + 'px)'
                                })
                            ;
                            $activeSide
                                .css({
                                    'transform' : 'rotateY(0deg) translateZ(' + box.depth.active + 'px)'
                                })
                            ;
                            $nextSide
                                .addClass(className.animating)
                                .css({
                                    'left'      : box.origin + 'px',
                                    'transform' : 'rotateY(-90deg) translateZ(' + box.depth.next + 'px)'
                                })
                            ;
                        },

                        right: function() {
                            var
                                height = {
                                    active : $activeSide.outerWidth(true),
                                    next   : $nextSide.outerWidth(true)
                                },
                                box = {
                                    origin : ( ( height.active - height.next ) / 2),
                                    depth  : {
                                        active : (height.next / 2),
                                        next   : (height.active / 2)
                                    }
                                }
                            ;
                            module.verbose('Setting the initial animation position as left', $nextSide, box);
                            $sides
                                .css({
                                    'transform' : 'translateZ(-' + box.depth.active + 'px)'
                                })
                            ;
                            $activeSide
                                .css({
                                    'transform' : 'rotateY(0deg) translateZ(' + box.depth.active + 'px)'
                                })
                            ;
                            $nextSide
                                .addClass(className.animating)
                                .css({
                                    'left'      : box.origin + 'px',
                                    'transform' : 'rotateY(90deg) translateZ(' + box.depth.next + 'px)'
                                })
                            ;
                        },

                        behind: function() {
                            var
                                height = {
                                    active : $activeSide.outerWidth(true),
                                    next   : $nextSide.outerWidth(true)
                                },
                                box = {
                                    origin : ( ( height.active - height.next ) / 2),
                                    depth  : {
                                        active : (height.next / 2),
                                        next   : (height.active / 2)
                                    }
                                }
                            ;
                            module.verbose('Setting the initial animation position as behind', $nextSide, box);
                            $activeSide
                                .css({
                                    'transform' : 'rotateY(0deg)'
                                })
                            ;
                            $nextSide
                                .addClass(className.animating)
                                .css({
                                    'left'      : box.origin + 'px',
                                    'transform' : 'rotateY(-180deg)'
                                })
                            ;
                        }
                    },
                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            if($.isPlainObject(settings[name])) {
                                $.extend(true, settings[name], value);
                            }
                            else {
                                settings[name] = value;
                            }
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if($allModules.length > 1) {
                                title += ' ' + '(' + $allModules.length + ')';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.shape.settings = {

        // module info
        name : 'Shape',

        // hide all debug content
        silent     : false,

        // debug content outputted to console
        debug      : false,

        // verbose debug output
        verbose    : false,

        // fudge factor in pixels when swapping from 2d to 3d (can be useful to correct rounding errors)
        jitter     : 0,

        // performance data output
        performance: true,

        // event namespace
        namespace  : 'shape',

        // width during animation, can be set to 'auto', initial', 'next' or pixel amount
        width: 'initial',

        // height during animation, can be set to 'auto', 'initial', 'next' or pixel amount
        height: 'initial',

        // callback occurs on side change
        beforeChange : function() {},
        onChange     : function() {},

        // allow animation to same side
        allowRepeats: false,

        // animation duration
        duration   : false,

        // possible errors
        error: {
            side   : 'You tried to switch to a side that does not exist.',
            method : 'The method you called is not defined'
        },

        // classnames used
        className   : {
            animating : 'animating',
            hidden    : 'hidden',
            loading   : 'loading',
            active    : 'active'
        },

        // selectors used
        selector    : {
            sides : '.sides',
            side  : '.side'
        }

    };


})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Sidebar
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.sidebar = function(parameters) {
        var
            $allModules     = $(this),
            $window         = $(window),
            $document       = $(document),
            $html           = $('html'),
            $head           = $('head'),

            moduleSelector  = $allModules.selector || '',

            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),

            requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(callback) { setTimeout(callback, 0); },

            returnedValue
        ;

        $allModules
            .each(function() {
                var
                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.sidebar.settings, parameters)
                        : $.extend({}, $.fn.sidebar.settings),

                    selector        = settings.selector,
                    className       = settings.className,
                    namespace       = settings.namespace,
                    regExp          = settings.regExp,
                    error           = settings.error,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    $module         = $(this),
                    $context        = $(settings.context),

                    $sidebars       = $module.children(selector.sidebar),
                    $fixed          = $context.children(selector.fixed),
                    $pusher         = $context.children(selector.pusher),
                    $style,

                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    elementNamespace,
                    id,
                    currentScroll,
                    transitionEvent,

                    module
                ;

                module      = {

                    initialize: function() {
                        module.debug('Initializing sidebar', parameters);

                        module.create.id();

                        transitionEvent = module.get.transitionEvent();

                        if(module.is.ios()) {
                            module.set.ios();
                        }

                        // avoids locking rendering if initialized in onReady
                        if(settings.delaySetup) {
                            requestAnimationFrame(module.setup.layout);
                        }
                        else {
                            module.setup.layout();
                        }

                        requestAnimationFrame(function() {
                            module.setup.cache();
                        });

                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    create: {
                        id: function() {
                            id = (Math.random().toString(16) + '000000000').substr(2,8);
                            elementNamespace = '.' + id;
                            module.verbose('Creating unique id for element', id);
                        }
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module for', $module);
                        $module
                            .off(eventNamespace)
                            .removeData(moduleNamespace)
                        ;
                        if(module.is.ios()) {
                            module.remove.ios();
                        }
                        // bound by uuid
                        $context.off(elementNamespace);
                        $window.off(elementNamespace);
                        $document.off(elementNamespace);
                    },

                    event: {
                        clickaway: function(event) {
                            var
                                clickedInPusher = ($pusher.find(event.target).length > 0 || $pusher.is(event.target)),
                                clickedContext  = ($context.is(event.target))
                            ;
                            if(clickedInPusher) {
                                module.verbose('User clicked on dimmed page');
                                module.hide();
                            }
                            if(clickedContext) {
                                module.verbose('User clicked on dimmable context (scaled out page)');
                                module.hide();
                            }
                        },
                        touch: function(event) {
                            //event.stopPropagation();
                        },
                        containScroll: function(event) {
                            if(element.scrollTop <= 0)  {
                                element.scrollTop = 1;
                            }
                            if((element.scrollTop + element.offsetHeight) >= element.scrollHeight) {
                                element.scrollTop = element.scrollHeight - element.offsetHeight - 1;
                            }
                        },
                        scroll: function(event) {
                            if( $(event.target).closest(selector.sidebar).length === 0 ) {
                                event.preventDefault();
                            }
                        }
                    },

                    bind: {
                        clickaway: function() {
                            module.verbose('Adding clickaway events to context', $context);
                            if(settings.closable) {
                                $context
                                    .on('click'    + elementNamespace, module.event.clickaway)
                                    .on('touchend' + elementNamespace, module.event.clickaway)
                                ;
                            }
                        },
                        scrollLock: function() {
                            if(settings.scrollLock) {
                                module.debug('Disabling page scroll');
                                $window
                                    .on('DOMMouseScroll' + elementNamespace, module.event.scroll)
                                ;
                            }
                            module.verbose('Adding events to contain sidebar scroll');
                            $document
                                .on('touchmove' + elementNamespace, module.event.touch)
                            ;
                            $module
                                .on('scroll' + eventNamespace, module.event.containScroll)
                            ;
                        }
                    },
                    unbind: {
                        clickaway: function() {
                            module.verbose('Removing clickaway events from context', $context);
                            $context.off(elementNamespace);
                        },
                        scrollLock: function() {
                            module.verbose('Removing scroll lock from page');
                            $document.off(elementNamespace);
                            $window.off(elementNamespace);
                            $module.off('scroll' + eventNamespace);
                        }
                    },

                    add: {
                        inlineCSS: function() {
                            var
                                width     = module.cache.width  || $module.outerWidth(),
                                height    = module.cache.height || $module.outerHeight(),
                                isRTL     = module.is.rtl(),
                                direction = module.get.direction(),
                                distance  = {
                                    left   : width,
                                    right  : -width,
                                    top    : height,
                                    bottom : -height
                                },
                                style
                            ;

                            if(isRTL){
                                module.verbose('RTL detected, flipping widths');
                                distance.left = -width;
                                distance.right = width;
                            }

                            style  = '<style>';

                            if(direction === 'left' || direction === 'right') {
                                module.debug('Adding CSS rules for animation distance', width);
                                style  += ''
                                    + ' .ui.visible.' + direction + '.sidebar ~ .fixed,'
                                    + ' .ui.visible.' + direction + '.sidebar ~ .pusher {'
                                    + '   -webkit-transform: translate3d('+ distance[direction] + 'px, 0, 0);'
                                    + '           transform: translate3d('+ distance[direction] + 'px, 0, 0);'
                                    + ' }'
                                ;
                            }
                            else if(direction === 'top' || direction == 'bottom') {
                                style  += ''
                                    + ' .ui.visible.' + direction + '.sidebar ~ .fixed,'
                                    + ' .ui.visible.' + direction + '.sidebar ~ .pusher {'
                                    + '   -webkit-transform: translate3d(0, ' + distance[direction] + 'px, 0);'
                                    + '           transform: translate3d(0, ' + distance[direction] + 'px, 0);'
                                    + ' }'
                                ;
                            }

                            /* IE is only browser not to create context with transforms */
                            /* https://www.w3.org/Bugs/Public/show_bug.cgi?id=16328 */
                            if( module.is.ie() ) {
                                if(direction === 'left' || direction === 'right') {
                                    module.debug('Adding CSS rules for animation distance', width);
                                    style  += ''
                                        + ' body.pushable > .ui.visible.' + direction + '.sidebar ~ .pusher:after {'
                                        + '   -webkit-transform: translate3d('+ distance[direction] + 'px, 0, 0);'
                                        + '           transform: translate3d('+ distance[direction] + 'px, 0, 0);'
                                        + ' }'
                                    ;
                                }
                                else if(direction === 'top' || direction == 'bottom') {
                                    style  += ''
                                        + ' body.pushable > .ui.visible.' + direction + '.sidebar ~ .pusher:after {'
                                        + '   -webkit-transform: translate3d(0, ' + distance[direction] + 'px, 0);'
                                        + '           transform: translate3d(0, ' + distance[direction] + 'px, 0);'
                                        + ' }'
                                    ;
                                }
                                /* opposite sides visible forces content overlay */
                                style += ''
                                    + ' body.pushable > .ui.visible.left.sidebar ~ .ui.visible.right.sidebar ~ .pusher:after,'
                                    + ' body.pushable > .ui.visible.right.sidebar ~ .ui.visible.left.sidebar ~ .pusher:after {'
                                    + '   -webkit-transform: translate3d(0px, 0, 0);'
                                    + '           transform: translate3d(0px, 0, 0);'
                                    + ' }'
                                ;
                            }
                            style += '</style>';
                            $style = $(style)
                                .appendTo($head)
                            ;
                            module.debug('Adding sizing css to head', $style);
                        }
                    },

                    refresh: function() {
                        module.verbose('Refreshing selector cache');
                        $context  = $(settings.context);
                        $sidebars = $context.children(selector.sidebar);
                        $pusher   = $context.children(selector.pusher);
                        $fixed    = $context.children(selector.fixed);
                        module.clear.cache();
                    },

                    refreshSidebars: function() {
                        module.verbose('Refreshing other sidebars');
                        $sidebars = $context.children(selector.sidebar);
                    },

                    repaint: function() {
                        module.verbose('Forcing repaint event');
                        element.style.display = 'none';
                        var ignored = element.offsetHeight;
                        element.scrollTop = element.scrollTop;
                        element.style.display = '';
                    },

                    setup: {
                        cache: function() {
                            module.cache = {
                                width  : $module.outerWidth(),
                                height : $module.outerHeight(),
                                rtl    : ($module.css('direction') == 'rtl')
                            };
                        },
                        layout: function() {
                            if( $context.children(selector.pusher).length === 0 ) {
                                module.debug('Adding wrapper element for sidebar');
                                module.error(error.pusher);
                                $pusher = $('<div class="pusher" />');
                                $context
                                    .children()
                                    .not(selector.omitted)
                                    .not($sidebars)
                                    .wrapAll($pusher)
                                ;
                                module.refresh();
                            }
                            if($module.nextAll(selector.pusher).length === 0 || $module.nextAll(selector.pusher)[0] !== $pusher[0]) {
                                module.debug('Moved sidebar to correct parent element');
                                module.error(error.movedSidebar, element);
                                $module.detach().prependTo($context);
                                module.refresh();
                            }
                            module.clear.cache();
                            module.set.pushable();
                            module.set.direction();
                        }
                    },

                    attachEvents: function(selector, event) {
                        var
                            $toggle = $(selector)
                        ;
                        event = $.isFunction(module[event])
                            ? module[event]
                            : module.toggle
                        ;
                        if($toggle.length > 0) {
                            module.debug('Attaching sidebar events to element', selector, event);
                            $toggle
                                .on('click' + eventNamespace, event)
                            ;
                        }
                        else {
                            module.error(error.notFound, selector);
                        }
                    },

                    show: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if(module.is.hidden()) {
                            module.refreshSidebars();
                            if(settings.overlay)  {
                                module.error(error.overlay);
                                settings.transition = 'overlay';
                            }
                            module.refresh();
                            if(module.othersActive()) {
                                module.debug('Other sidebars currently visible');
                                if(settings.exclusive) {
                                    // if not overlay queue animation after hide
                                    if(settings.transition != 'overlay') {
                                        module.hideOthers(module.show);
                                        return;
                                    }
                                    else {
                                        module.hideOthers();
                                    }
                                }
                                else {
                                    settings.transition = 'overlay';
                                }
                            }
                            module.pushPage(function() {
                                callback.call(element);
                                settings.onShow.call(element);
                            });
                            settings.onChange.call(element);
                            settings.onVisible.call(element);
                        }
                        else {
                            module.debug('Sidebar is already visible');
                        }
                    },

                    hide: function(callback) {
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if(module.is.visible() || module.is.animating()) {
                            module.debug('Hiding sidebar', callback);
                            module.refreshSidebars();
                            module.pullPage(function() {
                                callback.call(element);
                                settings.onHidden.call(element);
                            });
                            settings.onChange.call(element);
                            settings.onHide.call(element);
                        }
                    },

                    othersAnimating: function() {
                        return ($sidebars.not($module).filter('.' + className.animating).length > 0);
                    },
                    othersVisible: function() {
                        return ($sidebars.not($module).filter('.' + className.visible).length > 0);
                    },
                    othersActive: function() {
                        return(module.othersVisible() || module.othersAnimating());
                    },

                    hideOthers: function(callback) {
                        var
                            $otherSidebars = $sidebars.not($module).filter('.' + className.visible),
                            sidebarCount   = $otherSidebars.length,
                            callbackCount  = 0
                        ;
                        callback = callback || function(){};
                        $otherSidebars
                            .sidebar('hide', function() {
                                callbackCount++;
                                if(callbackCount == sidebarCount) {
                                    callback();
                                }
                            })
                        ;
                    },

                    toggle: function() {
                        module.verbose('Determining toggled direction');
                        if(module.is.hidden()) {
                            module.show();
                        }
                        else {
                            module.hide();
                        }
                    },

                    pushPage: function(callback) {
                        var
                            transition = module.get.transition(),
                            $transition = (transition === 'overlay' || module.othersActive())
                                ? $module
                                : $pusher,
                            animate,
                            dim,
                            transitionEnd
                        ;
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        if(settings.transition == 'scale down') {
                            module.scrollToTop();
                        }
                        module.set.transition(transition);
                        module.repaint();
                        animate = function() {
                            module.bind.clickaway();
                            module.add.inlineCSS();
                            module.set.animating();
                            module.set.visible();
                        };
                        dim = function() {
                            module.set.dimmed();
                        };
                        transitionEnd = function(event) {
                            if( event.target == $transition[0] ) {
                                $transition.off(transitionEvent + elementNamespace, transitionEnd);
                                module.remove.animating();
                                module.bind.scrollLock();
                                callback.call(element);
                            }
                        };
                        $transition.off(transitionEvent + elementNamespace);
                        $transition.on(transitionEvent + elementNamespace, transitionEnd);
                        requestAnimationFrame(animate);
                        if(settings.dimPage && !module.othersVisible()) {
                            requestAnimationFrame(dim);
                        }
                    },

                    pullPage: function(callback) {
                        var
                            transition = module.get.transition(),
                            $transition = (transition == 'overlay' || module.othersActive())
                                ? $module
                                : $pusher,
                            animate,
                            transitionEnd
                        ;
                        callback = $.isFunction(callback)
                            ? callback
                            : function(){}
                        ;
                        module.verbose('Removing context push state', module.get.direction());

                        module.unbind.clickaway();
                        module.unbind.scrollLock();

                        animate = function() {
                            module.set.transition(transition);
                            module.set.animating();
                            module.remove.visible();
                            if(settings.dimPage && !module.othersVisible()) {
                                $pusher.removeClass(className.dimmed);
                            }
                        };
                        transitionEnd = function(event) {
                            if( event.target == $transition[0] ) {
                                $transition.off(transitionEvent + elementNamespace, transitionEnd);
                                module.remove.animating();
                                module.remove.transition();
                                module.remove.inlineCSS();
                                if(transition == 'scale down' || (settings.returnScroll && module.is.mobile()) ) {
                                    module.scrollBack();
                                }
                                callback.call(element);
                            }
                        };
                        $transition.off(transitionEvent + elementNamespace);
                        $transition.on(transitionEvent + elementNamespace, transitionEnd);
                        requestAnimationFrame(animate);
                    },

                    scrollToTop: function() {
                        module.verbose('Scrolling to top of page to avoid animation issues');
                        currentScroll = $(window).scrollTop();
                        $module.scrollTop(0);
                        window.scrollTo(0, 0);
                    },

                    scrollBack: function() {
                        module.verbose('Scrolling back to original page position');
                        window.scrollTo(0, currentScroll);
                    },

                    clear: {
                        cache: function() {
                            module.verbose('Clearing cached dimensions');
                            module.cache = {};
                        }
                    },

                    set: {

                        // ios only (scroll on html not document). This prevent auto-resize canvas/scroll in ios
                        ios: function() {
                            $html.addClass(className.ios);
                        },

                        // container
                        pushed: function() {
                            $context.addClass(className.pushed);
                        },
                        pushable: function() {
                            $context.addClass(className.pushable);
                        },

                        // pusher
                        dimmed: function() {
                            $pusher.addClass(className.dimmed);
                        },

                        // sidebar
                        active: function() {
                            $module.addClass(className.active);
                        },
                        animating: function() {
                            $module.addClass(className.animating);
                        },
                        transition: function(transition) {
                            transition = transition || module.get.transition();
                            $module.addClass(transition);
                        },
                        direction: function(direction) {
                            direction = direction || module.get.direction();
                            $module.addClass(className[direction]);
                        },
                        visible: function() {
                            $module.addClass(className.visible);
                        },
                        overlay: function() {
                            $module.addClass(className.overlay);
                        }
                    },
                    remove: {

                        inlineCSS: function() {
                            module.debug('Removing inline css styles', $style);
                            if($style && $style.length > 0) {
                                $style.remove();
                            }
                        },

                        // ios scroll on html not document
                        ios: function() {
                            $html.removeClass(className.ios);
                        },

                        // context
                        pushed: function() {
                            $context.removeClass(className.pushed);
                        },
                        pushable: function() {
                            $context.removeClass(className.pushable);
                        },

                        // sidebar
                        active: function() {
                            $module.removeClass(className.active);
                        },
                        animating: function() {
                            $module.removeClass(className.animating);
                        },
                        transition: function(transition) {
                            transition = transition || module.get.transition();
                            $module.removeClass(transition);
                        },
                        direction: function(direction) {
                            direction = direction || module.get.direction();
                            $module.removeClass(className[direction]);
                        },
                        visible: function() {
                            $module.removeClass(className.visible);
                        },
                        overlay: function() {
                            $module.removeClass(className.overlay);
                        }
                    },

                    get: {
                        direction: function() {
                            if($module.hasClass(className.top)) {
                                return className.top;
                            }
                            else if($module.hasClass(className.right)) {
                                return className.right;
                            }
                            else if($module.hasClass(className.bottom)) {
                                return className.bottom;
                            }
                            return className.left;
                        },
                        transition: function() {
                            var
                                direction = module.get.direction(),
                                transition
                            ;
                            transition = ( module.is.mobile() )
                                ? (settings.mobileTransition == 'auto')
                                    ? settings.defaultTransition.mobile[direction]
                                    : settings.mobileTransition
                                : (settings.transition == 'auto')
                                    ? settings.defaultTransition.computer[direction]
                                    : settings.transition
                            ;
                            module.verbose('Determined transition', transition);
                            return transition;
                        },
                        transitionEvent: function() {
                            var
                                element     = document.createElement('element'),
                                transitions = {
                                    'transition'       :'transitionend',
                                    'OTransition'      :'oTransitionEnd',
                                    'MozTransition'    :'transitionend',
                                    'WebkitTransition' :'webkitTransitionEnd'
                                },
                                transition
                            ;
                            for(transition in transitions){
                                if( element.style[transition] !== undefined ){
                                    return transitions[transition];
                                }
                            }
                        }
                    },

                    is: {

                        ie: function() {
                            var
                                isIE11 = (!(window.ActiveXObject) && 'ActiveXObject' in window),
                                isIE   = ('ActiveXObject' in window)
                            ;
                            return (isIE11 || isIE);
                        },

                        ios: function() {
                            var
                                userAgent      = navigator.userAgent,
                                isIOS          = userAgent.match(regExp.ios),
                                isMobileChrome = userAgent.match(regExp.mobileChrome)
                            ;
                            if(isIOS && !isMobileChrome) {
                                module.verbose('Browser was found to be iOS', userAgent);
                                return true;
                            }
                            else {
                                return false;
                            }
                        },
                        mobile: function() {
                            var
                                userAgent    = navigator.userAgent,
                                isMobile     = userAgent.match(regExp.mobile)
                            ;
                            if(isMobile) {
                                module.verbose('Browser was found to be mobile', userAgent);
                                return true;
                            }
                            else {
                                module.verbose('Browser is not mobile, using regular transition', userAgent);
                                return false;
                            }
                        },
                        hidden: function() {
                            return !module.is.visible();
                        },
                        visible: function() {
                            return $module.hasClass(className.visible);
                        },
                        // alias
                        open: function() {
                            return module.is.visible();
                        },
                        closed: function() {
                            return module.is.hidden();
                        },
                        vertical: function() {
                            return $module.hasClass(className.top);
                        },
                        animating: function() {
                            return $context.hasClass(className.animating);
                        },
                        rtl: function () {
                            if(module.cache.rtl === undefined) {
                                module.cache.rtl = ($module.css('direction') == 'rtl');
                            }
                            return module.cache.rtl;
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            if($.isPlainObject(settings[name])) {
                                $.extend(true, settings[name], value);
                            }
                            else {
                                settings[name] = value;
                            }
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                }
                ;

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        module.invoke('destroy');
                    }
                    module.initialize();
                }
            });

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.sidebar.settings = {

        name              : 'Sidebar',
        namespace         : 'sidebar',

        silent            : false,
        debug             : false,
        verbose           : false,
        performance       : true,

        transition        : 'auto',
        mobileTransition  : 'auto',

        defaultTransition : {
            computer: {
                left   : 'uncover',
                right  : 'uncover',
                top    : 'overlay',
                bottom : 'overlay'
            },
            mobile: {
                left   : 'uncover',
                right  : 'uncover',
                top    : 'overlay',
                bottom : 'overlay'
            }
        },

        context           : 'body',
        exclusive         : false,
        closable          : true,
        dimPage           : true,
        scrollLock        : false,
        returnScroll      : false,
        delaySetup        : false,

        duration          : 500,

        onChange          : function(){},
        onShow            : function(){},
        onHide            : function(){},

        onHidden          : function(){},
        onVisible         : function(){},

        className         : {
            active    : 'active',
            animating : 'animating',
            dimmed    : 'dimmed',
            ios       : 'ios',
            pushable  : 'pushable',
            pushed    : 'pushed',
            right     : 'right',
            top       : 'top',
            left      : 'left',
            bottom    : 'bottom',
            visible   : 'visible'
        },

        selector: {
            fixed   : '.fixed',
            omitted : 'script, link, style, .ui.modal, .ui.dimmer, .ui.nag, .ui.fixed',
            pusher  : '.pusher',
            sidebar : '.ui.sidebar'
        },

        regExp: {
            ios          : /(iPad|iPhone|iPod)/g,
            mobileChrome : /(CriOS)/g,
            mobile       : /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/g
        },

        error   : {
            method       : 'The method you called is not defined.',
            pusher       : 'Had to add pusher element. For optimal performance make sure body content is inside a pusher element',
            movedSidebar : 'Had to move sidebar. For optimal performance make sure sidebar and pusher are direct children of your body tag',
            overlay      : 'The overlay setting is no longer supported, use animation: overlay',
            notFound     : 'There were no elements that matched the specified selector'
        }

    };


})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Sticky
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.sticky = function(parameters) {
        var
            $allModules    = $(this),
            moduleSelector = $allModules.selector || '',

            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),
            returnedValue
        ;

        $allModules
            .each(function() {
                var
                    settings              = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.sticky.settings, parameters)
                        : $.extend({}, $.fn.sticky.settings),

                    className             = settings.className,
                    namespace             = settings.namespace,
                    error                 = settings.error,

                    eventNamespace        = '.' + namespace,
                    moduleNamespace       = 'module-' + namespace,

                    $module               = $(this),
                    $window               = $(window),
                    $scroll               = $(settings.scrollContext),
                    $container,
                    $context,

                    selector              = $module.selector || '',
                    instance              = $module.data(moduleNamespace),

                    requestAnimationFrame = window.requestAnimationFrame
                        || window.mozRequestAnimationFrame
                        || window.webkitRequestAnimationFrame
                        || window.msRequestAnimationFrame
                        || function(callback) { setTimeout(callback, 0); },

                    element         = this,

                    documentObserver,
                    observer,
                    module
                ;

                module      = {

                    initialize: function() {

                        module.determineContainer();
                        module.determineContext();
                        module.verbose('Initializing sticky', settings, $container);

                        module.save.positions();
                        module.checkErrors();
                        module.bind.events();

                        if(settings.observeChanges) {
                            module.observeChanges();
                        }
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous instance');
                        module.reset();
                        if(documentObserver) {
                            documentObserver.disconnect();
                        }
                        if(observer) {
                            observer.disconnect();
                        }
                        $window
                            .off('load' + eventNamespace, module.event.load)
                            .off('resize' + eventNamespace, module.event.resize)
                        ;
                        $scroll
                            .off('scrollchange' + eventNamespace, module.event.scrollchange)
                        ;
                        $module.removeData(moduleNamespace);
                    },

                    observeChanges: function() {
                        if('MutationObserver' in window) {
                            documentObserver = new MutationObserver(module.event.documentChanged);
                            observer         = new MutationObserver(module.event.changed);
                            documentObserver.observe(document, {
                                childList : true,
                                subtree   : true
                            });
                            observer.observe(element, {
                                childList : true,
                                subtree   : true
                            });
                            observer.observe($context[0], {
                                childList : true,
                                subtree   : true
                            });
                            module.debug('Setting up mutation observer', observer);
                        }
                    },

                    determineContainer: function() {
                        if(settings.container) {
                            $container = $(settings.container);
                        }
                        else {
                            $container = $module.offsetParent();
                        }
                    },

                    determineContext: function() {
                        if(settings.context) {
                            $context = $(settings.context);
                        }
                        else {
                            $context = $container;
                        }
                        if($context.length === 0) {
                            module.error(error.invalidContext, settings.context, $module);
                            return;
                        }
                    },

                    checkErrors: function() {
                        if( module.is.hidden() ) {
                            module.error(error.visible, $module);
                        }
                        if(module.cache.element.height > module.cache.context.height) {
                            module.reset();
                            module.error(error.elementSize, $module);
                            return;
                        }
                    },

                    bind: {
                        events: function() {
                            $window
                                .on('load' + eventNamespace, module.event.load)
                                .on('resize' + eventNamespace, module.event.resize)
                            ;
                            // pub/sub pattern
                            $scroll
                                .off('scroll' + eventNamespace)
                                .on('scroll' + eventNamespace, module.event.scroll)
                                .on('scrollchange' + eventNamespace, module.event.scrollchange)
                            ;
                        }
                    },

                    event: {
                        changed: function(mutations) {
                            clearTimeout(module.timer);
                            module.timer = setTimeout(function() {
                                module.verbose('DOM tree modified, updating sticky menu', mutations);
                                module.refresh();
                            }, 100);
                        },
                        documentChanged: function(mutations) {
                            [].forEach.call(mutations, function(mutation) {
                                if(mutation.removedNodes) {
                                    [].forEach.call(mutation.removedNodes, function(node) {
                                        if(node == element || $(node).find(element).length > 0) {
                                            module.debug('Element removed from DOM, tearing down events');
                                            module.destroy();
                                        }
                                    });
                                }
                            });
                        },
                        load: function() {
                            module.verbose('Page contents finished loading');
                            requestAnimationFrame(module.refresh);
                        },
                        resize: function() {
                            module.verbose('Window resized');
                            requestAnimationFrame(module.refresh);
                        },
                        scroll: function() {
                            requestAnimationFrame(function() {
                                $scroll.triggerHandler('scrollchange' + eventNamespace, $scroll.scrollTop() );
                            });
                        },
                        scrollchange: function(event, scrollPosition) {
                            module.stick(scrollPosition);
                            settings.onScroll.call(element);
                        }
                    },

                    refresh: function(hardRefresh) {
                        module.reset();
                        if(!settings.context) {
                            module.determineContext();
                        }
                        if(hardRefresh) {
                            module.determineContainer();
                        }
                        module.save.positions();
                        module.stick();
                        settings.onReposition.call(element);
                    },

                    supports: {
                        sticky: function() {
                            var
                                $element = $('<div/>'),
                                element = $element[0]
                            ;
                            $element.addClass(className.supported);
                            return($element.css('position').match('sticky'));
                        }
                    },

                    save: {
                        lastScroll: function(scroll) {
                            module.lastScroll = scroll;
                        },
                        elementScroll: function(scroll) {
                            module.elementScroll = scroll;
                        },
                        positions: function() {
                            var
                                scrollContext = {
                                    height : $scroll.height()
                                },
                                element = {
                                    margin: {
                                        top    : parseInt($module.css('margin-top'), 10),
                                        bottom : parseInt($module.css('margin-bottom'), 10),
                                    },
                                    offset : $module.offset(),
                                    width  : $module.outerWidth(),
                                    height : $module.outerHeight()
                                },
                                context = {
                                    offset : $context.offset(),
                                    height : $context.outerHeight()
                                },
                                container = {
                                    height: $container.outerHeight()
                                }
                            ;
                            if( !module.is.standardScroll() ) {
                                module.debug('Non-standard scroll. Removing scroll offset from element offset');

                                scrollContext.top  = $scroll.scrollTop();
                                scrollContext.left = $scroll.scrollLeft();

                                element.offset.top  += scrollContext.top;
                                context.offset.top  += scrollContext.top;
                                element.offset.left += scrollContext.left;
                                context.offset.left += scrollContext.left;
                            }
                            module.cache = {
                                fits : ( element.height < scrollContext.height ),
                                scrollContext : {
                                    height : scrollContext.height
                                },
                                element: {
                                    margin : element.margin,
                                    top    : element.offset.top - element.margin.top,
                                    left   : element.offset.left,
                                    width  : element.width,
                                    height : element.height,
                                    bottom : element.offset.top + element.height
                                },
                                context: {
                                    top           : context.offset.top,
                                    height        : context.height,
                                    bottom        : context.offset.top + context.height
                                }
                            };
                            module.set.containerSize();
                            module.set.size();
                            module.stick();
                            module.debug('Caching element positions', module.cache);
                        }
                    },

                    get: {
                        direction: function(scroll) {
                            var
                                direction = 'down'
                            ;
                            scroll = scroll || $scroll.scrollTop();
                            if(module.lastScroll !== undefined) {
                                if(module.lastScroll < scroll) {
                                    direction = 'down';
                                }
                                else if(module.lastScroll > scroll) {
                                    direction = 'up';
                                }
                            }
                            return direction;
                        },
                        scrollChange: function(scroll) {
                            scroll = scroll || $scroll.scrollTop();
                            return (module.lastScroll)
                                ? (scroll - module.lastScroll)
                                : 0
                                ;
                        },
                        currentElementScroll: function() {
                            if(module.elementScroll) {
                                return module.elementScroll;
                            }
                            return ( module.is.top() )
                                ? Math.abs(parseInt($module.css('top'), 10))    || 0
                                : Math.abs(parseInt($module.css('bottom'), 10)) || 0
                                ;
                        },

                        elementScroll: function(scroll) {
                            scroll = scroll || $scroll.scrollTop();
                            var
                                element        = module.cache.element,
                                scrollContext  = module.cache.scrollContext,
                                delta          = module.get.scrollChange(scroll),
                                maxScroll      = (element.height - scrollContext.height + settings.offset),
                                elementScroll  = module.get.currentElementScroll(),
                                possibleScroll = (elementScroll + delta)
                            ;
                            if(module.cache.fits || possibleScroll < 0) {
                                elementScroll = 0;
                            }
                            else if(possibleScroll > maxScroll ) {
                                elementScroll = maxScroll;
                            }
                            else {
                                elementScroll = possibleScroll;
                            }
                            return elementScroll;
                        }
                    },

                    remove: {
                        lastScroll: function() {
                            delete module.lastScroll;
                        },
                        elementScroll: function(scroll) {
                            delete module.elementScroll;
                        },
                        offset: function() {
                            $module.css('margin-top', '');
                        }
                    },

                    set: {
                        offset: function() {
                            module.verbose('Setting offset on element', settings.offset);
                            $module
                                .css('margin-top', settings.offset)
                            ;
                        },
                        containerSize: function() {
                            var
                                tagName = $container.get(0).tagName
                            ;
                            if(tagName === 'HTML' || tagName == 'body') {
                                // this can trigger for too many reasons
                                //module.error(error.container, tagName, $module);
                                module.determineContainer();
                            }
                            else {
                                if( Math.abs($container.outerHeight() - module.cache.context.height) > settings.jitter) {
                                    module.debug('Context has padding, specifying exact height for container', module.cache.context.height);
                                    $container.css({
                                        height: module.cache.context.height
                                    });
                                }
                            }
                        },
                        minimumSize: function() {
                            var
                                element   = module.cache.element
                            ;
                            $container
                                .css('min-height', element.height)
                            ;
                        },
                        scroll: function(scroll) {
                            module.debug('Setting scroll on element', scroll);
                            if(module.elementScroll == scroll) {
                                return;
                            }
                            if( module.is.top() ) {
                                $module
                                    .css('bottom', '')
                                    .css('top', -scroll)
                                ;
                            }
                            if( module.is.bottom() ) {
                                $module
                                    .css('top', '')
                                    .css('bottom', scroll)
                                ;
                            }
                        },
                        size: function() {
                            if(module.cache.element.height !== 0 && module.cache.element.width !== 0) {
                                element.style.setProperty('width',  module.cache.element.width  + 'px', 'important');
                                element.style.setProperty('height', module.cache.element.height + 'px', 'important');
                            }
                        }
                    },

                    is: {
                        standardScroll: function() {
                            return ($scroll[0] == window);
                        },
                        top: function() {
                            return $module.hasClass(className.top);
                        },
                        bottom: function() {
                            return $module.hasClass(className.bottom);
                        },
                        initialPosition: function() {
                            return (!module.is.fixed() && !module.is.bound());
                        },
                        hidden: function() {
                            return (!$module.is(':visible'));
                        },
                        bound: function() {
                            return $module.hasClass(className.bound);
                        },
                        fixed: function() {
                            return $module.hasClass(className.fixed);
                        }
                    },

                    stick: function(scroll) {
                        var
                            cachedPosition = scroll || $scroll.scrollTop(),
                            cache          = module.cache,
                            fits           = cache.fits,
                            element        = cache.element,
                            scrollContext  = cache.scrollContext,
                            context        = cache.context,
                            offset         = (module.is.bottom() && settings.pushing)
                                ? settings.bottomOffset
                                : settings.offset,
                            scroll         = {
                                top    : cachedPosition + offset,
                                bottom : cachedPosition + offset + scrollContext.height
                            },
                            direction      = module.get.direction(scroll.top),
                            elementScroll  = (fits)
                                ? 0
                                : module.get.elementScroll(scroll.top),

                            // shorthand
                            doesntFit      = !fits,
                            elementVisible = (element.height !== 0)
                        ;

                        if(elementVisible) {

                            if( module.is.initialPosition() ) {
                                if(scroll.top >= context.bottom) {
                                    module.debug('Initial element position is bottom of container');
                                    module.bindBottom();
                                }
                                else if(scroll.top > element.top) {
                                    if( (element.height + scroll.top - elementScroll) >= context.bottom ) {
                                        module.debug('Initial element position is bottom of container');
                                        module.bindBottom();
                                    }
                                    else {
                                        module.debug('Initial element position is fixed');
                                        module.fixTop();
                                    }
                                }

                            }
                            else if( module.is.fixed() ) {

                                // currently fixed top
                                if( module.is.top() ) {
                                    if( scroll.top <= element.top ) {
                                        module.debug('Fixed element reached top of container');
                                        module.setInitialPosition();
                                    }
                                    else if( (element.height + scroll.top - elementScroll) >= context.bottom ) {
                                        module.debug('Fixed element reached bottom of container');
                                        module.bindBottom();
                                    }
                                    // scroll element if larger than screen
                                    else if(doesntFit) {
                                        module.set.scroll(elementScroll);
                                        module.save.lastScroll(scroll.top);
                                        module.save.elementScroll(elementScroll);
                                    }
                                }

                                // currently fixed bottom
                                else if(module.is.bottom() ) {

                                    // top edge
                                    if( (scroll.bottom - element.height) <= element.top) {
                                        module.debug('Bottom fixed rail has reached top of container');
                                        module.setInitialPosition();
                                    }
                                    // bottom edge
                                    else if(scroll.bottom >= context.bottom) {
                                        module.debug('Bottom fixed rail has reached bottom of container');
                                        module.bindBottom();
                                    }
                                    // scroll element if larger than screen
                                    else if(doesntFit) {
                                        module.set.scroll(elementScroll);
                                        module.save.lastScroll(scroll.top);
                                        module.save.elementScroll(elementScroll);
                                    }

                                }
                            }
                            else if( module.is.bottom() ) {
                                if( scroll.top <= element.top ) {
                                    module.debug('Jumped from bottom fixed to top fixed, most likely used home/end button');
                                    module.setInitialPosition();
                                }
                                else {
                                    if(settings.pushing) {
                                        if(module.is.bound() && scroll.bottom <= context.bottom ) {
                                            module.debug('Fixing bottom attached element to bottom of browser.');
                                            module.fixBottom();
                                        }
                                    }
                                    else {
                                        if(module.is.bound() && (scroll.top <= context.bottom - element.height) ) {
                                            module.debug('Fixing bottom attached element to top of browser.');
                                            module.fixTop();
                                        }
                                    }
                                }
                            }
                        }
                    },

                    bindTop: function() {
                        module.debug('Binding element to top of parent container');
                        module.remove.offset();
                        $module
                            .css({
                                left         : '',
                                top          : '',
                                marginBottom : ''
                            })
                            .removeClass(className.fixed)
                            .removeClass(className.bottom)
                            .addClass(className.bound)
                            .addClass(className.top)
                        ;
                        settings.onTop.call(element);
                        settings.onUnstick.call(element);
                    },
                    bindBottom: function() {
                        module.debug('Binding element to bottom of parent container');
                        module.remove.offset();
                        $module
                            .css({
                                left         : '',
                                top          : ''
                            })
                            .removeClass(className.fixed)
                            .removeClass(className.top)
                            .addClass(className.bound)
                            .addClass(className.bottom)
                        ;
                        settings.onBottom.call(element);
                        settings.onUnstick.call(element);
                    },

                    setInitialPosition: function() {
                        module.debug('Returning to initial position');
                        module.unfix();
                        module.unbind();
                    },


                    fixTop: function() {
                        module.debug('Fixing element to top of page');
                        module.set.minimumSize();
                        module.set.offset();
                        $module
                            .css({
                                left         : module.cache.element.left,
                                bottom       : '',
                                marginBottom : ''
                            })
                            .removeClass(className.bound)
                            .removeClass(className.bottom)
                            .addClass(className.fixed)
                            .addClass(className.top)
                        ;
                        settings.onStick.call(element);
                    },

                    fixBottom: function() {
                        module.debug('Sticking element to bottom of page');
                        module.set.minimumSize();
                        module.set.offset();
                        $module
                            .css({
                                left         : module.cache.element.left,
                                bottom       : '',
                                marginBottom : ''
                            })
                            .removeClass(className.bound)
                            .removeClass(className.top)
                            .addClass(className.fixed)
                            .addClass(className.bottom)
                        ;
                        settings.onStick.call(element);
                    },

                    unbind: function() {
                        if( module.is.bound() ) {
                            module.debug('Removing container bound position on element');
                            module.remove.offset();
                            $module
                                .removeClass(className.bound)
                                .removeClass(className.top)
                                .removeClass(className.bottom)
                            ;
                        }
                    },

                    unfix: function() {
                        if( module.is.fixed() ) {
                            module.debug('Removing fixed position on element');
                            module.remove.offset();
                            $module
                                .removeClass(className.fixed)
                                .removeClass(className.top)
                                .removeClass(className.bottom)
                            ;
                            settings.onUnstick.call(element);
                        }
                    },

                    reset: function() {
                        module.debug('Resetting elements position');
                        module.unbind();
                        module.unfix();
                        module.resetCSS();
                        module.remove.offset();
                        module.remove.lastScroll();
                    },

                    resetCSS: function() {
                        $module
                            .css({
                                width  : '',
                                height : ''
                            })
                        ;
                        $container
                            .css({
                                height: ''
                            })
                        ;
                    },

                    setting: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 0);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.sticky.settings = {

        name           : 'Sticky',
        namespace      : 'sticky',

        silent         : false,
        debug          : false,
        verbose        : true,
        performance    : true,

        // whether to stick in the opposite direction on scroll up
        pushing        : false,

        context        : false,
        container      : false,

        // Context to watch scroll events
        scrollContext  : window,

        // Offset to adjust scroll
        offset         : 0,

        // Offset to adjust scroll when attached to bottom of screen
        bottomOffset   : 0,

        jitter         : 5, // will only set container height if difference between context and container is larger than this number

        // Whether to automatically observe changes with Mutation Observers
        observeChanges : false,

        // Called when position is recalculated
        onReposition   : function(){},

        // Called on each scroll
        onScroll       : function(){},

        // Called when element is stuck to viewport
        onStick        : function(){},

        // Called when element is unstuck from viewport
        onUnstick      : function(){},

        // Called when element reaches top of context
        onTop          : function(){},

        // Called when element reaches bottom of context
        onBottom       : function(){},

        error         : {
            container      : 'Sticky element must be inside a relative container',
            visible        : 'Element is hidden, you must call refresh after element becomes visible. Use silent setting to surpress this warning in production.',
            method         : 'The method you called is not defined.',
            invalidContext : 'Context specified does not exist',
            elementSize    : 'Sticky element is larger than its container, cannot create sticky.'
        },

        className : {
            bound     : 'bound',
            fixed     : 'fixed',
            supported : 'native',
            top       : 'top',
            bottom    : 'bottom'
        }

    };

})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Tab
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.tab = function(parameters) {

        var
            // use window context if none specified
            $allModules     = $.isFunction(this)
                ? $(window)
                : $(this),

            moduleSelector  = $allModules.selector || '',
            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),

            initializedHistory = false,
            returnedValue
        ;

        $allModules
            .each(function() {
                var

                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.tab.settings, parameters)
                        : $.extend({}, $.fn.tab.settings),

                    className       = settings.className,
                    metadata        = settings.metadata,
                    selector        = settings.selector,
                    error           = settings.error,

                    eventNamespace  = '.' + settings.namespace,
                    moduleNamespace = 'module-' + settings.namespace,

                    $module         = $(this),
                    $context,
                    $tabs,

                    cache           = {},
                    firstLoad       = true,
                    recursionDepth  = 0,
                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    activeTabPath,
                    parameterArray,
                    module,

                    historyEvent

                ;

                module = {

                    initialize: function() {
                        module.debug('Initializing tab menu item', $module);
                        module.fix.callbacks();
                        module.determineTabs();

                        module.debug('Determining tabs', settings.context, $tabs);
                        // set up automatic routing
                        if(settings.auto) {
                            module.set.auto();
                        }
                        module.bind.events();

                        if(settings.history && !initializedHistory) {
                            module.initializeHistory();
                            initializedHistory = true;
                        }

                        module.instantiate();
                    },

                    instantiate: function () {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.debug('Destroying tabs', $module);
                        $module
                            .removeData(moduleNamespace)
                            .off(eventNamespace)
                        ;
                    },

                    bind: {
                        events: function() {
                            // if using $.tab don't add events
                            if( !$.isWindow( element ) ) {
                                module.debug('Attaching tab activation events to element', $module);
                                $module
                                    .on('click' + eventNamespace, module.event.click)
                                ;
                            }
                        }
                    },

                    determineTabs: function() {
                        var
                            $reference
                        ;

                        // determine tab context
                        if(settings.context === 'parent') {
                            if($module.closest(selector.ui).length > 0) {
                                $reference = $module.closest(selector.ui);
                                module.verbose('Using closest UI element as parent', $reference);
                            }
                            else {
                                $reference = $module;
                            }
                            $context = $reference.parent();
                            module.verbose('Determined parent element for creating context', $context);
                        }
                        else if(settings.context) {
                            $context = $(settings.context);
                            module.verbose('Using selector for tab context', settings.context, $context);
                        }
                        else {
                            $context = $('body');
                        }
                        // find tabs
                        if(settings.childrenOnly) {
                            $tabs = $context.children(selector.tabs);
                            module.debug('Searching tab context children for tabs', $context, $tabs);
                        }
                        else {
                            $tabs = $context.find(selector.tabs);
                            module.debug('Searching tab context for tabs', $context, $tabs);
                        }
                    },

                    fix: {
                        callbacks: function() {
                            if( $.isPlainObject(parameters) && (parameters.onTabLoad || parameters.onTabInit) ) {
                                if(parameters.onTabLoad) {
                                    parameters.onLoad = parameters.onTabLoad;
                                    delete parameters.onTabLoad;
                                    module.error(error.legacyLoad, parameters.onLoad);
                                }
                                if(parameters.onTabInit) {
                                    parameters.onFirstLoad = parameters.onTabInit;
                                    delete parameters.onTabInit;
                                    module.error(error.legacyInit, parameters.onFirstLoad);
                                }
                                settings = $.extend(true, {}, $.fn.tab.settings, parameters);
                            }
                        }
                    },

                    initializeHistory: function() {
                        module.debug('Initializing page state');
                        if( $.address === undefined ) {
                            module.error(error.state);
                            return false;
                        }
                        else {
                            if(settings.historyType == 'state') {
                                module.debug('Using HTML5 to manage state');
                                if(settings.path !== false) {
                                    $.address
                                        .history(true)
                                        .state(settings.path)
                                    ;
                                }
                                else {
                                    module.error(error.path);
                                    return false;
                                }
                            }
                            $.address
                                .bind('change', module.event.history.change)
                            ;
                        }
                    },

                    event: {
                        click: function(event) {
                            var
                                tabPath = $(this).data(metadata.tab)
                            ;
                            if(tabPath !== undefined) {
                                if(settings.history) {
                                    module.verbose('Updating page state', event);
                                    $.address.value(tabPath);
                                }
                                else {
                                    module.verbose('Changing tab', event);
                                    module.changeTab(tabPath);
                                }
                                event.preventDefault();
                            }
                            else {
                                module.debug('No tab specified');
                            }
                        },
                        history: {
                            change: function(event) {
                                var
                                    tabPath   = event.pathNames.join('/') || module.get.initialPath(),
                                    pageTitle = settings.templates.determineTitle(tabPath) || false
                                ;
                                module.performance.display();
                                module.debug('History change event', tabPath, event);
                                historyEvent = event;
                                if(tabPath !== undefined) {
                                    module.changeTab(tabPath);
                                }
                                if(pageTitle) {
                                    $.address.title(pageTitle);
                                }
                            }
                        }
                    },

                    refresh: function() {
                        if(activeTabPath) {
                            module.debug('Refreshing tab', activeTabPath);
                            module.changeTab(activeTabPath);
                        }
                    },

                    cache: {

                        read: function(cacheKey) {
                            return (cacheKey !== undefined)
                                ? cache[cacheKey]
                                : false
                                ;
                        },
                        add: function(cacheKey, content) {
                            cacheKey = cacheKey || activeTabPath;
                            module.debug('Adding cached content for', cacheKey);
                            cache[cacheKey] = content;
                        },
                        remove: function(cacheKey) {
                            cacheKey = cacheKey || activeTabPath;
                            module.debug('Removing cached content for', cacheKey);
                            delete cache[cacheKey];
                        }
                    },

                    set: {
                        auto: function() {
                            var
                                url = (typeof settings.path == 'string')
                                    ? settings.path.replace(/\/$/, '') + '/{$tab}'
                                    : '/{$tab}'
                            ;
                            module.verbose('Setting up automatic tab retrieval from server', url);
                            if($.isPlainObject(settings.apiSettings)) {
                                settings.apiSettings.url = url;
                            }
                            else {
                                settings.apiSettings = {
                                    url: url
                                };
                            }
                        },
                        loading: function(tabPath) {
                            var
                                $tab      = module.get.tabElement(tabPath),
                                isLoading = $tab.hasClass(className.loading)
                            ;
                            if(!isLoading) {
                                module.verbose('Setting loading state for', $tab);
                                $tab
                                    .addClass(className.loading)
                                    .siblings($tabs)
                                    .removeClass(className.active + ' ' + className.loading)
                                ;
                                if($tab.length > 0) {
                                    settings.onRequest.call($tab[0], tabPath);
                                }
                            }
                        },
                        state: function(state) {
                            $.address.value(state);
                        }
                    },

                    changeTab: function(tabPath) {
                        var
                            pushStateAvailable = (window.history && window.history.pushState),
                            shouldIgnoreLoad   = (pushStateAvailable && settings.ignoreFirstLoad && firstLoad),
                            remoteContent      = (settings.auto || $.isPlainObject(settings.apiSettings) ),
                            // only add default path if not remote content
                            pathArray = (remoteContent && !shouldIgnoreLoad)
                                ? module.utilities.pathToArray(tabPath)
                                : module.get.defaultPathArray(tabPath)
                        ;
                        tabPath = module.utilities.arrayToPath(pathArray);
                        $.each(pathArray, function(index, tab) {
                            var
                                currentPathArray   = pathArray.slice(0, index + 1),
                                currentPath        = module.utilities.arrayToPath(currentPathArray),

                                isTab              = module.is.tab(currentPath),
                                isLastIndex        = (index + 1 == pathArray.length),

                                $tab               = module.get.tabElement(currentPath),
                                $anchor,
                                nextPathArray,
                                nextPath,
                                isLastTab
                            ;
                            module.verbose('Looking for tab', tab);
                            if(isTab) {
                                module.verbose('Tab was found', tab);
                                // scope up
                                activeTabPath  = currentPath;
                                parameterArray = module.utilities.filterArray(pathArray, currentPathArray);

                                if(isLastIndex) {
                                    isLastTab = true;
                                }
                                else {
                                    nextPathArray = pathArray.slice(0, index + 2);
                                    nextPath      = module.utilities.arrayToPath(nextPathArray);
                                    isLastTab     = ( !module.is.tab(nextPath) );
                                    if(isLastTab) {
                                        module.verbose('Tab parameters found', nextPathArray);
                                    }
                                }
                                if(isLastTab && remoteContent) {
                                    if(!shouldIgnoreLoad) {
                                        module.activate.navigation(currentPath);
                                        module.fetch.content(currentPath, tabPath);
                                    }
                                    else {
                                        module.debug('Ignoring remote content on first tab load', currentPath);
                                        firstLoad = false;
                                        module.cache.add(tabPath, $tab.html());
                                        module.activate.all(currentPath);
                                        settings.onFirstLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                                        settings.onLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                                    }
                                    return false;
                                }
                                else {
                                    module.debug('Opened local tab', currentPath);
                                    module.activate.all(currentPath);
                                    if( !module.cache.read(currentPath) ) {
                                        module.cache.add(currentPath, true);
                                        module.debug('First time tab loaded calling tab init');
                                        settings.onFirstLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                                    }
                                    settings.onLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                                }

                            }
                            else if(tabPath.search('/') == -1 && tabPath !== '') {
                                // look for in page anchor
                                $anchor     = $('#' + tabPath + ', a[name="' + tabPath + '"]');
                                currentPath = $anchor.closest('[data-tab]').data(metadata.tab);
                                $tab        = module.get.tabElement(currentPath);
                                // if anchor exists use parent tab
                                if($anchor && $anchor.length > 0 && currentPath) {
                                    module.debug('Anchor link used, opening parent tab', $tab, $anchor);
                                    if( !$tab.hasClass(className.active) ) {
                                        setTimeout(function() {
                                            module.scrollTo($anchor);
                                        }, 0);
                                    }
                                    module.activate.all(currentPath);
                                    if( !module.cache.read(currentPath) ) {
                                        module.cache.add(currentPath, true);
                                        module.debug('First time tab loaded calling tab init');
                                        settings.onFirstLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                                    }
                                    settings.onLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                                    return false;
                                }
                            }
                            else {
                                module.error(error.missingTab, $module, $context, currentPath);
                                return false;
                            }
                        });
                    },

                    scrollTo: function($element) {
                        var
                            scrollOffset = ($element && $element.length > 0)
                                ? $element.offset().top
                                : false
                        ;
                        if(scrollOffset !== false) {
                            module.debug('Forcing scroll to an in-page link in a hidden tab', scrollOffset, $element);
                            $(document).scrollTop(scrollOffset);
                        }
                    },

                    update: {
                        content: function(tabPath, html, evaluateScripts) {
                            var
                                $tab = module.get.tabElement(tabPath),
                                tab  = $tab[0]
                            ;
                            evaluateScripts = (evaluateScripts !== undefined)
                                ? evaluateScripts
                                : settings.evaluateScripts
                            ;
                            if(typeof settings.cacheType == 'string' && settings.cacheType.toLowerCase() == 'dom' && typeof html !== 'string') {
                                $tab
                                    .empty()
                                    .append($(html).clone(true))
                                ;
                            }
                            else {
                                if(evaluateScripts) {
                                    module.debug('Updating HTML and evaluating inline scripts', tabPath, html);
                                    $tab.html(html);
                                }
                                else {
                                    module.debug('Updating HTML', tabPath, html);
                                    tab.innerHTML = html;
                                }
                            }
                        }
                    },

                    fetch: {

                        content: function(tabPath, fullTabPath) {
                            var
                                $tab        = module.get.tabElement(tabPath),
                                apiSettings = {
                                    dataType         : 'html',
                                    encodeParameters : false,
                                    on               : 'now',
                                    cache            : settings.alwaysRefresh,
                                    headers          : {
                                        'X-Remote': true
                                    },
                                    onSuccess : function(response) {
                                        if(settings.cacheType == 'response') {
                                            module.cache.add(fullTabPath, response);
                                        }
                                        module.update.content(tabPath, response);
                                        if(tabPath == activeTabPath) {
                                            module.debug('Content loaded', tabPath);
                                            module.activate.tab(tabPath);
                                        }
                                        else {
                                            module.debug('Content loaded in background', tabPath);
                                        }
                                        settings.onFirstLoad.call($tab[0], tabPath, parameterArray, historyEvent);
                                        settings.onLoad.call($tab[0], tabPath, parameterArray, historyEvent);

                                        if(typeof settings.cacheType == 'string' && settings.cacheType.toLowerCase() == 'dom' && $tab.children().length > 0) {
                                            setTimeout(function() {
                                                var
                                                    $clone = $tab.children().clone(true)
                                                ;
                                                $clone = $clone.not('script');
                                                module.cache.add(fullTabPath, $clone);
                                            }, 0);
                                        }
                                        else {
                                            module.cache.add(fullTabPath, $tab.html());
                                        }
                                    },
                                    urlData: {
                                        tab: fullTabPath
                                    }
                                },
                                request         = $tab.api('get request') || false,
                                existingRequest = ( request && request.state() === 'pending' ),
                                requestSettings,
                                cachedContent
                            ;

                            fullTabPath   = fullTabPath || tabPath;
                            cachedContent = module.cache.read(fullTabPath);


                            if(settings.cache && cachedContent) {
                                module.activate.tab(tabPath);
                                module.debug('Adding cached content', fullTabPath);
                                if(settings.evaluateScripts == 'once') {
                                    module.update.content(tabPath, cachedContent, false);
                                }
                                else {
                                    module.update.content(tabPath, cachedContent);
                                }
                                settings.onLoad.call($tab[0], tabPath, parameterArray, historyEvent);
                            }
                            else if(existingRequest) {
                                module.set.loading(tabPath);
                                module.debug('Content is already loading', fullTabPath);
                            }
                            else if($.api !== undefined) {
                                requestSettings = $.extend(true, {}, settings.apiSettings, apiSettings);
                                module.debug('Retrieving remote content', fullTabPath, requestSettings);
                                module.set.loading(tabPath);
                                $tab.api(requestSettings);
                            }
                            else {
                                module.error(error.api);
                            }
                        }
                    },

                    activate: {
                        all: function(tabPath) {
                            module.activate.tab(tabPath);
                            module.activate.navigation(tabPath);
                        },
                        tab: function(tabPath) {
                            var
                                $tab          = module.get.tabElement(tabPath),
                                $deactiveTabs = (settings.deactivate == 'siblings')
                                    ? $tab.siblings($tabs)
                                    : $tabs.not($tab),
                                isActive      = $tab.hasClass(className.active)
                            ;
                            module.verbose('Showing tab content for', $tab);
                            if(!isActive) {
                                $tab
                                    .addClass(className.active)
                                ;
                                $deactiveTabs
                                    .removeClass(className.active + ' ' + className.loading)
                                ;
                                if($tab.length > 0) {
                                    settings.onVisible.call($tab[0], tabPath);
                                }
                            }
                        },
                        navigation: function(tabPath) {
                            var
                                $navigation         = module.get.navElement(tabPath),
                                $deactiveNavigation = (settings.deactivate == 'siblings')
                                    ? $navigation.siblings($allModules)
                                    : $allModules.not($navigation),
                                isActive    = $navigation.hasClass(className.active)
                            ;
                            module.verbose('Activating tab navigation for', $navigation, tabPath);
                            if(!isActive) {
                                $navigation
                                    .addClass(className.active)
                                ;
                                $deactiveNavigation
                                    .removeClass(className.active + ' ' + className.loading)
                                ;
                            }
                        }
                    },

                    deactivate: {
                        all: function() {
                            module.deactivate.navigation();
                            module.deactivate.tabs();
                        },
                        navigation: function() {
                            $allModules
                                .removeClass(className.active)
                            ;
                        },
                        tabs: function() {
                            $tabs
                                .removeClass(className.active + ' ' + className.loading)
                            ;
                        }
                    },

                    is: {
                        tab: function(tabName) {
                            return (tabName !== undefined)
                                ? ( module.get.tabElement(tabName).length > 0 )
                                : false
                                ;
                        }
                    },

                    get: {
                        initialPath: function() {
                            return $allModules.eq(0).data(metadata.tab) || $tabs.eq(0).data(metadata.tab);
                        },
                        path: function() {
                            return $.address.value();
                        },
                        // adds default tabs to tab path
                        defaultPathArray: function(tabPath) {
                            return module.utilities.pathToArray( module.get.defaultPath(tabPath) );
                        },
                        defaultPath: function(tabPath) {
                            var
                                $defaultNav = $allModules.filter('[data-' + metadata.tab + '^="' + tabPath + '/"]').eq(0),
                                defaultTab  = $defaultNav.data(metadata.tab) || false
                            ;
                            if( defaultTab ) {
                                module.debug('Found default tab', defaultTab);
                                if(recursionDepth < settings.maxDepth) {
                                    recursionDepth++;
                                    return module.get.defaultPath(defaultTab);
                                }
                                module.error(error.recursion);
                            }
                            else {
                                module.debug('No default tabs found for', tabPath, $tabs);
                            }
                            recursionDepth = 0;
                            return tabPath;
                        },
                        navElement: function(tabPath) {
                            tabPath = tabPath || activeTabPath;
                            return $allModules.filter('[data-' + metadata.tab + '="' + tabPath + '"]');
                        },
                        tabElement: function(tabPath) {
                            var
                                $fullPathTab,
                                $simplePathTab,
                                tabPathArray,
                                lastTab
                            ;
                            tabPath        = tabPath || activeTabPath;
                            tabPathArray   = module.utilities.pathToArray(tabPath);
                            lastTab        = module.utilities.last(tabPathArray);
                            $fullPathTab   = $tabs.filter('[data-' + metadata.tab + '="' + tabPath + '"]');
                            $simplePathTab = $tabs.filter('[data-' + metadata.tab + '="' + lastTab + '"]');
                            return ($fullPathTab.length > 0)
                                ? $fullPathTab
                                : $simplePathTab
                                ;
                        },
                        tab: function() {
                            return activeTabPath;
                        }
                    },

                    utilities: {
                        filterArray: function(keepArray, removeArray) {
                            return $.grep(keepArray, function(keepValue) {
                                return ( $.inArray(keepValue, removeArray) == -1);
                            });
                        },
                        last: function(array) {
                            return $.isArray(array)
                                ? array[ array.length - 1]
                                : false
                                ;
                        },
                        pathToArray: function(pathName) {
                            if(pathName === undefined) {
                                pathName = activeTabPath;
                            }
                            return typeof pathName == 'string'
                                ? pathName.split('/')
                                : [pathName]
                                ;
                        },
                        arrayToPath: function(pathArray) {
                            return $.isArray(pathArray)
                                ? pathArray.join('/')
                                : false
                                ;
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            if($.isPlainObject(settings[name])) {
                                $.extend(true, settings[name], value);
                            }
                            else {
                                settings[name] = value;
                            }
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };
                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;
        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;

    };

// shortcut for tabbed content with no defined navigation
    $.tab = function() {
        $(window).tab.apply(this, arguments);
    };

    $.fn.tab.settings = {

        name            : 'Tab',
        namespace       : 'tab',

        silent          : false,
        debug           : false,
        verbose         : false,
        performance     : true,

        auto            : false,      // uses pjax style endpoints fetching content from same url with remote-content headers
        history         : false,      // use browser history
        historyType     : 'hash',     // #/ or html5 state
        path            : false,      // base path of url

        context         : false,      // specify a context that tabs must appear inside
        childrenOnly    : false,      // use only tabs that are children of context
        maxDepth        : 25,         // max depth a tab can be nested

        deactivate      : 'siblings', // whether tabs should deactivate sibling menu elements or all elements initialized together

        alwaysRefresh   : false,      // load tab content new every tab click
        cache           : true,       // cache the content requests to pull locally
        cacheType       : 'response', // Whether to cache exact response, or to html cache contents after scripts execute
        ignoreFirstLoad : false,      // don't load remote content on first load

        apiSettings     : false,      // settings for api call
        evaluateScripts : 'once',     // whether inline scripts should be parsed (true/false/once). Once will not re-evaluate on cached content

        onFirstLoad : function(tabPath, parameterArray, historyEvent) {}, // called first time loaded
        onLoad      : function(tabPath, parameterArray, historyEvent) {}, // called on every load
        onVisible   : function(tabPath, parameterArray, historyEvent) {}, // called every time tab visible
        onRequest   : function(tabPath, parameterArray, historyEvent) {}, // called ever time a tab beings loading remote content

        templates : {
            determineTitle: function(tabArray) {} // returns page title for path
        },

        error: {
            api        : 'You attempted to load content without API module',
            method     : 'The method you called is not defined',
            missingTab : 'Activated tab cannot be found. Tabs are case-sensitive.',
            noContent  : 'The tab you specified is missing a content url.',
            path       : 'History enabled, but no path was specified',
            recursion  : 'Max recursive depth reached',
            legacyInit : 'onTabInit has been renamed to onFirstLoad in 2.0, please adjust your code.',
            legacyLoad : 'onTabLoad has been renamed to onLoad in 2.0. Please adjust your code',
            state      : 'History requires Asual\'s Address library <https://github.com/asual/jquery-address>'
        },

        metadata : {
            tab    : 'tab',
            loaded : 'loaded',
            promise: 'promise'
        },

        className   : {
            loading : 'loading',
            active  : 'active'
        },

        selector    : {
            tabs : '.ui.tab',
            ui   : '.ui'
        }

    };

})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Transition
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.transition = function() {
        var
            $allModules     = $(this),
            moduleSelector  = $allModules.selector || '',

            time            = new Date().getTime(),
            performance     = [],

            moduleArguments = arguments,
            query           = moduleArguments[0],
            queryArguments  = [].slice.call(arguments, 1),
            methodInvoked   = (typeof query === 'string'),

            requestAnimationFrame = window.requestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.msRequestAnimationFrame
                || function(callback) { setTimeout(callback, 0); },

            returnedValue
        ;
        $allModules
            .each(function(index) {
                var
                    $module  = $(this),
                    element  = this,

                    // set at run time
                    settings,
                    instance,

                    error,
                    className,
                    metadata,
                    animationEnd,
                    animationName,

                    namespace,
                    moduleNamespace,
                    eventNamespace,
                    module
                ;

                module = {

                    initialize: function() {

                        // get full settings
                        settings        = module.get.settings.apply(element, moduleArguments);

                        // shorthand
                        className       = settings.className;
                        error           = settings.error;
                        metadata        = settings.metadata;

                        // define namespace
                        eventNamespace  = '.' + settings.namespace;
                        moduleNamespace = 'module-' + settings.namespace;
                        instance        = $module.data(moduleNamespace) || module;

                        // get vendor specific events
                        animationEnd    = module.get.animationEndEvent();

                        if(methodInvoked) {
                            methodInvoked = module.invoke(query);
                        }

                        // method not invoked, lets run an animation
                        if(methodInvoked === false) {
                            module.verbose('Converted arguments into settings object', settings);
                            if(settings.interval) {
                                module.delay(settings.animate);
                            }
                            else  {
                                module.animate();
                            }
                            module.instantiate();
                        }
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, instance)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module for', element);
                        $module
                            .removeData(moduleNamespace)
                        ;
                    },

                    refresh: function() {
                        module.verbose('Refreshing display type on next animation');
                        delete module.displayType;
                    },

                    forceRepaint: function() {
                        module.verbose('Forcing element repaint');
                        var
                            $parentElement = $module.parent(),
                            $nextElement = $module.next()
                        ;
                        if($nextElement.length === 0) {
                            $module.detach().appendTo($parentElement);
                        }
                        else {
                            $module.detach().insertBefore($nextElement);
                        }
                    },

                    repaint: function() {
                        module.verbose('Repainting element');
                        var
                            fakeAssignment = element.offsetWidth
                        ;
                    },

                    delay: function(interval) {
                        var
                            direction = module.get.animationDirection(),
                            shouldReverse,
                            delay
                        ;
                        if(!direction) {
                            direction = module.can.transition()
                                ? module.get.direction()
                                : 'static'
                            ;
                        }
                        interval = (interval !== undefined)
                            ? interval
                            : settings.interval
                        ;
                        shouldReverse = (settings.reverse == 'auto' && direction == className.outward);
                        delay = (shouldReverse || settings.reverse == true)
                            ? ($allModules.length - index) * settings.interval
                            : index * settings.interval
                        ;
                        module.debug('Delaying animation by', delay);
                        setTimeout(module.animate, delay);
                    },

                    animate: function(overrideSettings) {
                        settings = overrideSettings || settings;
                        if(!module.is.supported()) {
                            module.error(error.support);
                            return false;
                        }
                        module.debug('Preparing animation', settings.animation);
                        if(module.is.animating()) {
                            if(settings.queue) {
                                if(!settings.allowRepeats && module.has.direction() && module.is.occurring() && module.queuing !== true) {
                                    module.debug('Animation is currently occurring, preventing queueing same animation', settings.animation);
                                }
                                else {
                                    module.queue(settings.animation);
                                }
                                return false;
                            }
                            else if(!settings.allowRepeats && module.is.occurring()) {
                                module.debug('Animation is already occurring, will not execute repeated animation', settings.animation);
                                return false;
                            }
                            else {
                                module.debug('New animation started, completing previous early', settings.animation);
                                instance.complete();
                            }
                        }
                        if( module.can.animate() ) {
                            module.set.animating(settings.animation);
                        }
                        else {
                            module.error(error.noAnimation, settings.animation, element);
                        }
                    },

                    reset: function() {
                        module.debug('Resetting animation to beginning conditions');
                        module.remove.animationCallbacks();
                        module.restore.conditions();
                        module.remove.animating();
                    },

                    queue: function(animation) {
                        module.debug('Queueing animation of', animation);
                        module.queuing = true;
                        $module
                            .one(animationEnd + '.queue' + eventNamespace, function() {
                                module.queuing = false;
                                module.repaint();
                                module.animate.apply(this, settings);
                            })
                        ;
                    },

                    complete: function (event) {
                        module.debug('Animation complete', settings.animation);
                        module.remove.completeCallback();
                        module.remove.failSafe();
                        if(!module.is.looping()) {
                            if( module.is.outward() ) {
                                module.verbose('Animation is outward, hiding element');
                                module.restore.conditions();
                                module.hide();
                            }
                            else if( module.is.inward() ) {
                                module.verbose('Animation is outward, showing element');
                                module.restore.conditions();
                                module.show();
                            }
                            else {
                                module.verbose('Static animation completed');
                                module.restore.conditions();
                                settings.onComplete.call(element);
                            }
                        }
                    },

                    force: {
                        visible: function() {
                            var
                                style          = $module.attr('style'),
                                userStyle      = module.get.userStyle(),
                                displayType    = module.get.displayType(),
                                overrideStyle  = userStyle + 'display: ' + displayType + ' !important;',
                                currentDisplay = $module.css('display'),
                                emptyStyle     = (style === undefined || style === '')
                            ;
                            if(currentDisplay !== displayType) {
                                module.verbose('Overriding default display to show element', displayType);
                                $module
                                    .attr('style', overrideStyle)
                                ;
                            }
                            else if(emptyStyle) {
                                $module.removeAttr('style');
                            }
                        },
                        hidden: function() {
                            var
                                style          = $module.attr('style'),
                                currentDisplay = $module.css('display'),
                                emptyStyle     = (style === undefined || style === '')
                            ;
                            if(currentDisplay !== 'none' && !module.is.hidden()) {
                                module.verbose('Overriding default display to hide element');
                                $module
                                    .css('display', 'none')
                                ;
                            }
                            else if(emptyStyle) {
                                $module
                                    .removeAttr('style')
                                ;
                            }
                        }
                    },

                    has: {
                        direction: function(animation) {
                            var
                                hasDirection = false
                            ;
                            animation = animation || settings.animation;
                            if(typeof animation === 'string') {
                                animation = animation.split(' ');
                                $.each(animation, function(index, word){
                                    if(word === className.inward || word === className.outward) {
                                        hasDirection = true;
                                    }
                                });
                            }
                            return hasDirection;
                        },
                        inlineDisplay: function() {
                            var
                                style = $module.attr('style') || ''
                            ;
                            return $.isArray(style.match(/display.*?;/, ''));
                        }
                    },

                    set: {
                        animating: function(animation) {
                            var
                                animationClass,
                                direction
                            ;
                            // remove previous callbacks
                            module.remove.completeCallback();

                            // determine exact animation
                            animation      = animation || settings.animation;
                            animationClass = module.get.animationClass(animation);

                            // save animation class in cache to restore class names
                            module.save.animation(animationClass);

                            // override display if necessary so animation appears visibly
                            module.force.visible();

                            module.remove.hidden();
                            module.remove.direction();

                            module.start.animation(animationClass);

                        },
                        duration: function(animationName, duration) {
                            duration = duration || settings.duration;
                            duration = (typeof duration == 'number')
                                ? duration + 'ms'
                                : duration
                            ;
                            if(duration || duration === 0) {
                                module.verbose('Setting animation duration', duration);
                                $module
                                    .css({
                                        'animation-duration':  duration
                                    })
                                ;
                            }
                        },
                        direction: function(direction) {
                            direction = direction || module.get.direction();
                            if(direction == className.inward) {
                                module.set.inward();
                            }
                            else {
                                module.set.outward();
                            }
                        },
                        looping: function() {
                            module.debug('Transition set to loop');
                            $module
                                .addClass(className.looping)
                            ;
                        },
                        hidden: function() {
                            $module
                                .addClass(className.transition)
                                .addClass(className.hidden)
                            ;
                        },
                        inward: function() {
                            module.debug('Setting direction to inward');
                            $module
                                .removeClass(className.outward)
                                .addClass(className.inward)
                            ;
                        },
                        outward: function() {
                            module.debug('Setting direction to outward');
                            $module
                                .removeClass(className.inward)
                                .addClass(className.outward)
                            ;
                        },
                        visible: function() {
                            $module
                                .addClass(className.transition)
                                .addClass(className.visible)
                            ;
                        }
                    },

                    start: {
                        animation: function(animationClass) {
                            animationClass = animationClass || module.get.animationClass();
                            module.debug('Starting tween', animationClass);
                            $module
                                .addClass(animationClass)
                                .one(animationEnd + '.complete' + eventNamespace, module.complete)
                            ;
                            if(settings.useFailSafe) {
                                module.add.failSafe();
                            }
                            module.set.duration(settings.duration);
                            settings.onStart.call(element);
                        }
                    },

                    save: {
                        animation: function(animation) {
                            if(!module.cache) {
                                module.cache = {};
                            }
                            module.cache.animation = animation;
                        },
                        displayType: function(displayType) {
                            if(displayType !== 'none') {
                                $module.data(metadata.displayType, displayType);
                            }
                        },
                        transitionExists: function(animation, exists) {
                            $.fn.transition.exists[animation] = exists;
                            module.verbose('Saving existence of transition', animation, exists);
                        }
                    },

                    restore: {
                        conditions: function() {
                            var
                                animation = module.get.currentAnimation()
                            ;
                            if(animation) {
                                $module
                                    .removeClass(animation)
                                ;
                                module.verbose('Removing animation class', module.cache);
                            }
                            module.remove.duration();
                        }
                    },

                    add: {
                        failSafe: function() {
                            var
                                duration = module.get.duration()
                            ;
                            module.timer = setTimeout(function() {
                                $module.triggerHandler(animationEnd);
                            }, duration + settings.failSafeDelay);
                            module.verbose('Adding fail safe timer', module.timer);
                        }
                    },

                    remove: {
                        animating: function() {
                            $module.removeClass(className.animating);
                        },
                        animationCallbacks: function() {
                            module.remove.queueCallback();
                            module.remove.completeCallback();
                        },
                        queueCallback: function() {
                            $module.off('.queue' + eventNamespace);
                        },
                        completeCallback: function() {
                            $module.off('.complete' + eventNamespace);
                        },
                        display: function() {
                            $module.css('display', '');
                        },
                        direction: function() {
                            $module
                                .removeClass(className.inward)
                                .removeClass(className.outward)
                            ;
                        },
                        duration: function() {
                            $module
                                .css('animation-duration', '')
                            ;
                        },
                        failSafe: function() {
                            module.verbose('Removing fail safe timer', module.timer);
                            if(module.timer) {
                                clearTimeout(module.timer);
                            }
                        },
                        hidden: function() {
                            $module.removeClass(className.hidden);
                        },
                        visible: function() {
                            $module.removeClass(className.visible);
                        },
                        looping: function() {
                            module.debug('Transitions are no longer looping');
                            if( module.is.looping() ) {
                                module.reset();
                                $module
                                    .removeClass(className.looping)
                                ;
                            }
                        },
                        transition: function() {
                            $module
                                .removeClass(className.visible)
                                .removeClass(className.hidden)
                            ;
                        }
                    },
                    get: {
                        settings: function(animation, duration, onComplete) {
                            // single settings object
                            if(typeof animation == 'object') {
                                return $.extend(true, {}, $.fn.transition.settings, animation);
                            }
                            // all arguments provided
                            else if(typeof onComplete == 'function') {
                                return $.extend({}, $.fn.transition.settings, {
                                    animation  : animation,
                                    onComplete : onComplete,
                                    duration   : duration
                                });
                            }
                            // only duration provided
                            else if(typeof duration == 'string' || typeof duration == 'number') {
                                return $.extend({}, $.fn.transition.settings, {
                                    animation : animation,
                                    duration  : duration
                                });
                            }
                            // duration is actually settings object
                            else if(typeof duration == 'object') {
                                return $.extend({}, $.fn.transition.settings, duration, {
                                    animation : animation
                                });
                            }
                            // duration is actually callback
                            else if(typeof duration == 'function') {
                                return $.extend({}, $.fn.transition.settings, {
                                    animation  : animation,
                                    onComplete : duration
                                });
                            }
                            // only animation provided
                            else {
                                return $.extend({}, $.fn.transition.settings, {
                                    animation : animation
                                });
                            }
                        },
                        animationClass: function(animation) {
                            var
                                animationClass = animation || settings.animation,
                                directionClass = (module.can.transition() && !module.has.direction())
                                    ? module.get.direction() + ' '
                                    : ''
                            ;
                            return className.animating + ' '
                                + className.transition + ' '
                                + directionClass
                                + animationClass
                                ;
                        },
                        currentAnimation: function() {
                            return (module.cache && module.cache.animation !== undefined)
                                ? module.cache.animation
                                : false
                                ;
                        },
                        currentDirection: function() {
                            return module.is.inward()
                                ? className.inward
                                : className.outward
                                ;
                        },
                        direction: function() {
                            return module.is.hidden() || !module.is.visible()
                                ? className.inward
                                : className.outward
                                ;
                        },
                        animationDirection: function(animation) {
                            var
                                direction
                            ;
                            animation = animation || settings.animation;
                            if(typeof animation === 'string') {
                                animation = animation.split(' ');
                                // search animation name for out/in class
                                $.each(animation, function(index, word){
                                    if(word === className.inward) {
                                        direction = className.inward;
                                    }
                                    else if(word === className.outward) {
                                        direction = className.outward;
                                    }
                                });
                            }
                            // return found direction
                            if(direction) {
                                return direction;
                            }
                            return false;
                        },
                        duration: function(duration) {
                            duration = duration || settings.duration;
                            if(duration === false) {
                                duration = $module.css('animation-duration') || 0;
                            }
                            return (typeof duration === 'string')
                                ? (duration.indexOf('ms') > -1)
                                    ? parseFloat(duration)
                                    : parseFloat(duration) * 1000
                                : duration
                                ;
                        },
                        displayType: function(shouldDetermine) {
                            shouldDetermine = (shouldDetermine !== undefined)
                                ? shouldDetermine
                                : true
                            ;
                            if(settings.displayType) {
                                return settings.displayType;
                            }
                            if(shouldDetermine && $module.data(metadata.displayType) === undefined) {
                                // create fake element to determine display state
                                module.can.transition(true);
                            }
                            return $module.data(metadata.displayType);
                        },
                        userStyle: function(style) {
                            style = style || $module.attr('style') || '';
                            return style.replace(/display.*?;/, '');
                        },
                        transitionExists: function(animation) {
                            return $.fn.transition.exists[animation];
                        },
                        animationStartEvent: function() {
                            var
                                element     = document.createElement('div'),
                                animations  = {
                                    'animation'       :'animationstart',
                                    'OAnimation'      :'oAnimationStart',
                                    'MozAnimation'    :'mozAnimationStart',
                                    'WebkitAnimation' :'webkitAnimationStart'
                                },
                                animation
                            ;
                            for(animation in animations){
                                if( element.style[animation] !== undefined ){
                                    return animations[animation];
                                }
                            }
                            return false;
                        },
                        animationEndEvent: function() {
                            var
                                element     = document.createElement('div'),
                                animations  = {
                                    'animation'       :'animationend',
                                    'OAnimation'      :'oAnimationEnd',
                                    'MozAnimation'    :'mozAnimationEnd',
                                    'WebkitAnimation' :'webkitAnimationEnd'
                                },
                                animation
                            ;
                            for(animation in animations){
                                if( element.style[animation] !== undefined ){
                                    return animations[animation];
                                }
                            }
                            return false;
                        }

                    },

                    can: {
                        transition: function(forced) {
                            var
                                animation         = settings.animation,
                                transitionExists  = module.get.transitionExists(animation),
                                displayType       = module.get.displayType(false),
                                elementClass,
                                tagName,
                                $clone,
                                currentAnimation,
                                inAnimation,
                                directionExists
                            ;
                            if( transitionExists === undefined || forced) {
                                module.verbose('Determining whether animation exists');
                                elementClass = $module.attr('class');
                                tagName      = $module.prop('tagName');

                                $clone = $('<' + tagName + ' />').addClass( elementClass ).insertAfter($module);
                                currentAnimation = $clone
                                    .addClass(animation)
                                    .removeClass(className.inward)
                                    .removeClass(className.outward)
                                    .addClass(className.animating)
                                    .addClass(className.transition)
                                    .css('animationName')
                                ;
                                inAnimation = $clone
                                    .addClass(className.inward)
                                    .css('animationName')
                                ;
                                if(!displayType) {
                                    displayType = $clone
                                        .attr('class', elementClass)
                                        .removeAttr('style')
                                        .removeClass(className.hidden)
                                        .removeClass(className.visible)
                                        .show()
                                        .css('display')
                                    ;
                                    module.verbose('Determining final display state', displayType);
                                    module.save.displayType(displayType);
                                }

                                $clone.remove();
                                if(currentAnimation != inAnimation) {
                                    module.debug('Direction exists for animation', animation);
                                    directionExists = true;
                                }
                                else if(currentAnimation == 'none' || !currentAnimation) {
                                    module.debug('No animation defined in css', animation);
                                    return;
                                }
                                else {
                                    module.debug('Static animation found', animation, displayType);
                                    directionExists = false;
                                }
                                module.save.transitionExists(animation, directionExists);
                            }
                            return (transitionExists !== undefined)
                                ? transitionExists
                                : directionExists
                                ;
                        },
                        animate: function() {
                            // can transition does not return a value if animation does not exist
                            return (module.can.transition() !== undefined);
                        }
                    },

                    is: {
                        animating: function() {
                            return $module.hasClass(className.animating);
                        },
                        inward: function() {
                            return $module.hasClass(className.inward);
                        },
                        outward: function() {
                            return $module.hasClass(className.outward);
                        },
                        looping: function() {
                            return $module.hasClass(className.looping);
                        },
                        occurring: function(animation) {
                            animation = animation || settings.animation;
                            animation = '.' + animation.replace(' ', '.');
                            return ( $module.filter(animation).length > 0 );
                        },
                        visible: function() {
                            return $module.is(':visible');
                        },
                        hidden: function() {
                            return $module.css('visibility') === 'hidden';
                        },
                        supported: function() {
                            return(animationEnd !== false);
                        }
                    },

                    hide: function() {
                        module.verbose('Hiding element');
                        if( module.is.animating() ) {
                            module.reset();
                        }
                        element.blur(); // IE will trigger focus change if element is not blurred before hiding
                        module.remove.display();
                        module.remove.visible();
                        module.set.hidden();
                        module.force.hidden();
                        settings.onHide.call(element);
                        settings.onComplete.call(element);
                        // module.repaint();
                    },

                    show: function(display) {
                        module.verbose('Showing element', display);
                        module.remove.hidden();
                        module.set.visible();
                        module.force.visible();
                        settings.onShow.call(element);
                        settings.onComplete.call(element);
                        // module.repaint();
                    },

                    toggle: function() {
                        if( module.is.visible() ) {
                            module.hide();
                        }
                        else {
                            module.show();
                        }
                    },

                    stop: function() {
                        module.debug('Stopping current animation');
                        $module.triggerHandler(animationEnd);
                    },

                    stopAll: function() {
                        module.debug('Stopping all animation');
                        module.remove.queueCallback();
                        $module.triggerHandler(animationEnd);
                    },

                    clear: {
                        queue: function() {
                            module.debug('Clearing animation queue');
                            module.remove.queueCallback();
                        }
                    },

                    enable: function() {
                        module.verbose('Starting animation');
                        $module.removeClass(className.disabled);
                    },

                    disable: function() {
                        module.debug('Stopping animation');
                        $module.addClass(className.disabled);
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            if($.isPlainObject(settings[name])) {
                                $.extend(true, settings[name], value);
                            }
                            else {
                                settings[name] = value;
                            }
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if($allModules.length > 1) {
                                title += ' ' + '(' + $allModules.length + ')';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    // modified for transition to return invoke success
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }

                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return (found !== undefined)
                            ? found
                            : false
                            ;
                    }
                };
                module.initialize();
            })
        ;
        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

// Records if CSS transition is available
    $.fn.transition.exists = {};

    $.fn.transition.settings = {

        // module info
        name          : 'Transition',

        // hide all output from this component regardless of other settings
        silent        : false,

        // debug content outputted to console
        debug         : false,

        // verbose debug output
        verbose       : false,

        // performance data output
        performance   : true,

        // event namespace
        namespace     : 'transition',

        // delay between animations in group
        interval      : 0,

        // whether group animations should be reversed
        reverse       : 'auto',

        // animation callback event
        onStart       : function() {},
        onComplete    : function() {},
        onShow        : function() {},
        onHide        : function() {},

        // whether timeout should be used to ensure callback fires in cases animationend does not
        useFailSafe   : true,

        // delay in ms for fail safe
        failSafeDelay : 100,

        // whether EXACT animation can occur twice in a row
        allowRepeats  : false,

        // Override final display type on visible
        displayType   : false,

        // animation duration
        animation     : 'fade',
        duration      : false,

        // new animations will occur after previous ones
        queue         : true,

        metadata : {
            displayType: 'display'
        },

        className   : {
            animating  : 'animating',
            disabled   : 'disabled',
            hidden     : 'hidden',
            inward     : 'in',
            loading    : 'loading',
            looping    : 'looping',
            outward    : 'out',
            transition : 'transition',
            visible    : 'visible'
        },

        // possible errors
        error: {
            noAnimation : 'Element is no longer attached to DOM. Unable to animate.  Use silent setting to surpress this warning in production.',
            repeated    : 'That animation is already occurring, cancelling repeated animation',
            method      : 'The method you called is not defined',
            support     : 'This browser does not support CSS animations'
        }

    };


})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - API
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    var
        window = (typeof window != 'undefined' && window.Math == Math)
            ? window
            : (typeof self != 'undefined' && self.Math == Math)
                ? self
                : Function('return this')()
    ;

    $.api = $.fn.api = function(parameters) {

        var
            // use window context if none specified
            $allModules     = $.isFunction(this)
                ? $(window)
                : $(this),
            moduleSelector = $allModules.selector || '',
            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),

            returnedValue
        ;

        $allModules
            .each(function() {
                var
                    settings          = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.api.settings, parameters)
                        : $.extend({}, $.fn.api.settings),

                    // internal aliases
                    namespace       = settings.namespace,
                    metadata        = settings.metadata,
                    selector        = settings.selector,
                    error           = settings.error,
                    className       = settings.className,

                    // define namespaces for modules
                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    // element that creates request
                    $module         = $(this),
                    $form           = $module.closest(selector.form),

                    // context used for state
                    $context        = (settings.stateContext)
                        ? $(settings.stateContext)
                        : $module,

                    // request details
                    ajaxSettings,
                    requestSettings,
                    url,
                    data,
                    requestStartTime,

                    // standard module
                    element         = this,
                    context         = $context[0],
                    instance        = $module.data(moduleNamespace),
                    module
                ;

                module = {

                    initialize: function() {
                        if(!methodInvoked) {
                            module.bind.events();
                        }
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, instance)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module for', element);
                        $module
                            .removeData(moduleNamespace)
                            .off(eventNamespace)
                        ;
                    },

                    bind: {
                        events: function() {
                            var
                                triggerEvent = module.get.event()
                            ;
                            if( triggerEvent ) {
                                module.verbose('Attaching API events to element', triggerEvent);
                                $module
                                    .on(triggerEvent + eventNamespace, module.event.trigger)
                                ;
                            }
                            else if(settings.on == 'now') {
                                module.debug('Querying API endpoint immediately');
                                module.query();
                            }
                        }
                    },

                    decode: {
                        json: function(response) {
                            if(response !== undefined && typeof response == 'string') {
                                try {
                                    response = JSON.parse(response);
                                }
                                catch(e) {
                                    // isnt json string
                                }
                            }
                            return response;
                        }
                    },

                    read: {
                        cachedResponse: function(url) {
                            var
                                response
                            ;
                            if(window.Storage === undefined) {
                                module.error(error.noStorage);
                                return;
                            }
                            response = sessionStorage.getItem(url);
                            module.debug('Using cached response', url, response);
                            response = module.decode.json(response);
                            return response;
                        }
                    },
                    write: {
                        cachedResponse: function(url, response) {
                            if(response && response === '') {
                                module.debug('Response empty, not caching', response);
                                return;
                            }
                            if(window.Storage === undefined) {
                                module.error(error.noStorage);
                                return;
                            }
                            if( $.isPlainObject(response) ) {
                                response = JSON.stringify(response);
                            }
                            sessionStorage.setItem(url, response);
                            module.verbose('Storing cached response for url', url, response);
                        }
                    },

                    query: function() {

                        if(module.is.disabled()) {
                            module.debug('Element is disabled API request aborted');
                            return;
                        }

                        if(module.is.loading()) {
                            if(settings.interruptRequests) {
                                module.debug('Interrupting previous request');
                                module.abort();
                            }
                            else {
                                module.debug('Cancelling request, previous request is still pending');
                                return;
                            }
                        }

                        // pass element metadata to url (value, text)
                        if(settings.defaultData) {
                            $.extend(true, settings.urlData, module.get.defaultData());
                        }

                        // Add form content
                        if(settings.serializeForm) {
                            settings.data = module.add.formData(settings.data);
                        }

                        // call beforesend and get any settings changes
                        requestSettings = module.get.settings();

                        // check if before send cancelled request
                        if(requestSettings === false) {
                            module.cancelled = true;
                            module.error(error.beforeSend);
                            return;
                        }
                        else {
                            module.cancelled = false;
                        }

                        // get url
                        url = module.get.templatedURL();

                        if(!url && !module.is.mocked()) {
                            module.error(error.missingURL);
                            return;
                        }

                        // replace variables
                        url = module.add.urlData( url );
                        // missing url parameters
                        if( !url && !module.is.mocked()) {
                            return;
                        }

                        requestSettings.url = settings.base + url;

                        // look for jQuery ajax parameters in settings
                        ajaxSettings = $.extend(true, {}, settings, {
                            type       : settings.method || settings.type,
                            data       : data,
                            url        : settings.base + url,
                            beforeSend : settings.beforeXHR,
                            success    : function() {},
                            failure    : function() {},
                            complete   : function() {}
                        });

                        module.debug('Querying URL', ajaxSettings.url);
                        module.verbose('Using AJAX settings', ajaxSettings);
                        if(settings.cache === 'local' && module.read.cachedResponse(url)) {
                            module.debug('Response returned from local cache');
                            module.request = module.create.request();
                            module.request.resolveWith(context, [ module.read.cachedResponse(url) ]);
                            return;
                        }

                        if( !settings.throttle ) {
                            module.debug('Sending request', data, ajaxSettings.method);
                            module.send.request();
                        }
                        else {
                            if(!settings.throttleFirstRequest && !module.timer) {
                                module.debug('Sending request', data, ajaxSettings.method);
                                module.send.request();
                                module.timer = setTimeout(function(){}, settings.throttle);
                            }
                            else {
                                module.debug('Throttling request', settings.throttle);
                                clearTimeout(module.timer);
                                module.timer = setTimeout(function() {
                                    if(module.timer) {
                                        delete module.timer;
                                    }
                                    module.debug('Sending throttled request', data, ajaxSettings.method);
                                    module.send.request();
                                }, settings.throttle);
                            }
                        }

                    },

                    should: {
                        removeError: function() {
                            return ( settings.hideError === true || (settings.hideError === 'auto' && !module.is.form()) );
                        }
                    },

                    is: {
                        disabled: function() {
                            return ($module.filter(selector.disabled).length > 0);
                        },
                        expectingJSON: function() {
                            return settings.dataType === 'json' || settings.dataType === 'jsonp';
                        },
                        form: function() {
                            return $module.is('form') || $context.is('form');
                        },
                        mocked: function() {
                            return (settings.mockResponse || settings.mockResponseAsync || settings.response || settings.responseAsync);
                        },
                        input: function() {
                            return $module.is('input');
                        },
                        loading: function() {
                            return (module.request)
                                ? (module.request.state() == 'pending')
                                : false
                                ;
                        },
                        abortedRequest: function(xhr) {
                            if(xhr && xhr.readyState !== undefined && xhr.readyState === 0) {
                                module.verbose('XHR request determined to be aborted');
                                return true;
                            }
                            else {
                                module.verbose('XHR request was not aborted');
                                return false;
                            }
                        },
                        validResponse: function(response) {
                            if( (!module.is.expectingJSON()) || !$.isFunction(settings.successTest) ) {
                                module.verbose('Response is not JSON, skipping validation', settings.successTest, response);
                                return true;
                            }
                            module.debug('Checking JSON returned success', settings.successTest, response);
                            if( settings.successTest(response) ) {
                                module.debug('Response passed success test', response);
                                return true;
                            }
                            else {
                                module.debug('Response failed success test', response);
                                return false;
                            }
                        }
                    },

                    was: {
                        cancelled: function() {
                            return (module.cancelled || false);
                        },
                        succesful: function() {
                            return (module.request && module.request.state() == 'resolved');
                        },
                        failure: function() {
                            return (module.request && module.request.state() == 'rejected');
                        },
                        complete: function() {
                            return (module.request && (module.request.state() == 'resolved' || module.request.state() == 'rejected') );
                        }
                    },

                    add: {
                        urlData: function(url, urlData) {
                            var
                                requiredVariables,
                                optionalVariables
                            ;
                            if(url) {
                                requiredVariables = url.match(settings.regExp.required);
                                optionalVariables = url.match(settings.regExp.optional);
                                urlData           = urlData || settings.urlData;
                                if(requiredVariables) {
                                    module.debug('Looking for required URL variables', requiredVariables);
                                    $.each(requiredVariables, function(index, templatedString) {
                                        var
                                            // allow legacy {$var} style
                                            variable = (templatedString.indexOf('$') !== -1)
                                                ? templatedString.substr(2, templatedString.length - 3)
                                                : templatedString.substr(1, templatedString.length - 2),
                                            value   = ($.isPlainObject(urlData) && urlData[variable] !== undefined)
                                                ? urlData[variable]
                                                : ($module.data(variable) !== undefined)
                                                    ? $module.data(variable)
                                                    : ($context.data(variable) !== undefined)
                                                        ? $context.data(variable)
                                                        : urlData[variable]
                                        ;
                                        // remove value
                                        if(value === undefined) {
                                            module.error(error.requiredParameter, variable, url);
                                            url = false;
                                            return false;
                                        }
                                        else {
                                            module.verbose('Found required variable', variable, value);
                                            value = (settings.encodeParameters)
                                                ? module.get.urlEncodedValue(value)
                                                : value
                                            ;
                                            url = url.replace(templatedString, value);
                                        }
                                    });
                                }
                                if(optionalVariables) {
                                    module.debug('Looking for optional URL variables', requiredVariables);
                                    $.each(optionalVariables, function(index, templatedString) {
                                        var
                                            // allow legacy {/$var} style
                                            variable = (templatedString.indexOf('$') !== -1)
                                                ? templatedString.substr(3, templatedString.length - 4)
                                                : templatedString.substr(2, templatedString.length - 3),
                                            value   = ($.isPlainObject(urlData) && urlData[variable] !== undefined)
                                                ? urlData[variable]
                                                : ($module.data(variable) !== undefined)
                                                    ? $module.data(variable)
                                                    : ($context.data(variable) !== undefined)
                                                        ? $context.data(variable)
                                                        : urlData[variable]
                                        ;
                                        // optional replacement
                                        if(value !== undefined) {
                                            module.verbose('Optional variable Found', variable, value);
                                            url = url.replace(templatedString, value);
                                        }
                                        else {
                                            module.verbose('Optional variable not found', variable);
                                            // remove preceding slash if set
                                            if(url.indexOf('/' + templatedString) !== -1) {
                                                url = url.replace('/' + templatedString, '');
                                            }
                                            else {
                                                url = url.replace(templatedString, '');
                                            }
                                        }
                                    });
                                }
                            }
                            return url;
                        },
                        formData: function(data) {
                            var
                                canSerialize = ($.fn.serializeObject !== undefined),
                                formData     = (canSerialize)
                                    ? $form.serializeObject()
                                    : $form.serialize(),
                                hasOtherData
                            ;
                            data         = data || settings.data;
                            hasOtherData = $.isPlainObject(data);

                            if(hasOtherData) {
                                if(canSerialize) {
                                    module.debug('Extending existing data with form data', data, formData);
                                    data = $.extend(true, {}, data, formData);
                                }
                                else {
                                    module.error(error.missingSerialize);
                                    module.debug('Cant extend data. Replacing data with form data', data, formData);
                                    data = formData;
                                }
                            }
                            else {
                                module.debug('Adding form data', formData);
                                data = formData;
                            }
                            return data;
                        }
                    },

                    send: {
                        request: function() {
                            module.set.loading();
                            module.request = module.create.request();
                            if( module.is.mocked() ) {
                                module.mockedXHR = module.create.mockedXHR();
                            }
                            else {
                                module.xhr = module.create.xhr();
                            }
                            settings.onRequest.call(context, module.request, module.xhr);
                        }
                    },

                    event: {
                        trigger: function(event) {
                            module.query();
                            if(event.type == 'submit' || event.type == 'click') {
                                event.preventDefault();
                            }
                        },
                        xhr: {
                            always: function() {
                                // nothing special
                            },
                            done: function(response, textStatus, xhr) {
                                var
                                    context            = this,
                                    elapsedTime        = (new Date().getTime() - requestStartTime),
                                    timeLeft           = (settings.loadingDuration - elapsedTime),
                                    translatedResponse = ( $.isFunction(settings.onResponse) )
                                        ? module.is.expectingJSON()
                                            ? settings.onResponse.call(context, $.extend(true, {}, response))
                                            : settings.onResponse.call(context, response)
                                        : false
                                ;
                                timeLeft = (timeLeft > 0)
                                    ? timeLeft
                                    : 0
                                ;
                                if(translatedResponse) {
                                    module.debug('Modified API response in onResponse callback', settings.onResponse, translatedResponse, response);
                                    response = translatedResponse;
                                }
                                if(timeLeft > 0) {
                                    module.debug('Response completed early delaying state change by', timeLeft);
                                }
                                setTimeout(function() {
                                    if( module.is.validResponse(response) ) {
                                        module.request.resolveWith(context, [response, xhr]);
                                    }
                                    else {
                                        module.request.rejectWith(context, [xhr, 'invalid']);
                                    }
                                }, timeLeft);
                            },
                            fail: function(xhr, status, httpMessage) {
                                var
                                    context     = this,
                                    elapsedTime = (new Date().getTime() - requestStartTime),
                                    timeLeft    = (settings.loadingDuration - elapsedTime)
                                ;
                                timeLeft = (timeLeft > 0)
                                    ? timeLeft
                                    : 0
                                ;
                                if(timeLeft > 0) {
                                    module.debug('Response completed early delaying state change by', timeLeft);
                                }
                                setTimeout(function() {
                                    if( module.is.abortedRequest(xhr) ) {
                                        module.request.rejectWith(context, [xhr, 'aborted', httpMessage]);
                                    }
                                    else {
                                        module.request.rejectWith(context, [xhr, 'error', status, httpMessage]);
                                    }
                                }, timeLeft);
                            }
                        },
                        request: {
                            done: function(response, xhr) {
                                module.debug('Successful API Response', response);
                                if(settings.cache === 'local' && url) {
                                    module.write.cachedResponse(url, response);
                                    module.debug('Saving server response locally', module.cache);
                                }
                                settings.onSuccess.call(context, response, $module, xhr);
                            },
                            complete: function(firstParameter, secondParameter) {
                                var
                                    xhr,
                                    response
                                ;
                                // have to guess callback parameters based on request success
                                if( module.was.succesful() ) {
                                    response = firstParameter;
                                    xhr      = secondParameter;
                                }
                                else {
                                    xhr      = firstParameter;
                                    response = module.get.responseFromXHR(xhr);
                                }
                                module.remove.loading();
                                settings.onComplete.call(context, response, $module, xhr);
                            },
                            fail: function(xhr, status, httpMessage) {
                                var
                                    // pull response from xhr if available
                                    response     = module.get.responseFromXHR(xhr),
                                    errorMessage = module.get.errorFromRequest(response, status, httpMessage)
                                ;
                                if(status == 'aborted') {
                                    module.debug('XHR Aborted (Most likely caused by page navigation or CORS Policy)', status, httpMessage);
                                    settings.onAbort.call(context, status, $module, xhr);
                                    return true;
                                }
                                else if(status == 'invalid') {
                                    module.debug('JSON did not pass success test. A server-side error has most likely occurred', response);
                                }
                                else if(status == 'error') {
                                    if(xhr !== undefined) {
                                        module.debug('XHR produced a server error', status, httpMessage);
                                        // make sure we have an error to display to console
                                        if( xhr.status != 200 && httpMessage !== undefined && httpMessage !== '') {
                                            module.error(error.statusMessage + httpMessage, ajaxSettings.url);
                                        }
                                        settings.onError.call(context, errorMessage, $module, xhr);
                                    }
                                }

                                if(settings.errorDuration && status !== 'aborted') {
                                    module.debug('Adding error state');
                                    module.set.error();
                                    if( module.should.removeError() ) {
                                        setTimeout(module.remove.error, settings.errorDuration);
                                    }
                                }
                                module.debug('API Request failed', errorMessage, xhr);
                                settings.onFailure.call(context, response, $module, xhr);
                            }
                        }
                    },

                    create: {

                        request: function() {
                            // api request promise
                            return $.Deferred()
                                .always(module.event.request.complete)
                                .done(module.event.request.done)
                                .fail(module.event.request.fail)
                                ;
                        },

                        mockedXHR: function () {
                            var
                                // xhr does not simulate these properties of xhr but must return them
                                textStatus     = false,
                                status         = false,
                                httpMessage    = false,
                                responder      = settings.mockResponse      || settings.response,
                                asyncResponder = settings.mockResponseAsync || settings.responseAsync,
                                asyncCallback,
                                response,
                                mockedXHR
                            ;

                            mockedXHR = $.Deferred()
                                .always(module.event.xhr.complete)
                                .done(module.event.xhr.done)
                                .fail(module.event.xhr.fail)
                            ;

                            if(responder) {
                                if( $.isFunction(responder) ) {
                                    module.debug('Using specified synchronous callback', responder);
                                    response = responder.call(context, requestSettings);
                                }
                                else {
                                    module.debug('Using settings specified response', responder);
                                    response = responder;
                                }
                                // simulating response
                                mockedXHR.resolveWith(context, [ response, textStatus, { responseText: response }]);
                            }
                            else if( $.isFunction(asyncResponder) ) {
                                asyncCallback = function(response) {
                                    module.debug('Async callback returned response', response);

                                    if(response) {
                                        mockedXHR.resolveWith(context, [ response, textStatus, { responseText: response }]);
                                    }
                                    else {
                                        mockedXHR.rejectWith(context, [{ responseText: response }, status, httpMessage]);
                                    }
                                };
                                module.debug('Using specified async response callback', asyncResponder);
                                asyncResponder.call(context, requestSettings, asyncCallback);
                            }
                            return mockedXHR;
                        },

                        xhr: function() {
                            var
                                xhr
                            ;
                            // ajax request promise
                            xhr = $.ajax(ajaxSettings)
                                .always(module.event.xhr.always)
                                .done(module.event.xhr.done)
                                .fail(module.event.xhr.fail)
                            ;
                            module.verbose('Created server request', xhr, ajaxSettings);
                            return xhr;
                        }
                    },

                    set: {
                        error: function() {
                            module.verbose('Adding error state to element', $context);
                            $context.addClass(className.error);
                        },
                        loading: function() {
                            module.verbose('Adding loading state to element', $context);
                            $context.addClass(className.loading);
                            requestStartTime = new Date().getTime();
                        }
                    },

                    remove: {
                        error: function() {
                            module.verbose('Removing error state from element', $context);
                            $context.removeClass(className.error);
                        },
                        loading: function() {
                            module.verbose('Removing loading state from element', $context);
                            $context.removeClass(className.loading);
                        }
                    },

                    get: {
                        responseFromXHR: function(xhr) {
                            return $.isPlainObject(xhr)
                                ? (module.is.expectingJSON())
                                    ? module.decode.json(xhr.responseText)
                                    : xhr.responseText
                                : false
                                ;
                        },
                        errorFromRequest: function(response, status, httpMessage) {
                            return ($.isPlainObject(response) && response.error !== undefined)
                                ? response.error // use json error message
                                : (settings.error[status] !== undefined) // use server error message
                                    ? settings.error[status]
                                    : httpMessage
                                ;
                        },
                        request: function() {
                            return module.request || false;
                        },
                        xhr: function() {
                            return module.xhr || false;
                        },
                        settings: function() {
                            var
                                runSettings
                            ;
                            runSettings = settings.beforeSend.call(context, settings);
                            if(runSettings) {
                                if(runSettings.success !== undefined) {
                                    module.debug('Legacy success callback detected', runSettings);
                                    module.error(error.legacyParameters, runSettings.success);
                                    runSettings.onSuccess = runSettings.success;
                                }
                                if(runSettings.failure !== undefined) {
                                    module.debug('Legacy failure callback detected', runSettings);
                                    module.error(error.legacyParameters, runSettings.failure);
                                    runSettings.onFailure = runSettings.failure;
                                }
                                if(runSettings.complete !== undefined) {
                                    module.debug('Legacy complete callback detected', runSettings);
                                    module.error(error.legacyParameters, runSettings.complete);
                                    runSettings.onComplete = runSettings.complete;
                                }
                            }
                            if(runSettings === undefined) {
                                module.error(error.noReturnedValue);
                            }
                            if(runSettings === false) {
                                return runSettings;
                            }
                            return (runSettings !== undefined)
                                ? $.extend(true, {}, runSettings)
                                : $.extend(true, {}, settings)
                                ;
                        },
                        urlEncodedValue: function(value) {
                            var
                                decodedValue   = window.decodeURIComponent(value),
                                encodedValue   = window.encodeURIComponent(value),
                                alreadyEncoded = (decodedValue !== value)
                            ;
                            if(alreadyEncoded) {
                                module.debug('URL value is already encoded, avoiding double encoding', value);
                                return value;
                            }
                            module.verbose('Encoding value using encodeURIComponent', value, encodedValue);
                            return encodedValue;
                        },
                        defaultData: function() {
                            var
                                data = {}
                            ;
                            if( !$.isWindow(element) ) {
                                if( module.is.input() ) {
                                    data.value = $module.val();
                                }
                                else if( module.is.form() ) {

                                }
                                else {
                                    data.text = $module.text();
                                }
                            }
                            return data;
                        },
                        event: function() {
                            if( $.isWindow(element) || settings.on == 'now' ) {
                                module.debug('API called without element, no events attached');
                                return false;
                            }
                            else if(settings.on == 'auto') {
                                if( $module.is('input') ) {
                                    return (element.oninput !== undefined)
                                        ? 'input'
                                        : (element.onpropertychange !== undefined)
                                            ? 'propertychange'
                                            : 'keyup'
                                        ;
                                }
                                else if( $module.is('form') ) {
                                    return 'submit';
                                }
                                else {
                                    return 'click';
                                }
                            }
                            else {
                                return settings.on;
                            }
                        },
                        templatedURL: function(action) {
                            action = action || $module.data(metadata.action) || settings.action || false;
                            url    = $module.data(metadata.url) || settings.url || false;
                            if(url) {
                                module.debug('Using specified url', url);
                                return url;
                            }
                            if(action) {
                                module.debug('Looking up url for action', action, settings.api);
                                if(settings.api[action] === undefined && !module.is.mocked()) {
                                    module.error(error.missingAction, settings.action, settings.api);
                                    return;
                                }
                                url = settings.api[action];
                            }
                            else if( module.is.form() ) {
                                url = $module.attr('action') || $context.attr('action') || false;
                                module.debug('No url or action specified, defaulting to form action', url);
                            }
                            return url;
                        }
                    },

                    abort: function() {
                        var
                            xhr = module.get.xhr()
                        ;
                        if( xhr && xhr.state() !== 'resolved') {
                            module.debug('Cancelling API request');
                            xhr.abort();
                        }
                    },

                    // reset state
                    reset: function() {
                        module.remove.error();
                        module.remove.loading();
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            if($.isPlainObject(settings[name])) {
                                $.extend(true, settings[name], value);
                            }
                            else {
                                settings[name] = value;
                            }
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    //'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.api.settings = {

        name              : 'API',
        namespace         : 'api',

        debug             : false,
        verbose           : false,
        performance       : true,

        // object containing all templates endpoints
        api               : {},

        // whether to cache responses
        cache             : true,

        // whether new requests should abort previous requests
        interruptRequests : true,

        // event binding
        on                : 'auto',

        // context for applying state classes
        stateContext      : false,

        // duration for loading state
        loadingDuration   : 0,

        // whether to hide errors after a period of time
        hideError         : 'auto',

        // duration for error state
        errorDuration     : 2000,

        // whether parameters should be encoded with encodeURIComponent
        encodeParameters  : true,

        // API action to use
        action            : false,

        // templated URL to use
        url               : false,

        // base URL to apply to all endpoints
        base              : '',

        // data that will
        urlData           : {},

        // whether to add default data to url data
        defaultData          : true,

        // whether to serialize closest form
        serializeForm        : false,

        // how long to wait before request should occur
        throttle             : 0,

        // whether to throttle first request or only repeated
        throttleFirstRequest : true,

        // standard ajax settings
        method            : 'get',
        data              : {},
        dataType          : 'json',

        // mock response
        mockResponse      : false,
        mockResponseAsync : false,

        // aliases for mock
        response          : false,
        responseAsync     : false,

        // callbacks before request
        beforeSend  : function(settings) { return settings; },
        beforeXHR   : function(xhr) {},
        onRequest   : function(promise, xhr) {},

        // after request
        onResponse  : false, // function(response) { },

        // response was successful, if JSON passed validation
        onSuccess   : function(response, $module) {},

        // request finished without aborting
        onComplete  : function(response, $module) {},

        // failed JSON success test
        onFailure   : function(response, $module) {},

        // server error
        onError     : function(errorMessage, $module) {},

        // request aborted
        onAbort     : function(errorMessage, $module) {},

        successTest : false,

        // errors
        error : {
            beforeSend        : 'The before send function has aborted the request',
            error             : 'There was an error with your request',
            exitConditions    : 'API Request Aborted. Exit conditions met',
            JSONParse         : 'JSON could not be parsed during error handling',
            legacyParameters  : 'You are using legacy API success callback names',
            method            : 'The method you called is not defined',
            missingAction     : 'API action used but no url was defined',
            missingSerialize  : 'jquery-serialize-object is required to add form data to an existing data object',
            missingURL        : 'No URL specified for api event',
            noReturnedValue   : 'The beforeSend callback must return a settings object, beforeSend ignored.',
            noStorage         : 'Caching responses locally requires session storage',
            parseError        : 'There was an error parsing your request',
            requiredParameter : 'Missing a required URL parameter: ',
            statusMessage     : 'Server gave an error: ',
            timeout           : 'Your request timed out'
        },

        regExp  : {
            required : /\{\$*[A-z0-9]+\}/g,
            optional : /\{\/\$*[A-z0-9]+\}/g,
        },

        className: {
            loading : 'loading',
            error   : 'error'
        },

        selector: {
            disabled : '.disabled',
            form      : 'form'
        },

        metadata: {
            action  : 'action',
            url     : 'url'
        }
    };



})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - State
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.state = function(parameters) {
        var
            $allModules     = $(this),

            moduleSelector  = $allModules.selector || '',

            hasTouch        = ('ontouchstart' in document.documentElement),
            time            = new Date().getTime(),
            performance     = [],

            query           = arguments[0],
            methodInvoked   = (typeof query == 'string'),
            queryArguments  = [].slice.call(arguments, 1),

            returnedValue
        ;
        $allModules
            .each(function() {
                var
                    settings          = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.state.settings, parameters)
                        : $.extend({}, $.fn.state.settings),

                    error           = settings.error,
                    metadata        = settings.metadata,
                    className       = settings.className,
                    namespace       = settings.namespace,
                    states          = settings.states,
                    text            = settings.text,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = namespace + '-module',

                    $module         = $(this),

                    element         = this,
                    instance        = $module.data(moduleNamespace),

                    module
                ;
                module = {

                    initialize: function() {
                        module.verbose('Initializing module');

                        // allow module to guess desired state based on element
                        if(settings.automatic) {
                            module.add.defaults();
                        }

                        // bind events with delegated events
                        if(settings.context && moduleSelector !== '') {
                            $(settings.context)
                                .on(moduleSelector, 'mouseenter' + eventNamespace, module.change.text)
                                .on(moduleSelector, 'mouseleave' + eventNamespace, module.reset.text)
                                .on(moduleSelector, 'click'      + eventNamespace, module.toggle.state)
                            ;
                        }
                        else {
                            $module
                                .on('mouseenter' + eventNamespace, module.change.text)
                                .on('mouseleave' + eventNamespace, module.reset.text)
                                .on('click'      + eventNamespace, module.toggle.state)
                            ;
                        }
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.verbose('Storing instance of module', module);
                        instance = module;
                        $module
                            .data(moduleNamespace, module)
                        ;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module', instance);
                        $module
                            .off(eventNamespace)
                            .removeData(moduleNamespace)
                        ;
                    },

                    refresh: function() {
                        module.verbose('Refreshing selector cache');
                        $module = $(element);
                    },

                    add: {
                        defaults: function() {
                            var
                                userStates = parameters && $.isPlainObject(parameters.states)
                                    ? parameters.states
                                    : {}
                            ;
                            $.each(settings.defaults, function(type, typeStates) {
                                if( module.is[type] !== undefined && module.is[type]() ) {
                                    module.verbose('Adding default states', type, element);
                                    $.extend(settings.states, typeStates, userStates);
                                }
                            });
                        }
                    },

                    is: {

                        active: function() {
                            return $module.hasClass(className.active);
                        },
                        loading: function() {
                            return $module.hasClass(className.loading);
                        },
                        inactive: function() {
                            return !( $module.hasClass(className.active) );
                        },
                        state: function(state) {
                            if(className[state] === undefined) {
                                return false;
                            }
                            return $module.hasClass( className[state] );
                        },

                        enabled: function() {
                            return !( $module.is(settings.filter.active) );
                        },
                        disabled: function() {
                            return ( $module.is(settings.filter.active) );
                        },
                        textEnabled: function() {
                            return !( $module.is(settings.filter.text) );
                        },

                        // definitions for automatic type detection
                        button: function() {
                            return $module.is('.button:not(a, .submit)');
                        },
                        input: function() {
                            return $module.is('input');
                        },
                        progress: function() {
                            return $module.is('.ui.progress');
                        }
                    },

                    allow: function(state) {
                        module.debug('Now allowing state', state);
                        states[state] = true;
                    },
                    disallow: function(state) {
                        module.debug('No longer allowing', state);
                        states[state] = false;
                    },

                    allows: function(state) {
                        return states[state] || false;
                    },

                    enable: function() {
                        $module.removeClass(className.disabled);
                    },

                    disable: function() {
                        $module.addClass(className.disabled);
                    },

                    setState: function(state) {
                        if(module.allows(state)) {
                            $module.addClass( className[state] );
                        }
                    },

                    removeState: function(state) {
                        if(module.allows(state)) {
                            $module.removeClass( className[state] );
                        }
                    },

                    toggle: {
                        state: function() {
                            var
                                apiRequest,
                                requestCancelled
                            ;
                            if( module.allows('active') && module.is.enabled() ) {
                                module.refresh();
                                if($.fn.api !== undefined) {
                                    apiRequest       = $module.api('get request');
                                    requestCancelled = $module.api('was cancelled');
                                    if( requestCancelled ) {
                                        module.debug('API Request cancelled by beforesend');
                                        settings.activateTest   = function(){ return false; };
                                        settings.deactivateTest = function(){ return false; };
                                    }
                                    else if(apiRequest) {
                                        module.listenTo(apiRequest);
                                        return;
                                    }
                                }
                                module.change.state();
                            }
                        }
                    },

                    listenTo: function(apiRequest) {
                        module.debug('API request detected, waiting for state signal', apiRequest);
                        if(apiRequest) {
                            if(text.loading) {
                                module.update.text(text.loading);
                            }
                            $.when(apiRequest)
                                .then(function() {
                                    if(apiRequest.state() == 'resolved') {
                                        module.debug('API request succeeded');
                                        settings.activateTest   = function(){ return true; };
                                        settings.deactivateTest = function(){ return true; };
                                    }
                                    else {
                                        module.debug('API request failed');
                                        settings.activateTest   = function(){ return false; };
                                        settings.deactivateTest = function(){ return false; };
                                    }
                                    module.change.state();
                                })
                            ;
                        }
                    },

                    // checks whether active/inactive state can be given
                    change: {

                        state: function() {
                            module.debug('Determining state change direction');
                            // inactive to active change
                            if( module.is.inactive() ) {
                                module.activate();
                            }
                            else {
                                module.deactivate();
                            }
                            if(settings.sync) {
                                module.sync();
                            }
                            settings.onChange.call(element);
                        },

                        text: function() {
                            if( module.is.textEnabled() ) {
                                if(module.is.disabled() ) {
                                    module.verbose('Changing text to disabled text', text.hover);
                                    module.update.text(text.disabled);
                                }
                                else if( module.is.active() ) {
                                    if(text.hover) {
                                        module.verbose('Changing text to hover text', text.hover);
                                        module.update.text(text.hover);
                                    }
                                    else if(text.deactivate) {
                                        module.verbose('Changing text to deactivating text', text.deactivate);
                                        module.update.text(text.deactivate);
                                    }
                                }
                                else {
                                    if(text.hover) {
                                        module.verbose('Changing text to hover text', text.hover);
                                        module.update.text(text.hover);
                                    }
                                    else if(text.activate){
                                        module.verbose('Changing text to activating text', text.activate);
                                        module.update.text(text.activate);
                                    }
                                }
                            }
                        }

                    },

                    activate: function() {
                        if( settings.activateTest.call(element) ) {
                            module.debug('Setting state to active');
                            $module
                                .addClass(className.active)
                            ;
                            module.update.text(text.active);
                            settings.onActivate.call(element);
                        }
                    },

                    deactivate: function() {
                        if( settings.deactivateTest.call(element) ) {
                            module.debug('Setting state to inactive');
                            $module
                                .removeClass(className.active)
                            ;
                            module.update.text(text.inactive);
                            settings.onDeactivate.call(element);
                        }
                    },

                    sync: function() {
                        module.verbose('Syncing other buttons to current state');
                        if( module.is.active() ) {
                            $allModules
                                .not($module)
                                .state('activate');
                        }
                        else {
                            $allModules
                                .not($module)
                                .state('deactivate')
                            ;
                        }
                    },

                    get: {
                        text: function() {
                            return (settings.selector.text)
                                ? $module.find(settings.selector.text).text()
                                : $module.html()
                                ;
                        },
                        textFor: function(state) {
                            return text[state] || false;
                        }
                    },

                    flash: {
                        text: function(text, duration, callback) {
                            var
                                previousText = module.get.text()
                            ;
                            module.debug('Flashing text message', text, duration);
                            text     = text     || settings.text.flash;
                            duration = duration || settings.flashDuration;
                            callback = callback || function() {};
                            module.update.text(text);
                            setTimeout(function(){
                                module.update.text(previousText);
                                callback.call(element);
                            }, duration);
                        }
                    },

                    reset: {
                        // on mouseout sets text to previous value
                        text: function() {
                            var
                                activeText   = text.active   || $module.data(metadata.storedText),
                                inactiveText = text.inactive || $module.data(metadata.storedText)
                            ;
                            if( module.is.textEnabled() ) {
                                if( module.is.active() && activeText) {
                                    module.verbose('Resetting active text', activeText);
                                    module.update.text(activeText);
                                }
                                else if(inactiveText) {
                                    module.verbose('Resetting inactive text', activeText);
                                    module.update.text(inactiveText);
                                }
                            }
                        }
                    },

                    update: {
                        text: function(text) {
                            var
                                currentText = module.get.text()
                            ;
                            if(text && text !== currentText) {
                                module.debug('Updating text', text);
                                if(settings.selector.text) {
                                    $module
                                        .data(metadata.storedText, text)
                                        .find(settings.selector.text)
                                        .text(text)
                                    ;
                                }
                                else {
                                    $module
                                        .data(metadata.storedText, text)
                                        .html(text)
                                    ;
                                }
                            }
                            else {
                                module.debug('Text is already set, ignoring update', text);
                            }
                        }
                    },

                    setting: function(name, value) {
                        module.debug('Changing setting', name, value);
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            if($.isPlainObject(settings[name])) {
                                $.extend(true, settings[name], value);
                            }
                            else {
                                settings[name] = value;
                            }
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.state.settings = {

        // module info
        name           : 'State',

        // debug output
        debug          : false,

        // verbose debug output
        verbose        : false,

        // namespace for events
        namespace      : 'state',

        // debug data includes performance
        performance    : true,

        // callback occurs on state change
        onActivate     : function() {},
        onDeactivate   : function() {},
        onChange       : function() {},

        // state test functions
        activateTest   : function() { return true; },
        deactivateTest : function() { return true; },

        // whether to automatically map default states
        automatic      : true,

        // activate / deactivate changes all elements instantiated at same time
        sync           : false,

        // default flash text duration, used for temporarily changing text of an element
        flashDuration  : 1000,

        // selector filter
        filter     : {
            text   : '.loading, .disabled',
            active : '.disabled'
        },

        context    : false,

        // error
        error: {
            beforeSend : 'The before send function has cancelled state change',
            method     : 'The method you called is not defined.'
        },

        // metadata
        metadata: {
            promise    : 'promise',
            storedText : 'stored-text'
        },

        // change class on state
        className: {
            active   : 'active',
            disabled : 'disabled',
            error    : 'error',
            loading  : 'loading',
            success  : 'success',
            warning  : 'warning'
        },

        selector: {
            // selector for text node
            text: false
        },

        defaults : {
            input: {
                disabled : true,
                loading  : true,
                active   : true
            },
            button: {
                disabled : true,
                loading  : true,
                active   : true,
            },
            progress: {
                active   : true,
                success  : true,
                warning  : true,
                error    : true
            }
        },

        states     : {
            active   : true,
            disabled : true,
            error    : true,
            loading  : true,
            success  : true,
            warning  : true
        },

        text     : {
            disabled   : false,
            flash      : false,
            hover      : false,
            active     : false,
            inactive   : false,
            activate   : false,
            deactivate : false
        }

    };



})( jQuery, window, document );

/*!
 * # Semantic UI 2.2.7 - Visibility
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */

;(function ($, window, document, undefined) {

    "use strict";

    window = (typeof window != 'undefined' && window.Math == Math)
        ? window
        : (typeof self != 'undefined' && self.Math == Math)
            ? self
            : Function('return this')()
    ;

    $.fn.visibility = function(parameters) {
        var
            $allModules    = $(this),
            moduleSelector = $allModules.selector || '',

            time           = new Date().getTime(),
            performance    = [],

            query          = arguments[0],
            methodInvoked  = (typeof query == 'string'),
            queryArguments = [].slice.call(arguments, 1),
            returnedValue,

            moduleCount    = $allModules.length,
            loadedCount    = 0
        ;

        $allModules
            .each(function() {
                var
                    settings        = ( $.isPlainObject(parameters) )
                        ? $.extend(true, {}, $.fn.visibility.settings, parameters)
                        : $.extend({}, $.fn.visibility.settings),

                    className       = settings.className,
                    namespace       = settings.namespace,
                    error           = settings.error,
                    metadata        = settings.metadata,

                    eventNamespace  = '.' + namespace,
                    moduleNamespace = 'module-' + namespace,

                    $window         = $(window),

                    $module         = $(this),
                    $context        = $(settings.context),

                    $placeholder,

                    selector        = $module.selector || '',
                    instance        = $module.data(moduleNamespace),

                    requestAnimationFrame = window.requestAnimationFrame
                        || window.mozRequestAnimationFrame
                        || window.webkitRequestAnimationFrame
                        || window.msRequestAnimationFrame
                        || function(callback) { setTimeout(callback, 0); },

                    element         = this,
                    disabled        = false,

                    contextObserver,
                    observer,
                    module
                ;

                module = {

                    initialize: function() {
                        module.debug('Initializing', settings);

                        module.setup.cache();

                        if( module.should.trackChanges() ) {

                            if(settings.type == 'image') {
                                module.setup.image();
                            }
                            if(settings.type == 'fixed') {
                                module.setup.fixed();
                            }

                            if(settings.observeChanges) {
                                module.observeChanges();
                            }
                            module.bind.events();
                        }

                        module.save.position();
                        if( !module.is.visible() ) {
                            module.error(error.visible, $module);
                        }

                        if(settings.initialCheck) {
                            module.checkVisibility();
                        }
                        module.instantiate();
                    },

                    instantiate: function() {
                        module.debug('Storing instance', module);
                        $module
                            .data(moduleNamespace, module)
                        ;
                        instance = module;
                    },

                    destroy: function() {
                        module.verbose('Destroying previous module');
                        if(observer) {
                            observer.disconnect();
                        }
                        if(contextObserver) {
                            contextObserver.disconnect();
                        }
                        $window
                            .off('load'   + eventNamespace, module.event.load)
                            .off('resize' + eventNamespace, module.event.resize)
                        ;
                        $context
                            .off('scroll'       + eventNamespace, module.event.scroll)
                            .off('scrollchange' + eventNamespace, module.event.scrollchange)
                        ;
                        if(settings.type == 'fixed') {
                            module.resetFixed();
                            module.remove.placeholder();
                        }
                        $module
                            .off(eventNamespace)
                            .removeData(moduleNamespace)
                        ;
                    },

                    observeChanges: function() {
                        if('MutationObserver' in window) {
                            contextObserver = new MutationObserver(module.event.contextChanged);
                            observer        = new MutationObserver(module.event.changed);
                            contextObserver.observe(document, {
                                childList : true,
                                subtree   : true
                            });
                            observer.observe(element, {
                                childList : true,
                                subtree   : true
                            });
                            module.debug('Setting up mutation observer', observer);
                        }
                    },

                    bind: {
                        events: function() {
                            module.verbose('Binding visibility events to scroll and resize');
                            if(settings.refreshOnLoad) {
                                $window
                                    .on('load'   + eventNamespace, module.event.load)
                                ;
                            }
                            $window
                                .on('resize' + eventNamespace, module.event.resize)
                            ;
                            // pub/sub pattern
                            $context
                                .off('scroll'      + eventNamespace)
                                .on('scroll'       + eventNamespace, module.event.scroll)
                                .on('scrollchange' + eventNamespace, module.event.scrollchange)
                            ;
                        }
                    },

                    event: {
                        changed: function(mutations) {
                            module.verbose('DOM tree modified, updating visibility calculations');
                            module.timer = setTimeout(function() {
                                module.verbose('DOM tree modified, updating sticky menu');
                                module.refresh();
                            }, 100);
                        },
                        contextChanged: function(mutations) {
                            [].forEach.call(mutations, function(mutation) {
                                if(mutation.removedNodes) {
                                    [].forEach.call(mutation.removedNodes, function(node) {
                                        if(node == element || $(node).find(element).length > 0) {
                                            module.debug('Element removed from DOM, tearing down events');
                                            module.destroy();
                                        }
                                    });
                                }
                            });
                        },
                        resize: function() {
                            module.debug('Window resized');
                            if(settings.refreshOnResize) {
                                requestAnimationFrame(module.refresh);
                            }
                        },
                        load: function() {
                            module.debug('Page finished loading');
                            requestAnimationFrame(module.refresh);
                        },
                        // publishes scrollchange event on one scroll
                        scroll: function() {
                            if(settings.throttle) {
                                clearTimeout(module.timer);
                                module.timer = setTimeout(function() {
                                    $context.triggerHandler('scrollchange' + eventNamespace, [ $context.scrollTop() ]);
                                }, settings.throttle);
                            }
                            else {
                                requestAnimationFrame(function() {
                                    $context.triggerHandler('scrollchange' + eventNamespace, [ $context.scrollTop() ]);
                                });
                            }
                        },
                        // subscribes to scrollchange
                        scrollchange: function(event, scrollPosition) {
                            module.checkVisibility(scrollPosition);
                        },
                    },

                    precache: function(images, callback) {
                        if (!(images instanceof Array)) {
                            images = [images];
                        }
                        var
                            imagesLength  = images.length,
                            loadedCounter = 0,
                            cache         = [],
                            cacheImage    = document.createElement('img'),
                            handleLoad    = function() {
                                loadedCounter++;
                                if (loadedCounter >= images.length) {
                                    if ($.isFunction(callback)) {
                                        callback();
                                    }
                                }
                            }
                        ;
                        while (imagesLength--) {
                            cacheImage         = document.createElement('img');
                            cacheImage.onload  = handleLoad;
                            cacheImage.onerror = handleLoad;
                            cacheImage.src     = images[imagesLength];
                            cache.push(cacheImage);
                        }
                    },

                    enableCallbacks: function() {
                        module.debug('Allowing callbacks to occur');
                        disabled = false;
                    },

                    disableCallbacks: function() {
                        module.debug('Disabling all callbacks temporarily');
                        disabled = true;
                    },

                    should: {
                        trackChanges: function() {
                            if(methodInvoked) {
                                module.debug('One time query, no need to bind events');
                                return false;
                            }
                            module.debug('Callbacks being attached');
                            return true;
                        }
                    },

                    setup: {
                        cache: function() {
                            module.cache = {
                                occurred : {},
                                screen   : {},
                                element  : {},
                            };
                        },
                        image: function() {
                            var
                                src = $module.data(metadata.src)
                            ;
                            if(src) {
                                module.verbose('Lazy loading image', src);
                                settings.once           = true;
                                settings.observeChanges = false;

                                // show when top visible
                                settings.onOnScreen = function() {
                                    module.debug('Image on screen', element);
                                    module.precache(src, function() {
                                        module.set.image(src, function() {
                                            loadedCount++;
                                            if(loadedCount == moduleCount) {
                                                settings.onAllLoaded.call(this);
                                            }
                                            settings.onLoad.call(this);
                                        });
                                    });
                                };
                            }
                        },
                        fixed: function() {
                            module.debug('Setting up fixed');
                            settings.once           = false;
                            settings.observeChanges = false;
                            settings.initialCheck   = true;
                            settings.refreshOnLoad  = true;
                            if(!parameters.transition) {
                                settings.transition = false;
                            }
                            module.create.placeholder();
                            module.debug('Added placeholder', $placeholder);
                            settings.onTopPassed = function() {
                                module.debug('Element passed, adding fixed position', $module);
                                module.show.placeholder();
                                module.set.fixed();
                                if(settings.transition) {
                                    if($.fn.transition !== undefined) {
                                        $module.transition(settings.transition, settings.duration);
                                    }
                                }
                            };
                            settings.onTopPassedReverse = function() {
                                module.debug('Element returned to position, removing fixed', $module);
                                module.hide.placeholder();
                                module.remove.fixed();
                            };
                        }
                    },

                    create: {
                        placeholder: function() {
                            module.verbose('Creating fixed position placeholder');
                            $placeholder = $module
                                .clone(false)
                                .css('display', 'none')
                                .addClass(className.placeholder)
                                .insertAfter($module)
                            ;
                        }
                    },

                    show: {
                        placeholder: function() {
                            module.verbose('Showing placeholder');
                            $placeholder
                                .css('display', 'block')
                                .css('visibility', 'hidden')
                            ;
                        }
                    },
                    hide: {
                        placeholder: function() {
                            module.verbose('Hiding placeholder');
                            $placeholder
                                .css('display', 'none')
                                .css('visibility', '')
                            ;
                        }
                    },

                    set: {
                        fixed: function() {
                            module.verbose('Setting element to fixed position');
                            $module
                                .addClass(className.fixed)
                                .css({
                                    position : 'fixed',
                                    top      : settings.offset + 'px',
                                    left     : 'auto',
                                    zIndex   : settings.zIndex
                                })
                            ;
                            settings.onFixed.call(element);
                        },
                        image: function(src, callback) {
                            $module
                                .attr('src', src)
                            ;
                            if(settings.transition) {
                                if( $.fn.transition !== undefined ) {
                                    $module.transition(settings.transition, settings.duration, callback);
                                }
                                else {
                                    $module.fadeIn(settings.duration, callback);
                                }
                            }
                            else {
                                $module.show();
                            }
                        }
                    },

                    is: {
                        onScreen: function() {
                            var
                                calculations   = module.get.elementCalculations()
                            ;
                            return calculations.onScreen;
                        },
                        offScreen: function() {
                            var
                                calculations   = module.get.elementCalculations()
                            ;
                            return calculations.offScreen;
                        },
                        visible: function() {
                            if(module.cache && module.cache.element) {
                                return !(module.cache.element.width === 0 && module.cache.element.offset.top === 0);
                            }
                            return false;
                        }
                    },

                    refresh: function() {
                        module.debug('Refreshing constants (width/height)');
                        if(settings.type == 'fixed') {
                            module.resetFixed();
                        }
                        module.reset();
                        module.save.position();
                        if(settings.checkOnRefresh) {
                            module.checkVisibility();
                        }
                        settings.onRefresh.call(element);
                    },

                    resetFixed: function () {
                        module.remove.fixed();
                        module.remove.occurred();
                    },

                    reset: function() {
                        module.verbose('Resetting all cached values');
                        if( $.isPlainObject(module.cache) ) {
                            module.cache.screen = {};
                            module.cache.element = {};
                        }
                    },

                    checkVisibility: function(scroll) {
                        module.verbose('Checking visibility of element', module.cache.element);

                        if( !disabled && module.is.visible() ) {

                            // save scroll position
                            module.save.scroll(scroll);

                            // update calculations derived from scroll
                            module.save.calculations();

                            // percentage
                            module.passed();

                            // reverse (must be first)
                            module.passingReverse();
                            module.topVisibleReverse();
                            module.bottomVisibleReverse();
                            module.topPassedReverse();
                            module.bottomPassedReverse();

                            // one time
                            module.onScreen();
                            module.offScreen();
                            module.passing();
                            module.topVisible();
                            module.bottomVisible();
                            module.topPassed();
                            module.bottomPassed();

                            // on update callback
                            if(settings.onUpdate) {
                                settings.onUpdate.call(element, module.get.elementCalculations());
                            }
                        }
                    },

                    passed: function(amount, newCallback) {
                        var
                            calculations   = module.get.elementCalculations(),
                            amountInPixels
                        ;
                        // assign callback
                        if(amount && newCallback) {
                            settings.onPassed[amount] = newCallback;
                        }
                        else if(amount !== undefined) {
                            return (module.get.pixelsPassed(amount) > calculations.pixelsPassed);
                        }
                        else if(calculations.passing) {
                            $.each(settings.onPassed, function(amount, callback) {
                                if(calculations.bottomVisible || calculations.pixelsPassed > module.get.pixelsPassed(amount)) {
                                    module.execute(callback, amount);
                                }
                                else if(!settings.once) {
                                    module.remove.occurred(callback);
                                }
                            });
                        }
                    },

                    onScreen: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onOnScreen,
                            callbackName = 'onScreen'
                        ;
                        if(newCallback) {
                            module.debug('Adding callback for onScreen', newCallback);
                            settings.onOnScreen = newCallback;
                        }
                        if(calculations.onScreen) {
                            module.execute(callback, callbackName);
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback !== undefined) {
                            return calculations.onOnScreen;
                        }
                    },

                    offScreen: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onOffScreen,
                            callbackName = 'offScreen'
                        ;
                        if(newCallback) {
                            module.debug('Adding callback for offScreen', newCallback);
                            settings.onOffScreen = newCallback;
                        }
                        if(calculations.offScreen) {
                            module.execute(callback, callbackName);
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback !== undefined) {
                            return calculations.onOffScreen;
                        }
                    },

                    passing: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onPassing,
                            callbackName = 'passing'
                        ;
                        if(newCallback) {
                            module.debug('Adding callback for passing', newCallback);
                            settings.onPassing = newCallback;
                        }
                        if(calculations.passing) {
                            module.execute(callback, callbackName);
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback !== undefined) {
                            return calculations.passing;
                        }
                    },


                    topVisible: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onTopVisible,
                            callbackName = 'topVisible'
                        ;
                        if(newCallback) {
                            module.debug('Adding callback for top visible', newCallback);
                            settings.onTopVisible = newCallback;
                        }
                        if(calculations.topVisible) {
                            module.execute(callback, callbackName);
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return calculations.topVisible;
                        }
                    },

                    bottomVisible: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onBottomVisible,
                            callbackName = 'bottomVisible'
                        ;
                        if(newCallback) {
                            module.debug('Adding callback for bottom visible', newCallback);
                            settings.onBottomVisible = newCallback;
                        }
                        if(calculations.bottomVisible) {
                            module.execute(callback, callbackName);
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return calculations.bottomVisible;
                        }
                    },

                    topPassed: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onTopPassed,
                            callbackName = 'topPassed'
                        ;
                        if(newCallback) {
                            module.debug('Adding callback for top passed', newCallback);
                            settings.onTopPassed = newCallback;
                        }
                        if(calculations.topPassed) {
                            module.execute(callback, callbackName);
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return calculations.topPassed;
                        }
                    },

                    bottomPassed: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onBottomPassed,
                            callbackName = 'bottomPassed'
                        ;
                        if(newCallback) {
                            module.debug('Adding callback for bottom passed', newCallback);
                            settings.onBottomPassed = newCallback;
                        }
                        if(calculations.bottomPassed) {
                            module.execute(callback, callbackName);
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return calculations.bottomPassed;
                        }
                    },

                    passingReverse: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onPassingReverse,
                            callbackName = 'passingReverse'
                        ;
                        if(newCallback) {
                            module.debug('Adding callback for passing reverse', newCallback);
                            settings.onPassingReverse = newCallback;
                        }
                        if(!calculations.passing) {
                            if(module.get.occurred('passing')) {
                                module.execute(callback, callbackName);
                            }
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback !== undefined) {
                            return !calculations.passing;
                        }
                    },


                    topVisibleReverse: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onTopVisibleReverse,
                            callbackName = 'topVisibleReverse'
                        ;
                        if(newCallback) {
                            module.debug('Adding callback for top visible reverse', newCallback);
                            settings.onTopVisibleReverse = newCallback;
                        }
                        if(!calculations.topVisible) {
                            if(module.get.occurred('topVisible')) {
                                module.execute(callback, callbackName);
                            }
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return !calculations.topVisible;
                        }
                    },

                    bottomVisibleReverse: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onBottomVisibleReverse,
                            callbackName = 'bottomVisibleReverse'
                        ;
                        if(newCallback) {
                            module.debug('Adding callback for bottom visible reverse', newCallback);
                            settings.onBottomVisibleReverse = newCallback;
                        }
                        if(!calculations.bottomVisible) {
                            if(module.get.occurred('bottomVisible')) {
                                module.execute(callback, callbackName);
                            }
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return !calculations.bottomVisible;
                        }
                    },

                    topPassedReverse: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onTopPassedReverse,
                            callbackName = 'topPassedReverse'
                        ;
                        if(newCallback) {
                            module.debug('Adding callback for top passed reverse', newCallback);
                            settings.onTopPassedReverse = newCallback;
                        }
                        if(!calculations.topPassed) {
                            if(module.get.occurred('topPassed')) {
                                module.execute(callback, callbackName);
                            }
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return !calculations.onTopPassed;
                        }
                    },

                    bottomPassedReverse: function(newCallback) {
                        var
                            calculations = module.get.elementCalculations(),
                            callback     = newCallback || settings.onBottomPassedReverse,
                            callbackName = 'bottomPassedReverse'
                        ;
                        if(newCallback) {
                            module.debug('Adding callback for bottom passed reverse', newCallback);
                            settings.onBottomPassedReverse = newCallback;
                        }
                        if(!calculations.bottomPassed) {
                            if(module.get.occurred('bottomPassed')) {
                                module.execute(callback, callbackName);
                            }
                        }
                        else if(!settings.once) {
                            module.remove.occurred(callbackName);
                        }
                        if(newCallback === undefined) {
                            return !calculations.bottomPassed;
                        }
                    },

                    execute: function(callback, callbackName) {
                        var
                            calculations = module.get.elementCalculations(),
                            screen       = module.get.screenCalculations()
                        ;
                        callback = callback || false;
                        if(callback) {
                            if(settings.continuous) {
                                module.debug('Callback being called continuously', callbackName, calculations);
                                callback.call(element, calculations, screen);
                            }
                            else if(!module.get.occurred(callbackName)) {
                                module.debug('Conditions met', callbackName, calculations);
                                callback.call(element, calculations, screen);
                            }
                        }
                        module.save.occurred(callbackName);
                    },

                    remove: {
                        fixed: function() {
                            module.debug('Removing fixed position');
                            $module
                                .removeClass(className.fixed)
                                .css({
                                    position : '',
                                    top      : '',
                                    left     : '',
                                    zIndex   : ''
                                })
                            ;
                            settings.onUnfixed.call(element);
                        },
                        placeholder: function() {
                            module.debug('Removing placeholder content');
                            if($placeholder) {
                                $placeholder.remove();
                            }
                        },
                        occurred: function(callback) {
                            if(callback) {
                                var
                                    occurred = module.cache.occurred
                                ;
                                if(occurred[callback] !== undefined && occurred[callback] === true) {
                                    module.debug('Callback can now be called again', callback);
                                    module.cache.occurred[callback] = false;
                                }
                            }
                            else {
                                module.cache.occurred = {};
                            }
                        }
                    },

                    save: {
                        calculations: function() {
                            module.verbose('Saving all calculations necessary to determine positioning');
                            module.save.direction();
                            module.save.screenCalculations();
                            module.save.elementCalculations();
                        },
                        occurred: function(callback) {
                            if(callback) {
                                if(module.cache.occurred[callback] === undefined || (module.cache.occurred[callback] !== true)) {
                                    module.verbose('Saving callback occurred', callback);
                                    module.cache.occurred[callback] = true;
                                }
                            }
                        },
                        scroll: function(scrollPosition) {
                            scrollPosition      = scrollPosition + settings.offset || $context.scrollTop() + settings.offset;
                            module.cache.scroll = scrollPosition;
                        },
                        direction: function() {
                            var
                                scroll     = module.get.scroll(),
                                lastScroll = module.get.lastScroll(),
                                direction
                            ;
                            if(scroll > lastScroll && lastScroll) {
                                direction = 'down';
                            }
                            else if(scroll < lastScroll && lastScroll) {
                                direction = 'up';
                            }
                            else {
                                direction = 'static';
                            }
                            module.cache.direction = direction;
                            return module.cache.direction;
                        },
                        elementPosition: function() {
                            var
                                element = module.cache.element,
                                screen  = module.get.screenSize()
                            ;
                            module.verbose('Saving element position');
                            // (quicker than $.extend)
                            element.fits          = (element.height < screen.height);
                            element.offset        = $module.offset();
                            element.width         = $module.outerWidth();
                            element.height        = $module.outerHeight();
                            // store
                            module.cache.element = element;
                            return element;
                        },
                        elementCalculations: function() {
                            var
                                screen     = module.get.screenCalculations(),
                                element    = module.get.elementPosition()
                            ;
                            // offset
                            if(settings.includeMargin) {
                                element.margin        = {};
                                element.margin.top    = parseInt($module.css('margin-top'), 10);
                                element.margin.bottom = parseInt($module.css('margin-bottom'), 10);
                                element.top    = element.offset.top - element.margin.top;
                                element.bottom = element.offset.top + element.height + element.margin.bottom;
                            }
                            else {
                                element.top    = element.offset.top;
                                element.bottom = element.offset.top + element.height;
                            }

                            // visibility
                            element.topVisible       = (screen.bottom >= element.top);
                            element.topPassed        = (screen.top >= element.top);
                            element.bottomVisible    = (screen.bottom >= element.bottom);
                            element.bottomPassed     = (screen.top >= element.bottom);
                            element.pixelsPassed     = 0;
                            element.percentagePassed = 0;

                            // meta calculations
                            element.onScreen  = (element.topVisible && !element.bottomPassed);
                            element.passing   = (element.topPassed && !element.bottomPassed);
                            element.offScreen = (!element.onScreen);

                            // passing calculations
                            if(element.passing) {
                                element.pixelsPassed     = (screen.top - element.top);
                                element.percentagePassed = (screen.top - element.top) / element.height;
                            }
                            module.cache.element = element;
                            module.verbose('Updated element calculations', element);
                            return element;
                        },
                        screenCalculations: function() {
                            var
                                scroll = module.get.scroll()
                            ;
                            module.save.direction();
                            module.cache.screen.top    = scroll;
                            module.cache.screen.bottom = scroll + module.cache.screen.height;
                            return module.cache.screen;
                        },
                        screenSize: function() {
                            module.verbose('Saving window position');
                            module.cache.screen = {
                                height: $context.height()
                            };
                        },
                        position: function() {
                            module.save.screenSize();
                            module.save.elementPosition();
                        }
                    },

                    get: {
                        pixelsPassed: function(amount) {
                            var
                                element = module.get.elementCalculations()
                            ;
                            if(amount.search('%') > -1) {
                                return ( element.height * (parseInt(amount, 10) / 100) );
                            }
                            return parseInt(amount, 10);
                        },
                        occurred: function(callback) {
                            return (module.cache.occurred !== undefined)
                                ? module.cache.occurred[callback] || false
                                : false
                                ;
                        },
                        direction: function() {
                            if(module.cache.direction === undefined) {
                                module.save.direction();
                            }
                            return module.cache.direction;
                        },
                        elementPosition: function() {
                            if(module.cache.element === undefined) {
                                module.save.elementPosition();
                            }
                            return module.cache.element;
                        },
                        elementCalculations: function() {
                            if(module.cache.element === undefined) {
                                module.save.elementCalculations();
                            }
                            return module.cache.element;
                        },
                        screenCalculations: function() {
                            if(module.cache.screen === undefined) {
                                module.save.screenCalculations();
                            }
                            return module.cache.screen;
                        },
                        screenSize: function() {
                            if(module.cache.screen === undefined) {
                                module.save.screenSize();
                            }
                            return module.cache.screen;
                        },
                        scroll: function() {
                            if(module.cache.scroll === undefined) {
                                module.save.scroll();
                            }
                            return module.cache.scroll;
                        },
                        lastScroll: function() {
                            if(module.cache.screen === undefined) {
                                module.debug('First scroll event, no last scroll could be found');
                                return false;
                            }
                            return module.cache.screen.top;
                        }
                    },

                    setting: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, settings, name);
                        }
                        else if(value !== undefined) {
                            settings[name] = value;
                        }
                        else {
                            return settings[name];
                        }
                    },
                    internal: function(name, value) {
                        if( $.isPlainObject(name) ) {
                            $.extend(true, module, name);
                        }
                        else if(value !== undefined) {
                            module[name] = value;
                        }
                        else {
                            return module[name];
                        }
                    },
                    debug: function() {
                        if(!settings.silent && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.debug.apply(console, arguments);
                            }
                        }
                    },
                    verbose: function() {
                        if(!settings.silent && settings.verbose && settings.debug) {
                            if(settings.performance) {
                                module.performance.log(arguments);
                            }
                            else {
                                module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
                                module.verbose.apply(console, arguments);
                            }
                        }
                    },
                    error: function() {
                        if(!settings.silent) {
                            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
                            module.error.apply(console, arguments);
                        }
                    },
                    performance: {
                        log: function(message) {
                            var
                                currentTime,
                                executionTime,
                                previousTime
                            ;
                            if(settings.performance) {
                                currentTime   = new Date().getTime();
                                previousTime  = time || currentTime;
                                executionTime = currentTime - previousTime;
                                time          = currentTime;
                                performance.push({
                                    'Name'           : message[0],
                                    'Arguments'      : [].slice.call(message, 1) || '',
                                    'Element'        : element,
                                    'Execution Time' : executionTime
                                });
                            }
                            clearTimeout(module.performance.timer);
                            module.performance.timer = setTimeout(module.performance.display, 500);
                        },
                        display: function() {
                            var
                                title = settings.name + ':',
                                totalTime = 0
                            ;
                            time = false;
                            clearTimeout(module.performance.timer);
                            $.each(performance, function(index, data) {
                                totalTime += data['Execution Time'];
                            });
                            title += ' ' + totalTime + 'ms';
                            if(moduleSelector) {
                                title += ' \'' + moduleSelector + '\'';
                            }
                            if( (console.group !== undefined || console.table !== undefined) && performance.length > 0) {
                                console.groupCollapsed(title);
                                if(console.table) {
                                    console.table(performance);
                                }
                                else {
                                    $.each(performance, function(index, data) {
                                        console.log(data['Name'] + ': ' + data['Execution Time']+'ms');
                                    });
                                }
                                console.groupEnd();
                            }
                            performance = [];
                        }
                    },
                    invoke: function(query, passedArguments, context) {
                        var
                            object = instance,
                            maxDepth,
                            found,
                            response
                        ;
                        passedArguments = passedArguments || queryArguments;
                        context         = element         || context;
                        if(typeof query == 'string' && object !== undefined) {
                            query    = query.split(/[\. ]/);
                            maxDepth = query.length - 1;
                            $.each(query, function(depth, value) {
                                var camelCaseValue = (depth != maxDepth)
                                    ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1)
                                    : query
                                ;
                                if( $.isPlainObject( object[camelCaseValue] ) && (depth != maxDepth) ) {
                                    object = object[camelCaseValue];
                                }
                                else if( object[camelCaseValue] !== undefined ) {
                                    found = object[camelCaseValue];
                                    return false;
                                }
                                else if( $.isPlainObject( object[value] ) && (depth != maxDepth) ) {
                                    object = object[value];
                                }
                                else if( object[value] !== undefined ) {
                                    found = object[value];
                                    return false;
                                }
                                else {
                                    module.error(error.method, query);
                                    return false;
                                }
                            });
                        }
                        if ( $.isFunction( found ) ) {
                            response = found.apply(context, passedArguments);
                        }
                        else if(found !== undefined) {
                            response = found;
                        }
                        if($.isArray(returnedValue)) {
                            returnedValue.push(response);
                        }
                        else if(returnedValue !== undefined) {
                            returnedValue = [returnedValue, response];
                        }
                        else if(response !== undefined) {
                            returnedValue = response;
                        }
                        return found;
                    }
                };

                if(methodInvoked) {
                    if(instance === undefined) {
                        module.initialize();
                    }
                    instance.save.scroll();
                    instance.save.calculations();
                    module.invoke(query);
                }
                else {
                    if(instance !== undefined) {
                        instance.invoke('destroy');
                    }
                    module.initialize();
                }
            })
        ;

        return (returnedValue !== undefined)
            ? returnedValue
            : this
            ;
    };

    $.fn.visibility.settings = {

        name                   : 'Visibility',
        namespace              : 'visibility',

        debug                  : false,
        verbose                : false,
        performance            : true,

        // whether to use mutation observers to follow changes
        observeChanges         : true,

        // check position immediately on init
        initialCheck           : true,

        // whether to refresh calculations after all page images load
        refreshOnLoad          : true,

        // whether to refresh calculations after page resize event
        refreshOnResize        : true,

        // should call callbacks on refresh event (resize, etc)
        checkOnRefresh         : true,

        // callback should only occur one time
        once                   : true,

        // callback should fire continuously whe evaluates to true
        continuous             : false,

        // offset to use with scroll top
        offset                 : 0,

        // whether to include margin in elements position
        includeMargin          : false,

        // scroll context for visibility checks
        context                : window,

        // visibility check delay in ms (defaults to animationFrame)
        throttle               : false,

        // special visibility type (image, fixed)
        type                   : false,

        // z-index to use with visibility 'fixed'
        zIndex                 : '10',

        // image only animation settings
        transition             : 'fade in',
        duration               : 1000,

        // array of callbacks for percentage
        onPassed               : {},

        // standard callbacks
        onOnScreen             : false,
        onOffScreen            : false,
        onPassing              : false,
        onTopVisible           : false,
        onBottomVisible        : false,
        onTopPassed            : false,
        onBottomPassed         : false,

        // reverse callbacks
        onPassingReverse       : false,
        onTopVisibleReverse    : false,
        onBottomVisibleReverse : false,
        onTopPassedReverse     : false,
        onBottomPassedReverse  : false,

        // special callbacks for image
        onLoad                 : function() {},
        onAllLoaded            : function() {},

        // special callbacks for fixed position
        onFixed                : function() {},
        onUnfixed              : function() {},

        // utility callbacks
        onUpdate               : false, // disabled by default for performance
        onRefresh              : function(){},

        metadata : {
            src: 'src'
        },

        className: {
            fixed       : 'fixed',
            placeholder : 'placeholder'
        },

        error : {
            method  : 'The method you called is not defined.',
            visible : 'Element is hidden, you must call refresh after element becomes visible'
        }

    };

})( jQuery, window, document );

/*jslint newcap: true */
/*global XMLHttpRequest: false, FormData: false */
/*
 * Inline Text Attachment
 *
 * Author: Roy van Kaathoven
 * Contact: ik@royvankaathoven.nl
 */
(function(document, window) {
    'use strict';

    var inlineAttachment = function(options, instance) {
        this.settings = inlineAttachment.util.merge(options, inlineAttachment.defaults);
        this.editor = instance;
        this.filenameTag = '{filename}';
        this.lastValue = null;
    };

    /**
     * Will holds the available editors
     *
     * @type {Object}
     */
    inlineAttachment.editors = {};

    /**
     * Utility functions
     */
    inlineAttachment.util = {

        /**
         * Simple function to merge the given objects
         *
         * @param {Object[]} object Multiple object parameters
         * @returns {Object}
         */
        merge: function() {
            var result = {};
            for (var i = arguments.length - 1; i >= 0; i--) {
                var obj = arguments[i];
                for (var k in obj) {
                    if (obj.hasOwnProperty(k)) {
                        result[k] = obj[k];
                    }
                }
            }
            return result;
        },

        /**
         * Append a line of text at the bottom, ensuring there aren't unnecessary newlines
         *
         * @param {String} appended Current content
         * @param {String} previous Value which should be appended after the current content
         */
        appendInItsOwnLine: function(previous, appended) {
            return (previous + "\n\n[[D]]" + appended)
                .replace(/(\n{2,})\[\[D\]\]/, "\n\n")
                .replace(/^(\n*)/, "");
        },

        /**
         * Inserts the given value at the current cursor position of the textarea element
         *
         * @param  {HtmlElement} el
         * @param  {String} value Text which will be inserted at the cursor position
         */
        insertTextAtCursor: function(el, text) {
            var scrollPos = el.scrollTop,
                strPos = 0,
                browser = false,
                range;

            if ((el.selectionStart || el.selectionStart === '0')) {
                browser = "ff";
            } else if (document.selection) {
                browser = "ie";
            }

            if (browser === "ie") {
                el.focus();
                range = document.selection.createRange();
                range.moveStart('character', -el.value.length);
                strPos = range.text.length;
            } else if (browser === "ff") {
                strPos = el.selectionStart;
            }

            var front = (el.value).substring(0, strPos);
            var back = (el.value).substring(strPos, el.value.length);
            el.value = front + text + back;
            strPos = strPos + text.length;
            if (browser === "ie") {
                el.focus();
                range = document.selection.createRange();
                range.moveStart('character', -el.value.length);
                range.moveStart('character', strPos);
                range.moveEnd('character', 0);
                range.select();
            } else if (browser === "ff") {
                el.selectionStart = strPos;
                el.selectionEnd = strPos;
                el.focus();
            }
            el.scrollTop = scrollPos;
        }
    };

    /**
     * Default configuration options
     *
     * @type {Object}
     */
    inlineAttachment.defaults = {
        /**
         * URL where the file will be send
         */
        uploadUrl: 'upload_attachment.php',

        /**
         * Which method will be used to send the file to the upload URL
         */
        uploadMethod: 'POST',

        /**
         * Name in which the file will be placed
         */
        uploadFieldName: 'file',

        /**
         * Extension which will be used when a file extension could not
         * be detected
         */
        defaultExtension: 'png',

        /**
         * JSON field which refers to the uploaded file URL
         */
        jsonFieldName: 'filename',

        /**
         * Allowed MIME types
         */
        allowedTypes: [
            'image/jpeg',
            'image/png',
            'image/jpg',
            'image/gif'
        ],

        /**
         * Text which will be inserted when dropping or pasting a file.
         * Acts as a placeholder which will be replaced when the file is done with uploading
         */
        progressText: '![Uploading file...]()',

        /**
         * When a file has successfully been uploaded the progressText
         * will be replaced by the urlText, the {filename} tag will be replaced
         * by the filename that has been returned by the server
         */
        urlText: "![file]({filename})",

        /**
         * Text which will be used when uploading has failed
         */
        errorText: "Error uploading file",

        /**
         * Extra parameters which will be send when uploading a file
         */
        extraParams: {},

        /**
         * Extra headers which will be send when uploading a file
         */
        extraHeaders: {},

        /**
         * Before the file is send
         */
        beforeFileUpload: function() {
            return true;
        },

        /**
         * Triggers when a file is dropped or pasted
         */
        onFileReceived: function() {},

        /**
         * Custom upload handler
         *
         * @return {Boolean} when false is returned it will prevent default upload behavior
         */
        onFileUploadResponse: function() {
            return true;
        },

        /**
         * Custom error handler. Runs after removing the placeholder text and before the alert().
         * Return false from this function to prevent the alert dialog.
         *
         * @return {Boolean} when false is returned it will prevent default error behavior
         */
        onFileUploadError: function() {
            return true;
        },

        /**
         * When a file has succesfully been uploaded
         */
        onFileUploaded: function() {}
    };

    /**
     * Uploads the blob
     *
     * @param  {Blob} file blob data received from event.dataTransfer object
     * @return {XMLHttpRequest} request object which sends the file
     */
    inlineAttachment.prototype.uploadFile = function(file) {
        var me = this,
            formData = new FormData(),
            xhr = new XMLHttpRequest(),
            settings = this.settings,
            extension = settings.defaultExtension || settings.defualtExtension;

        if (typeof settings.setupFormData === 'function') {
            settings.setupFormData(formData, file);
        }

        // Attach the file. If coming from clipboard, add a default filename (only works in Chrome for now)
        // http://stackoverflow.com/questions/6664967/how-to-give-a-blob-uploaded-as-formdata-a-file-name
        if (file.name) {
            var fileNameMatches = file.name.match(/\.(.+)$/);
            if (fileNameMatches) {
                extension = fileNameMatches[1];
            }
        }

        var remoteFilename = "image-" + Date.now() + "." + extension;
        if (typeof settings.remoteFilename === 'function') {
            remoteFilename = settings.remoteFilename(file);
        }

        formData.append(settings.uploadFieldName, file, remoteFilename);

        // Append the extra parameters to the formdata
        if (typeof settings.extraParams === "object") {
            for (var key in settings.extraParams) {
                if (settings.extraParams.hasOwnProperty(key)) {
                    formData.append(key, settings.extraParams[key]);
                }
            }
        }

        xhr.open('POST', settings.uploadUrl);

        // Add any available extra headers
        if (typeof settings.extraHeaders === "object") {
            for (var header in settings.extraHeaders) {
                if (settings.extraHeaders.hasOwnProperty(header)) {
                    xhr.setRequestHeader(header, settings.extraHeaders[header]);
                }
            }
        }

        xhr.onload = function() {
            // If HTTP status is OK or Created
            if (xhr.status === 200 || xhr.status === 201) {
                me.onFileUploadResponse(xhr);
            } else {
                me.onFileUploadError(xhr);
            }
        };
        if (settings.beforeFileUpload(xhr) !== false) {
            xhr.send(formData);
        }
        return xhr;
    };

    /**
     * Returns if the given file is allowed to handle
     *
     * @param {File} clipboard data file
     */
    inlineAttachment.prototype.isFileAllowed = function(file) {
        if (file.kind === 'string') { return false; }
        if (this.settings.allowedTypes.indexOf('*') === 0){
            return true;
        } else {
            return this.settings.allowedTypes.indexOf(file.type) >= 0;
        }
    };

    /**
     * Handles upload response
     *
     * @param  {XMLHttpRequest} xhr
     * @return {Void}
     */
    inlineAttachment.prototype.onFileUploadResponse = function(xhr) {
        if (this.settings.onFileUploadResponse.call(this, xhr) !== false) {
            var result = JSON.parse(xhr.responseText),
                filename = result[this.settings.jsonFieldName];

            if (result && filename) {
                var newValue;
                if (typeof this.settings.urlText === 'function') {
                    newValue = this.settings.urlText.call(this, filename, result);
                } else {
                    newValue = this.settings.urlText.replace(this.filenameTag, filename);
                }
                var text = this.editor.getValue().replace(this.lastValue, newValue);
                this.editor.setValue(text);
                this.settings.onFileUploaded.call(this, filename);
            }
        }
    };


    /**
     * Called when a file has failed to upload
     *
     * @param  {XMLHttpRequest} xhr
     * @return {Void}
     */
    inlineAttachment.prototype.onFileUploadError = function(xhr) {
        if (this.settings.onFileUploadError.call(this, xhr) !== false) {
            var text = this.editor.getValue().replace(this.lastValue, "");
            this.editor.setValue(text);
        }
    };

    /**
     * Called when a file has been inserted, either by drop or paste
     *
     * @param  {File} file
     * @return {Void}
     */
    inlineAttachment.prototype.onFileInserted = function(file) {
        if (this.settings.onFileReceived.call(this, file) !== false) {
            this.lastValue = this.settings.progressText;
            this.editor.insertValue(this.lastValue);
        }
    };


    /**
     * Called when a paste event occured
     * @param  {Event} e
     * @return {Boolean} if the event was handled
     */
    inlineAttachment.prototype.onPaste = function(e) {
        var result = false,
            clipboardData = e.clipboardData,
            items;

        if (typeof clipboardData === "object") {
            items = clipboardData.items || clipboardData.files || [];

            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                if (this.isFileAllowed(item)) {
                    result = true;
                    this.onFileInserted(item.getAsFile());
                    this.uploadFile(item.getAsFile());
                }
            }
        }

        if (result) { e.preventDefault(); }

        return result;
    };

    /**
     * Called when a drop event occures
     * @param  {Event} e
     * @return {Boolean} if the event was handled
     */
    inlineAttachment.prototype.onDrop = function(e) {
        var result = false;
        for (var i = 0; i < e.dataTransfer.files.length; i++) {
            var file = e.dataTransfer.files[i];
            if (this.isFileAllowed(file)) {
                result = true;
                this.onFileInserted(file);
                this.uploadFile(file);
            }
        }

        return result;
    };

    window.inlineAttachment = inlineAttachment;

})(document, window);

/*jslint newcap: true */
/*global inlineAttachment: false */
/**
 * CodeMirror version for inlineAttachment
 *
 * Call inlineAttachment.attach(editor) to attach to a codemirror instance
 */
(function() {
    'use strict';

    var codeMirrorEditor = function(instance) {

        if (!instance.getWrapperElement) {
            throw "Invalid CodeMirror object given";
        }

        this.codeMirror = instance;
    };

    codeMirrorEditor.prototype.getValue = function() {
        return this.codeMirror.getValue();
    };

    codeMirrorEditor.prototype.insertValue = function(val) {
        this.codeMirror.replaceSelection(val);
    };

    codeMirrorEditor.prototype.setValue = function(val) {
        var cursor = this.codeMirror.getCursor();
        this.codeMirror.setValue(val);
        this.codeMirror.setCursor(cursor);
    };

    /**
     * Attach InlineAttachment to CodeMirror
     *
     * @param {CodeMirror} codeMirror
     */
    codeMirrorEditor.attach = function(codeMirror, options) {

        options = options || {};

        var editor = new codeMirrorEditor(codeMirror),
            inlineattach = new inlineAttachment(options, editor),
            el = codeMirror.getWrapperElement();

        el.addEventListener('paste', function(e) {
            inlineattach.onPaste(e);
        }, false);

        codeMirror.setOption('onDragEvent', function(data, e) {
            if (e.type === "drop") {
                e.stopPropagation();
                e.preventDefault();
                return inlineattach.onDrop(e);
            }
        });
    };

    var codeMirrorEditor4 = function(instance) {
        codeMirrorEditor.call(this, instance);
    };

    codeMirrorEditor4.attach = function(codeMirror, options) {

        options = options || {};

        var editor = new codeMirrorEditor(codeMirror),
            inlineattach = new inlineAttachment(options, editor),
            el = codeMirror.getWrapperElement();

        el.addEventListener('paste', function(e) {
            inlineattach.onPaste(e);
        }, false);

        codeMirror.on('drop', function(data, e) {
            if (inlineattach.onDrop(e)) {
                e.stopPropagation();
                e.preventDefault();
                return true;
            } else {
                return false;
            }
        });
    };

    inlineAttachment.editors.codemirror4 = codeMirrorEditor4;

})();
(function(){var $c=function(a){this.w=a||[]};$c.prototype.set=function(a){this.w[a]=!0};$c.prototype.encode=function(){for(var a=[],b=0;b<this.w.length;b++)this.w[b]&&(a[Math.floor(b/6)]^=1<<b%6);for(b=0;b<a.length;b++)a[b]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".charAt(a[b]||0);return a.join("")+"~"};var vd=new $c;function J(a){vd.set(a)}var Nd=function(a,b){var c=new $c(Dd(a));c.set(b);a.set(Gd,c.w)},Td=function(a){a=Dd(a);a=new $c(a);for(var b=vd.w.slice(),c=0;c<a.w.length;c++)b[c]=b[c]||a.w[c];return(new $c(b)).encode()},Dd=function(a){a=a.get(Gd);ka(a)||(a=[]);return a};var ea=function(a){return"function"==typeof a},ka=function(a){return"[object Array]"==Object.prototype.toString.call(Object(a))},qa=function(a){return void 0!=a&&-1<(a.constructor+"").indexOf("String")},D=function(a,b){return 0==a.indexOf(b)},sa=function(a){return a?a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,""):""},ta=function(a){var b=M.createElement("img");b.width=1;b.height=1;b.src=a;return b},ua=function(){},K=function(a){if(encodeURIComponent instanceof Function)return encodeURIComponent(a);J(28);return a},
    L=function(a,b,c,d){try{a.addEventListener?a.addEventListener(b,c,!!d):a.attachEvent&&a.attachEvent("on"+b,c)}catch(e){J(27)}},f=/^[\w\-:/.?=&%!]+$/,wa=function(a,b,c){a&&(c?(c="",b&&f.test(b)&&(c=' id="'+b+'"'),f.test(a)&&M.write("<script"+c+' src="'+a+'">\x3c/script>')):(c=M.createElement("script"),c.type="text/javascript",c.async=!0,c.src=a,b&&(c.id=b),a=M.getElementsByTagName("script")[0],a.parentNode.insertBefore(c,a)))},Ud=function(){return"https:"==M.location.protocol},E=function(a,b){var c=
        a.match("(?:&|#|\\?)"+K(b).replace(/([.*+?^=!:${}()|\[\]\/\\])/g,"\\$1")+"=([^&#]*)");return c&&2==c.length?c[1]:""},xa=function(){var a=""+M.location.hostname;return 0==a.indexOf("www.")?a.substring(4):a},ya=function(a){var b=M.referrer;if(/^https?:\/\//i.test(b)){if(a)return b;a="//"+M.location.hostname;var c=b.indexOf(a);if(5==c||6==c)if(a=b.charAt(c+a.length),"/"==a||"?"==a||""==a||":"==a)return;return b}},za=function(a,b){if(1==b.length&&null!=b[0]&&"object"===typeof b[0])return b[0];for(var c=
        {},d=Math.min(a.length+1,b.length),e=0;e<d;e++)if("object"===typeof b[e]){for(var g in b[e])b[e].hasOwnProperty(g)&&(c[g]=b[e][g]);break}else e<a.length&&(c[a[e]]=b[e]);return c};var ee=function(){this.keys=[];this.values={};this.m={}};ee.prototype.set=function(a,b,c){this.keys.push(a);c?this.m[":"+a]=b:this.values[":"+a]=b};ee.prototype.get=function(a){return this.m.hasOwnProperty(":"+a)?this.m[":"+a]:this.values[":"+a]};ee.prototype.map=function(a){for(var b=0;b<this.keys.length;b++){var c=this.keys[b],d=this.get(c);d&&a(c,d)}};var O=window,M=document;var F=window,G=function(a){var b=F._gaUserPrefs;if(b&&b.ioo&&b.ioo()||a&&!0===F["ga-disable-"+a])return!0;try{var c=F.external;if(c&&c._gaUserPrefs&&"oo"==c._gaUserPrefs)return!0}catch(d){}return!1};var Ca=function(a){var b=[],c=M.cookie.split(";");a=new RegExp("^\\s*"+a+"=\\s*(.*?)\\s*$");for(var d=0;d<c.length;d++){var e=c[d].match(a);e&&b.push(e[1])}return b},zc=function(a,b,c,d,e,g){e=G(e)?!1:eb.test(M.location.hostname)||"/"==c&&vc.test(d)?!1:!0;if(!e)return!1;b&&1200<b.length&&(b=b.substring(0,1200),J(24));c=a+"="+b+"; path="+c+"; ";g&&(c+="expires="+(new Date((new Date).getTime()+g)).toGMTString()+"; ");d&&"none"!=d&&(c+="domain="+d+";");d=M.cookie;M.cookie=c;if(!(d=d!=M.cookie))a:{a=
    Ca(a);for(d=0;d<a.length;d++)if(b==a[d]){d=!0;break a}d=!1}return d},Cc=function(a){return K(a).replace(/\(/g,"%28").replace(/\)/g,"%29")},vc=/^(www\.)?google(\.com?)?(\.[a-z]{2})?$/,eb=/(^|\.)doubleclick\.net$/i;var oc=function(){return(Ba||Ud()?"https:":"http:")+"//www.google-analytics.com"},Da=function(a){this.name="len";this.message=a+"-8192"},ba=function(a,b,c){c=c||ua;if(2036>=b.length)wc(a,b,c);else if(8192>=b.length)x(a,b,c)||wd(a,b,c)||wc(a,b,c);else throw ge("len",b.length),new Da(b.length);},wc=function(a,b,c){var d=ta(a+"?"+b);d.onload=d.onerror=function(){d.onload=null;d.onerror=null;c()}},wd=function(a,b,c){var d=O.XMLHttpRequest;if(!d)return!1;var e=new d;if(!("withCredentials"in e))return!1;
    e.open("POST",a,!0);e.withCredentials=!0;e.setRequestHeader("Content-Type","text/plain");e.onreadystatechange=function(){4==e.readyState&&(c(),e=null)};e.send(b);return!0},x=function(a,b,c){return O.navigator.sendBeacon?O.navigator.sendBeacon(a,b)?(c(),!0):!1:!1},ge=function(a,b,c){1<=100*Math.random()||G("?")||(a=["t=error","_e="+a,"_v=j47","sr=1"],b&&a.push("_f="+b),c&&a.push("_m="+K(c.substring(0,100))),a.push("aip=1"),a.push("z="+hd()),wc(oc()+"/collect",a.join("&"),ua))};var h=function(a){var b=O.gaData=O.gaData||{};return b[a]=b[a]||{}};var Ha=function(){this.M=[]};Ha.prototype.add=function(a){this.M.push(a)};Ha.prototype.D=function(a){try{for(var b=0;b<this.M.length;b++){var c=a.get(this.M[b]);c&&ea(c)&&c.call(O,a)}}catch(d){}b=a.get(Ia);b!=ua&&ea(b)&&(a.set(Ia,ua,!0),setTimeout(b,10))};function Ja(a){if(100!=a.get(Ka)&&La(P(a,Q))%1E4>=100*R(a,Ka))throw"abort";}function Ma(a){if(G(P(a,Na)))throw"abort";}function Oa(){var a=M.location.protocol;if("http:"!=a&&"https:"!=a)throw"abort";}
    function Pa(a){try{O.navigator.sendBeacon?J(42):O.XMLHttpRequest&&"withCredentials"in new O.XMLHttpRequest&&J(40)}catch(c){}a.set(ld,Td(a),!0);a.set(Ac,R(a,Ac)+1);var b=[];Qa.map(function(c,d){if(d.F){var e=a.get(c);void 0!=e&&e!=d.defaultValue&&("boolean"==typeof e&&(e*=1),b.push(d.F+"="+K(""+e)))}});b.push("z="+Bd());a.set(Ra,b.join("&"),!0)}
    function Sa(a){var b=P(a,gd)||oc()+"/collect",c=P(a,fa);!c&&a.get(Vd)&&(c="beacon");if(c){var d=P(a,Ra),e=a.get(Ia),e=e||ua;"image"==c?wc(b,d,e):"xhr"==c&&wd(b,d,e)||"beacon"==c&&x(b,d,e)||ba(b,d,e)}else ba(b,P(a,Ra),a.get(Ia));b=a.get(Na);b=h(b);c=b.hitcount;b.hitcount=c?c+1:1;b=a.get(Na);delete h(b).pending_experiments;a.set(Ia,ua,!0)}
    function Hc(a){(O.gaData=O.gaData||{}).expId&&a.set(Nc,(O.gaData=O.gaData||{}).expId);(O.gaData=O.gaData||{}).expVar&&a.set(Oc,(O.gaData=O.gaData||{}).expVar);var b;var c=a.get(Na);if(c=h(c).pending_experiments){var d=[];for(b in c)c.hasOwnProperty(b)&&c[b]&&d.push(encodeURIComponent(b)+"."+encodeURIComponent(c[b]));b=d.join("!")}else b=void 0;b&&a.set(m,b,!0)}function cd(){if(O.navigator&&"preview"==O.navigator.loadPurpose)throw"abort";}
    function yd(a){var b=O.gaDevIds;ka(b)&&0!=b.length&&a.set("&did",b.join(","),!0)}function vb(a){if(!a.get(Na))throw"abort";};var hd=function(){return Math.round(2147483647*Math.random())},Bd=function(){try{var a=new Uint32Array(1);O.crypto.getRandomValues(a);return a[0]&2147483647}catch(b){return hd()}};function Ta(a){var b=R(a,Ua);500<=b&&J(15);var c=P(a,Va);if("transaction"!=c&&"item"!=c){var c=R(a,Wa),d=(new Date).getTime(),e=R(a,Xa);0==e&&a.set(Xa,d);e=Math.round(2*(d-e)/1E3);0<e&&(c=Math.min(c+e,20),a.set(Xa,d));if(0>=c)throw"abort";a.set(Wa,--c)}a.set(Ua,++b)};var Ya=function(){this.data=new ee},Qa=new ee,Za=[];Ya.prototype.get=function(a){var b=$a(a),c=this.data.get(a);b&&void 0==c&&(c=ea(b.defaultValue)?b.defaultValue():b.defaultValue);return b&&b.Z?b.Z(this,a,c):c};var P=function(a,b){var c=a.get(b);return void 0==c?"":""+c},R=function(a,b){var c=a.get(b);return void 0==c||""===c?0:1*c};Ya.prototype.set=function(a,b,c){if(a)if("object"==typeof a)for(var d in a)a.hasOwnProperty(d)&&ab(this,d,a[d],c);else ab(this,a,b,c)};
    var ab=function(a,b,c,d){if(void 0!=c)switch(b){case Na:wb.test(c)}var e=$a(b);e&&e.o?e.o(a,b,c,d):a.data.set(b,c,d)},bb=function(a,b,c,d,e){this.name=a;this.F=b;this.Z=d;this.o=e;this.defaultValue=c},$a=function(a){var b=Qa.get(a);if(!b)for(var c=0;c<Za.length;c++){var d=Za[c],e=d[0].exec(a);if(e){b=d[1](e);Qa.set(b.name,b);break}}return b},yc=function(a){var b;Qa.map(function(c,d){d.F==a&&(b=d)});return b&&b.name},S=function(a,b,c,d,e){a=new bb(a,b,c,d,e);Qa.set(a.name,a);return a.name},cb=function(a,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              b){Za.push([new RegExp("^"+a+"$"),b])},T=function(a,b,c){return S(a,b,c,void 0,db)},db=function(){};var gb=qa(window.GoogleAnalyticsObject)&&sa(window.GoogleAnalyticsObject)||"ga",Ba=!1,hb=T("apiVersion","v"),ib=T("clientVersion","_v");S("anonymizeIp","aip");var jb=S("adSenseId","a"),Va=S("hitType","t"),Ia=S("hitCallback"),Ra=S("hitPayload");S("nonInteraction","ni");S("currencyCode","cu");S("dataSource","ds");var Vd=S("useBeacon",void 0,!1),fa=S("transport");S("sessionControl","sc","");S("sessionGroup","sg");S("queueTime","qt");var Ac=S("_s","_s");S("screenName","cd");
    var kb=S("location","dl",""),lb=S("referrer","dr"),mb=S("page","dp","");S("hostname","dh");var nb=S("language","ul"),ob=S("encoding","de");S("title","dt",function(){return M.title||void 0});cb("contentGroup([0-9]+)",function(a){return new bb(a[0],"cg"+a[1])});var pb=S("screenColors","sd"),qb=S("screenResolution","sr"),rb=S("viewportSize","vp"),sb=S("javaEnabled","je"),tb=S("flashVersion","fl");S("campaignId","ci");S("campaignName","cn");S("campaignSource","cs");S("campaignMedium","cm");
    S("campaignKeyword","ck");S("campaignContent","cc");var ub=S("eventCategory","ec"),xb=S("eventAction","ea"),yb=S("eventLabel","el"),zb=S("eventValue","ev"),Bb=S("socialNetwork","sn"),Cb=S("socialAction","sa"),Db=S("socialTarget","st"),Eb=S("l1","plt"),Fb=S("l2","pdt"),Gb=S("l3","dns"),Hb=S("l4","rrt"),Ib=S("l5","srt"),Jb=S("l6","tcp"),Kb=S("l7","dit"),Lb=S("l8","clt"),Mb=S("timingCategory","utc"),Nb=S("timingVar","utv"),Ob=S("timingLabel","utl"),Pb=S("timingValue","utt");S("appName","an");
    S("appVersion","av","");S("appId","aid","");S("appInstallerId","aiid","");S("exDescription","exd");S("exFatal","exf");var Nc=S("expId","xid"),Oc=S("expVar","xvar"),m=S("exp","exp"),Rc=S("_utma","_utma"),Sc=S("_utmz","_utmz"),Tc=S("_utmht","_utmht"),Ua=S("_hc",void 0,0),Xa=S("_ti",void 0,0),Wa=S("_to",void 0,20);cb("dimension([0-9]+)",function(a){return new bb(a[0],"cd"+a[1])});cb("metric([0-9]+)",function(a){return new bb(a[0],"cm"+a[1])});S("linkerParam",void 0,void 0,Bc,db);
    var ld=S("usage","_u"),Gd=S("_um");S("forceSSL",void 0,void 0,function(){return Ba},function(a,b,c){J(34);Ba=!!c});var ed=S("_j1","jid");cb("\\&(.*)",function(a){var b=new bb(a[0],a[1]),c=yc(a[0].substring(1));c&&(b.Z=function(a){return a.get(c)},b.o=function(a,b,g,ca){a.set(c,g,ca)},b.F=void 0);return b});
    var Qb=T("_oot"),dd=S("previewTask"),Rb=S("checkProtocolTask"),md=S("validationTask"),Sb=S("checkStorageTask"),Uc=S("historyImportTask"),Tb=S("samplerTask"),Vb=S("_rlt"),Wb=S("buildHitTask"),Xb=S("sendHitTask"),Vc=S("ceTask"),zd=S("devIdTask"),Cd=S("timingTask"),Ld=S("displayFeaturesTask"),V=T("name"),Q=T("clientId","cid"),n=T("clientIdTime"),Ad=S("userId","uid"),Na=T("trackingId","tid"),U=T("cookieName",void 0,"_ga"),W=T("cookieDomain"),Yb=T("cookiePath",void 0,"/"),Zb=T("cookieExpires",void 0,63072E3),
        $b=T("legacyCookieDomain"),Wc=T("legacyHistoryImport",void 0,!0),ac=T("storage",void 0,"cookie"),bc=T("allowLinker",void 0,!1),cc=T("allowAnchor",void 0,!0),Ka=T("sampleRate","sf",100),dc=T("siteSpeedSampleRate",void 0,1),ec=T("alwaysSendReferrer",void 0,!1),gd=S("transportUrl"),Md=S("_r","_r");function X(a,b,c,d){b[a]=function(){try{return d&&J(d),c.apply(this,arguments)}catch(e){throw ge("exc",a,e&&e.name),e;}}};var Od=function(a){this.V=a;this.fa=void 0;this.$=!1;this.oa=void 0;this.ea=1},Ed=function(a,b){var c;if(a.fa&&a.$)return 0;a.$=!0;if(b){if(a.oa&&R(b,a.oa))return R(b,a.oa);if(0==b.get(dc))return 0}if(0==a.V)return 0;void 0===c&&(c=Bd());return 0==c%a.V?Math.floor(c/a.V)%a.ea+1:0};function fc(){var a,b,c;if((c=(c=O.navigator)?c.plugins:null)&&c.length)for(var d=0;d<c.length&&!b;d++){var e=c[d];-1<e.name.indexOf("Shockwave Flash")&&(b=e.description)}if(!b)try{a=new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7"),b=a.GetVariable("$version")}catch(g){}if(!b)try{a=new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6"),b="WIN 6,0,21,0",a.AllowScriptAccess="always",b=a.GetVariable("$version")}catch(g){}if(!b)try{a=new ActiveXObject("ShockwaveFlash.ShockwaveFlash"),b=a.GetVariable("$version")}catch(g){}b&&
    (a=b.match(/[\d]+/g))&&3<=a.length&&(b=a[0]+"."+a[1]+" r"+a[2]);return b||void 0};var aa=function(a){var b=Math.min(R(a,dc),100);return La(P(a,Q))%100>=b?!1:!0},gc=function(a){var b={};if(Ec(b)||Fc(b)){var c=b[Eb];void 0==c||Infinity==c||isNaN(c)||(0<c?(Y(b,Gb),Y(b,Jb),Y(b,Ib),Y(b,Fb),Y(b,Hb),Y(b,Kb),Y(b,Lb),a(b)):L(O,"load",function(){gc(a)},!1))}},Ec=function(a){var b=O.performance||O.webkitPerformance,b=b&&b.timing;if(!b)return!1;var c=b.navigationStart;if(0==c)return!1;a[Eb]=b.loadEventStart-c;a[Gb]=b.domainLookupEnd-b.domainLookupStart;a[Jb]=b.connectEnd-b.connectStart;a[Ib]=
        b.responseStart-b.requestStart;a[Fb]=b.responseEnd-b.responseStart;a[Hb]=b.fetchStart-c;a[Kb]=b.domInteractive-c;a[Lb]=b.domContentLoadedEventStart-c;return!0},Fc=function(a){if(O.top!=O)return!1;var b=O.external,c=b&&b.onloadT;b&&!b.isValidLoadTime&&(c=void 0);2147483648<c&&(c=void 0);0<c&&b.setPageReadyTime();if(void 0==c)return!1;a[Eb]=c;return!0},Y=function(a,b){var c=a[b];if(isNaN(c)||Infinity==c||0>c)a[b]=void 0},Fd=function(a){return function(b){if("pageview"==b.get(Va)&&!a.I){a.I=!0;var c=
        aa(b);b=0<E(b.get(kb),"gclid").length;(c||b)&&gc(function(b){a.send(c?"timing":"adtiming",b)})}}};var hc=!1,mc=function(a){if("cookie"==P(a,ac)){var b=P(a,U),c=nd(a),d=kc(P(a,Yb)),e=lc(P(a,W)),g=1E3*R(a,Zb),ca=P(a,Na);if("auto"!=e)zc(b,c,d,e,ca,g)&&(hc=!0);else{J(32);var l;a:{c=[];e=xa().split(".");if(4==e.length&&(l=e[e.length-1],parseInt(l,10)==l)){l=["none"];break a}for(l=e.length-2;0<=l;l--)c.push(e.slice(l).join("."));c.push("none");l=c}for(var k=0;k<l.length;k++)if(e=l[k],a.data.set(W,e),c=nd(a),zc(b,c,d,e,ca,g)){hc=!0;return}a.data.set(W,"auto")}}},nc=function(a){if("cookie"==P(a,ac)&&
        !hc&&(mc(a),!hc))throw"abort";},Yc=function(a){if(a.get(Wc)){var b=P(a,W),c=P(a,$b)||xa(),d=Xc("__utma",c,b);d&&(J(19),a.set(Tc,(new Date).getTime(),!0),a.set(Rc,d.R),(b=Xc("__utmz",c,b))&&d.hash==b.hash&&a.set(Sc,b.R))}},nd=function(a){var b=Cc(P(a,Q)),c=lc(P(a,W)).split(".").length;a=jc(P(a,Yb));1<a&&(c+="-"+a);return["GA1",c,b].join(".")},Gc=function(a,b,c){for(var d=[],e=[],g,ca=0;ca<a.length;ca++){var l=a[ca];l.H[c]==b?d.push(l):void 0==g||l.H[c]<g?(e=[l],g=l.H[c]):l.H[c]==g&&e.push(l)}return 0<
    d.length?d:e},lc=function(a){return 0==a.indexOf(".")?a.substr(1):a},kc=function(a){if(!a)return"/";1<a.length&&a.lastIndexOf("/")==a.length-1&&(a=a.substr(0,a.length-1));0!=a.indexOf("/")&&(a="/"+a);return a},jc=function(a){a=kc(a);return"/"==a?1:a.split("/").length};function Xc(a,b,c){"none"==b&&(b="");var d=[],e=Ca(a);a="__utma"==a?6:2;for(var g=0;g<e.length;g++){var ca=(""+e[g]).split(".");ca.length>=a&&d.push({hash:ca[0],R:e[g],O:ca})}if(0!=d.length)return 1==d.length?d[0]:Zc(b,d)||Zc(c,d)||Zc(null,d)||d[0]}function Zc(a,b){var c,d;null==a?c=d=1:(c=La(a),d=La(D(a,".")?a.substring(1):"."+a));for(var e=0;e<b.length;e++)if(b[e].hash==c||b[e].hash==d)return b[e]};var od=new RegExp(/^https?:\/\/([^\/:]+)/),pd=/(.*)([?&#])(?:_ga=[^&#]*)(?:&?)(.*)/;function Bc(a){a=a.get(Q);var b=Ic(a,0);return"_ga=1."+K(b+"."+a)}function Ic(a,b){for(var c=new Date,d=O.navigator,e=d.plugins||[],c=[a,d.userAgent,c.getTimezoneOffset(),c.getYear(),c.getDate(),c.getHours(),c.getMinutes()+b],d=0;d<e.length;++d)c.push(e[d].description);return La(c.join("."))}var Dc=function(a){J(48);this.target=a;this.T=!1};
    Dc.prototype.ca=function(a,b){if(a.tagName){if("a"==a.tagName.toLowerCase()){a.href&&(a.href=qd(this,a.href,b));return}if("form"==a.tagName.toLowerCase())return rd(this,a)}if("string"==typeof a)return qd(this,a,b)};
    var qd=function(a,b,c){var d=pd.exec(b);d&&3<=d.length&&(b=d[1]+(d[3]?d[2]+d[3]:""));a=a.target.get("linkerParam");var e=b.indexOf("?"),d=b.indexOf("#");c?b+=(-1==d?"#":"&")+a:(c=-1==e?"?":"&",b=-1==d?b+(c+a):b.substring(0,d)+c+a+b.substring(d));return b=b.replace(/&+_ga=/,"&_ga=")},rd=function(a,b){if(b&&b.action){var c=a.target.get("linkerParam").split("=")[1];if("get"==b.method.toLowerCase()){for(var d=b.childNodes||[],e=0;e<d.length;e++)if("_ga"==d[e].name){d[e].setAttribute("value",c);return}d=
        M.createElement("input");d.setAttribute("type","hidden");d.setAttribute("name","_ga");d.setAttribute("value",c);b.appendChild(d)}else"post"==b.method.toLowerCase()&&(b.action=qd(a,b.action))}};
    Dc.prototype.S=function(a,b,c){function d(c){try{c=c||O.event;var d;a:{var g=c.target||c.srcElement;for(c=100;g&&0<c;){if(g.href&&g.nodeName.match(/^a(?:rea)?$/i)){d=g;break a}g=g.parentNode;c--}d={}}("http:"==d.protocol||"https:"==d.protocol)&&sd(a,d.hostname||"")&&d.href&&(d.href=qd(e,d.href,b))}catch(k){J(26)}}var e=this;this.T||(this.T=!0,L(M,"mousedown",d,!1),L(M,"keyup",d,!1));c&&L(M,"submit",function(b){b=b||O.event;if((b=b.target||b.srcElement)&&b.action){var c=b.action.match(od);c&&sd(a,
        c[1])&&rd(e,b)}})};function sd(a,b){if(b==M.location.hostname)return!1;for(var c=0;c<a.length;c++)if(a[c]instanceof RegExp){if(a[c].test(b))return!0}else if(0<=b.indexOf(a[c]))return!0;return!1};var p=/^(GTM|OPT)-[A-Z0-9]+$/,q=/;_gaexp=[^;]*/g,r=/;((__utma=)|([^;=]+=GAX?\d+\.))[^;]*/g,t=function(a){function b(a,b){b&&(c+="&"+a+"="+K(b))}var c="https://www.google-analytics.com/gtm/js?id="+K(a.id);"dataLayer"!=a.B&&b("l",a.B);b("t",a.target);b("cid",a.ja);b("cidt",a.ka);b("gac",a.la);b("aip",a.ia);a.na&&b("m","sync");b("cycle",a.G);return c};var Jd=function(a,b,c){this.U=ed;this.aa=b;(b=c)||(b=(b=P(a,V))&&"t0"!=b?Wd.test(b)?"_gat_"+Cc(P(a,Na)):"_gat_"+Cc(b):"_gat");this.Y=b;Ed(new Od(100),a)&&(J(30),this.pa=!0)},Rd=function(a,b){var c=b.get(Wb);b.set(Wb,function(b){Pd(a,b);var d=c(b);Qd(a,b);return d});var d=b.get(Xb);b.set(Xb,function(b){var c=d(b);Id(a,b);return c})},Pd=function(a,b){b.get(a.U)||("1"==Ca(a.Y)[0]?b.set(a.U,"",!0):b.set(a.U,""+hd(),!0))},Qd=function(a,b){if(b.get(a.U)){var c=6E5;a.pa&&(c/=10);zc(a.Y,"1",b.get(Yb),b.get(W),
        b.get(Na),c)}},Id=function(a,b){if(b.get(a.U)){var c=new ee,d=function(a){$a(a).F&&c.set($a(a).F,b.get(a))};d(hb);d(ib);d(Na);d(Q);d(Ad);d(a.U);c.set($a(ld).F,Td(b));var e=a.aa;c.map(function(a,b){e+=K(a)+"=";e+=K(""+b)+"&"});e+="z="+hd();ta(e);b.set(a.U,"",!0)}},Wd=/^gtm\d+$/;var fd=function(a,b){var c=a.b;if(!c.get("dcLoaded")){Nd(c,29);b=b||{};var d;b[U]&&(d=Cc(b[U]));d=new Jd(c,"https://stats.g.doubleclick.net/r/collect?t=dc&aip=1&_r=3&",d);Rd(d,c);c.set("dcLoaded",!0)}};var Sd=function(a){if(!a.get("dcLoaded")&&"cookie"==a.get(ac)){Nd(a,51);var b=new Jd(a);Pd(b,a);Qd(b,a);a.get(b.U)&&(a.set(Md,1,!0),a.set(gd,oc()+"/r/collect",!0))}};var Lc=function(){var a=O.gaGlobal=O.gaGlobal||{};return a.hid=a.hid||hd()};var ad,bd=function(a,b,c){if(!ad){var d;d=M.location.hash;var e=O.name,g=/^#?gaso=([^&]*)/;if(e=(d=(d=d&&d.match(g)||e&&e.match(g))?d[1]:Ca("GASO")[0]||"")&&d.match(/^(?:!([-0-9a-z.]{1,40})!)?([-.\w]{10,1200})$/i))zc("GASO",""+d,c,b,a,0),window._udo||(window._udo=b),window._utcp||(window._utcp=c),a=e[1],wa("https://www.google.com/analytics/web/inpage/pub/inpage.js?"+(a?"prefix="+a+"&":"")+hd(),"_gasojs");ad=!0}};var wb=/^(UA|YT|MO|GP)-(\d+)-(\d+)$/,pc=function(a){function b(a,b){d.b.data.set(a,b)}function c(a,c){b(a,c);d.filters.add(a)}var d=this;this.b=new Ya;this.filters=new Ha;b(V,a[V]);b(Na,sa(a[Na]));b(U,a[U]);b(W,a[W]||xa());b(Yb,a[Yb]);b(Zb,a[Zb]);b($b,a[$b]);b(Wc,a[Wc]);b(bc,a[bc]);b(cc,a[cc]);b(Ka,a[Ka]);b(dc,a[dc]);b(ec,a[ec]);b(ac,a[ac]);b(Ad,a[Ad]);b(n,a[n]);b(hb,1);b(ib,"j47");c(Qb,Ma);c(dd,cd);c(Rb,Oa);c(md,vb);c(Sb,nc);c(Uc,Yc);c(Tb,Ja);c(Vb,Ta);c(Vc,Hc);c(zd,yd);c(Ld,Sd);c(Wb,Pa);c(Xb,Sa);
        c(Cd,Fd(this));Jc(this.b,a[Q]);Kc(this.b);this.b.set(jb,Lc());bd(this.b.get(Na),this.b.get(W),this.b.get(Yb))},Jc=function(a,b){if("cookie"==P(a,ac)){hc=!1;var c;b:{var d=Ca(P(a,U));if(d&&!(1>d.length)){c=[];for(var e=0;e<d.length;e++){var g;g=d[e].split(".");var ca=g.shift();("GA1"==ca||"1"==ca)&&1<g.length?(ca=g.shift().split("-"),1==ca.length&&(ca[1]="1"),ca[0]*=1,ca[1]*=1,g={H:ca,s:g.join(".")}):g=void 0;g&&c.push(g)}if(1==c.length){J(13);c=c[0].s;break b}if(0==c.length)J(12);else{J(14);d=lc(P(a,
        W)).split(".").length;c=Gc(c,d,0);if(1==c.length){c=c[0].s;break b}d=jc(P(a,Yb));c=Gc(c,d,1);c=c[0]&&c[0].s;break b}}c=void 0}c||(c=P(a,W),d=P(a,$b)||xa(),c=Xc("__utma",d,c),void 0!=c?(J(10),c=c.O[1]+"."+c.O[2]):c=void 0);c&&(a.data.set(Q,c),hc=!0)}c=a.get(cc);if(e=E(M.location[c?"href":"search"],"_ga"))a.get(bc)?(c=e.indexOf("."),-1==c?J(22):(d=e.substring(c+1),"1"!=e.substring(0,c)?J(22):(c=d.indexOf("."),-1==c?J(22):(e=d.substring(0,c),c=d.substring(c+1),e!=Ic(c,0)&&e!=Ic(c,-1)&&e!=Ic(c,-2)?J(23):
        (J(11),a.data.set(Q,c)))))):J(21);b&&(J(9),a.data.set(Q,K(b)));if(!a.get(Q))if(c=(c=O.gaGlobal&&O.gaGlobal.vid)&&-1!=c.search(/^(?:utma\.)?\d+\.\d+$/)?c:void 0)J(17),a.data.set(Q,c);else{J(8);c=O.navigator.userAgent+(M.cookie?M.cookie:"")+(M.referrer?M.referrer:"");d=c.length;for(e=O.history.length;0<e;)c+=e--^d++;a.data.set(Q,[hd()^La(c)&2147483647,Math.round((new Date).getTime()/1E3)].join("."))}mc(a)},Kc=function(a){var b=O.navigator,c=O.screen,d=M.location;a.set(lb,ya(a.get(ec)));if(d){var e=
        d.pathname||"";"/"!=e.charAt(0)&&(J(31),e="/"+e);a.set(kb,d.protocol+"//"+d.hostname+e+d.search)}c&&a.set(qb,c.width+"x"+c.height);c&&a.set(pb,c.colorDepth+"-bit");var c=M.documentElement,g=(e=M.body)&&e.clientWidth&&e.clientHeight,ca=[];c&&c.clientWidth&&c.clientHeight&&("CSS1Compat"===M.compatMode||!g)?ca=[c.clientWidth,c.clientHeight]:g&&(ca=[e.clientWidth,e.clientHeight]);c=0>=ca[0]||0>=ca[1]?"":ca.join("x");a.set(rb,c);a.set(tb,fc());a.set(ob,M.characterSet||M.charset);a.set(sb,b&&"function"===
        typeof b.javaEnabled&&b.javaEnabled()||!1);a.set(nb,(b&&(b.language||b.browserLanguage)||"").toLowerCase());if(d&&a.get(cc)&&(b=M.location.hash)){b=b.split(/[?&#]+/);d=[];for(c=0;c<b.length;++c)(D(b[c],"utm_id")||D(b[c],"utm_campaign")||D(b[c],"utm_source")||D(b[c],"utm_medium")||D(b[c],"utm_term")||D(b[c],"utm_content")||D(b[c],"gclid")||D(b[c],"dclid")||D(b[c],"gclsrc"))&&d.push(b[c]);0<d.length&&(b="#"+d.join("&"),a.set(kb,a.get(kb)+b))}};pc.prototype.get=function(a){return this.b.get(a)};
    pc.prototype.set=function(a,b){this.b.set(a,b)};var qc={pageview:[mb],event:[ub,xb,yb,zb],social:[Bb,Cb,Db],timing:[Mb,Nb,Pb,Ob]};pc.prototype.send=function(a){if(!(1>arguments.length)){var b,c;"string"===typeof arguments[0]?(b=arguments[0],c=[].slice.call(arguments,1)):(b=arguments[0]&&arguments[0][Va],c=arguments);b&&(c=za(qc[b]||[],c),c[Va]=b,this.b.set(c,void 0,!0),this.filters.D(this.b),this.b.data.m={})}};
    pc.prototype.ma=function(a,b){var c=this;u(a,c,b)||(v(a,function(){u(a,c,b)}),y(String(c.get(V)),a,void 0,b,!0))};var rc=function(a){if("prerender"==M.visibilityState)return!1;a();return!0},z=function(a){if(!rc(a)){J(16);var b=!1,c=function(){if(!b&&rc(a)){b=!0;var d=c,e=M;e.removeEventListener?e.removeEventListener("visibilitychange",d,!1):e.detachEvent&&e.detachEvent("onvisibilitychange",d)}};L(M,"visibilitychange",c)}};var td=/^(?:(\w+)\.)?(?:(\w+):)?(\w+)$/,sc=function(a){if(ea(a[0]))this.u=a[0];else{var b=td.exec(a[0]);null!=b&&4==b.length&&(this.c=b[1]||"t0",this.K=b[2]||"",this.C=b[3],this.a=[].slice.call(a,1),this.K||(this.A="create"==this.C,this.i="require"==this.C,this.g="provide"==this.C,this.ba="remove"==this.C),this.i&&(3<=this.a.length?(this.X=this.a[1],this.W=this.a[2]):this.a[1]&&(qa(this.a[1])?this.X=this.a[1]:this.W=this.a[1])));b=a[1];a=a[2];if(!this.C)throw"abort";if(this.i&&(!qa(b)||""==b))throw"abort";
        if(this.g&&(!qa(b)||""==b||!ea(a)))throw"abort";if(ud(this.c)||ud(this.K))throw"abort";if(this.g&&"t0"!=this.c)throw"abort";}};function ud(a){return 0<=a.indexOf(".")||0<=a.indexOf(":")};var Yd,Zd,$d,A;Yd=new ee;$d=new ee;A=new ee;Zd={ec:45,ecommerce:46,linkid:47};
    var u=function(a,b,c){b==N||b.get(V);var d=Yd.get(a);if(!ea(d))return!1;b.plugins_=b.plugins_||new ee;if(b.plugins_.get(a))return!0;b.plugins_.set(a,new d(b,c||{}));return!0},y=function(a,b,c,d,e){if(!ea(Yd.get(b))&&!$d.get(b)){Zd.hasOwnProperty(b)&&J(Zd[b]);if(p.test(b)){J(52);a=N.j(a);if(!a)return!0;c=d||{};d={id:b,B:c.dataLayer||"dataLayer",ia:!!a.get("anonymizeIp"),na:e,G:!1};a.get("&gtm")==b&&(d.G=!0);var g=String(a.get("name"));"t0"!=g&&(d.target=g);G(String(a.get("trackingId")))||(d.ja=String(a.get(Q)),
            d.ka=Number(a.get(n)),a=c.palindrome?r:q,a=(a=M.cookie.replace(/^|(; +)/g,";").match(a))?a.sort().join("").substring(1):void 0,d.la=a);a=d.B;c=(new Date).getTime();O[a]=O[a]||[];c={"gtm.start":c};e||(c.event="gtm.js");O[a].push(c);c=t(d)}!c&&Zd.hasOwnProperty(b)?(J(39),c=b+".js"):J(43);c&&(c&&0<=c.indexOf("/")||(c=(Ba||Ud()?"https:":"http:")+"//www.google-analytics.com/plugins/ua/"+c),d=ae(c),a=d.protocol,c=M.location.protocol,("https:"==a||a==c||("http:"!=a?0:"http:"==c))&&B(d)&&(wa(d.url,void 0,
        e),$d.set(b,!0)))}},v=function(a,b){var c=A.get(a)||[];c.push(b);A.set(a,c)},C=function(a,b){Yd.set(a,b);for(var c=A.get(a)||[],d=0;d<c.length;d++)c[d]();A.set(a,[])},B=function(a){var b=ae(M.location.href);if(D(a.url,"https://www.google-analytics.com/gtm/js?id="))return!0;if(a.query||0<=a.url.indexOf("?")||0<=a.path.indexOf("://"))return!1;if(a.host==b.host&&a.port==b.port)return!0;b="http:"==a.protocol?80:443;return"www.google-analytics.com"==a.host&&(a.port||b)==b&&D(a.path,"/plugins/")?!0:!1},
        ae=function(a){function b(a){var b=(a.hostname||"").split(":")[0].toLowerCase(),c=(a.protocol||"").toLowerCase(),c=1*a.port||("http:"==c?80:"https:"==c?443:"");a=a.pathname||"";D(a,"/")||(a="/"+a);return[b,""+c,a]}var c=M.createElement("a");c.href=M.location.href;var d=(c.protocol||"").toLowerCase(),e=b(c),g=c.search||"",ca=d+"//"+e[0]+(e[1]?":"+e[1]:"");D(a,"//")?a=d+a:D(a,"/")?a=ca+a:!a||D(a,"?")?a=ca+e[2]+(a||g):0>a.split("/")[0].indexOf(":")&&(a=ca+e[2].substring(0,e[2].lastIndexOf("/"))+"/"+
            a);c.href=a;d=b(c);return{protocol:(c.protocol||"").toLowerCase(),host:d[0],port:d[1],path:d[2],query:c.search||"",url:a||""}};var Z={ga:function(){Z.f=[]}};Z.ga();Z.D=function(a){var b=Z.J.apply(Z,arguments),b=Z.f.concat(b);for(Z.f=[];0<b.length&&!Z.v(b[0])&&!(b.shift(),0<Z.f.length););Z.f=Z.f.concat(b)};Z.J=function(a){for(var b=[],c=0;c<arguments.length;c++)try{var d=new sc(arguments[c]);d.g?C(d.a[0],d.a[1]):(d.i&&(d.ha=y(d.c,d.a[0],d.X,d.W)),b.push(d))}catch(e){}return b};
    Z.v=function(a){try{if(a.u)a.u.call(O,N.j("t0"));else{var b=a.c==gb?N:N.j(a.c);if(a.A)"t0"!=a.c||N.create.apply(N,a.a);else if(a.ba)N.remove(a.c);else if(b)if(a.i){if(a.ha&&(a.ha=y(a.c,a.a[0],a.X,a.W)),!u(a.a[0],b,a.W))return!0}else if(a.K){var c=a.C,d=a.a,e=b.plugins_.get(a.K);e[c].apply(e,d)}else b[a.C].apply(b,a.a)}}catch(g){}};var N=function(a){J(1);Z.D.apply(Z,[arguments])};N.h={};N.P=[];N.L=0;N.answer=42;var uc=[Na,W,V];N.create=function(a){var b=za(uc,[].slice.call(arguments));b[V]||(b[V]="t0");var c=""+b[V];if(N.h[c])return N.h[c];b=new pc(b);N.h[c]=b;N.P.push(b);return b};N.remove=function(a){for(var b=0;b<N.P.length;b++)if(N.P[b].get(V)==a){N.P.splice(b,1);N.h[a]=null;break}};N.j=function(a){return N.h[a]};N.getAll=function(){return N.P.slice(0)};
    N.N=function(){"ga"!=gb&&J(49);var a=O[gb];if(!a||42!=a.answer){N.L=a&&a.l;N.loaded=!0;var b=O[gb]=N;X("create",b,b.create);X("remove",b,b.remove);X("getByName",b,b.j,5);X("getAll",b,b.getAll,6);b=pc.prototype;X("get",b,b.get,7);X("set",b,b.set,4);X("send",b,b.send);X("requireSync",b,b.ma);b=Ya.prototype;X("get",b,b.get);X("set",b,b.set);if(!Ud()&&!Ba){a:{for(var b=M.getElementsByTagName("script"),c=0;c<b.length&&100>c;c++){var d=b[c].src;if(d&&0==d.indexOf("https://www.google-analytics.com/analytics")){J(33);
        b=!0;break a}}b=!1}b&&(Ba=!0)}Ud()||Ba||!Ed(new Od(1E4))||(J(36),Ba=!0);(O.gaplugins=O.gaplugins||{}).Linker=Dc;b=Dc.prototype;C("linker",Dc);X("decorate",b,b.ca,20);X("autoLink",b,b.S,25);C("displayfeatures",fd);C("adfeatures",fd);a=a&&a.q;ka(a)?Z.D.apply(N,a):J(50)}};N.da=function(){for(var a=N.getAll(),b=0;b<a.length;b++)a[b].get(V)};var H=N.N,I=O[gb];I&&I.r?H():z(H);z(function(){Z.D(["provide","render",ua])});function La(a){var b=1,c,d;if(a)for(b=0,d=a.length-1;0<=d;d--)c=a.charCodeAt(d),b=(b<<6&268435455)+c+(c<<14),c=b&266338304,b=0!=c?b^c>>21:b;return b};})(window);

/*
    The MIT License (MIT)

    Copyright (c) <2013> <Ren Aysha>

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
*/

if ( typeof Object.create !== 'function' ) {
    Object.create = function( obj ) {
        function F() {}
        F.prototype = obj;
        return new F();
    };
}

(function( $, window, document, undefined ) {
    "use strict";

    var Anchorific = {

        init: function( options, elem ) {
            var self = this;

            self.elem = elem;
            self.$elem = $( elem );

            self.opt = $.extend( {},  this.opt, options );

            self.headers = self.$elem.find( 'h1, h2, h3, h4, h5, h6' );
            self.previous = 0;

            // Fix bug #1
            if ( self.headers.length !== 0 ) {
                self.first = parseInt( self.headers.prop( 'nodeName' ).substring( 1 ), null );
            }

            self.build();
        },

        opt: {
            navigation: '.anchorific', // position of navigation
            speed: 200, // speed of sliding back to top
            anchorClass: 'anchor', // class of anchor links
            anchorText: '#', // prepended or appended to anchor headings
            top: '.top', // back to top button or link class
            spy: true, // scroll spy
            position: 'append', // position of anchor text
            spyOffset: !0 // specify heading offset for spy scrolling
        },

        build: function() {
            var self = this, obj, navigations = function() {};
            // when navigation configuration is set
            if ( self.opt.navigation ) {
                $( self.opt.navigation ).append( '<ul />' );
                self.previous = $( self.opt.navigation ).find( 'ul' ).last();
                navigations = function( obj ) {
                    return self.navigations( obj );
                };
            }

            for( var i = 0; i < self.headers.length; i++ ) {
                obj = self.headers.eq( i );
                navigations( obj );
                self.anchor( obj );
            }

            if ( self.opt.spy )
                self.spy();

            if ( self.opt.top )
                self.back();
        },

        navigations: function( obj ) {
            var self = this, link, list, which, name = self.name( obj );

            if ( obj.attr( 'id' ) !== undefined )
                name = obj.attr( 'id' );

            link = $( '<a />' ).attr( 'href', '#' + name ).text( obj.text() );
            list = $( '<li />' ).append( link );

            which = parseInt( obj.prop( 'nodeName' ).substring( 1 ), null );
            list.attr( 'data-tag', which );

            self.subheadings( which, list );

            self.first = which;
        },

        subheadings: function( which, a ) {
            var self = this, ul = $( self.opt.navigation ).find( 'ul' ),
                li = $( self.opt.navigation ).find( 'li' );

            if ( which === self.first ) {
                self.previous.append( a );
            } else if ( which > self.first ) {
                li.last().append( '<ul />' );
                // can't use cache ul; need to find ul once more
                $( self.opt.navigation ).find( 'ul' ).last().append( a );
                self.previous = a.parent();
            } else {
                $( 'li[data-tag=' + which + ']' ).last().parent().append( a );
                self.previous = a.parent();
            }
        },

        name: function( obj ) {
            var name = obj.text().replace( /\s+/g, '-' );
            var pattern = new RegExp("[`~!@#$^&*()=|{}':;',\\[\\].<>/?~@#&*&;|{}']")
            var rs = "";
            for (var i = 0; i < name.length; i++) {
                rs = rs+name.substr(i, 1).replace(pattern, '');
            }
            return rs;
        },

        anchor: function( obj ) {
            var self = this, name = self.name( obj ), anchor, text = self.opt.anchorText,
                klass = self.opt.anchorClass, id;

            if ( obj.attr( 'id' ) === undefined )
                obj.attr( 'id', name );

            id = obj.attr( 'id' );

            anchor = $( '<a />' ).attr( 'href', '#' + id ).html( text ).addClass( klass );

            if ( self.opt.position === 'append' ) {
                obj.append( anchor );
            } else {
                obj.prepend( anchor );
            }
        },

        back: function() {
            var self = this, body = $( 'body, html' ), top = $( self.opt.top );

            top.on( 'click', function( e ) {
                e.preventDefault();

                body.animate({
                    'scrollTop': 0
                }, self.opt.speed );
            });
        },

        top: function( that ) {
            var self = this, top = self.opt.top, back;

            if ( top !== false ) {
                back = ( $( that ).scrollTop() > 200 ) ?
                    $( top ).fadeIn() :
                    $( top ).fadeOut();
            }
        },

        spy: function() {
            var self = this, previous, current, list, top, prev;

            $( window ).scroll( function( e ) {
                // show links back to top
                self.top( this );
                // get all the header on top of the viewport
                current = self.headers.map( function( e ) {
                    if ( ( $( this ).offset().top - $( window ).scrollTop() ) < self.opt.spyOffset ) {
                        return this;
                    }
                });
                // get only the latest header on the viewport
                current = $( current ).eq( current.length - 1 );

                if ( current && current.length ) {
                    // get all li tag that contains href of # ( all the parents )
                    list = $( 'li:has(a[href="#' + current.attr( 'id' ) + '"])' );

                    if ( prev !== undefined ) {
                        prev.removeClass( 'active' );
                    }

                    list.addClass( 'active' );
                    prev = list;
                }
            });
        }
    };

    $.fn.anchorific = function( options ) {
        return this.each(function() {
            if ( ! $.data( this, 'anchorific' ) ) {
                var anchor = Object.create( Anchorific );

                anchor.init( options, this );

                $.data( this, 'anchorific', anchor );
            }
        });
    };

})( jQuery, window, document );
/*
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function(b,c){var $=b.jQuery||b.Cowboy||(b.Cowboy={}),a;$.throttle=a=function(e,f,j,i){var h,d=0;if(typeof f!=="boolean"){i=j;j=f;f=c}function g(){var o=this,m=+new Date()-d,n=arguments;function l(){d=+new Date();j.apply(o,n)}function k(){h=c}if(i&&!h){l()}h&&clearTimeout(h);if(i===c&&m>e){l()}else{if(f!==true){h=setTimeout(i?k:l,i===c?e-m:e)}}}if($.guid){g.guid=j.guid=j.guid||$.guid++}return g};$.debounce=function(d,e,f){return f===c?a(d,e,false):a(d,f,e!==false)}})(this);

// the semi-colon before function invocation is a safety net against concatenated
// scripts and/or other plugins which may not be closed properly.
;(function ( $, window, document, undefined ) {

    "use strict";

    // undefined is used here as the undefined global variable in ECMAScript 3 is
    // mutable (ie. it can be changed by someone else). undefined isn't really being
    // passed in so we can ensure the value of it is truly undefined. In ES5, undefined
    // can no longer be modified.

    // window and document are passed through as local variable rather than global
    // as this (slightly) quickens the resolution process and can be more efficiently
    // minified (especially when both are regularly referenced in your plugin).

    // Create the defaults once
    var $w          = $(window),
        $d          = $(document),
        pluginName  = "fluidbox",
        defaults    = {
            immediateOpen: false,
            loader: false,
            maxWidth: 0,
            maxHeight: 0,
            resizeThrottle: 500,
            stackIndex: 1000,
            stackIndexDelta: 10,
            viewportFill: 0.95,
        },
        globalData = {},
        keyboardEvents = ['keyup', 'keydown', 'keypress'];

    // Global plugin instance tracker
    var fbInstance = 0;

    // Check the availability of the console object. This ensures compatibility with IE8.
    if(typeof console === "undefined" || console.warn === "undefined" ) {
        console = {};
        console.warn = function(){};
    }

    // Check if dependencies are loaded
    // 1. Ben Almen's debounce/throttle plugin
    if (!$.isFunction($.throttle)) {
        console.warn('Fluidbox: The jQuery debounce/throttle plugin is not found/loaded. Even though Fluidbox works without it, the window resize event will fire extremely rapidly in browsers, resulting in significant degradation in performance upon viewport resize.');
    }

    // ---------------------------------------------------------------------------------------------------------------------- //
    //  Dependency: David Walsh (http://davidwalsh.name/css-animation-callback)                                               //
    //              and                                                                                                       //
    //              Jonathan Suh (https://jonsuh.com/blog/detect-the-end-of-css-animations-and-transitions-with-javascript/)  //
    // ---------------------------------------------------------------------------------------------------------------------- //
    var whichTransitionEvent = function() {
        var t,
            el = document.createElement("fakeelement");

        var transitions = {
            "transition"      : "transitionend",
            "OTransition"     : "oTransitionEnd",
            "MozTransition"   : "transitionend",
            "WebkitTransition": "webkitTransitionEnd"
        };

        for (t in transitions){
            if (el.style[t] !== undefined){
                return transitions[t];
            }
        }
    };
    var customTransitionEnd = whichTransitionEvent();

    // The actual plugin constructor
    function Plugin (element, options) {
        // Assign element
        this.element = element;

        // Manipulate HTML5 dataset object
        // -  Format: data-fluidbox-(setting-name). When converted into camel case: fluidboxSettingName
        // - So, we will have to remove 'fluidbox' in the front, and change the first letter to lowercase
        var elementData = {};
        $.each($(this.element).data(), function(k,v) {
            var capitalize = function(s) {
                    return s && s[0].toLowerCase() + s.slice(1);
                },
                key = capitalize(k.replace('fluidbox',''));

            // Only push non-empty keys (that are part of the Fluidbox HTML5 data- attributes) into new object
            if(key !== '' || key !== null) {
                // Coerce boolean values
                if (v == 'false') {
                    v = false;
                } else if (v == 'true') {
                    v = true;
                }
                elementData[key] = v;
            }
        });

        // Merge defaults into options, into dataset
        this.settings = $.extend( {}, defaults, options, elementData);

        // Coerce settings
        this.settings.viewportFill = Math.max(Math.min(parseFloat(this.settings.viewportFill), 1), 0);
        if(this.settings.stackIndex < this.settings.stackIndexDelta) {
            settings.stackIndexDelta = settings.stackIndex;
        }

        // Store plugin name
        this._name = pluginName;

        // Initialize
        this.init();
    }

    // Private functions
    var _fun = {
        dom: function() {
            // Wrap and add ghost element
            var $fb_innerWrap = $('<div />', {
                'class': 'fluidbox__wrap',
                css: {
                    zIndex: this.settings.stackIndex - this.settings.stackIndexDelta
                }
            });
            $(this.element)
                .addClass('fluidbox--closed')
                .wrapInner($fb_innerWrap)
                .find('img')
                .first()
                .css({ opacity: 1})
                .addClass('fluidbox__thumb')
                .after('<div class="fluidbox__ghost" />');

            // Append loader
            if(this.settings.loader) {
                var $fbLoader = $('<div />', {
                    'class': 'fluidbox__loader',
                    css: {
                        zIndex: 2
                    }
                });
                $(this.element).find('.fluidbox__wrap').append($fbLoader);
            }
        },
        prepareFb: function() {
            var fb  = this,
                $fb = $(this.element);

            // Thumbnail is successfully loaded, fire event
            $fb.trigger('thumbloaddone.fluidbox');

            // Get basic measurements and to resize the ghost element
            _fun.measure.fbElements.call(this);

            // Bind events
            fb.bindEvents();

            // Status: Fluidbox is ready to use
            $fb.addClass('fluidbox--ready');

            // Bind listeners
            fb.bindListeners();

            // Emit custom event
            $fb.trigger('ready.fluidbox');
        },
        measure: {
            viewport: function() {
                globalData.viewport = {
                    w: $w.width(),
                    h: $w.height()
                };
            },
            fbElements: function() {
                var fb          = this,
                    $fb         = $(this.element),
                    $fbThumb    = $fb.find('img').first(),
                    $fbGhost    = $fb.find('.fluidbox__ghost'),
                    $fbWrap     = $fb.find('.fluidbox__wrap');

                // Store image dimensions in instance data
                fb.instanceData.thumb = {
                    natW:   $fbThumb[0].naturalWidth,
                    natH:   $fbThumb[0].naturalHeight,
                    w:      $fbThumb.width(),
                    h:      $fbThumb.height()
                };

                // Set ghost dimensions
                $fbGhost
                    .css({
                        width: $fbThumb.width(),
                        height: $fbThumb.height(),
                        top: $fbThumb.offset().top - $fbWrap.offset().top + parseInt($fbThumb.css('borderTopWidth')) + parseInt($fbThumb.css('paddingTop')),
                        left: $fbThumb.offset().left - $fbWrap.offset().left + parseInt($fbThumb.css('borderLeftWidth')) + parseInt($fbThumb.css('paddingLeft'))
                    });
            }
        },
        checkURL: function(url) {
            var exitCode = 0;

            if(/[\s+]/g.test(url)) {
                console.warn('Fluidbox: Fluidbox opening is halted because it has detected characters in your URL string that need to be properly encoded/escaped. Whitespace(s) have to be escaped manually. See RFC3986 documentation.');
                exitCode = 1;
            } else if(/[\"\'\(\)]/g.test(url)) {
                console.warn('Fluidbox: Fluidbox opening will proceed, but it has detected characters in your URL string that need to be properly encoded/escaped. These will be escaped for you. See RFC3986 documentation.');
                exitCode = 0;
            }
            return exitCode;
        },
        formatURL: function(url) {
            return url
                .replace(/"/g, '%22')
                .replace(/'/g, '%27')
                .replace(/\(/g, '%28')
                .replace(/\)/g, '%29');
        }
    };

    // Public functions
    $.extend(Plugin.prototype, {
        init: function () {

            // Define elements
            var fb              = this,
                $fb             = $(this.element),
                $fbThumb        = $fb.find('img').first();

            // Get basic measurements
            _fun.measure.viewport();

            // Only perform initialization when
            // - It is not yet initialized
            // + DOM checks are satisfied:
            // +-- An anchor element is selected
            // +-- Contains one and only one child
            // +-- The only child is an image element OR a picture element
            // +-- The element must not be hidden (itself or its parents)
            if(
                (!fb.instanceData || !fb.instanceData.initialized) &&
                (
                    $fb.is('a') &&
                    $fb.children().length === 1 &&
                    (
                        $fb.children().is('img') || (
                            $fb.children().is('picture') &&
                            $fb.find('img').length === 1
                        )
                    ) &&
                    $fb.css('display') !== 'none' &&
                    $fb.children().css('display') !== 'none' &&
                    $fb.parents().css('display') !== 'none'
                )
            ) {

                // Initialize and store original node
                $fb.removeClass('fluidbox--destroyed');
                fb.instanceData = {};
                fb.instanceData.initialized = true;
                fb.instanceData.originalNode = $fb.html();

                // Append instance ID
                fbInstance += 1;
                fb.instanceData.id = fbInstance;
                $fb.addClass('fluidbox__instance-'+fbInstance);

                // Status: Fluidbox has been initialized
                $fb.addClass('fluidbox--initialized');

                // DOM replacement
                _fun.dom.call(fb);

                // Emit custom event
                $fb.trigger('init.fluidbox');

                // Wait for image to load, but only if image is not found in cache
                var img = new Image();
                if($fbThumb.width() > 0 && $fbThumb.height() > 0) {
                    // Thumbnail loaded from cache, let's prepare fluidbox
                    _fun.prepareFb.call(fb);
                } else {
                    img.onload = function() {
                        // Thumbnail loaded, let's prepare fluidbox
                        _fun.prepareFb.call(fb);
                    };
                    img.onerror = function() {
                        // Trigger custom error event
                        $fb.trigger('thumbloadfail.fluidbox');
                    };
                    img.src = $fbThumb.attr('src');
                }
            }

        },
        open: function() {

            // Open Fluidbox
            var fb          = this,
                $fb         = $(this.element),
                $fbThumb    = $fb.find('img').first(),
                $fbGhost    = $fb.find('.fluidbox__ghost'),
                $fbWrap     = $fb.find('.fluidbox__wrap');

            // Update state
            fb.instanceData.state = 1;

            // Forcibly turn off transition end detection,
            // otherwise users will get choppy transition if toggling between states rapidly
            $fbGhost.off(customTransitionEnd);

            // Close all other Fluidbox instances
            $('.fluidbox--opened').fluidbox('close');

            // Append overlay
            var $fbOverlay = $('<div />', {
                'class': 'fluidbox__overlay',
                css: {
                    zIndex: -1
                }
            });
            $fbWrap.append($fbOverlay);

            // Add class to indicate larger image being loaded
            $fb
                .removeClass('fluidbox--closed')
                .addClass('fluidbox--loading');

            // Check of URL is properly formatted
            if(_fun.checkURL($fbThumb.attr('src'))) {
                fb.close();
                return false;
            }

            // Set thumbnail image source as background image first, worry later
            $fbGhost.css({
                'background-image': 'url(' + _fun.formatURL($fbThumb.attr('src')) + ')',
                opacity: 1
            });

            // Set dimensions for ghost
            _fun.measure.fbElements.call(fb);

            // Wait for ghost image to preload
            var img;
            if (fb.settings.immediateOpen) {
                // Update classes
                $fb
                    .addClass('fluidbox--opened fluidbox--loaded')
                    .find('.fluidbox__wrap')
                    .css({ zIndex: fb.settings.stackIndex + fb.settings.stackIndexDelta });

                // Emit custom event
                $fb.trigger('openstart.fluidbox');

                // Compute
                fb.compute();

                // Hide thumbnail
                $fbThumb.css({ opacity: 0 });

                // Show overlay
                $('.fluidbox__overlay').css({ opacity: 1 });

                // Emit custom event when ghost image finishes transition
                $fbGhost.one(customTransitionEnd, function() {
                    $fb.trigger('openend.fluidbox');
                });

                img = new Image();
                img.onload = function() {
                    // Emit custom event
                    $fb.trigger('imageloaddone.fluidbox');

                    // Perform only if the Fluidbox instance is still open
                    if (fb.instanceData.state === 1) {
                        // Set new natural dimensions
                        fb.instanceData.thumb.natW = img.naturalWidth;
                        fb.instanceData.thumb.natH = img.naturalHeight;

                        // Remove loading status
                        $fb.removeClass('fluidbox--loading');

                        // Check of URL is properly formatted
                        if(_fun.checkURL(img.src)) {
                            fb.close({ error: true });
                            return false;
                        }

                        // Set new image background
                        $fbGhost.css({ 'background-image': 'url(' + _fun.formatURL(img.src) + ')' });

                        // Compute
                        fb.compute();
                    }
                };
                img.onerror = function() {
                    // Trigger closing
                    fb.close({ error: true });

                    // Emit custom event
                    $fb.trigger('imageloadfail.fluidbox');
                    $fb.trigger('delayedloadfail.fluidbox');
                };
                img.src = $fb.attr('href');

            } else {
                img = new Image();
                img.onload = function() {

                    // Emit custom event
                    $fb.trigger('imageloaddone.fluidbox');

                    // Update classes
                    $fb
                        .removeClass('fluidbox--loading')
                        .addClass('fluidbox--opened fluidbox--loaded')
                        .find('.fluidbox__wrap')
                        .css({ zIndex: fb.settings.stackIndex + fb.settings.stackIndexDelta });

                    // Emit custom event
                    $fb.trigger('openstart.fluidbox');

                    // Check of URL is properly formatted
                    if(_fun.checkURL(img.src)) {
                        fb.close({ error: true });
                        return false;
                    }

                    // Set new image background
                    $fbGhost.css({ 'background-image': 'url(' + _fun.formatURL(img.src) + ')' });

                    // Set new natural dimensions
                    fb.instanceData.thumb.natW = img.naturalWidth;
                    fb.instanceData.thumb.natH = img.naturalHeight;

                    // Compute
                    fb.compute();

                    // Hide thumbnail
                    $fbThumb.css({ opacity: 0 });

                    // Show overlay
                    $('.fluidbox__overlay').css({ opacity: 1 });

                    // Emit custom event when ghost image finishes transition
                    $fbGhost.one(customTransitionEnd, function() {
                        $fb.trigger('openend.fluidbox');
                    });
                };
                img.onerror = function() {
                    // Trigger closing
                    fb.close({ error: true });

                    // Emit custom event
                    $fb.trigger('imageloadfail.fluidbox');
                };
                img.src = $fb.attr('href');
            }

        },
        compute: function() {
            var fb          = this,
                $fb         = $(this.element),
                $fbThumb    = $fb.find('img').first(),
                $fbGhost    = $fb.find('.fluidbox__ghost'),
                $fbWrap     = $fb.find('.fluidbox__wrap');

            // Shorthand for dimensions
            var imgNatW = fb.instanceData.thumb.natW,
                imgNatH = fb.instanceData.thumb.natH,
                imgW    = fb.instanceData.thumb.w,
                imgH    = fb.instanceData.thumb.h;

            // Calculate aspect ratios
            var thumbRatio = imgNatW / imgNatH,
                viewportRatio = globalData.viewport.w / globalData.viewport.h;

            // Replace dimensions if maxWidth or maxHeight is declared
            if (fb.settings.maxWidth > 0) {
                imgNatW = fb.settings.maxWidth;
                imgNatH = imgNatW / thumbRatio;
            } else if (fb.settings.maxHeight > 0) {
                imgNatH = fb.settings.maxHeight;
                imgNatW = imgNatH * thumbRatio;
            }

            // Compare image ratio with viewport ratio
            var computedHeight, computedWidth, imgScaleY, imgScaleX, imgMinScale;
            if (viewportRatio > thumbRatio) {
                computedHeight  = (imgNatH < globalData.viewport.h) ? imgNatH : globalData.viewport.h*fb.settings.viewportFill;
                imgScaleY       = computedHeight / imgH;
                imgScaleX       = imgNatW * (imgH * imgScaleY / imgNatH) / imgW;
                imgMinScale     = imgScaleY;
            } else {
                computedWidth   = (imgNatW < globalData.viewport.w) ? imgNatW : globalData.viewport.w*fb.settings.viewportFill;
                imgScaleX       = computedWidth / imgW;
                imgScaleY       = imgNatH * (imgW * imgScaleX / imgNatW) / imgH;
                imgMinScale     = imgScaleX;
            }

            // Display console error if both maxHeight and maxWidth are specific
            if (fb.settings.maxWidth && fb.settings.maxHeight)
                console.warn('Fluidbox: Both maxHeight and maxWidth are specified. You can only specify one. If both are specified, only the maxWidth property will be respected. This will not generate any error, but may cause unexpected sizing behavior.');

            // Scale
            var offsetY = $w.scrollTop() - $fbThumb.offset().top + 0.5*(imgH*(imgMinScale-1)) + 0.5*($w.height() - imgH*imgMinScale),
                offsetX = 0.5*(imgW*(imgMinScale-1)) + 0.5*($w.width() - imgW*imgMinScale) - $fbThumb.offset().left,
                scale = parseInt(imgScaleX*100)/100 + ',' + parseInt(imgScaleY*100)/100;

            // Apply styles to ghost and loader (if present)
            $fbGhost
                .css({
                    'transform': 'translate(' + parseInt(offsetX*100)/100 + 'px,' + parseInt(offsetY*100)/100 + 'px) scale(' + scale + ')',
                    top: $fbThumb.offset().top - $fbWrap.offset().top,
                    left: $fbThumb.offset().left - $fbWrap.offset().left
                });
            $fb.find('.fluidbox__loader').css({
                'transform': 'translate(' + parseInt(offsetX*100)/100 + 'px,' + parseInt(offsetY*100)/100 + 'px) scale(' + scale + ')'
            });

            // Emit custom event
            $fb.trigger('computeend.fluidbox');
        },
        recompute: function() {
            // Recompute is simply an alias for the compute method
            this.compute();
        },
        close: function(d) {

            // Close Fluidbox
            var fb          = this,
                $fb         = $(this.element),
                $fbThumb    = $fb.find('img').first(),
                $fbGhost    = $fb.find('.fluidbox__ghost'),
                $fbWrap     = $fb.find('.fluidbox__wrap'),
                $fbOverlay  = $fb.find('.fluidbox__overlay'),
                closeData   = $.extend(null, {
                    error: false
                }, d);

            // Do not do anything if Fluidbox is not opened/closed, for performance reasons
            if (fb.instanceData.state === null || typeof fb.instanceData.state === typeof undefined || fb.instanceData.state === 0) return false;

            // Update state
            fb.instanceData.state = 0;

            // Emit custom event
            $fb.trigger('closestart.fluidbox');

            // Change classes
            $fb
                .removeClass(function(i,c) {
                    return (c.match (/(^|\s)fluidbox--(opened|loaded|loading)+/g) || []).join(' ');
                })
                .addClass('fluidbox--closed');

            $fbGhost
                .css({
                    'transform': 'translate(0,0) scale(1,1)',
                    top: $fbThumb.offset().top - $fbWrap.offset().top + parseInt($fbThumb.css('borderTopWidth')) + parseInt($fbThumb.css('paddingTop')),
                    left: $fbThumb.offset().left - $fbWrap.offset().left + parseInt($fbThumb.css('borderLeftWidth')) + parseInt($fbThumb.css('paddingLeft'))
                });

            $fb.find('.fluidbox__loader')
                .css({
                    'transform': 'none'
                });

            $fbGhost.one(customTransitionEnd, function() {
                $fbGhost.css({ opacity: 0 });
                $fbThumb.css({ opacity: 1 });
                $fbOverlay.remove();
                $fbWrap.css({ zIndex: fb.settings.stackIndex - fb.settings.stackIndexDelta });
                $fb.trigger('closeend.fluidbox');
            });

            // Manually trigger transitionend if an error is detected
            // Errors will not trigger any transition changes to the ghost element
            if(closeData.error) $fbGhost.trigger('transitionend');

            // Fadeout overlay
            $fbOverlay.css({ opacity: 0 });
        },
        bindEvents: function() {
            var fb = this,
                $fb = $(this.element);

            // Click handler
            $fb.on('click.fluidbox', function(e) {
                e.preventDefault();

                // Check state
                // If state does not exist, or if Fluidbox is closed, we open it
                if(!fb.instanceData.state || fb.instanceData.state === 0) {

                    // Open Fluidbox
                    fb.open();

                    // If state exists, we close it
                } else {

                    // Close Fluidbox
                    fb.close();
                }
            });
        },
        bindListeners: function() {
            var fb  = this,
                $fb = $(this.element);

            // Window resize
            // Namespaced using unique instance IDs so that we can unbind resize event specific to a Fluidbox instance
            var resizeFunction = function() {
                // Re-measure viewport dimensions
                _fun.measure.viewport();
                _fun.measure.fbElements.call(fb);

                // Re-compute, but only for the active element
                if($fb.hasClass('fluidbox--opened')) fb.compute();
            };
            if ($.isFunction($.throttle)) {
                $w.on('resize.fluidbox'+fb.instanceData.id, $.throttle(fb.settings.resizeThrottle, resizeFunction));
            } else {
                $w.on('resize.fluidbox'+fb.instanceData.id, resizeFunction);
            }

            // Reposition
            $fb.on('reposition.fluidbox', function() {
                fb.reposition();
            });

            // Recompute
            $fb.on('recompute.fluidbox, compute.fluidbox', function() {
                fb.compute();
            });

            // Destroy
            $fb.on('destroy.fluidbox', function() {
                fb.destroy();
            });

            // Close
            $fb.on('close.fluidbox', function() {
                fb.close();
            });
        },
        unbind: function() {
            $(this.element).off('click.fluidbox reposition.fluidbox recompute.fluidbox compute.fluidbox destroy.fluidbox close.fluidbox');
            $w.off('resize.fluidbox'+this.instanceData.id);
        },
        reposition: function() {
            _fun.measure.fbElements.call(this);
        },
        destroy: function() {
            // Cache original node
            var originalNode = this.instanceData.originalNode;

            // Unbind event hanlders
            this.unbind();

            // Destroy plugin data entirely
            $.data(this.element, 'plugin_' + pluginName, null);

            // DOM reversal
            $(this.element)
                .removeClass(function(i,c) {
                    return (c.match (/(^|\s)fluidbox[--|__]\S+/g) || []).join(' ');
                })
                .empty()
                .html(originalNode)
                .addClass('fluidbox--destroyed')
                .trigger('destroyed.fluidbox');
        },
        getMetadata: function() {
            // Return instance data
            return this.instanceData;
        }
    });

    // A really lightweight plugin wrapper around the constructor,
    // preventing against multiple instantiations
    $.fn[pluginName] = function (options) {

        var args = arguments;

        // Check the options parameter
        // If it is undefined or is an object (plugin configuration),
        // we create a new instance (conditionally, see inside) of the plugin
        if (options === undefined || typeof options === 'object') {

            return this.each(function() {
                // Only if the plugin_fluidbox data is not present,
                // to prevent multiple instances being created
                if (!$.data(this, "plugin_" + pluginName)) {

                    $.data(this, "plugin_" + pluginName, new Plugin(this, options));
                }
            });

            // If it is defined, but it is a string, does not start with an underscore and does not call init(),
            // we allow users to make calls to public methods
        } else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {
            var returnVal;

            this.each(function() {
                var instance = $.data(this, 'plugin_' + pluginName);
                if (instance instanceof Plugin && typeof instance[options] === 'function') {
                    returnVal = instance[options].apply(instance, Array.prototype.slice.call(args, 1));
                } else {
                    console.warn('Fluidbox: The method "' + options + '" used is not defined in Fluidbox. Please make sure you are calling the correct public method.');
                }
            });
            return returnVal !== undefined ? returnVal : this;
        }

        // Return to allow chaining
        return this;
    };



})(jQuery, window, document);

var emojies = [
    '+1', '-1', '100', '1234', '8ball', 'a', 'ab', 'abc', 'abcd', 'accept',
    'aerial_tramway', 'airplane', 'alarm_clock', 'alien', 'ambulance', 'anchor',
    'angel', 'anger', 'angry', 'anguished', 'ant', 'apple', 'aquarius', 'aries',
    'arrow_backward', 'arrow_double_down', 'arrow_double_up', 'arrow_down',
    'arrow_down_small', 'arrow_forward', 'arrow_heading_down',
    'arrow_heading_up', 'arrow_left', 'arrow_lower_left', 'arrow_lower_right',
    'arrow_right', 'arrow_right_hook', 'arrow_up', 'arrow_up_down',
    'arrow_up_small', 'arrow_upper_left', 'arrow_upper_right',
    'arrows_clockwise', 'arrows_counterclockwise', 'art', 'articulated_lorry',
    'astonished', 'athletic_shoe', 'atm', 'b', 'baby', 'baby_bottle',
    'baby_chick', 'baby_symbol', 'back', 'baggage_claim', 'balloon',
    'ballot_box_with_check', 'bamboo', 'banana', 'bangbang', 'bank', 'bar_chart',
    'barber', 'baseball', 'basketball', 'bath', 'bathtub', 'battery', 'bear',
    'bee', 'beer', 'beers', 'beetle', 'beginner', 'bell', 'bento', 'bicyclist',
    'bike', 'bikini', 'bird', 'birthday', 'black_circle', 'black_joker',
    'black_large_square', 'black_medium_small_square', 'black_medium_square',
    'black_nib', 'black_small_square', 'black_square_button', 'blossom',
    'blowfish', 'blue_book', 'blue_car', 'blue_heart', 'blush', 'boar', 'boat',
    'bomb', 'book', 'bookmark', 'bookmark_tabs', 'books', 'boom', 'boot',
    'bouquet', 'bow', 'bowling', 'bowtie', 'boy', 'bread', 'bride_with_veil',
    'bridge_at_night', 'briefcase', 'broken_heart', 'bug', 'bulb',
    'bullettrain_front', 'bullettrain_side', 'bus', 'busstop',
    'bust_in_silhouette', 'busts_in_silhouette', 'cactus', 'cake', 'calendar',
    'calling', 'camel', 'camera', 'cancer', 'candy', 'capital_abcd', 'capricorn',
    'car', 'card_index', 'carousel_horse', 'cat', 'cat2', 'cd', 'chart',
    'chart_with_downwards_trend', 'chart_with_upwards_trend', 'checkered_flag',
    'cherries', 'cherry_blossom', 'chestnut', 'chicken', 'children_crossing',
    'chocolate_bar', 'christmas_tree', 'church', 'cinema', 'circus_tent',
    'city_sunrise', 'city_sunset', 'cl', 'clap', 'clapper', 'clipboard',
    'clock1', 'clock10', 'clock1030', 'clock11', 'clock1130', 'clock12',
    'clock1230', 'clock130', 'clock2', 'clock230', 'clock3', 'clock330',
    'clock4', 'clock430', 'clock5', 'clock530', 'clock6', 'clock630', 'clock7',
    'clock730', 'clock8', 'clock830', 'clock9', 'clock930', 'closed_book',
    'closed_lock_with_key', 'closed_umbrella', 'cloud', 'clubs', 'cn',
    'cocktail', 'coffee', 'cold_sweat', 'collision', 'computer', 'confetti_ball',
    'confounded', 'confused', 'congratulations', 'construction',
    'construction_worker', 'convenience_store', 'cookie', 'cool', 'cop',
    'copyright', 'corn', 'couple', 'couple_with_heart', 'couplekiss', 'cow',
    'cow2', 'credit_card', 'crescent_moon', 'crocodile', 'crossed_flags',
    'crown', 'cry', 'crying_cat_face', 'crystal_ball', 'cupid', 'curly_loop',
    'currency_exchange', 'curry', 'custard', 'customs', 'cyclone', 'dancer',
    'dancers', 'dango', 'dart', 'dash', 'date', 'de', 'deciduous_tree',
    'department_store', 'diamond_shape_with_a_dot_inside', 'diamonds',
    'disappointed', 'disappointed_relieved', 'dizzy', 'dizzy_face',
    'do_not_litter', 'dog', 'dog2', 'dollar', 'dolls', 'dolphin', 'door',
    'doughnut', 'dragon', 'dragon_face', 'dress', 'dromedary_camel', 'droplet',
    'dvd', 'e-mail', 'ear', 'ear_of_rice', 'earth_africa', 'earth_americas',
    'earth_asia', 'egg', 'eggplant', 'eight', 'eight_pointed_black_star',
    'eight_spoked_asterisk', 'electric_plug', 'elephant', 'email', 'end',
    'envelope', 'envelope_with_arrow', 'es', 'euro', 'european_castle',
    'european_post_office', 'evergreen_tree', 'exclamation', 'expressionless',
    'eyeglasses', 'eyes', 'facepunch', 'factory', 'fallen_leaf', 'family',
    'fast_forward', 'fax', 'fearful', 'feelsgood', 'feet', 'ferris_wheel',
    'file_folder', 'finnadie', 'fire', 'fire_engine', 'fireworks',
    'first_quarter_moon', 'first_quarter_moon_with_face', 'fish', 'fish_cake',
    'fishing_pole_and_fish', 'fist', 'five', 'flags', 'flashlight',
    'floppy_disk', 'flower_playing_cards', 'flushed', 'foggy', 'football',
    'footprints', 'fork_and_knife', 'fountain', 'four', 'four_leaf_clover', 'fr',
    'free', 'fried_shrimp', 'fries', 'frog', 'frowning', 'fu', 'fuelpump',
    'full_moon', 'full_moon_with_face', 'game_die', 'gb', 'gem', 'gemini',
    'ghost', 'gift', 'gift_heart', 'girl', 'globe_with_meridians', 'goat',
    'goberserk', 'godmode', 'golf', 'grapes', 'green_apple', 'green_book',
    'green_heart', 'grey_exclamation', 'grey_question', 'grimacing', 'grin',
    'grinning', 'guardsman', 'guitar', 'gun', 'haircut', 'hamburger', 'hammer',
    'hamster', 'hand', 'handbag', 'hankey', 'hash', 'hatched_chick',
    'hatching_chick', 'headphones', 'hear_no_evil', 'heart', 'heart_decoration',
    'heart_eyes', 'heart_eyes_cat', 'heartbeat', 'heartpulse', 'hearts',
    'heavy_check_mark', 'heavy_division_sign', 'heavy_dollar_sign',
    'heavy_exclamation_mark', 'heavy_minus_sign', 'heavy_multiplication_x',
    'heavy_plus_sign', 'helicopter', 'herb', 'hibiscus', 'high_brightness',
    'high_heel', 'hocho', 'honey_pot', 'honeybee', 'horse', 'horse_racing',
    'hospital', 'hotel', 'hotsprings', 'hourglass', 'hourglass_flowing_sand',
    'house', 'house_with_garden', 'hurtrealbad', 'hushed', 'ice_cream',
    'icecream', 'id', 'ideograph_advantage', 'imp', 'inbox_tray',
    'incoming_envelope', 'information_desk_person', 'information_source',
    'innocent', 'interrobang', 'iphone', 'it', 'izakaya_lantern',
    'jack_o_lantern', 'japan', 'japanese_castle', 'japanese_goblin',
    'japanese_ogre', 'jeans', 'joy', 'joy_cat', 'jp', 'key', 'keycap_ten',
    'kimono', 'kiss', 'kissing', 'kissing_cat', 'kissing_closed_eyes',
    'kissing_heart', 'kissing_smiling_eyes', 'koala', 'koko', 'kr', 'lantern',
    'large_blue_circle', 'large_blue_diamond', 'large_orange_diamond',
    'last_quarter_moon', 'last_quarter_moon_with_face', 'laughing', 'leaves',
    'ledger', 'left_luggage', 'left_right_arrow', 'leftwards_arrow_with_hook',
    'lemon', 'leo', 'leopard', 'libra', 'light_rail', 'link', 'lips', 'lipstick',
    'lock', 'lock_with_ink_pen', 'lollipop', 'loop', 'loudspeaker', 'love_hotel',
    'love_letter', 'low_brightness', 'm', 'mag', 'mag_right', 'mahjong',
    'mailbox', 'mailbox_closed', 'mailbox_with_mail', 'mailbox_with_no_mail',
    'man', 'man_with_gua_pi_mao', 'man_with_turban', 'mans_shoe', 'maple_leaf',
    'mask', 'massage', 'meat_on_bone', 'mega', 'melon', 'memo', 'mens', 'metal',
    'metro', 'microphone', 'microscope', 'milky_way', 'minibus', 'minidisc',
    'mobile_phone_off', 'money_with_wings', 'moneybag', 'monkey', 'monkey_face',
    'monorail', 'moon', 'mortar_board', 'mount_fuji', 'mountain_bicyclist',
    'mountain_cableway', 'mountain_railway', 'mouse', 'mouse2', 'movie_camera',
    'moyai', 'muscle', 'mushroom', 'musical_keyboard', 'musical_note',
    'musical_score', 'mute', 'nail_care', 'name_badge', 'neckbeard', 'necktie',
    'negative_squared_cross_mark', 'neutral_face', 'new', 'new_moon',
    'new_moon_with_face', 'newspaper', 'ng', 'nine', 'no_bell', 'no_bicycles',
    'no_entry', 'no_entry_sign', 'no_good', 'no_mobile_phones', 'no_mouth',
    'no_pedestrians', 'no_smoking', 'non-potable_water', 'nose', 'notebook',
    'notebook_with_decorative_cover', 'notes', 'nut_and_bolt', 'o', 'o2',
    'ocean', 'octocat', 'octopus', 'oden', 'office', 'ok', 'ok_hand', 'ok_woman',
    'older_man', 'older_woman', 'on', 'oncoming_automobile', 'oncoming_bus',
    'oncoming_police_car', 'oncoming_taxi', 'one', 'open_book',
    'open_file_folder', 'open_hands', 'open_mouth', 'ophiuchus', 'orange_book',
    'outbox_tray', 'ox', 'package', 'page_facing_up', 'page_with_curl', 'pager',
    'palm_tree', 'panda_face', 'paperclip', 'parking', 'part_alternation_mark',
    'partly_sunny', 'passport_control', 'paw_prints', 'peach', 'pear', 'pencil',
    'pencil2', 'penguin', 'pensive', 'performing_arts', 'persevere',
    'person_frowning', 'person_with_blond_hair', 'person_with_pouting_face',
    'phone', 'pig', 'pig2', 'pig_nose', 'pill', 'pineapple', 'pisces', 'pizza',
    'point_down', 'point_left', 'point_right', 'point_up', 'point_up_2',
    'police_car', 'poodle', 'poop', 'post_office', 'postal_horn', 'postbox',
    'potable_water', 'pouch', 'poultry_leg', 'pound', 'pouting_cat', 'pray',
    'princess', 'punch', 'purple_heart', 'purse', 'pushpin',
    'put_litter_in_its_place', 'question', 'rabbit', 'rabbit2', 'racehorse',
    'radio', 'radio_button', 'rage', 'rage1', 'rage2', 'rage3', 'rage4',
    'railway_car', 'rainbow', 'raised_hand', 'raised_hands', 'raising_hand',
    'ram', 'ramen', 'rat', 'recycle', 'red_car', 'red_circle', 'registered',
    'relaxed', 'relieved', 'repeat', 'repeat_one', 'restroom',
    'revolving_hearts', 'rewind', 'ribbon', 'rice', 'rice_ball', 'rice_cracker',
    'rice_scene', 'ring', 'rocket', 'roller_coaster', 'rooster', 'rose',
    'rotating_light', 'round_pushpin', 'rowboat', 'ru', 'rugby_football',
    'runner', 'running', 'running_shirt_with_sash', 'sa', 'sagittarius',
    'sailboat', 'sake', 'sandal', 'santa', 'satellite', 'satisfied', 'saxophone',
    'school', 'school_satchel', 'scissors', 'scorpius', 'scream', 'scream_cat',
    'scroll', 'seat', 'secret', 'see_no_evil', 'seedling', 'seven', 'shaved_ice',
    'sheep', 'shell', 'ship', 'shipit', 'shirt', 'shit', 'shoe', 'shower',
    'signal_strength', 'six', 'six_pointed_star', 'ski', 'skull', 'sleeping',
    'sleepy', 'slot_machine', 'small_blue_diamond', 'small_orange_diamond',
    'small_red_triangle', 'small_red_triangle_down', 'smile', 'smile_cat',
    'smiley', 'smiley_cat', 'smiling_imp', 'smirk', 'smirk_cat', 'smoking',
    'snail', 'snake', 'snowboarder', 'snowflake', 'snowman', 'sob', 'soccer',
    'soon', 'sos', 'sound', 'space_invader', 'spades', 'spaghetti', 'sparkle',
    'sparkler', 'sparkles', 'sparkling_heart', 'speak_no_evil', 'speaker',
    'speech_balloon', 'speedboat', 'squirrel', 'star', 'star2', 'stars',
    'station', 'statue_of_liberty', 'steam_locomotive', 'stew', 'straight_ruler',
    'strawberry', 'stuck_out_tongue', 'stuck_out_tongue_closed_eyes',
    'stuck_out_tongue_winking_eye', 'sun_with_face', 'sunflower', 'sunglasses',
    'sunny', 'sunrise', 'sunrise_over_mountains', 'surfer', 'sushi', 'suspect',
    'suspension_railway', 'sweat', 'sweat_drops', 'sweat_smile', 'sweet_potato',
    'swimmer', 'symbols', 'syringe', 'tada', 'tanabata_tree', 'tangerine',
    'taurus', 'taxi', 'tea', 'telephone', 'telephone_receiver', 'telescope',
    'tennis', 'tent', 'thought_balloon', 'three', 'thumbsdown', 'thumbsup',
    'ticket', 'tiger', 'tiger2', 'tired_face', 'tm', 'toilet', 'tokyo_tower',
    'tomato', 'tongue', 'top', 'tophat', 'tractor', 'traffic_light', 'train',
    'train2', 'tram', 'triangular_flag_on_post', 'triangular_ruler', 'trident',
    'triumph', 'trolleybus', 'trollface', 'trophy', 'tropical_drink',
    'tropical_fish', 'truck', 'trumpet', 'tshirt', 'tulip', 'turtle', 'tv',
    'twisted_rightwards_arrows', 'two', 'two_hearts', 'two_men_holding_hands',
    'two_women_holding_hands', 'u5272', 'u5408', 'u55b6', 'u6307', 'u6708',
    'u6709', 'u6e80', 'u7121', 'u7533', 'u7981', 'u7a7a', 'uk', 'umbrella',
    'unamused', 'underage', 'unlock', 'up', 'us', 'v', 'vertical_traffic_light',
    'vhs', 'vibration_mode', 'video_camera', 'video_game', 'violin', 'virgo',
    'volcano', 'vs', 'walking', 'waning_crescent_moon', 'waning_gibbous_moon',
    'warning', 'watch', 'water_buffalo', 'watermelon', 'wave', 'wavy_dash',
    'waxing_crescent_moon', 'waxing_gibbous_moon', 'wc', 'weary', 'wedding',
    'whale', 'whale2', 'wheelchair', 'white_check_mark', 'white_circle',
    'white_flower', 'white_large_square', 'white_medium_small_square',
    'white_medium_square', 'white_small_square', 'white_square_button',
    'wind_chime', 'wine_glass', 'wink', 'wolf', 'woman', 'womans_clothes',
    'womans_hat', 'womens', 'worried', 'wrench', 'x', 'yellow_heart', 'yen',
    'yum', 'zap', 'zero', 'zzz'
];

/*! emojify.js - v0.9.2 -
 * Copyright (c) Hassan Khan 2014
 */!function(a){"use strict";var b=function(){function b(a){return" "===a||"	"===a||"\r"===a||"\n"===a||""===a}function c(a,b,c){var d=i.createElement("img");d.setAttribute("title",":"+c+":"),d.setAttribute("alt",":"+c+":"),d.setAttribute("class","emoji"),d.setAttribute("src",q.img_dir+"/"+c+".png"),d.setAttribute("align","absmiddle"),a.splitText(b.index),a.nextSibling.nodeValue=a.nextSibling.nodeValue.substr(b[0].length,a.nextSibling.nodeValue.length),d.appendChild(a.splitText(b.index)),a.parentNode.insertBefore(d,a.nextSibling)}function d(a){if(a[1]&&a[2]){var b=a[2];if(l[b])return b}else for(var c=3;c<a.length-1;c++)if(a[c])return n[c-2][1]}function e(a,b){return"<img title=':"+b+":' alt=':"+b+":' class='emoji' src='"+q.img_dir+"/"+b+".png' align='absmiddle' />"}function f(){this.lastEmojiTerminatedAt=-1}function g(a,b){if(!a)return a;b||(b=e);var c=new f;return a.replace(p,function(){var a=Array.prototype.slice.call(arguments,0,-2),d=arguments[arguments.length-2],e=arguments[arguments.length-1],f=c.validate(a,d,e);return f?b(arguments[0],f):arguments[0]})}function h(a){"undefined"==typeof a&&(a=q.only_crawl_id?i.getElementById(q.only_crawl_id):i.body);for(var b,e=q.ignored_tags,g=i.createTreeWalker(a,NodeFilter.SHOW_TEXT|NodeFilter.SHOW_ELEMENT,function(a){return 1!==a.nodeType?NodeFilter.FILTER_ACCEPT:e[a.tagName]||a.classList.contains("no-emojify")?NodeFilter.FILTER_REJECT:NodeFilter.FILTER_SKIP},!1),h=[];null!==(b=g.nextNode());)h.push(b);h.forEach(function(a){for(var b,e=[],g=new f;null!==(b=p.exec(a.data));)g.validate(b,b.index,b.input)&&e.push(b);for(var h=e.length;h-->0;){var i=d(e[h]);c(a,e[h],i)}})}var i=a.window.document,j="+1,-1,100,109,1234,8ball,a,ab,abc,abcd,accept,aerial_tramway,airplane,alarm_clock,alien,ambulance,anchor,angel,anger,angry,anguished,ant,apple,aquarius,aries,arrow_backward,arrow_double_down,arrow_double_up,arrow_down,arrow_down_small,arrow_forward,arrow_heading_down,arrow_heading_up,arrow_left,arrow_lower_left,arrow_lower_right,arrow_right,arrow_right_hook,arrow_up,arrow_up_down,arrow_up_small,arrow_upper_left,arrow_upper_right,arrows_clockwise,arrows_counterclockwise,art,articulated_lorry,astonished,atm,b,baby,baby_bottle,baby_chick,baby_symbol,baggage_claim,balloon,ballot_box_with_check,bamboo,banana,bangbang,bank,bar_chart,barber,baseball,basketball,bath,bathtub,battery,bear,bee,beer,beers,beetle,beginner,bell,bento,bicyclist,bike,bikini,bird,birthday,black_circle,black_joker,black_nib,black_square,black_square_button,blossom,blowfish,blue_book,blue_car,blue_heart,blush,boar,boat,bomb,book,bookmark,bookmark_tabs,books,boom,boot,bouquet,bow,bowling,bowtie,boy,bread,bride_with_veil,bridge_at_night,briefcase,broken_heart,bug,bulb,bullettrain_front,bullettrain_side,bus,busstop,bust_in_silhouette,busts_in_silhouette,cactus,cake,calendar,calling,camel,camera,cancer,candy,capital_abcd,capricorn,car,card_index,carousel_horse,cat,cat2,cd,chart,chart_with_downwards_trend,chart_with_upwards_trend,checkered_flag,cherries,cherry_blossom,chestnut,chicken,children_crossing,chocolate_bar,christmas_tree,church,cinema,circus_tent,city_sunrise,city_sunset,cl,clap,clapper,clipboard,clock1,clock10,clock1030,clock11,clock1130,clock12,clock1230,clock130,clock2,clock230,clock3,clock330,clock4,clock430,clock5,clock530,clock6,clock630,clock7,clock730,clock8,clock830,clock9,clock930,closed_book,closed_lock_with_key,closed_umbrella,cloud,clubs,cn,cocktail,coffee,cold_sweat,collision,computer,confetti_ball,confounded,confused,congratulations,construction,construction_worker,convenience_store,cookie,cool,cop,copyright,corn,couple,couple_with_heart,couplekiss,cow,cow2,credit_card,crocodile,crossed_flags,crown,cry,crying_cat_face,crystal_ball,cupid,curly_loop,currency_exchange,curry,custard,customs,cyclone,dancer,dancers,dango,dart,dash,date,de,deciduous_tree,department_store,diamond_shape_with_a_dot_inside,diamonds,disappointed,disappointed_relieved,dizzy,dizzy_face,do_not_litter,dog,dog2,dollar,dolls,dolphin,donut,door,doughnut,dragon,dragon_face,dress,dromedary_camel,droplet,dvd,e-mail,ear,ear_of_rice,earth_africa,earth_americas,earth_asia,egg,eggplant,eight,eight_pointed_black_star,eight_spoked_asterisk,electric_plug,elephant,email,end,envelope,es,euro,european_castle,european_post_office,evergreen_tree,exclamation,expressionless,eyeglasses,eyes,facepunch,factory,fallen_leaf,family,fast_forward,fax,fearful,feelsgood,feet,ferris_wheel,file_folder,finnadie,fire,fire_engine,fireworks,first_quarter_moon,first_quarter_moon_with_face,fish,fish_cake,fishing_pole_and_fish,fist,five,flags,flashlight,floppy_disk,flower_playing_cards,flushed,foggy,football,fork_and_knife,fountain,four,four_leaf_clover,fr,free,fried_shrimp,fries,frog,frowning,fu,fuelpump,full_moon,full_moon_with_face,game_die,gb,gem,gemini,ghost,gift,gift_heart,girl,globe_with_meridians,goat,goberserk,godmode,golf,grapes,green_apple,green_book,green_heart,grey_exclamation,grey_question,grimacing,grin,grinning,guardsman,guitar,gun,haircut,hamburger,hammer,hamster,hand,handbag,hankey,hash,hatched_chick,hatching_chick,headphones,hear_no_evil,heart,heart_decoration,heart_eyes,heart_eyes_cat,heartbeat,heartpulse,hearts,heavy_check_mark,heavy_division_sign,heavy_dollar_sign,heavy_exclamation_mark,heavy_minus_sign,heavy_multiplication_x,heavy_plus_sign,helicopter,herb,hibiscus,high_brightness,high_heel,hocho,honey_pot,honeybee,horse,horse_racing,hospital,hotel,hotsprings,hourglass,hourglass_flowing_sand,house,house_with_garden,hurtrealbad,hushed,ice_cream,icecream,id,ideograph_advantage,imp,inbox_tray,incoming_envelope,information_desk_person,information_source,innocent,interrobang,iphone,it,izakaya_lantern,jack_o_lantern,japan,japanese_castle,japanese_goblin,japanese_ogre,jeans,joy,joy_cat,jp,key,keycap_ten,kimono,kiss,kissing,kissing_cat,kissing_closed_eyes,kissing_face,kissing_heart,kissing_smiling_eyes,koala,koko,kr,large_blue_circle,large_blue_diamond,large_orange_diamond,last_quarter_moon,last_quarter_moon_with_face,laughing,leaves,ledger,left_luggage,left_right_arrow,leftwards_arrow_with_hook,lemon,leo,leopard,libra,light_rail,link,lips,lipstick,lock,lock_with_ink_pen,lollipop,loop,loudspeaker,love_hotel,love_letter,low_brightness,m,mag,mag_right,mahjong,mailbox,mailbox_closed,mailbox_with_mail,mailbox_with_no_mail,man,man_with_gua_pi_mao,man_with_turban,mans_shoe,maple_leaf,mask,massage,meat_on_bone,mega,melon,memo,mens,metal,metro,microphone,microscope,milky_way,minibus,minidisc,mobile_phone_off,money_with_wings,moneybag,monkey,monkey_face,monorail,moon,mortar_board,mount_fuji,mountain_bicyclist,mountain_cableway,mountain_railway,mouse,mouse2,movie_camera,moyai,muscle,mushroom,musical_keyboard,musical_note,musical_score,mute,nail_care,name_badge,neckbeard,necktie,negative_squared_cross_mark,neutral_face,new,new_moon,new_moon_with_face,newspaper,ng,nine,no_bell,no_bicycles,no_entry,no_entry_sign,no_good,no_mobile_phones,no_mouth,no_pedestrians,no_smoking,non-potable_water,nose,notebook,notebook_with_decorative_cover,notes,nut_and_bolt,o,o2,ocean,octocat,octopus,oden,office,ok,ok_hand,ok_woman,older_man,older_woman,on,oncoming_automobile,oncoming_bus,oncoming_police_car,oncoming_taxi,one,open_file_folder,open_hands,open_mouth,ophiuchus,orange_book,outbox_tray,ox,page_facing_up,page_with_curl,pager,palm_tree,panda_face,paperclip,parking,part_alternation_mark,partly_sunny,passport_control,paw_prints,peach,pear,pencil,pencil2,penguin,pensive,performing_arts,persevere,person_frowning,person_with_blond_hair,person_with_pouting_face,phone,pig,pig2,pig_nose,pill,pineapple,pisces,pizza,plus1,point_down,point_left,point_right,point_up,point_up_2,police_car,poodle,poop,post_office,postal_horn,postbox,potable_water,pouch,poultry_leg,pound,pouting_cat,pray,princess,punch,purple_heart,purse,pushpin,put_litter_in_its_place,question,rabbit,rabbit2,racehorse,radio,radio_button,rage,rage1,rage2,rage3,rage4,railway_car,rainbow,raised_hand,raised_hands,raising_hand,ram,ramen,rat,recycle,red_car,red_circle,registered,relaxed,relieved,repeat,repeat_one,restroom,revolving_hearts,rewind,ribbon,rice,rice_ball,rice_cracker,rice_scene,ring,rocket,roller_coaster,rooster,rose,rotating_light,round_pushpin,rowboat,ru,rugby_football,runner,running,running_shirt_with_sash,sa,sagittarius,sailboat,sake,sandal,santa,satellite,satisfied,saxophone,school,school_satchel,scissors,scorpius,scream,scream_cat,scroll,seat,secret,see_no_evil,seedling,seven,shaved_ice,sheep,shell,ship,shipit,shirt,shit,shoe,shower,signal_strength,six,six_pointed_star,ski,skull,sleeping,sleepy,slot_machine,small_blue_diamond,small_orange_diamond,small_red_triangle,small_red_triangle_down,smile,smile_cat,smiley,smiley_cat,smiling_imp,smirk,smirk_cat,smoking,snail,snake,snowboarder,snowflake,snowman,sob,soccer,soon,sos,sound,space_invader,spades,spaghetti,sparkler,sparkles,sparkling_heart,speak_no_evil,speaker,speech_balloon,speedboat,squirrel,star,star2,stars,station,statue_of_liberty,steam_locomotive,stew,straight_ruler,strawberry,stuck_out_tongue,stuck_out_tongue_closed_eyes,stuck_out_tongue_winking_eye,sun_with_face,sunflower,sunglasses,sunny,sunrise,sunrise_over_mountains,surfer,sushi,suspect,suspension_railway,sweat,sweat_drops,sweat_smile,sweet_potato,swimmer,symbols,syringe,tada,tanabata_tree,tangerine,taurus,taxi,tea,telephone,telephone_receiver,telescope,tennis,tent,thought_balloon,three,thumbsdown,thumbsup,ticket,tiger,tiger2,tired_face,tm,toilet,tokyo_tower,tomato,tongue,top,tophat,tractor,traffic_light,train,train2,tram,triangular_flag_on_post,triangular_ruler,trident,triumph,trolleybus,trollface,trophy,tropical_drink,tropical_fish,truck,trumpet,tshirt,tulip,turtle,tv,twisted_rightwards_arrows,two,two_hearts,two_men_holding_hands,two_women_holding_hands,u5272,u5408,u55b6,u6307,u6708,u6709,u6e80,u7121,u7533,u7981,u7a7a,uk,umbrella,unamused,underage,unlock,up,us,v,vertical_traffic_light,vhs,vibration_mode,video_camera,video_game,violin,virgo,volcano,vs,walking,waning_crescent_moon,waning_gibbous_moon,warning,watch,water_buffalo,watermelon,wave,wavy_dash,waxing_crescent_moon,waxing_gibbous_moon,wc,weary,wedding,whale,whale2,wheelchair,white_check_mark,white_circle,white_flower,white_large_square,white_square,white_square_button,wind_chime,wine_glass,wink,wink2,wolf,woman,womans_clothes,womans_hat,womens,worried,wrench,x,yellow_heart,yen,yum,zap,zero,zzz",k=j.split(/,/),l=k.reduce(function(a,b){return a[b]=!0,a},{}),m={named:/:([a-z0-9A-Z_-]+):/,blush:/:-?\)/g,scream:/:-o/gi,smirk:/[:;]-?]/g,smiley:/[:;]-?d/gi,stuck_out_tongue_closed_eyes:/x-d/gi,stuck_out_tongue_winking_eye:/[:;]-?p/gi,rage:/:-?[\[@]/g,disappointed:/:-?\(/g,sob:/:[']-?\(|:&#x27;\(/g,kissing_heart:/:-?\*/g,wink:/;-?\)/g,pensive:/:-?\//g,confounded:/:-?s/gi,flushed:/:-?\|/g,relaxed:/:-?\$/g,mask:/:-x/gi,heart:/<3|&lt;3/g,broken_heart:/<\/3|&lt;&#x2F;3/g,thumbsup:/:\+1:/g,thumbsdown:/:\-1:/g},n=Object.keys(m).map(function(a){return[m[a],a]}),o=n.map(function(a){var b=a[0],c=b.source||b;return c=c.replace(/(^|[^\[])\^/g,"$1"),"("+c+")"}).join("|"),p=new RegExp(o,"gi"),q={emojify_tag_type:"div",only_crawl_id:null,img_dir:"images/emoji",ignored_tags:{SCRIPT:1,TEXTAREA:1,A:1,PRE:1,CODE:1}};return f.prototype={validate:function(a,c,e){function f(){return g.lastEmojiTerminatedAt=j+c,h}var g=this,h=d(a);if(h){var i=a[0],j=i.length;return 0===c?f():e.length===i.length+c?f():b(e.charAt(c-1))?f():b(e.charAt(i.length+c))?f():this.lastEmojiTerminatedAt===c?f():void 0}}},{defaultConfig:q,emojiNames:k,setConfig:function(a){Object.keys(q).forEach(function(b){b in a&&(q[b]=a[b])})},replace:g,run:h}}();return a.emojify=b,"function"==typeof define&&define.amd&&define([],function(){return b}),b}(this);
/* ===================================================
 *  jquery-sortable.js v0.9.13
 *  http://johnny.github.com/jquery-sortable/
 * ===================================================
 *  Copyright (c) 2012 Jonas von Andrian
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * ========================================================== */


!function ( $, window, pluginName, undefined){
    var containerDefaults = {
            // If true, items can be dragged from this container
            drag: true,
            // If true, items can be droped onto this container
            drop: true,
            // Exclude items from being draggable, if the
            // selector matches the item
            exclude: "",
            // If true, search for nested containers within an item.If you nest containers,
            // either the original selector with which you call the plugin must only match the top containers,
            // or you need to specify a group (see the bootstrap nav example)
            nested: true,
            // If true, the items are assumed to be arranged vertically
            vertical: true
        }, // end container defaults
        groupDefaults = {
            // This is executed after the placeholder has been moved.
            // $closestItemOrContainer contains the closest item, the placeholder
            // has been put at or the closest empty Container, the placeholder has
            // been appended to.
            afterMove: function ($placeholder, container, $closestItemOrContainer) {
            },
            // The exact css path between the container and its items, e.g. "> tbody"
            containerPath: "",
            // The css selector of the containers
            containerSelector: "ol, ul",
            // Distance the mouse has to travel to start dragging
            distance: 0,
            // Time in milliseconds after mousedown until dragging should start.
            // This option can be used to prevent unwanted drags when clicking on an element.
            delay: 0,
            // The css selector of the drag handle
            handle: "",
            // The exact css path between the item and its subcontainers.
            // It should only match the immediate items of a container.
            // No item of a subcontainer should be matched. E.g. for ol>div>li the itemPath is "> div"
            itemPath: "",
            // The css selector of the items
            itemSelector: "li",
            // The class given to "body" while an item is being dragged
            bodyClass: "dragging",
            // The class giving to an item while being dragged
            draggedClass: "dragged",
            // Check if the dragged item may be inside the container.
            // Use with care, since the search for a valid container entails a depth first search
            // and may be quite expensive.
            isValidTarget: function ($item, container) {
                return true
            },
            // Executed before onDrop if placeholder is detached.
            // This happens if pullPlaceholder is set to false and the drop occurs outside a container.
            onCancel: function ($item, container, _super, event) {
            },
            // Executed at the beginning of a mouse move event.
            // The Placeholder has not been moved yet.
            onDrag: function ($item, position, _super, event) {
                $item.css(position)
            },
            // Called after the drag has been started,
            // that is the mouse button is being held down and
            // the mouse is moving.
            // The container is the closest initialized container.
            // Therefore it might not be the container, that actually contains the item.
            onDragStart: function ($item, container, _super, event) {
                $item.css({
                    height: $item.outerHeight(),
                    width: $item.outerWidth()
                })
                $item.addClass(container.group.options.draggedClass)
                $("body").addClass(container.group.options.bodyClass)
            },
            // Called when the mouse button is being released
            onDrop: function ($item, container, _super, event) {
                $item.removeClass(container.group.options.draggedClass).removeAttr("style")
                $("body").removeClass(container.group.options.bodyClass)
            },
            // Called on mousedown. If falsy value is returned, the dragging will not start.
            // Ignore if element clicked is input, select or textarea
            onMousedown: function ($item, _super, event) {
                if (!event.target.nodeName.match(/^(input|select|textarea)$/i)) {
                    event.preventDefault()
                    return true
                }
            },
            // The class of the placeholder (must match placeholder option markup)
            placeholderClass: "placeholder",
            // Template for the placeholder. Can be any valid jQuery input
            // e.g. a string, a DOM element.
            // The placeholder must have the class "placeholder"
            placeholder: '<li class="placeholder"></li>',
            // If true, the position of the placeholder is calculated on every mousemove.
            // If false, it is only calculated when the mouse is above a container.
            pullPlaceholder: true,
            // Specifies serialization of the container group.
            // The pair $parent/$children is either container/items or item/subcontainers.
            serialize: function ($parent, $children, parentIsContainer) {
                var result = $.extend({}, $parent.data())

                if(parentIsContainer)
                    return [$children]
                else if ($children[0]){
                    result.children = $children
                }

                delete result.subContainers
                delete result.sortable

                return result
            },
            // Set tolerance while dragging. Positive values decrease sensitivity,
            // negative values increase it.
            tolerance: 0
        }, // end group defaults
        containerGroups = {},
        groupCounter = 0,
        emptyBox = {
            left: 0,
            top: 0,
            bottom: 0,
            right:0
        },
        eventNames = {
            start: "touchstart.sortable mousedown.sortable",
            drop: "touchend.sortable touchcancel.sortable mouseup.sortable",
            drag: "touchmove.sortable mousemove.sortable",
            scroll: "scroll.sortable"
        },
        subContainerKey = "subContainers"

    /*
   * a is Array [left, right, top, bottom]
   * b is array [left, top]
   */
    function d(a,b) {
        var x = Math.max(0, a[0] - b[0], b[0] - a[1]),
            y = Math.max(0, a[2] - b[1], b[1] - a[3])
        return x+y;
    }

    function setDimensions(array, dimensions, tolerance, useOffset) {
        var i = array.length,
            offsetMethod = useOffset ? "offset" : "position"
        tolerance = tolerance || 0

        while(i--){
            var el = array[i].el ? array[i].el : $(array[i]),
                // use fitting method
                pos = el[offsetMethod]()
            pos.left += parseInt(el.css('margin-left'), 10)
            pos.top += parseInt(el.css('margin-top'),10)
            dimensions[i] = [
                pos.left - tolerance,
                pos.left + el.outerWidth() + tolerance,
                pos.top - tolerance,
                pos.top + el.outerHeight() + tolerance
            ]
        }
    }

    function getRelativePosition(pointer, element) {
        var offset = element.offset()
        return {
            left: pointer.left - offset.left,
            top: pointer.top - offset.top
        }
    }

    function sortByDistanceDesc(dimensions, pointer, lastPointer) {
        pointer = [pointer.left, pointer.top]
        lastPointer = lastPointer && [lastPointer.left, lastPointer.top]

        var dim,
            i = dimensions.length,
            distances = []

        while(i--){
            dim = dimensions[i]
            distances[i] = [i,d(dim,pointer), lastPointer && d(dim, lastPointer)]
        }
        distances = distances.sort(function  (a,b) {
            return b[1] - a[1] || b[2] - a[2] || b[0] - a[0]
        })

        // last entry is the closest
        return distances
    }

    function ContainerGroup(options) {
        this.options = $.extend({}, groupDefaults, options)
        this.containers = []

        if(!this.options.rootGroup){
            this.scrollProxy = $.proxy(this.scroll, this)
            this.dragProxy = $.proxy(this.drag, this)
            this.dropProxy = $.proxy(this.drop, this)
            this.placeholder = $(this.options.placeholder)

            if(!options.isValidTarget)
                this.options.isValidTarget = undefined
        }
    }

    ContainerGroup.get = function  (options) {
        if(!containerGroups[options.group]) {
            if(options.group === undefined)
                options.group = groupCounter ++

            containerGroups[options.group] = new ContainerGroup(options)
        }

        return containerGroups[options.group]
    }

    ContainerGroup.prototype = {
        dragInit: function  (e, itemContainer) {
            this.$document = $(itemContainer.el[0].ownerDocument)

            // get item to drag
            var closestItem = $(e.target).closest(this.options.itemSelector);
            // using the length of this item, prevents the plugin from being started if there is no handle being clicked on.
            // this may also be helpful in instantiating multidrag.
            if (closestItem.length) {
                this.item = closestItem;
                this.itemContainer = itemContainer;
                if (this.item.is(this.options.exclude) || !this.options.onMousedown(this.item, groupDefaults.onMousedown, e)) {
                    return;
                }
                this.setPointer(e);
                this.toggleListeners('on');
                this.setupDelayTimer();
                this.dragInitDone = true;
            }
        },
        drag: function  (e) {
            if(!this.dragging){
                if(!this.distanceMet(e) || !this.delayMet)
                    return

                this.options.onDragStart(this.item, this.itemContainer, groupDefaults.onDragStart, e)
                this.item.before(this.placeholder)
                this.dragging = true
            }

            this.setPointer(e)
            // place item under the cursor
            this.options.onDrag(this.item,
                getRelativePosition(this.pointer, this.item.offsetParent()),
                groupDefaults.onDrag,
                e)

            var p = this.getPointer(e),
                box = this.sameResultBox,
                t = this.options.tolerance

            if(!box || box.top - t > p.top || box.bottom + t < p.top || box.left - t > p.left || box.right + t < p.left)
                if(!this.searchValidTarget()){
                    this.placeholder.detach()
                    this.lastAppendedItem = undefined
                }
        },
        drop: function  (e) {
            this.toggleListeners('off')

            this.dragInitDone = false

            if(this.dragging){
                // processing Drop, check if placeholder is detached
                if(this.placeholder.closest("html")[0]){
                    this.placeholder.before(this.item).detach()
                } else {
                    this.options.onCancel(this.item, this.itemContainer, groupDefaults.onCancel, e)
                }
                this.options.onDrop(this.item, this.getContainer(this.item), groupDefaults.onDrop, e)

                // cleanup
                this.clearDimensions()
                this.clearOffsetParent()
                this.lastAppendedItem = this.sameResultBox = undefined
                this.dragging = false
            }
        },
        searchValidTarget: function  (pointer, lastPointer) {
            if(!pointer){
                pointer = this.relativePointer || this.pointer
                lastPointer = this.lastRelativePointer || this.lastPointer
            }

            var distances = sortByDistanceDesc(this.getContainerDimensions(),
                pointer,
                lastPointer),
                i = distances.length

            while(i--){
                var index = distances[i][0],
                    distance = distances[i][1]

                if(!distance || this.options.pullPlaceholder){
                    var container = this.containers[index]
                    if(!container.disabled){
                        if(!this.$getOffsetParent()){
                            var offsetParent = container.getItemOffsetParent()
                            pointer = getRelativePosition(pointer, offsetParent)
                            lastPointer = getRelativePosition(lastPointer, offsetParent)
                        }
                        if(container.searchValidTarget(pointer, lastPointer))
                            return true
                    }
                }
            }
            if(this.sameResultBox)
                this.sameResultBox = undefined
        },
        movePlaceholder: function  (container, item, method, sameResultBox) {
            var lastAppendedItem = this.lastAppendedItem
            if(!sameResultBox && lastAppendedItem && lastAppendedItem[0] === item[0])
                return;

            item[method](this.placeholder)
            this.lastAppendedItem = item
            this.sameResultBox = sameResultBox
            this.options.afterMove(this.placeholder, container, item)
        },
        getContainerDimensions: function  () {
            if(!this.containerDimensions)
                setDimensions(this.containers, this.containerDimensions = [], this.options.tolerance, !this.$getOffsetParent())
            return this.containerDimensions
        },
        getContainer: function  (element) {
            return element.closest(this.options.containerSelector).data(pluginName)
        },
        $getOffsetParent: function  () {
            if(this.offsetParent === undefined){
                var i = this.containers.length - 1,
                    offsetParent = this.containers[i].getItemOffsetParent()

                if(!this.options.rootGroup){
                    while(i--){
                        if(offsetParent[0] != this.containers[i].getItemOffsetParent()[0]){
                            // If every container has the same offset parent,
                            // use position() which is relative to this parent,
                            // otherwise use offset()
                            // compare #setDimensions
                            offsetParent = false
                            break;
                        }
                    }
                }

                this.offsetParent = offsetParent
            }
            return this.offsetParent
        },
        setPointer: function (e) {
            var pointer = this.getPointer(e)

            if(this.$getOffsetParent()){
                var relativePointer = getRelativePosition(pointer, this.$getOffsetParent())
                this.lastRelativePointer = this.relativePointer
                this.relativePointer = relativePointer
            }

            this.lastPointer = this.pointer
            this.pointer = pointer
        },
        distanceMet: function (e) {
            var currentPointer = this.getPointer(e)
            return (Math.max(
                Math.abs(this.pointer.left - currentPointer.left),
                Math.abs(this.pointer.top - currentPointer.top)
            ) >= this.options.distance)
        },
        getPointer: function(e) {
            var o = e.originalEvent || e.originalEvent.touches && e.originalEvent.touches[0]
            return {
                left: e.pageX || o.pageX,
                top: e.pageY || o.pageY
            }
        },
        setupDelayTimer: function () {
            var that = this
            this.delayMet = !this.options.delay

            // init delay timer if needed
            if (!this.delayMet) {
                clearTimeout(this._mouseDelayTimer);
                this._mouseDelayTimer = setTimeout(function() {
                    that.delayMet = true
                }, this.options.delay)
            }
        },
        scroll: function  (e) {
            this.clearDimensions()
            this.clearOffsetParent() // TODO is this needed?
        },
        toggleListeners: function (method) {
            var that = this,
                events = ['drag','drop','scroll']

            $.each(events,function  (i,event) {
                that.$document[method](eventNames[event], that[event + 'Proxy'])
            })
        },
        clearOffsetParent: function () {
            this.offsetParent = undefined
        },
        // Recursively clear container and item dimensions
        clearDimensions: function  () {
            this.traverse(function(object){
                object._clearDimensions()
            })
        },
        traverse: function(callback) {
            callback(this)
            var i = this.containers.length
            while(i--){
                this.containers[i].traverse(callback)
            }
        },
        _clearDimensions: function(){
            this.containerDimensions = undefined
        },
        _destroy: function () {
            containerGroups[this.options.group] = undefined
        }
    }

    function Container(element, options) {
        this.el = element
        this.options = $.extend( {}, containerDefaults, options)

        this.group = ContainerGroup.get(this.options)
        this.rootGroup = this.options.rootGroup || this.group
        this.handle = this.rootGroup.options.handle || this.rootGroup.options.itemSelector

        var itemPath = this.rootGroup.options.itemPath
        this.target = itemPath ? this.el.find(itemPath) : this.el

        this.target.on(eventNames.start, this.handle, $.proxy(this.dragInit, this))

        if(this.options.drop)
            this.group.containers.push(this)
    }

    Container.prototype = {
        dragInit: function  (e) {
            var rootGroup = this.rootGroup

            if( !this.disabled &&
                !rootGroup.dragInitDone &&
                this.options.drag &&
                this.isValidDrag(e)) {
                rootGroup.dragInit(e, this)
            }
        },
        isValidDrag: function(e) {
            return e.which == 1 ||
                e.type == "touchstart" && e.originalEvent.touches.length == 1
        },
        searchValidTarget: function  (pointer, lastPointer) {
            var distances = sortByDistanceDesc(this.getItemDimensions(),
                pointer,
                lastPointer),
                i = distances.length,
                rootGroup = this.rootGroup,
                validTarget = !rootGroup.options.isValidTarget ||
                    rootGroup.options.isValidTarget(rootGroup.item, this)

            if(!i && validTarget){
                rootGroup.movePlaceholder(this, this.target, "append")
                return true
            } else
                while(i--){
                    var index = distances[i][0],
                        distance = distances[i][1]
                    if(!distance && this.hasChildGroup(index)){
                        var found = this.getContainerGroup(index).searchValidTarget(pointer, lastPointer)
                        if(found)
                            return true
                    }
                    else if(validTarget){
                        this.movePlaceholder(index, pointer)
                        return true
                    }
                }
        },
        movePlaceholder: function  (index, pointer) {
            var item = $(this.items[index]),
                dim = this.itemDimensions[index],
                method = "after",
                width = item.outerWidth(),
                height = item.outerHeight(),
                offset = item.offset(),
                sameResultBox = {
                    left: offset.left,
                    right: offset.left + width,
                    top: offset.top,
                    bottom: offset.top + height
                }
            if(this.options.vertical){
                var yCenter = (dim[2] + dim[3]) / 2,
                    inUpperHalf = pointer.top <= yCenter
                if(inUpperHalf){
                    method = "before"
                    sameResultBox.bottom -= height / 2
                } else
                    sameResultBox.top += height / 2
            } else {
                var xCenter = (dim[0] + dim[1]) / 2,
                    inLeftHalf = pointer.left <= xCenter
                if(inLeftHalf){
                    method = "before"
                    sameResultBox.right -= width / 2
                } else
                    sameResultBox.left += width / 2
            }
            if(this.hasChildGroup(index))
                sameResultBox = emptyBox
            this.rootGroup.movePlaceholder(this, item, method, sameResultBox)
        },
        getItemDimensions: function  () {
            if(!this.itemDimensions){
                this.items = this.$getChildren(this.el, "item").filter(
                    ":not(." + this.group.options.placeholderClass + ", ." + this.group.options.draggedClass + ")"
                ).get()
                setDimensions(this.items, this.itemDimensions = [], this.options.tolerance)
            }
            return this.itemDimensions
        },
        getItemOffsetParent: function  () {
            var offsetParent,
                el = this.el
            // Since el might be empty we have to check el itself and
            // can not do something like el.children().first().offsetParent()
            if(el.css("position") === "relative" || el.css("position") === "absolute"  || el.css("position") === "fixed")
                offsetParent = el
            else
                offsetParent = el.offsetParent()
            return offsetParent
        },
        hasChildGroup: function (index) {
            return this.options.nested && this.getContainerGroup(index)
        },
        getContainerGroup: function  (index) {
            var childGroup = $.data(this.items[index], subContainerKey)
            if( childGroup === undefined){
                var childContainers = this.$getChildren(this.items[index], "container")
                childGroup = false

                if(childContainers[0]){
                    var options = $.extend({}, this.options, {
                        rootGroup: this.rootGroup,
                        group: groupCounter ++
                    })
                    childGroup = childContainers[pluginName](options).data(pluginName).group
                }
                $.data(this.items[index], subContainerKey, childGroup)
            }
            return childGroup
        },
        $getChildren: function (parent, type) {
            var options = this.rootGroup.options,
                path = options[type + "Path"],
                selector = options[type + "Selector"]

            parent = $(parent)
            if(path)
                parent = parent.find(path)

            return parent.children(selector)
        },
        _serialize: function (parent, isContainer) {
            var that = this,
                childType = isContainer ? "item" : "container",

                children = this.$getChildren(parent, childType).not(this.options.exclude).map(function () {
                    return that._serialize($(this), !isContainer)
                }).get()

            return this.rootGroup.options.serialize(parent, children, isContainer)
        },
        traverse: function(callback) {
            $.each(this.items || [], function(item){
                var group = $.data(this, subContainerKey)
                if(group)
                    group.traverse(callback)
            });

            callback(this)
        },
        _clearDimensions: function  () {
            this.itemDimensions = undefined
        },
        _destroy: function() {
            var that = this;

            this.target.off(eventNames.start, this.handle);
            this.el.removeData(pluginName)

            if(this.options.drop)
                this.group.containers = $.grep(this.group.containers, function(val){
                    return val != that
                })

            $.each(this.items || [], function(){
                $.removeData(this, subContainerKey)
            })
        }
    }

    var API = {
        enable: function() {
            this.traverse(function(object){
                object.disabled = false
            })
        },
        disable: function (){
            this.traverse(function(object){
                object.disabled = true
            })
        },
        serialize: function () {
            return this._serialize(this.el, true)
        },
        refresh: function() {
            this.traverse(function(object){
                object._clearDimensions()
            })
        },
        destroy: function () {
            this.traverse(function(object){
                object._destroy();
            })
        }
    }

    $.extend(Container.prototype, API)

    /**
     * jQuery API
     *
     * Parameters are
     *   either options on init
     *   or a method name followed by arguments to pass to the method
     */
    $.fn[pluginName] = function(methodOrOptions) {
        var args = Array.prototype.slice.call(arguments, 1)

        return this.map(function(){
            var $t = $(this),
                object = $t.data(pluginName)

            if(object && API[methodOrOptions])
                return API[methodOrOptions].apply(object, args) || this
            else if(!object && (methodOrOptions === undefined ||
                    typeof methodOrOptions === "object"))
                $t.data(pluginName, new Container($t, methodOrOptions))

            return this
        });
    };

}(jQuery, window, 'sortable');
/*! inline-attach - v1.3.2 - 2014-11-07 */
(function(e,t){"use strict";function a(){for(var e={},t=arguments.length-1;t>=0;t--){var a=arguments[t];for(var n in a)e[n]=a[n]}return e}t.inlineAttach=function(e,n){function r(e,t){return(e+"\n\n[[D]]"+t).replace(/(\n{2,})\[\[D\]\]/,"\n\n").replace(/^(\n*)/,"")}var o,i=a(e,inlineAttach.defaults),l=n,s="{filename}",d=this;this.uploadFile=function(e){var t=new FormData,a=new XMLHttpRequest,n="png";if(e.name){var r=e.name.match(/\.(.+)$/);r&&(n=r[1])}if(i.addFileBeforeExtraParameters&&t.append(i.uploadFieldName,e,"image-"+Date.now()+"."+n),"object"==typeof i.extraParams)for(var o in i.extraParams)i.extraParams.hasOwnProperty(o)&&t.append(o,i.extraParams[o]);if(i.addFileBeforeExtraParameters||t.append(i.uploadFieldName,e,"image-"+Date.now()+"."+n),a.open(i.uploadMethod,i.uploadUrl),"object"==typeof i.extraHeaders)for(var l in i.extraHeaders)i.extraHeaders.hasOwnProperty(l)&&a.setRequestHeader(l,i.extraHeaders[l]);a.onload=function(){if(200===a.status||201===a.status){var e=d.parseResponse(a);d.onUploadedFile(e)}else d.onErrorUploading()},a.send(t)},this.parseResponse=function(e){return i.customResponseParser.call(this,e)||JSON.parse(e.responseText)},this.isAllowedFile=function(e){return i.allowedTypes.indexOf(e.type)>=0},this.onUploadedFile=function(e){var t,a=i.onUploadedFile.call(this,e);if(i.dataProcessor&&(e=i.dataProcessor.call(this,e)),t=e[i.downloadFieldName],a!==!1&&t){var n=l.getValue().replace(o,i.urlText.replace(s,t));l.setValue(n)}},this.customUploadHandler=function(e){return i.customUploadHandler.call(this,e)},this.onErrorUploading=function(){var e=l.getValue().replace(o,"");l.setValue(e),i.customErrorHandler.call(this)&&t.alert(i.errorText)},this.onReceivedFile=function(e){var t=i.onReceivedFile.call(this,e);t!==!1&&(o=i.progressText,l.setValue(r(l.getValue(),o)))},this.onPaste=function(e){var t,a=!1,n=e.clipboardData;if("object"==typeof n){t=n.items||n.files||[];for(var r=0;t.length>r;r++){var o=t[r];d.isAllowedFile(o)&&(a=!0,this.onReceivedFile(o.getAsFile()),this.customUploadHandler(o.getAsFile())&&this.uploadFile(o.getAsFile()))}}return a},this.onDrop=function(e){for(var t=!1,a=0;e.dataTransfer.files.length>a;a++){var n=e.dataTransfer.files[a];d.isAllowedFile(n)&&(t=!0,this.onReceivedFile(n),this.customUploadHandler(n)&&this.uploadFile(n))}return t}},t.inlineAttach.Editor=function(e){var t=e;return{getValue:function(){return t.value},setValue:function(e){t.value=e}}},t.inlineAttach.defaults={uploadUrl:"upload_attachment.php",uploadMethod:"POST",uploadFieldName:"file",addFileBeforeExtraParameters:!0,downloadFieldName:"filename",allowedTypes:["image/jpeg","image/png","image/jpg","image/gif"],progressText:"![Uploading file...]()",urlText:"![file]({filename})",errorText:"Error uploading file",extraParams:{},extraHeaders:{},onReceivedFile:function(){},customUploadHandler:function(){return!0},customErrorHandler:function(){return!0},customResponseParser:function(){return null},onUploadedFile:function(){}},t.inlineAttach.attachToInput=function(e,t){t=t||{};var a=new inlineAttach.Editor(e),n=new inlineAttach(t,a);e.addEventListener("paste",function(e){n.onPaste(e)},!1),e.addEventListener("drop",function(e){e.stopPropagation(),e.preventDefault(),n.onDrop(e)},!1),e.addEventListener("dragenter",function(e){e.stopPropagation(),e.preventDefault()},!1),e.addEventListener("dragover",function(e){e.stopPropagation(),e.preventDefault()},!1)}})(document,window),function(e,t,a){"use strict";function n(e){var t=a(e);return{getValue:function(){return t.val()},setValue:function(e){t.val(e)}}}n.prototype=new inlineAttach.Editor,a.fn.inlineattach=function(e){var t=a(this);return t.each(function(){var t=a(this),r=new n(t),o=new inlineAttach(e,r);t.bind({paste:function(e){o.onPaste(e.originalEvent)},drop:function(e){e.stopPropagation(),e.preventDefault(),o.onDrop(e.originalEvent)},"dragenter dragover":function(e){e.stopPropagation(),e.preventDefault()}})}),this}}(document,window,jQuery);
jQuery.fn.highlight=function(c){function e(b,c){var d=0;if(3==b.nodeType){var a=b.data.toUpperCase().indexOf(c),a=a-(b.data.substr(0,a).toUpperCase().length-b.data.substr(0,a).length);if(0<=a){d=document.createElement("span");d.className="highlight";a=b.splitText(a);a.splitText(c.length);var f=a.cloneNode(!0);d.appendChild(f);a.parentNode.replaceChild(d,a);d=1}}else if(1==b.nodeType&&b.childNodes&&!/(script|style)/i.test(b.tagName))for(a=0;a<b.childNodes.length;++a)a+=e(b.childNodes[a],c);return d} return this.length&&c&&c.length?this.each(function(){e(this,c.toUpperCase())}):this};jQuery.fn.removeHighlight=function(){return this.find("span.highlight").each(function(){this.parentNode.firstChild.nodeName;with(this.parentNode)replaceChild(this.firstChild,this),normalize()}).end()};

// extension:
$.fn.scrollEnd = function(callback, timeout) {
    $(this).scroll(function(){
        var $this = $(this);
        if ($this.data('scrollTimeout')) {
            clearTimeout($this.data('scrollTimeout'));
        }
        $this.data('scrollTimeout', setTimeout(callback,timeout));
    });
};

(function ($, window, document) {
    'use strict';

    // Main function
    $.fn.scrollUp = function (options) {

        // Ensure that only one scrollUp exists
        if (!$.data(document.body, 'scrollUp')) {
            $.data(document.body, 'scrollUp', true);
            $.fn.scrollUp.init(options);
        }
    };

    // Init
    $.fn.scrollUp.init = function (options) {

        // Define vars
        var o = $.fn.scrollUp.settings = $.extend({}, $.fn.scrollUp.defaults, options),
            triggerVisible = false,
            animIn, animOut, animSpeed, scrollDis, scrollEvent, scrollTarget, $self;

        // Create element
        if (o.scrollTrigger) {
            $self = $(o.scrollTrigger);
        } else {
            $self = $('<a/>', {
                id: o.scrollName,
                href: '#top'
            });
        }

        // Set scrollTitle if there is one
        if (o.scrollTitle) {
            $self.attr('title', o.scrollTitle);
        }

        $self.appendTo('body');

        // If not using an image display text
        if (!(o.scrollImg || o.scrollTrigger)) {
            $self.html(o.scrollText);
        }

        // Minimum CSS to make the magic happen
        $self.css({
            display: 'none',
            position: 'fixed',
            zIndex: o.zIndex
        });

        // Active point overlay
        if (o.activeOverlay) {
            $('<div/>', {
                id: o.scrollName + '-active'
            }).css({
                position: 'absolute',
                'top': o.scrollDistance + 'px',
                width: '100%',
                borderTop: '1px dotted' + o.activeOverlay,
                zIndex: o.zIndex
            }).appendTo('body');
        }

        // Switch animation type
        switch (o.animation) {
            case 'fade':
                animIn = 'fadeIn';
                animOut = 'fadeOut';
                animSpeed = o.animationSpeed;
                break;

            case 'slide':
                animIn = 'slideDown';
                animOut = 'slideUp';
                animSpeed = o.animationSpeed;
                break;

            default:
                animIn = 'show';
                animOut = 'hide';
                animSpeed = 0;
        }

        // If from top or bottom
        if (o.scrollFrom === 'top') {
            scrollDis = o.scrollDistance;
        } else {
            scrollDis = $(document).height() - $(window).height() - o.scrollDistance;
        }

        // Scroll function
        scrollEvent = $(window).scroll(function () {
            if ($(window).scrollTop() > scrollDis) {
                if (!triggerVisible) {
                    $self[animIn](animSpeed);
                    triggerVisible = true;
                }
            } else {
                if (triggerVisible) {
                    $self[animOut](animSpeed);
                    triggerVisible = false;
                }
            }
        });

        // how to call it (with a 1500ms timeout):
        $(window).scrollEnd(function(){
            $self[animOut](animSpeed);
            triggerVisible = false;
        }, 1200);

        if (o.scrollTarget) {
            if (typeof o.scrollTarget === 'number') {
                scrollTarget = o.scrollTarget;
            } else if (typeof o.scrollTarget === 'string') {
                scrollTarget = Math.floor($(o.scrollTarget).offset().top);
            }
        } else {
            scrollTarget = 0;
        }

        // To the top
        $self.click(function (e) {
            e.preventDefault();

            $('html, body').animate({
                scrollTop: scrollTarget
            }, o.scrollSpeed, o.easingType);
        });
    };

    // Defaults
    $.fn.scrollUp.defaults = {
        scrollName: 'scrollUp',      // Element ID
        scrollDistance: 300,         // Distance from top/bottom before showing element (px)
        scrollFrom: 'top',           // 'top' or 'bottom'
        scrollSpeed: 300,            // Speed back to top (ms)
        easingType: 'linear',        // Scroll to top easing (see http://easings.net/)
        animation: 'fade',           // Fade, slide, none
        animationSpeed: 200,         // Animation in speed (ms)
        scrollTrigger: false,        // Set a custom triggering element. Can be an HTML string or jQuery object
        scrollTarget: false,         // Set a custom target element for scrolling to. Can be element or number
        scrollText: 'Scroll to top', // Text for element, can contain HTML
        scrollTitle: false,          // Set a custom <a> title if required. Defaults to scrollText
        scrollImg: false,            // Set true to use image
        activeOverlay: false,        // Set CSS color to display scrollUp active point, e.g '#00FFFF'
        zIndex: 2147483647           // Z-Index for the overlay
    };

    // Destroy scrollUp plugin and clean all modifications to the DOM
    $.fn.scrollUp.destroy = function (scrollEvent) {
        $.removeData(document.body, 'scrollUp');
        $('#' + $.fn.scrollUp.settings.scrollName).remove();
        $('#' + $.fn.scrollUp.settings.scrollName + '-active').remove();

        // If 1.7 or above use the new .off()
        if ($.fn.jquery.split('.')[1] >= 7) {
            $(window).off('scroll', scrollEvent);

            // Else use the old .unbind()
        } else {
            $(window).unbind('scroll', scrollEvent);
        }
    };

    $.scrollUp = $.fn.scrollUp;

})(jQuery, window, document);

/*!
 * jQuery.textcomplete.js
 *
 * Repositiory: https://github.com/yuku-t/jquery-textcomplete
 * License:     MIT
 * Author:      Yuku Takahashi
 */

;(function ($) {

    'use strict';

    /**
     * Exclusive execution control utility.
     */
    var lock = function (func) {
        var free, locked, queuedArgsToReplay;
        free = function () { locked = false; };
        return function () {
            var args = toArray(arguments);
            if (locked) {
                // Keep a copy of this argument list to replay later.
                // OK to overwrite a previous value because we only replay the last one.
                queuedArgsToReplay = args;
                return;
            }
            locked = true;
            var that = this;
            args.unshift(function replayOrFree() {
                if (queuedArgsToReplay) {
                    // Other request(s) arrived while we were locked.
                    // Now that the lock is becoming available, replay
                    // the latest such request, then call back here to
                    // unlock (or replay another request that arrived
                    // while this one was in flight).
                    var replayArgs = queuedArgsToReplay;
                    queuedArgsToReplay = undefined;
                    replayArgs.unshift(replayOrFree);
                    func.apply(that, replayArgs);
                } else {
                    locked = false;
                }
            });
            func.apply(this, args);
        };
    };

    /**
     * Convert arguments into a real array.
     */
    var toArray = function (args) {
        var result;
        result = Array.prototype.slice.call(args);
        return result;
    };

    /**
     * Get the styles of any element from property names.
     */
    var getStyles = (function () {
        var color;
        color = $('<div></div>').css(['color']).color;
        if (typeof color !== 'undefined') {
            return function ($el, properties) {
                return $el.css(properties);
            };
        } else {  // for jQuery 1.8 or below
            return function ($el, properties) {
                var styles;
                styles = {};
                $.each(properties, function (i, property) {
                    styles[property] = $el.css(property);
                });
                return styles;
            };
        }
    })();

    /**
     * Default template function.
     */
    var identity = function (obj) { return obj; };

    /**
     * Memoize a search function.
     */
    var memoize = function (func) {
        var memo = {};
        return function (term, callback) {
            if (memo[term]) {
                callback(memo[term]);
            } else {
                func.call(this, term, function (data) {
                    memo[term] = (memo[term] || []).concat(data);
                    callback.apply(null, arguments);
                });
            }
        };
    };

    /**
     * Determine if the array contains a given value.
     */
    var include = function (array, value) {
        var i, l;
        if (array.indexOf) return array.indexOf(value) != -1;
        for (i = 0, l = array.length; i < l; i++) {
            if (array[i] === value) return true;
        }
        return false;
    };

    /**
     * Textarea manager class.
     */
    var Completer = (function () {
        var html, css, $baseList, _id;

        html = {
            list: '<ul class="dropdown-menu"></ul>'
        };
        css = {
            // Removed the 'top' property to support the placement: 'top' option
            list: {
                position: 'absolute',
                left: 0,
                zIndex: '100',
                display: 'none'
            }
        };
        $baseList = $(html.list).css(css.list);
        _id = 0;

        function Completer($el, option) {
            var focus;
            this.el = $el.get(0);  // textarea element
            focus = this.el === document.activeElement;
            this.$el = $el;
            this.id = 'textComplete' + _id++;
            this.strategies = [];
            this.option = option;
            if (focus) {
                this.initialize();
                this.$el.focus();
            } else {
                this.$el.one('focus.textComplete', $.proxy(this.initialize, this));
            }
        }

        /**
         * Completer's public methods
         */
        $.extend(Completer.prototype, {

            /**
             * Prepare ListView and bind events.
             */
            initialize: function () {
                var $list, globalEvents, appendTo, height;
                $list = $baseList.clone();
                this.listView = new ListView($list, this);
                this.$el.on({
                    'keyup.textComplete': $.proxy(this.onKeyup, this),
                    'keydown.textComplete': $.proxy(this.listView.onKeydown, this.listView)
                });
                appendTo = this.option.appendTo;
                if (appendTo) {
                    // Append ListView to specified element.
                    this.listView.appendTo(appendTo instanceof $ ? appendTo : $(appendTo));
                } else {
                    this.listView.appendTo($('body'));
                }
                height = this.option.height;
                if (height) {
                    $list.css("overflow-y", "auto");
                    $list.height(height);
                }
                globalEvents = {};
                globalEvents['click.' + this.id] = $.proxy(this.onClickDocument, this);
                globalEvents['keyup.' + this.id] = $.proxy(this.onKeyupDocument, this);
                $(document).on(globalEvents);
            },

            /**
             * Register strategies to the completer.
             */
            register: function (strategies) {
                this.strategies = this.strategies.concat(strategies);
            },

            /**
             * Show autocomplete list next to the caret.
             */
            renderList: function (data) {
                if (this.clearAtNext) {
                    this.listView.clear();
                    this.clearAtNext = false;
                }
                if (data.length) {
                    this.listView.strategy = this.strategy;
                    if (!this.listView.shown) {
                        this.listView
                            .setPosition(this.getCaretPosition())
                            .clear()
                            .activate();
                    }
                    data = data.slice(0, this.strategy.maxCount);
                    this.listView.render(data);
                }

                if (!this.listView.data.length && this.listView.shown) {
                    this.listView.deactivate();
                }
            },

            searchCallbackFactory: function (free) {
                var self = this;
                return function (data, keep) {
                    self.renderList(data);
                    if (!keep) {
                        // This is the last callback for this search.
                        free();
                        self.clearAtNext = true;
                    }
                };
            },

            /**
             * Keyup event handler.
             */
            onKeyup: function (e) {
                if (this.skipSearch(e)) { return; }
                this.trigger(null, true);
            },

            /**
             * Public interface for invoking textcomplete.
             */
            trigger: function (text, suppress) {
                var searchQuery, term;
                text || (text = this.getTextFromHeadToCaret());
                searchQuery = this.extractSearchQuery(text);
                if (searchQuery.length) {
                    term = searchQuery[1];
                    if (suppress && this.term === term) {
                        return; // Ignore shift-key or something.
                    }
                    this.term = term;
                    this.search(searchQuery);
                } else {
                    this.term = null;
                    this.listView.deactivate();
                }
            },

            /**
             * Suppress searching if it returns true.
             */
            skipSearch: function (e) {
                switch (e.keyCode) {
                    case 40: // DOWN
                    case 38: // UP
                        return true;
                }
                if (e.ctrlKey) switch (e.keyCode) {
                    case 78: // Ctrl-N
                    case 80: // Ctrl-P
                        return true;
                }
            },

            onSelect: function (value) {
                var pre, post, newSubStr, sel, range, selection, remainder;
                pre = this.getTextFromHeadToCaret();
                remainder = pre.length;

                if (this.el.isContentEditable) {
                    sel = window.getSelection();
                    range = sel.getRangeAt(0);
                    selection = range.cloneRange();
                    selection.selectNodeContents(range.startContainer);
                    var content = selection.toString();
                    post = content.substring(range.startOffset);
                } else {
                    post = this.el.value.substring(this.el.selectionEnd);
                }

                newSubStr = this.strategy.replace(value);

                if ($.isArray(newSubStr)) {
                    post = newSubStr[1] + post;
                    newSubStr = newSubStr[0];
                }

                pre = pre.replace(this.strategy.match, newSubStr);

                if (this.el.isContentEditable) {
                    range.selectNodeContents(range.startContainer);
                    range.deleteContents();
                    var node = document.createTextNode(pre + post);
                    range.insertNode(node);
                    range.setStart(node, pre.length);
                    range.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(range);
                } else {
                    this.$el.val(pre + post);
                    this.el.selectionStart = this.el.selectionEnd = pre.length;
                }

                this.$el.trigger('change')
                    .trigger('textComplete:select', value);
                this.el.focus();
            },

            /**
             * Global click event handler.
             */
            onClickDocument: function (e) {
                if (e.originalEvent && !e.originalEvent.keepTextCompleteDropdown) {
                    this.listView.deactivate();
                }
            },

            /**
             * Global keyup event handler.
             */
            onKeyupDocument: function (e) {
                if (this.listView.shown && e.keyCode === 27) { // ESC
                    this.listView.deactivate();
                    this.$el.focus();
                }
            },

            /**
             * Remove all event handlers.
             */
            destroy: function () {
                this.$el.off('.textComplete');
                $(document).off('.' + this.id);
                if (this.listView) { this.listView.destroy(); }
                this.$el.removeData('textComplete');
                this.$el = null;
            },

            // Helper methods
            // ==============

            getCaretPosition: function () {
                var caretPosition, textareaOffset;
                caretPosition = this.getCaretRelativePosition();
                textareaOffset = this.$el.offset();
                caretPosition.top += textareaOffset.top;
                caretPosition.left += textareaOffset.left;
                return caretPosition;
            },

            /**
             * Returns caret's relative coordinates from textarea's left top corner.
             */
            getCaretRelativePosition: function () {
                var properties, css, $div, $span, position, dir, scrollbar, range, node, $node;
                if (!this.el.isContentEditable) {
                    // Browser native API does not provide the way to know the position of
                    // caret in pixels, so that here we use a kind of hack to accomplish
                    // the aim. First of all it puts a div element and completely copies
                    // the textarea's style to the element, then it inserts the text and a
                    // span element into the textarea.
                    // Consequently, the span element's position is the thing what we want.
                    properties = ['border-width', 'font-family', 'font-size', 'font-style',
                        'font-variant', 'font-weight', 'height', 'letter-spacing',
                        'word-spacing', 'line-height', 'text-decoration', 'text-align',
                        'width', 'padding-top', 'padding-right', 'padding-bottom',
                        'padding-left', 'margin-top', 'margin-right', 'margin-bottom',
                        'margin-left', 'border-style', 'box-sizing'
                    ];
                    scrollbar = this.$el[0].scrollHeight > this.$el[0].offsetHeight;
                    css = $.extend({
                        position: 'absolute',
                        overflow: scrollbar ? 'scroll' : 'auto',
                        'white-space': 'pre-wrap',
                        top: 0,
                        left: -9999,
                        direction: dir
                    }, getStyles(this.$el, properties));

                    $div = $('<div></div>').css(css).text(this.getTextFromHeadToCaret());
                    $span = $('<span></span>').text('.').appendTo($div);
                    this.$el.before($div);
                    position = $span.position();
                    position.top += $span.height() - this.$el.scrollTop();
                    $div.remove();
                } else {
                    range = window.getSelection().getRangeAt(0).cloneRange();
                    node = document.createElement('span');
                    range.insertNode(node);
                    range.selectNodeContents(node);
                    range.deleteContents();
                    $node = $(node);
                    position = $node.offset();
                    position.left -= this.$el.offset().left;
                    position.top += $node.height() - this.$el.offset().top;
                }
                dir = this.$el.attr('dir') || this.$el.css('direction');
                if (dir === 'rtl') { position.left -= this.listView.$el.width(); }
                return position;
            },

            getTextFromHeadToCaret: function () {
                var text, selectionEnd, range;
                if (this.el.isContentEditable) {
                    if (window.getSelection) {
                        // IE9+ and non-IE
                        var range = window.getSelection().getRangeAt(0);
                        var selection = range.cloneRange();
                        selection.selectNodeContents(range.startContainer);
                        text = selection.toString().substring(0, range.startOffset);
                    }
                } else {
                    selectionEnd = this.el.selectionEnd;
                    if (typeof selectionEnd === 'number') {
                        text = this.el.value.substring(0, selectionEnd);
                    } else if (document.selection) {
                        range = this.el.createTextRange();
                        range.moveStart('character', 0);
                        range.moveEnd('textedit');
                        text = range.text;
                    }
                }
                return text;
            },

            /**
             * Parse the value of textarea and extract search query.
             */
            extractSearchQuery: function (text) {
                var i, l, strategy, match;
                for (i = 0, l = this.strategies.length; i < l; i++) {
                    strategy = this.strategies[i];
                    match = text.match(strategy.match);
                    if (match) { return [strategy, match[strategy.index]]; }
                }
                return [];
            },

            search: lock(function (free, searchQuery) {
                var term;
                this.strategy = searchQuery[0];
                term = searchQuery[1];
                this.strategy.search(term, this.searchCallbackFactory(free));
            })
        });

        return Completer;
    })();

    /**
     * Dropdown menu manager class.
     */
    var ListView = (function () {

        function ListView($el, completer) {
            this.data = [];
            this.$el = $el;
            this.index = 0;
            this.completer = completer;
            if (completer.option.listPosition) {
                this.setPosition = completer.option.listPosition;
            }

            this.$el.on('mousedown.textComplete', 'li.textcomplete-item',
                $.proxy(this.onClick, this));
            this.$el.on('mouseover.textComplete', 'li.textcomplete-item',
                $.proxy(this.onMouseover, this));
        }

        $.extend(ListView.prototype, {
            shown: false,

            render: function (data) {
                var html, i, l, index, val, str;

                html = '';

                if(this.strategy.header) {
                    if ($.isFunction(this.strategy.header)) {
                        str = this.strategy.header(data);
                    } else {
                        str = this.strategy.header;
                    }
                    html += '<li class="textcomplete-header">' + str + '</li>';
                }

                for (i = 0, l = data.length; i < l; i++) {
                    val = data[i];
                    if (include(this.data, val)) continue;
                    index = this.data.length;
                    this.data.push(val);
                    html += '<li class="textcomplete-item" data-index="' + index + '"><a>';
                    html +=   this.strategy.template(val);
                    html += '</a></li>';
                    if (this.data.length === this.strategy.maxCount) break;
                }

                if(this.strategy.footer) {
                    if ($.isFunction(this.strategy.footer)) {
                        str = this.strategy.footer(data);
                    } else {
                        str = this.strategy.footer;
                    }
                    html += '<li class="textcomplete-footer">' + str + '</li>';
                }

                this.$el.append(html);
                if (!this.data.length) {
                    this.deactivate();
                } else {
                    this.activateIndexedItem();
                    this.setScroll();
                }
            },

            clear: function () {
                this.data = [];
                this.$el.html('');
                this.index = 0;
                return this;
            },

            activateIndexedItem: function () {
                this.$el.find('.active').removeClass('active');
                this.getActiveItem().addClass('active');
            },

            getActiveItem: function () {
                return $(this.$el.children('.textcomplete-item').get(this.index));
            },

            activate: function () {
                if (!this.shown) {
                    this.$el.show();
                    this.completer.$el.trigger('textComplete:show');
                    this.shown = true;
                }
                return this;
            },

            deactivate: function () {
                if (this.shown) {
                    this.$el.hide();
                    this.completer.$el.trigger('textComplete:hide');
                    this.shown = false;
                    this.data = [];
                    this.index = null;
                }
                return this;
            },

            setPosition: function (position) {
                var fontSize;
                // If the strategy has the 'placement' option set to 'top', move the
                // position above the element
                if(this.strategy.placement.indexOf('top') > -1) {
                    // Move it to be in line with the match character
                    fontSize = parseInt(this.$el.css('font-size'));
                    // Overwrite the position object to set the 'bottom' property instead of the top.
                    position = {
                        top: 'auto',
                        bottom: this.$el.parent().height() - position.top + fontSize,
                        left: position.left
                    };
                } else {
                    // Overwrite 'bottom' property because once `placement: 'top'`
                    // strategy is shown, $el keeps the property.
                    position.bottom = 'auto';
                }

                if (this.strategy.placement.indexOf('absleft') > -1) {
                    position.left = 0;
                }

                if (this.strategy.placement.indexOf('absright') > -1) {
                    position.right = 0;
                    position.left = 'auto';
                }

                this.$el.css(position);
                return this;
            },

            setScroll: function (e) {
                var $activeItem = this.getActiveItem();
                var itemTop = $activeItem.position().top;
                var itemHeight = $activeItem.outerHeight();
                var visibleHeight = this.$el.innerHeight();
                var visibleTop = this.$el.scrollTop();
                if (this.index === 0 || this.index === this.data.length - 1 || itemTop < 0) {
                    this.$el.scrollTop(itemTop + visibleTop);
                } else if (itemTop + itemHeight > visibleHeight) {
                    this.$el.scrollTop(itemTop + itemHeight + visibleTop - visibleHeight);
                }
            },

            select: function (index) {
                var self = this;
                this.completer.onSelect(this.data[index]);
                // Deactive at next tick to allow other event handlers to know whether
                // the dropdown has been shown or not.
                setTimeout(function () { self.deactivate(); }, 0);
            },

            onKeydown: function (e) {
                if (!this.shown) return;
                var modifiers = e.ctrlKey || e.altKey || e.metaKey || e.shiftKey;
                if (e.keyCode === 38 || (e.ctrlKey && e.keyCode === 80)) {         // UP, or Ctrl-P
                    e.preventDefault();
                    if (this.index === 0) {
                        this.index = this.data.length-1;
                    } else {
                        this.index -= 1;
                    }
                    this.activateIndexedItem();
                    this.setScroll();
                } else if (e.keyCode === 40 || (e.ctrlKey && e.keyCode === 78)) {  // DOWN, or Ctrl-N
                    e.preventDefault();
                    if (this.index === this.data.length - 1) {
                        this.index = 0;
                    } else {
                        this.index += 1;
                    }
                    this.activateIndexedItem();
                    this.setScroll();
                } else if (!modifiers && (e.keyCode === 13 || e.keyCode === 9)) {  // ENTER or TAB
                    e.preventDefault();
                    this.select(parseInt(this.getActiveItem().data('index'), 10));
                }
                else if (e.keyCode === 33) {                                       // PAGEUP
                    e.preventDefault();
                    var target = 0;
                    var threshold = this.getActiveItem().position().top - this.$el.innerHeight();
                    this.$el.children().each(function (i) {
                        if ($(this).position().top + $(this).outerHeight() > threshold) {
                            target = i;
                            return false;
                        }
                    });
                    this.index = target;
                    this.activateIndexedItem();
                    this.setScroll();
                }
                else if (e.keyCode === 34) {                                       // PAGEDOWN
                    e.preventDefault();
                    var target = this.data.length - 1;
                    var threshold = this.getActiveItem().position().top + this.$el.innerHeight();
                    this.$el.children().each(function (i) {
                        if ($(this).position().top > threshold) {
                            target = i;
                            return false;
                        }
                    });
                    this.index = target;
                    this.activateIndexedItem();
                    this.setScroll();
                }
            },

            onClick: function (e) {
                var $e = $(e.target);
                e.preventDefault();
                e.originalEvent.keepTextCompleteDropdown = true;
                if (!$e.hasClass('textcomplete-item')) {
                    $e = $e.parents('li.textcomplete-item');
                }
                this.select(parseInt($e.data('index'), 10));
            },

            onMouseover: function (e){
                var $e = $(e.target);
                e.preventDefault();
                if(!$e.hasClass('textcomplete-item')) {
                    $e = $e.parents('li.textcomplete-item');
                }
                this.index = parseInt($e.data('index'), 10)
                this.activateIndexedItem();
            },

            destroy: function () {
                this.deactivate();
                this.$el.off('click.textComplete').remove();
                this.$el = null;
            },

            appendTo: function ($el) {
                $el.css({ position: 'relative' }).append(this.$el)
            }
        });

        return ListView;
    })();

    $.fn.textcomplete = function (strategies, option) {
        var i, l, strategy, dataKey;

        dataKey = 'textComplete';
        option || (option = {});

        if (strategies === 'destroy') {
            return this.each(function () {
                var completer = $(this).data(dataKey);
                if (completer) { completer.destroy(); }
            });
        }

        for (i = 0, l = strategies.length; i < l; i++) {
            strategy = strategies[i];
            if (!strategy.template) {
                strategy.template = identity;
            }
            if (strategy.index == null) {
                strategy.index = 2;
            }
            if (strategy.placement == null) {
                strategy.placement = '';
            }
            if (strategy.cache) {
                strategy.search = memoize(strategy.search);
            }
            strategy.maxCount || (strategy.maxCount = 10);
        }

        return this.each(function () {
            var $this, completer;
            $this = $(this);
            completer = $this.data(dataKey);
            if (!completer) {
                completer = new Completer($this, option);
                $this.data(dataKey, completer);
            }
            completer.register(strategies);
        });
    };

})(window.jQuery || window.Zepto);

(function(){"use strict";function a(a){var b=this,c={db:null};if(a)for(var d in a)c[d]=a[d];return new m(function(a,d){var e=n.open(c.name,c.version);e.onerror=function(){d(e.error)},e.onupgradeneeded=function(){e.result.createObjectStore(c.storeName)},e.onsuccess=function(){c.db=e.result,b._dbInfo=c,a()}})}function b(a,b){var c=this;"string"!=typeof a&&(window.console.warn(a+" used as a key, but it is not a string."),a=String(a));var d=new m(function(b,d){c.ready().then(function(){var e=c._dbInfo,f=e.db.transaction(e.storeName,"readonly").objectStore(e.storeName),g=f.get(a);g.onsuccess=function(){var a=g.result;void 0===a&&(a=null),b(a)},g.onerror=function(){d(g.error)}})["catch"](d)});return k(d,b),d}function c(a,b){var c=this,d=new m(function(b,d){c.ready().then(function(){var e=c._dbInfo,f=e.db.transaction(e.storeName,"readonly").objectStore(e.storeName),g=f.openCursor();g.onsuccess=function(){var c=g.result;if(c){var d=a(c.value,c.key);void 0!==d?b(d):c["continue"]()}else b()},g.onerror=function(){d(g.error)}})["catch"](d)});return k(d,b),d}function d(a,b,c){var d=this;"string"!=typeof a&&(window.console.warn(a+" used as a key, but it is not a string."),a=String(a));var e=new m(function(c,e){d.ready().then(function(){var f=d._dbInfo,g=f.db.transaction(f.storeName,"readwrite"),h=g.objectStore(f.storeName);null===b&&(b=void 0);var i=h.put(b,a);g.oncomplete=function(){void 0===b&&(b=null),c(b)},g.onabort=g.onerror=function(){e(i.error)}})["catch"](e)});return k(e,c),e}function e(a,b){var c=this;"string"!=typeof a&&(window.console.warn(a+" used as a key, but it is not a string."),a=String(a));var d=new m(function(b,d){c.ready().then(function(){var e=c._dbInfo,f=e.db.transaction(e.storeName,"readwrite"),g=f.objectStore(e.storeName),h=g["delete"](a);f.oncomplete=function(){b()},f.onerror=function(){d(h.error)},f.onabort=function(a){var b=a.target.error;"QuotaExceededError"===b&&d(b)}})["catch"](d)});return k(d,b),d}function f(a){var b=this,c=new m(function(a,c){b.ready().then(function(){var d=b._dbInfo,e=d.db.transaction(d.storeName,"readwrite"),f=e.objectStore(d.storeName),g=f.clear();e.oncomplete=function(){a()},e.onabort=e.onerror=function(){c(g.error)}})["catch"](c)});return k(c,a),c}function g(a){var b=this,c=new m(function(a,c){b.ready().then(function(){var d=b._dbInfo,e=d.db.transaction(d.storeName,"readonly").objectStore(d.storeName),f=e.count();f.onsuccess=function(){a(f.result)},f.onerror=function(){c(f.error)}})["catch"](c)});return j(c,a),c}function h(a,b){var c=this,d=new m(function(b,d){return 0>a?void b(null):void c.ready().then(function(){var e=c._dbInfo,f=e.db.transaction(e.storeName,"readonly").objectStore(e.storeName),g=!1,h=f.openCursor();h.onsuccess=function(){var c=h.result;return c?void(0===a?b(c.key):g?b(c.key):(g=!0,c.advance(a))):void b(null)},h.onerror=function(){d(h.error)}})["catch"](d)});return j(d,b),d}function i(a){var b=this,c=new m(function(a,c){b.ready().then(function(){var d=b._dbInfo,e=d.db.transaction(d.storeName,"readonly").objectStore(d.storeName),f=e.openCursor(),g=[];f.onsuccess=function(){var b=f.result;return b?(g.push(b.key),void b["continue"]()):void a(g)},f.onerror=function(){c(f.error)}})["catch"](c)});return j(c,a),c}function j(a,b){b&&a.then(function(a){b(null,a)},function(a){b(a)})}function k(a,b){b&&a.then(function(a){l(b,a)},function(a){b(a)})}function l(a,b){return a?setTimeout(function(){return a(null,b)},0):void 0}var m="undefined"!=typeof module&&module.exports?require("promise"):this.Promise,n=n||this.indexedDB||this.webkitIndexedDB||this.mozIndexedDB||this.OIndexedDB||this.msIndexedDB;if(n){var o={_driver:"asyncStorage",_initStorage:a,iterate:c,getItem:b,setItem:d,removeItem:e,clear:f,length:g,key:h,keys:i};"function"==typeof define&&define.amd?define("asyncStorage",function(){return o}):"undefined"!=typeof module&&module.exports?module.exports=o:this.asyncStorage=o}}).call(window),function(){"use strict";function a(a){var b=this,c={};if(a)for(var d in a)c[d]=a[d];return c.keyPrefix=c.name+"/",b._dbInfo=c,n.resolve()}function b(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo.keyPrefix,c=o.length-1;c>=0;c--){var d=o.key(c);0===d.indexOf(a)&&o.removeItem(d)}});return m(c,a),c}function c(a,b){var c=this;"string"!=typeof a&&(window.console.warn(a+" used as a key, but it is not a string."),a=String(a));var d=c.ready().then(function(){var b=c._dbInfo,d=o.getItem(b.keyPrefix+a);return d&&(d=i(d)),d});return m(d,b),d}function d(a,b){var c=this,d=c.ready().then(function(){for(var b=c._dbInfo.keyPrefix,d=b.length,e=o.length,f=0;e>f;f++){var g=o.key(f),h=o.getItem(g);if(h&&(h=i(h)),h=a(h,g.substring(d)),void 0!==h)return h}});return m(d,b),d}function e(a,b){var c=this,d=c.ready().then(function(){var b,d=c._dbInfo;try{b=o.key(a)}catch(e){b=null}return b&&(b=b.substring(d.keyPrefix.length)),b});return m(d,b),d}function f(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo,c=o.length,d=[],e=0;c>e;e++)0===o.key(e).indexOf(a.keyPrefix)&&d.push(o.key(e).substring(a.keyPrefix.length));return d});return m(c,a),c}function g(a){var b=this,c=b.keys().then(function(a){return a.length});return m(c,a),c}function h(a,b){var c=this;"string"!=typeof a&&(window.console.warn(a+" used as a key, but it is not a string."),a=String(a));var d=c.ready().then(function(){var b=c._dbInfo;o.removeItem(b.keyPrefix+a)});return m(d,b),d}function i(a){if(a.substring(0,r)!==q)return JSON.parse(a);for(var b=a.substring(D),c=a.substring(r,D),d=new ArrayBuffer(2*b.length),e=new Uint16Array(d),f=b.length-1;f>=0;f--)e[f]=b.charCodeAt(f);switch(c){case s:return d;case t:return new Blob([d]);case u:return new Int8Array(d);case v:return new Uint8Array(d);case w:return new Uint8ClampedArray(d);case x:return new Int16Array(d);case z:return new Uint16Array(d);case y:return new Int32Array(d);case A:return new Uint32Array(d);case B:return new Float32Array(d);case C:return new Float64Array(d);default:throw new Error("Unkown type: "+c)}}function j(a){var b="",c=new Uint16Array(a);try{b=String.fromCharCode.apply(null,c)}catch(d){for(var e=0;e<c.length;e++)b+=String.fromCharCode(c[e])}return b}function k(a,b){var c="";if(a&&(c=a.toString()),a&&("[object ArrayBuffer]"===a.toString()||a.buffer&&"[object ArrayBuffer]"===a.buffer.toString())){var d,e=q;a instanceof ArrayBuffer?(d=a,e+=s):(d=a.buffer,"[object Int8Array]"===c?e+=u:"[object Uint8Array]"===c?e+=v:"[object Uint8ClampedArray]"===c?e+=w:"[object Int16Array]"===c?e+=x:"[object Uint16Array]"===c?e+=z:"[object Int32Array]"===c?e+=y:"[object Uint32Array]"===c?e+=A:"[object Float32Array]"===c?e+=B:"[object Float64Array]"===c?e+=C:b(new Error("Failed to get type for BinaryArray"))),b(e+j(d))}else if("[object Blob]"===c){var f=new FileReader;f.onload=function(){var a=j(this.result);b(q+t+a)},f.readAsArrayBuffer(a)}else try{b(JSON.stringify(a))}catch(g){window.console.error("Couldn't convert value into a JSON string: ",a),b(g)}}function l(a,b,c){var d=this;"string"!=typeof a&&(window.console.warn(a+" used as a key, but it is not a string."),a=String(a));var e=d.ready().then(function(){void 0===b&&(b=null);var c=b;return k(b,function(b,c){if(c)throw c;try{var e=d._dbInfo;o.setItem(e.keyPrefix+a,b)}catch(f){if("QuotaExceededError"===f.name||"NS_ERROR_DOM_QUOTA_REACHED"===f.name)throw f}}),c});return m(e,c),e}function m(a,b){b&&a.then(function(a){b(null,a)},function(a){b(a)})}var n="undefined"!=typeof module&&module.exports?require("promise"):this.Promise,o=null;try{if(!(this.localStorage&&"setItem"in this.localStorage))return;o=this.localStorage}catch(p){return}var q="__lfsc__:",r=q.length,s="arbf",t="blob",u="si08",v="ui08",w="uic8",x="si16",y="si32",z="ur16",A="ui32",B="fl32",C="fl64",D=r+s.length,E={_driver:"localStorageWrapper",_initStorage:a,iterate:d,getItem:c,setItem:l,removeItem:h,clear:b,length:g,key:e,keys:f};"function"==typeof define&&define.amd?define("localStorageWrapper",function(){return E}):"undefined"!=typeof module&&module.exports?module.exports=E:this.localStorageWrapper=E}.call(window),function(){"use strict";function a(a){var b=this,c={db:null};if(a)for(var d in a)c[d]="string"!=typeof a[d]?a[d].toString():a[d];return new o(function(d,e){try{c.db=p(c.name,String(c.version),c.description,c.size)}catch(f){return b.setDriver("localStorageWrapper").then(function(){return b._initStorage(a)}).then(d)["catch"](e)}c.db.transaction(function(a){a.executeSql("CREATE TABLE IF NOT EXISTS "+c.storeName+" (id INTEGER PRIMARY KEY, key unique, value)",[],function(){b._dbInfo=c,d()},function(a,b){e(b)})})})}function b(a,b){var c=this;"string"!=typeof a&&(window.console.warn(a+" used as a key, but it is not a string."),a=String(a));var d=new o(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){c.executeSql("SELECT * FROM "+e.storeName+" WHERE key = ? LIMIT 1",[a],function(a,c){var d=c.rows.length?c.rows.item(0).value:null;d&&(d=k(d)),b(d)},function(a,b){d(b)})})})["catch"](d)});return m(d,b),d}function c(a,b){var c=this,d=new o(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){c.executeSql("SELECT * FROM "+e.storeName,[],function(c,d){for(var e=d.rows,f=e.length,g=0;f>g;g++){var h=e.item(g),i=h.value;if(i&&(i=k(i)),i=a(i,h.key),void 0!==i)return void b(i)}b()},function(a,b){d(b)})})})["catch"](d)});return m(d,b),d}function d(a,b,c){var d=this;"string"!=typeof a&&(window.console.warn(a+" used as a key, but it is not a string."),a=String(a));var e=new o(function(c,e){d.ready().then(function(){void 0===b&&(b=null);var f=b;l(b,function(b,g){if(g)e(g);else{var h=d._dbInfo;h.db.transaction(function(d){d.executeSql("INSERT OR REPLACE INTO "+h.storeName+" (key, value) VALUES (?, ?)",[a,b],function(){c(f)},function(a,b){e(b)})},function(a){a.code===a.QUOTA_ERR&&e(a)})}})})["catch"](e)});return m(e,c),e}function e(a,b){var c=this;"string"!=typeof a&&(window.console.warn(a+" used as a key, but it is not a string."),a=String(a));var d=new o(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){c.executeSql("DELETE FROM "+e.storeName+" WHERE key = ?",[a],function(){b()},function(a,b){d(b)})})})["catch"](d)});return m(d,b),d}function f(a){var b=this,c=new o(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){b.executeSql("DELETE FROM "+d.storeName,[],function(){a()},function(a,b){c(b)})})})["catch"](c)});return m(c,a),c}function g(a){var b=this,c=new o(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){b.executeSql("SELECT COUNT(key) as c FROM "+d.storeName,[],function(b,c){var d=c.rows.item(0).c;a(d)},function(a,b){c(b)})})})["catch"](c)});return m(c,a),c}function h(a,b){var c=this,d=new o(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){c.executeSql("SELECT key FROM "+e.storeName+" WHERE id = ? LIMIT 1",[a+1],function(a,c){var d=c.rows.length?c.rows.item(0).key:null;b(d)},function(a,b){d(b)})})})["catch"](d)});return m(d,b),d}function i(a){var b=this,c=new o(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){b.executeSql("SELECT key FROM "+d.storeName,[],function(b,c){for(var d=[],e=0;e<c.rows.length;e++)d.push(c.rows.item(e).key);a(d)},function(a,b){c(b)})})})["catch"](c)});return m(c,a),c}function j(a){var b,c=new Uint8Array(a),d="";for(b=0;b<c.length;b+=3)d+=n[c[b]>>2],d+=n[(3&c[b])<<4|c[b+1]>>4],d+=n[(15&c[b+1])<<2|c[b+2]>>6],d+=n[63&c[b+2]];return c.length%3===2?d=d.substring(0,d.length-1)+"=":c.length%3===1&&(d=d.substring(0,d.length-2)+"=="),d}function k(a){if(a.substring(0,r)!==q)return JSON.parse(a);var b,c,d,e,f,g=a.substring(D),h=a.substring(r,D),i=.75*g.length,j=g.length,k=0;"="===g[g.length-1]&&(i--,"="===g[g.length-2]&&i--);var l=new ArrayBuffer(i),m=new Uint8Array(l);for(b=0;j>b;b+=4)c=n.indexOf(g[b]),d=n.indexOf(g[b+1]),e=n.indexOf(g[b+2]),f=n.indexOf(g[b+3]),m[k++]=c<<2|d>>4,m[k++]=(15&d)<<4|e>>2,m[k++]=(3&e)<<6|63&f;switch(h){case s:return l;case t:return new Blob([l]);case u:return new Int8Array(l);case v:return new Uint8Array(l);case w:return new Uint8ClampedArray(l);case x:return new Int16Array(l);case z:return new Uint16Array(l);case y:return new Int32Array(l);case A:return new Uint32Array(l);case B:return new Float32Array(l);case C:return new Float64Array(l);default:throw new Error("Unkown type: "+h)}}function l(a,b){var c="";if(a&&(c=a.toString()),a&&("[object ArrayBuffer]"===a.toString()||a.buffer&&"[object ArrayBuffer]"===a.buffer.toString())){var d,e=q;a instanceof ArrayBuffer?(d=a,e+=s):(d=a.buffer,"[object Int8Array]"===c?e+=u:"[object Uint8Array]"===c?e+=v:"[object Uint8ClampedArray]"===c?e+=w:"[object Int16Array]"===c?e+=x:"[object Uint16Array]"===c?e+=z:"[object Int32Array]"===c?e+=y:"[object Uint32Array]"===c?e+=A:"[object Float32Array]"===c?e+=B:"[object Float64Array]"===c?e+=C:b(new Error("Failed to get type for BinaryArray"))),b(e+j(d))}else if("[object Blob]"===c){var f=new FileReader;f.onload=function(){var a=j(this.result);b(q+t+a)},f.readAsArrayBuffer(a)}else try{b(JSON.stringify(a))}catch(g){window.console.error("Couldn't convert value into a JSON string: ",a),b(null,g)}}function m(a,b){b&&a.then(function(a){b(null,a)},function(a){b(a)})}var n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o="undefined"!=typeof module&&module.exports?require("promise"):this.Promise,p=this.openDatabase,q="__lfsc__:",r=q.length,s="arbf",t="blob",u="si08",v="ui08",w="uic8",x="si16",y="si32",z="ur16",A="ui32",B="fl32",C="fl64",D=r+s.length;if(p){var E={_driver:"webSQLStorage",_initStorage:a,iterate:c,getItem:b,setItem:d,removeItem:e,clear:f,length:g,key:h,keys:i};"function"==typeof define&&define.amd?define("webSQLStorage",function(){return E}):"undefined"!=typeof module&&module.exports?module.exports=E:this.webSQLStorage=E}}.call(window),function(){"use strict";function a(a,b){a[b]=function(){var c=arguments;return a.ready().then(function(){return a[b].apply(a,c)})}}function b(){for(var a=1;a<arguments.length;a++){var b=arguments[a];if(b)for(var c in b)b.hasOwnProperty(c)&&(arguments[0][c]=n(b[c])?b[c].slice():b[c])}return arguments[0]}function c(a){for(var b in g)if(g.hasOwnProperty(b)&&g[b]===a)return!0;return!1}function d(c){this._config=b({},k,c),this._driverSet=null,this._ready=!1,this._dbInfo=null;for(var d=0;d<i.length;d++)a(this,i[d]);this.setDriver(this._config.driver)}var e="undefined"!=typeof module&&module.exports?require("promise"):this.Promise,f={},g={INDEXEDDB:"asyncStorage",LOCALSTORAGE:"localStorageWrapper",WEBSQL:"webSQLStorage"},h=[g.INDEXEDDB,g.WEBSQL,g.LOCALSTORAGE],i=["clear","getItem","iterate","key","keys","length","removeItem","setItem"],j={DEFINE:1,EXPORT:2,WINDOW:3},k={description:"",driver:h.slice(),name:"localforage",size:4980736,storeName:"keyvaluepairs",version:1},l=j.WINDOW;"function"==typeof define&&define.amd?l=j.DEFINE:"undefined"!=typeof module&&module.exports&&(l=j.EXPORT);var m=function(a){var b=b||a.indexedDB||a.webkitIndexedDB||a.mozIndexedDB||a.OIndexedDB||a.msIndexedDB,c={};return c[g.WEBSQL]=!!a.openDatabase,c[g.INDEXEDDB]=!!function(){if("undefined"!=typeof a.openDatabase&&a.navigator&&a.navigator.userAgent&&/Safari/.test(a.navigator.userAgent)&&!/Chrome/.test(a.navigator.userAgent))return!1;try{return b&&"function"==typeof b.open&&"undefined"!=typeof a.IDBKeyRange}catch(c){return!1}}(),c[g.LOCALSTORAGE]=!!function(){try{return a.localStorage&&"setItem"in a.localStorage&&a.localStorage.setItem}catch(b){return!1}}(),c}(this),n=Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)},o=this;d.prototype.INDEXEDDB=g.INDEXEDDB,d.prototype.LOCALSTORAGE=g.LOCALSTORAGE,d.prototype.WEBSQL=g.WEBSQL,d.prototype.config=function(a){if("object"==typeof a){if(this._ready)return new Error("Can't call config() after localforage has been used.");for(var b in a)"storeName"===b&&(a[b]=a[b].replace(/\W/g,"_")),this._config[b]=a[b];return"driver"in a&&a.driver&&this.setDriver(this._config.driver),!0}return"string"==typeof a?this._config[a]:this._config},d.prototype.defineDriver=function(a,b,d){var g=new e(function(b,d){try{var g=a._driver,h=new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver"),j=new Error("Custom driver name already in use: "+a._driver);if(!a._driver)return void d(h);if(c(a._driver))return void d(j);for(var k=i.concat("_initStorage"),l=0;l<k.length;l++){var n=k[l];if(!n||!a[n]||"function"!=typeof a[n])return void d(h)}var o=e.resolve(!0);"_support"in a&&(o=a._support&&"function"==typeof a._support?a._support():e.resolve(!!a._support)),o.then(function(c){m[g]=c,f[g]=a,b()},d)}catch(p){d(p)}});return g.then(b,d),g},d.prototype.driver=function(){return this._driver||null},d.prototype.ready=function(a){var b=this,c=new e(function(a,c){b._driverSet.then(function(){null===b._ready&&(b._ready=b._initStorage(b._config)),b._ready.then(a,c)})["catch"](c)});return c.then(a,a),c},d.prototype.setDriver=function(a,b,d){function g(){h._config.driver=h.driver()}var h=this;return"string"==typeof a&&(a=[a]),this._driverSet=new e(function(b,d){var g=h._getFirstSupportedDriver(a),i=new Error("No available storage method found.");if(!g)return h._driverSet=e.reject(i),void d(i);if(h._dbInfo=null,h._ready=null,c(g)){if(l===j.DEFINE)return void require([g],function(a){h._extend(a),b()});if(l===j.EXPORT){var k;switch(g){case h.INDEXEDDB:k=require("./drivers/indexeddb");break;case h.LOCALSTORAGE:k=require("./drivers/localstorage");break;case h.WEBSQL:k=require("./drivers/websql")}h._extend(k)}else h._extend(o[g])}else{if(!f[g])return h._driverSet=e.reject(i),void d(i);h._extend(f[g])}b()}),this._driverSet.then(g,g),this._driverSet.then(b,d),this._driverSet},d.prototype.supports=function(a){return!!m[a]},d.prototype._extend=function(a){b(this,a)},d.prototype._getFirstSupportedDriver=function(a){if(a&&n(a))for(var b=0;b<a.length;b++){var c=a[b];if(this.supports(c))return c}return null},d.prototype.createInstance=function(a){return new d(a)};var p=new d;l===j.DEFINE?define("localforage",function(){return p}):l===j.EXPORT?module.exports=p:this.localforage=p}.call(window);
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */
(function(){var block={newline:/^\n+/,code:/^( {4}[^\n]+\n*)+/,fences:noop,hr:/^( *[-*_]){3,} *(?:\n+|$)/,heading:/^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,nptable:noop,lheading:/^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,blockquote:/^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,list:/^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,html:/^ *(?:comment|closed|closing) *(?:\n{2,}|\s*$)/,def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,table:noop,paragraph:/^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,text:/^[^\n]+/};block.bullet=/(?:[*+-]|\d+\.)/;block.item=/^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;block.item=replace(block.item,"gm")(/bull/g,block.bullet)();block.list=replace(block.list)(/bull/g,block.bullet)("hr","\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))")("def","\\n+(?="+block.def.source+")")();block.blockquote=replace(block.blockquote)("def",block.def)();block._tag="(?!(?:"+"a|em|strong|small|s|cite|q|dfn|abbr|data|time|code"+"|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo"+"|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b";block.html=replace(block.html)("comment",/<!--[\s\S]*?-->/)("closed",/<(tag)[\s\S]+?<\/\1>/)("closing",/<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)(/tag/g,block._tag)();block.paragraph=replace(block.paragraph)("hr",block.hr)("heading",block.heading)("lheading",block.lheading)("blockquote",block.blockquote)("tag","<"+block._tag)("def",block.def)();block.normal=merge({},block);block.gfm=merge({},block.normal,{fences:/^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,paragraph:/^/});block.gfm.paragraph=replace(block.paragraph)("(?!","(?!"+block.gfm.fences.source.replace("\\1","\\2")+"|"+block.list.source.replace("\\1","\\3")+"|")();block.tables=merge({},block.gfm,{nptable:/^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,table:/^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/});function Lexer(options){this.tokens=[];this.tokens.links={};this.options=options||marked.defaults;this.rules=block.normal;if(this.options.gfm){if(this.options.tables){this.rules=block.tables}else{this.rules=block.gfm}}}Lexer.rules=block;Lexer.lex=function(src,options){var lexer=new Lexer(options);return lexer.lex(src)};Lexer.prototype.lex=function(src){src=src.replace(/\r\n|\r/g,"\n").replace(/\t/g,"    ").replace(/\u00a0/g," ").replace(/\u2424/g,"\n");return this.token(src,true)};Lexer.prototype.token=function(src,top,bq){var src=src.replace(/^ +$/gm,""),next,loose,cap,bull,b,item,space,i,l;while(src){if(cap=this.rules.newline.exec(src)){src=src.substring(cap[0].length);if(cap[0].length>1){this.tokens.push({type:"space"})}}if(cap=this.rules.code.exec(src)){src=src.substring(cap[0].length);cap=cap[0].replace(/^ {4}/gm,"");this.tokens.push({type:"code",text:!this.options.pedantic?cap.replace(/\n+$/,""):cap});continue}if(cap=this.rules.fences.exec(src)){src=src.substring(cap[0].length);this.tokens.push({type:"code",lang:cap[2],text:cap[3]});continue}if(cap=this.rules.heading.exec(src)){src=src.substring(cap[0].length);this.tokens.push({type:"heading",depth:cap[1].length,text:cap[2]});continue}if(top&&(cap=this.rules.nptable.exec(src))){src=src.substring(cap[0].length);item={type:"table",header:cap[1].replace(/^ *| *\| *$/g,"").split(/ *\| */),align:cap[2].replace(/^ *|\| *$/g,"").split(/ *\| */),cells:cap[3].replace(/\n$/,"").split("\n")};for(i=0;i<item.align.length;i++){if(/^ *-+: *$/.test(item.align[i])){item.align[i]="right"}else if(/^ *:-+: *$/.test(item.align[i])){item.align[i]="center"}else if(/^ *:-+ *$/.test(item.align[i])){item.align[i]="left"}else{item.align[i]=null}}for(i=0;i<item.cells.length;i++){item.cells[i]=item.cells[i].split(/ *\| */)}this.tokens.push(item);continue}if(cap=this.rules.lheading.exec(src)){src=src.substring(cap[0].length);this.tokens.push({type:"heading",depth:cap[2]==="="?1:2,text:cap[1]});continue}if(cap=this.rules.hr.exec(src)){src=src.substring(cap[0].length);this.tokens.push({type:"hr"});continue}if(cap=this.rules.blockquote.exec(src)){src=src.substring(cap[0].length);this.tokens.push({type:"blockquote_start"});cap=cap[0].replace(/^ *> ?/gm,"");this.token(cap,top,true);this.tokens.push({type:"blockquote_end"});continue}if(cap=this.rules.list.exec(src)){src=src.substring(cap[0].length);bull=cap[2];this.tokens.push({type:"list_start",ordered:bull.length>1});cap=cap[0].match(this.rules.item);next=false;l=cap.length;i=0;for(;i<l;i++){item=cap[i];space=item.length;item=item.replace(/^ *([*+-]|\d+\.) +/,"");if(~item.indexOf("\n ")){space-=item.length;item=!this.options.pedantic?item.replace(new RegExp("^ {1,"+space+"}","gm"),""):item.replace(/^ {1,4}/gm,"")}if(this.options.smartLists&&i!==l-1){b=block.bullet.exec(cap[i+1])[0];if(bull!==b&&!(bull.length>1&&b.length>1)){src=cap.slice(i+1).join("\n")+src;i=l-1}}loose=next||/\n\n(?!\s*$)/.test(item);if(i!==l-1){next=item.charAt(item.length-1)==="\n";if(!loose)loose=next}this.tokens.push({type:loose?"loose_item_start":"list_item_start"});this.token(item,false,bq);this.tokens.push({type:"list_item_end"})}this.tokens.push({type:"list_end"});continue}if(cap=this.rules.html.exec(src)){src=src.substring(cap[0].length);this.tokens.push({type:this.options.sanitize?"paragraph":"html",pre:cap[1]==="pre"||cap[1]==="script"||cap[1]==="style",text:cap[0]});continue}if(!bq&&top&&(cap=this.rules.def.exec(src))){src=src.substring(cap[0].length);this.tokens.links[cap[1].toLowerCase()]={href:cap[2],title:cap[3]};continue}if(top&&(cap=this.rules.table.exec(src))){src=src.substring(cap[0].length);item={type:"table",header:cap[1].replace(/^ *| *\| *$/g,"").split(/ *\| */),align:cap[2].replace(/^ *|\| *$/g,"").split(/ *\| */),cells:cap[3].replace(/(?: *\| *)?\n$/,"").split("\n")};for(i=0;i<item.align.length;i++){if(/^ *-+: *$/.test(item.align[i])){item.align[i]="right"}else if(/^ *:-+: *$/.test(item.align[i])){item.align[i]="center"}else if(/^ *:-+ *$/.test(item.align[i])){item.align[i]="left"}else{item.align[i]=null}}for(i=0;i<item.cells.length;i++){item.cells[i]=item.cells[i].replace(/^ *\| *| *\| *$/g,"").split(/ *\| */)}this.tokens.push(item);continue}if(top&&(cap=this.rules.paragraph.exec(src))){src=src.substring(cap[0].length);this.tokens.push({type:"paragraph",text:cap[1].charAt(cap[1].length-1)==="\n"?cap[1].slice(0,-1):cap[1]});continue}if(cap=this.rules.text.exec(src)){src=src.substring(cap[0].length);this.tokens.push({type:"text",text:cap[0]});continue}if(src){throw new Error("Infinite loop on byte: "+src.charCodeAt(0))}}return this.tokens};var inline={escape:/^\\([\\`*{}\[\]()#+\-.!_>])/,autolink:/^<([^ >]+(@|:\/)[^ >]+)>/,url:noop,tag:/^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,link:/^!?\[(inside)\]\(href\)/,reflink:/^!?\[(inside)\]\s*\[([^\]]*)\]/,nolink:/^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,strong:/^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,em:/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,code:/^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,br:/^ {2,}\n(?!\s*$)/,del:noop,text:/^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/};inline._inside=/(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;inline._href=/\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;inline.link=replace(inline.link)("inside",inline._inside)("href",inline._href)();inline.reflink=replace(inline.reflink)("inside",inline._inside)();inline.normal=merge({},inline);inline.pedantic=merge({},inline.normal,{strong:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,em:/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/});inline.gfm=merge({},inline.normal,{escape:replace(inline.escape)("])","~|])")(),url:/^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,del:/^~~(?=\S)([\s\S]*?\S)~~/,text:replace(inline.text)("]|","~]|")("|","|https?://|")()});inline.breaks=merge({},inline.gfm,{br:replace(inline.br)("{2,}","*")(),text:replace(inline.gfm.text)("{2,}","*")()});function InlineLexer(links,options){this.options=options||marked.defaults;this.links=links;this.rules=inline.normal;this.renderer=this.options.renderer||new Renderer;this.renderer.options=this.options;if(!this.links){throw new Error("Tokens array requires a `links` property.")}if(this.options.gfm){if(this.options.breaks){this.rules=inline.breaks}else{this.rules=inline.gfm}}else if(this.options.pedantic){this.rules=inline.pedantic}}InlineLexer.rules=inline;InlineLexer.output=function(src,links,options){var inline=new InlineLexer(links,options);return inline.output(src)};InlineLexer.prototype.output=function(src){var out="",link,text,href,cap;while(src){if(cap=this.rules.escape.exec(src)){src=src.substring(cap[0].length);out+=cap[1];continue}if(cap=this.rules.autolink.exec(src)){src=src.substring(cap[0].length);if(cap[2]==="@"){text=cap[1].charAt(6)===":"?this.mangle(cap[1].substring(7)):this.mangle(cap[1]);href=this.mangle("mailto:")+text}else{text=escape(cap[1]);href=text}out+=this.renderer.link(href,null,text);continue}if(!this.inLink&&(cap=this.rules.url.exec(src))){src=src.substring(cap[0].length);text=escape(cap[1]);href=text;out+=this.renderer.link(href,null,text);continue}if(cap=this.rules.tag.exec(src)){if(!this.inLink&&/^<a /i.test(cap[0])){this.inLink=true}else if(this.inLink&&/^<\/a>/i.test(cap[0])){this.inLink=false}src=src.substring(cap[0].length);out+=this.options.sanitize?escape(cap[0]):cap[0];continue}if(cap=this.rules.link.exec(src)){src=src.substring(cap[0].length);this.inLink=true;out+=this.outputLink(cap,{href:cap[2],title:cap[3]});this.inLink=false;continue}if((cap=this.rules.reflink.exec(src))||(cap=this.rules.nolink.exec(src))){src=src.substring(cap[0].length);link=(cap[2]||cap[1]).replace(/\s+/g," ");link=this.links[link.toLowerCase()];if(!link||!link.href){out+=cap[0].charAt(0);src=cap[0].substring(1)+src;continue}this.inLink=true;out+=this.outputLink(cap,link);this.inLink=false;continue}if(cap=this.rules.strong.exec(src)){src=src.substring(cap[0].length);out+=this.renderer.strong(this.output(cap[2]||cap[1]));continue}if(cap=this.rules.em.exec(src)){src=src.substring(cap[0].length);out+=this.renderer.em(this.output(cap[2]||cap[1]));continue}if(cap=this.rules.code.exec(src)){src=src.substring(cap[0].length);out+=this.renderer.codespan(escape(cap[2],true));continue}if(cap=this.rules.br.exec(src)){src=src.substring(cap[0].length);out+=this.renderer.br();continue}if(cap=this.rules.del.exec(src)){src=src.substring(cap[0].length);out+=this.renderer.del(this.output(cap[1]));continue}if(cap=this.rules.text.exec(src)){src=src.substring(cap[0].length);out+=escape(this.smartypants(cap[0]));continue}if(src){throw new Error("Infinite loop on byte: "+src.charCodeAt(0))}}return out};InlineLexer.prototype.outputLink=function(cap,link){var href=escape(link.href),title=link.title?escape(link.title):null;return cap[0].charAt(0)!=="!"?this.renderer.link(href,title,this.output(cap[1])):this.renderer.image(href,title,escape(cap[1]))};InlineLexer.prototype.smartypants=function(text){if(!this.options.smartypants)return text;return text.replace(/--/g,"").replace(/(^|[-\u2014/(\[{"\s])'/g,"$1").replace(/'/g,"").replace(/(^|[-\u2014/(\[{\u2018\s])"/g,"$1").replace(/"/g,"").replace(/\.{3}/g,"")};InlineLexer.prototype.mangle=function(text){var out="",l=text.length,i=0,ch;for(;i<l;i++){ch=text.charCodeAt(i);if(Math.random()>.5){ch="x"+ch.toString(16)}out+="&#"+ch+";"}return out};function Renderer(options){this.options=options||{}}Renderer.prototype.code=function(code,lang,escaped){if(this.options.highlight){var out=this.options.highlight(code,lang);if(out!=null&&out!==code){escaped=true;code=out}}if(!lang){return"<pre><code>"+(escaped?code:escape(code,true))+"\n</code></pre>"}return'<pre><code class="'+this.options.langPrefix+escape(lang,true)+'">'+(escaped?code:escape(code,true))+"\n</code></pre>\n"};Renderer.prototype.blockquote=function(quote){return"<blockquote>\n"+quote+"</blockquote>\n"};Renderer.prototype.html=function(html){return html};Renderer.prototype.heading=function(text,level,raw){return"<h"+level+' id="'+this.options.headerPrefix+raw.toLowerCase().replace(/[^\w]+/g,"-")+'">'+text+"</h"+level+">\n"};Renderer.prototype.hr=function(){return this.options.xhtml?"<hr/>\n":"<hr>\n"};Renderer.prototype.list=function(body,ordered){var type=ordered?"ol":"ul";return"<"+type+">\n"+body+"</"+type+">\n"};Renderer.prototype.listitem=function(text){return"<li>"+text+"</li>\n"};Renderer.prototype.paragraph=function(text){return"<p>"+text+"</p>\n"};Renderer.prototype.table=function(header,body){return"<table>\n"+"<thead>\n"+header+"</thead>\n"+"<tbody>\n"+body+"</tbody>\n"+"</table>\n"};Renderer.prototype.tablerow=function(content){return"<tr>\n"+content+"</tr>\n"};Renderer.prototype.tablecell=function(content,flags){var type=flags.header?"th":"td";var tag=flags.align?"<"+type+' style="text-align:'+flags.align+'">':"<"+type+">";return tag+content+"</"+type+">\n"};Renderer.prototype.strong=function(text){return"<strong>"+text+"</strong>"};Renderer.prototype.em=function(text){return"<em>"+text+"</em>"};Renderer.prototype.codespan=function(text){return"<code>"+text+"</code>"};Renderer.prototype.br=function(){return this.options.xhtml?"<br/>":"<br>"};Renderer.prototype.del=function(text){return"<del>"+text+"</del>"};Renderer.prototype.link=function(href,title,text){if(this.options.sanitize){try{var prot=decodeURIComponent(unescape(href)).replace(/[^\w:]/g,"").toLowerCase()}catch(e){return""}if(prot.indexOf("javascript:")===0){return""}}var out='<a href="'+href+'"';if(title){out+=' title="'+title+'"'}out+=">"+text+"</a>";return out};Renderer.prototype.image=function(href,title,text){var out='<img src="'+href+'" alt="'+text+'"';if(title){out+=' title="'+title+'"'}out+=this.options.xhtml?"/>":">";return out};function Parser(options){this.tokens=[];this.token=null;this.options=options||marked.defaults;this.options.renderer=this.options.renderer||new Renderer;this.renderer=this.options.renderer;this.renderer.options=this.options}Parser.parse=function(src,options,renderer){var parser=new Parser(options,renderer);return parser.parse(src)};Parser.prototype.parse=function(src){this.inline=new InlineLexer(src.links,this.options,this.renderer);this.tokens=src.reverse();var out="";while(this.next()){out+=this.tok()}return out};Parser.prototype.next=function(){return this.token=this.tokens.pop()};Parser.prototype.peek=function(){return this.tokens[this.tokens.length-1]||0};Parser.prototype.parseText=function(){var body=this.token.text;while(this.peek().type==="text"){body+="\n"+this.next().text}return this.inline.output(body)};Parser.prototype.tok=function(){switch(this.token.type){case"space":{return""}case"hr":{return this.renderer.hr()}case"heading":{return this.renderer.heading(this.inline.output(this.token.text),this.token.depth,this.token.text)}case"code":{return this.renderer.code(this.token.text,this.token.lang,this.token.escaped)}case"table":{var header="",body="",i,row,cell,flags,j;cell="";for(i=0;i<this.token.header.length;i++){flags={header:true,align:this.token.align[i]};cell+=this.renderer.tablecell(this.inline.output(this.token.header[i]),{header:true,align:this.token.align[i]})}header+=this.renderer.tablerow(cell);for(i=0;i<this.token.cells.length;i++){row=this.token.cells[i];cell="";for(j=0;j<row.length;j++){cell+=this.renderer.tablecell(this.inline.output(row[j]),{header:false,align:this.token.align[j]})}body+=this.renderer.tablerow(cell)}return this.renderer.table(header,body)}case"blockquote_start":{var body="";while(this.next().type!=="blockquote_end"){body+=this.tok()}return this.renderer.blockquote(body)}case"list_start":{var body="",ordered=this.token.ordered;while(this.next().type!=="list_end"){body+=this.tok()}return this.renderer.list(body,ordered)}case"list_item_start":{var body="";while(this.next().type!=="list_item_end"){body+=this.token.type==="text"?this.parseText():this.tok()}return this.renderer.listitem(body)}case"loose_item_start":{var body="";while(this.next().type!=="list_item_end"){body+=this.tok()}return this.renderer.listitem(body)}case"html":{var html=!this.token.pre&&!this.options.pedantic?this.inline.output(this.token.text):this.token.text;return this.renderer.html(html)}case"paragraph":{return this.renderer.paragraph(this.inline.output(this.token.text))}case"text":{return this.renderer.paragraph(this.parseText())}}};function escape(html,encode){return html.replace(!encode?/&(?!#?\w+;)/g:/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;")}function unescape(html){return html.replace(/&([#\w]+);/g,function(_,n){n=n.toLowerCase();if(n==="colon")return":";if(n.charAt(0)==="#"){return n.charAt(1)==="x"?String.fromCharCode(parseInt(n.substring(2),16)):String.fromCharCode(+n.substring(1))}return""})}function replace(regex,opt){regex=regex.source;opt=opt||"";return function self(name,val){if(!name)return new RegExp(regex,opt);val=val.source||val;val=val.replace(/(^|[^\[])\^/g,"$1");regex=regex.replace(name,val);return self}}function noop(){}noop.exec=noop;function merge(obj){var i=1,target,key;for(;i<arguments.length;i++){target=arguments[i];for(key in target){if(Object.prototype.hasOwnProperty.call(target,key)){obj[key]=target[key]}}}return obj}function marked(src,opt,callback){if(callback||typeof opt==="function"){if(!callback){callback=opt;opt=null}opt=merge({},marked.defaults,opt||{});var highlight=opt.highlight,tokens,pending,i=0;try{tokens=Lexer.lex(src,opt)}catch(e){return callback(e)}pending=tokens.length;var done=function(err){if(err){opt.highlight=highlight;return callback(err)}var out;try{out=Parser.parse(tokens,opt)}catch(e){err=e}opt.highlight=highlight;return err?callback(err):callback(null,out)};if(!highlight||highlight.length<3){return done()}delete opt.highlight;if(!pending)return done();for(;i<tokens.length;i++){(function(token){if(token.type!=="code"){return--pending||done()}return highlight(token.text,token.lang,function(err,code){if(err)return done(err);if(code==null||code===token.text){return--pending||done()}token.text=code;token.escaped=true;--pending||done()})})(tokens[i])}return}try{if(opt)opt=merge({},marked.defaults,opt);return Parser.parse(Lexer.lex(src,opt),opt)}catch(e){e.message+="\nPlease report this to https://github.com/chjj/marked.";if((opt||marked.defaults).silent){return"<p>An error occured:</p><pre>"+escape(e.message+"",true)+"</pre>"}throw e}}marked.options=marked.setOptions=function(opt){merge(marked.defaults,opt);return marked};marked.defaults={gfm:true,tables:true,breaks:false,pedantic:false,sanitize:false,smartLists:false,silent:false,highlight:null,langPrefix:"lang-",smartypants:false,headerPrefix:"",renderer:new Renderer,xhtml:false};marked.Parser=Parser;marked.parser=Parser.parse;marked.Renderer=Renderer;marked.Lexer=Lexer;marked.lexer=Lexer.lex;marked.InlineLexer=InlineLexer;marked.inlineLexer=InlineLexer.output;marked.parse=marked;if(typeof module!=="undefined"&&typeof exports==="object"){module.exports=marked}else if(typeof define==="function"&&define.amd){define(function(){return marked})}else{this.marked=marked}}).call(function(){return this||(typeof window!=="undefined"?window:global)}());
/*! messenger 1.5.0 */
/*
 * This file begins the output concatenated into messenger.js
 *
 * It establishes the Messenger object while preserving whatever it was before
 * (for noConflict), and making it a callable function.
 */

(function(){
    var _prevMessenger = window.Messenger;
    var localMessenger;

    localMessenger = window.Messenger = function(){
        return localMessenger._call.apply(this, arguments);
    }

    window.Messenger.noConflict = function(){
        window.Messenger = _prevMessenger;

        return localMessenger;
    }
})();

/*
 * This file contains shims for when Underscore and Backbone
 * are not included.
 *
 * Portions taken from Underscore.js and Backbone.js
 * Both of which are Copyright (c) 2009-2013 Jeremy Ashkenas, DocumentCloud
 */
window.Messenger._ = (function() {
    if (window._)
        return window._

    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

    // Create quick reference variables for speed access to core prototypes.
    var push             = ArrayProto.push,
        slice            = ArrayProto.slice,
        concat           = ArrayProto.concat,
        toString         = ObjProto.toString,
        hasOwnProperty   = ObjProto.hasOwnProperty;

    // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.
    var
        nativeForEach      = ArrayProto.forEach,
        nativeMap          = ArrayProto.map,
        nativeReduce       = ArrayProto.reduce,
        nativeReduceRight  = ArrayProto.reduceRight,
        nativeFilter       = ArrayProto.filter,
        nativeEvery        = ArrayProto.every,
        nativeSome         = ArrayProto.some,
        nativeIndexOf      = ArrayProto.indexOf,
        nativeLastIndexOf  = ArrayProto.lastIndexOf,
        nativeIsArray      = Array.isArray,
        nativeKeys         = Object.keys,
        nativeBind         = FuncProto.bind;

    // Create a safe reference to the Underscore object for use below.
    var _ = {};

    // Establish the object that gets returned to break out of a loop iteration.
    var breaker = {};

    var each = _.each = _.forEach = function(obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
            obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
            for (var i = 0, l = obj.length; i < l; i++) {
                if (iterator.call(context, obj[i], i, obj) === breaker) return;
            }
        } else {
            for (var key in obj) {
                if (_.has(obj, key)) {
                    if (iterator.call(context, obj[key], key, obj) === breaker) return;
                }
            }
        }
    };

    _.result = function(object, property) {
        if (object == null) return null;
        var value = object[property];
        return _.isFunction(value) ? value.call(object) : value;
    };

    _.once = function(func) {
        var ran = false, memo;
        return function() {
            if (ran) return memo;
            ran = true;
            memo = func.apply(this, arguments);
            func = null;
            return memo;
        };
    };

    var idCounter = 0;
    _.uniqueId = function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
    };

    _.filter = _.select = function(obj, iterator, context) {
        var results = [];
        if (obj == null) return results;
        if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
        each(obj, function(value, index, list) {
            if (iterator.call(context, value, index, list)) results[results.length] = value;
        });
        return results;
    };

    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
    each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
        _['is' + name] = function(obj) {
            return toString.call(obj) == '[object ' + name + ']';
        };
    });

    _.defaults = function(obj) {
        each(slice.call(arguments, 1), function(source) {
            if (source) {
                for (var prop in source) {
                    if (obj[prop] == null) obj[prop] = source[prop];
                }
            }
        });
        return obj;
    };

    _.extend = function(obj) {
        each(slice.call(arguments, 1), function(source) {
            if (source) {
                for (var prop in source) {
                    obj[prop] = source[prop];
                }
            }
        });
        return obj;
    };

    _.keys = nativeKeys || function(obj) {
        if (obj !== Object(obj)) throw new TypeError('Invalid object');
        var keys = [];
        for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
        return keys;
    };

    _.bind = function(func, context) {
        if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
        var args = slice.call(arguments, 2);
        return function() {
            return func.apply(context, args.concat(slice.call(arguments)));
        };
    };

    _.isObject = function(obj) {
        return obj === Object(obj);
    };

    return _;
})();

window.Messenger.Events = (function() {
    if (window.Backbone && Backbone.Events) {
        return Backbone.Events;
    }

    var eventsShim = function() {
        var eventSplitter = /\s+/;

        var eventsApi = function(obj, action, name, rest) {
            if (!name) return true;
            if (typeof name === 'object') {
                for (var key in name) {
                    obj[action].apply(obj, [key, name[key]].concat(rest));
                }
            } else if (eventSplitter.test(name)) {
                var names = name.split(eventSplitter);
                for (var i = 0, l = names.length; i < l; i++) {
                    obj[action].apply(obj, [names[i]].concat(rest));
                }
            } else {
                return true;
            }
        };

        var triggerEvents = function(events, args) {
            var ev, i = -1, l = events.length;
            switch (args.length) {
                case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx);
                    return;
                case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, args[0]);
                    return;
                case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, args[0], args[1]);
                    return;
                case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, args[0], args[1], args[2]);
                    return;
                default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
            }
        };

        var Events = {

            on: function(name, callback, context) {
                if (!(eventsApi(this, 'on', name, [callback, context]) && callback)) return this;
                this._events || (this._events = {});
                var list = this._events[name] || (this._events[name] = []);
                list.push({callback: callback, context: context, ctx: context || this});
                return this;
            },

            once: function(name, callback, context) {
                if (!(eventsApi(this, 'once', name, [callback, context]) && callback)) return this;
                var self = this;
                var once = _.once(function() {
                    self.off(name, once);
                    callback.apply(this, arguments);
                });
                once._callback = callback;
                this.on(name, once, context);
                return this;
            },

            off: function(name, callback, context) {
                var list, ev, events, names, i, l, j, k;
                if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
                if (!name && !callback && !context) {
                    this._events = {};
                    return this;
                }

                names = name ? [name] : _.keys(this._events);
                for (i = 0, l = names.length; i < l; i++) {
                    name = names[i];
                    if (list = this._events[name]) {
                        events = [];
                        if (callback || context) {
                            for (j = 0, k = list.length; j < k; j++) {
                                ev = list[j];
                                if ((callback && callback !== ev.callback &&
                                        callback !== ev.callback._callback) ||
                                    (context && context !== ev.context)) {
                                    events.push(ev);
                                }
                            }
                        }
                        this._events[name] = events;
                    }
                }

                return this;
            },

            trigger: function(name) {
                if (!this._events) return this;
                var args = Array.prototype.slice.call(arguments, 1);
                if (!eventsApi(this, 'trigger', name, args)) return this;
                var events = this._events[name];
                var allEvents = this._events.all;
                if (events) triggerEvents(events, args);
                if (allEvents) triggerEvents(allEvents, arguments);
                return this;
            },

            listenTo: function(obj, name, callback) {
                var listeners = this._listeners || (this._listeners = {});
                var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
                listeners[id] = obj;
                obj.on(name, typeof name === 'object' ? this : callback, this);
                return this;
            },

            stopListening: function(obj, name, callback) {
                var listeners = this._listeners;
                if (!listeners) return;
                if (obj) {
                    obj.off(name, typeof name === 'object' ? this : callback, this);
                    if (!name && !callback) delete listeners[obj._listenerId];
                } else {
                    if (typeof name === 'object') callback = this;
                    for (var id in listeners) {
                        listeners[id].off(name, callback, this);
                    }
                    this._listeners = {};
                }
                return this;
            }
        };

        Events.bind   = Events.on;
        Events.unbind = Events.off;
        return Events;
    };
    return eventsShim();
})();

(function() {
    var $, ActionMessenger, BaseView, Events, RetryingMessage, _, _Message, _Messenger, _ref, _ref1, _ref2,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        __slice = [].slice,
        __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

    $ = jQuery;

    _ = (_ref = window._) != null ? _ref : window.Messenger._;

    Events = (_ref1 = typeof Backbone !== "undefined" && Backbone !== null ? Backbone.Events : void 0) != null ? _ref1 : window.Messenger.Events;

    BaseView = (function() {

        function BaseView(options) {
            $.extend(this, Events);
            if (_.isObject(options)) {
                if (options.el) {
                    this.setElement(options.el);
                }
                this.model = options.model;
            }
            this.initialize.apply(this, arguments);
        }

        BaseView.prototype.setElement = function(el) {
            this.$el = $(el);
            return this.el = this.$el[0];
        };

        BaseView.prototype.delegateEvents = function(events) {
            var delegateEventSplitter, eventName, key, match, method, selector, _results;
            if (!(events || (events = _.result(this, "events")))) {
                return;
            }
            this.undelegateEvents();
            delegateEventSplitter = /^(\S+)\s*(.*)$/;
            _results = [];
            for (key in events) {
                method = events[key];
                if (!_.isFunction(method)) {
                    method = this[events[key]];
                }
                if (!method) {
                    throw new Error("Method \"" + events[key] + "\" does not exist");
                }
                match = key.match(delegateEventSplitter);
                eventName = match[1];
                selector = match[2];
                method = _.bind(method, this);
                eventName += ".delegateEvents" + this.cid;
                if (selector === '') {
                    _results.push(this.jqon(eventName, method));
                } else {
                    _results.push(this.jqon(eventName, selector, method));
                }
            }
            return _results;
        };

        BaseView.prototype.jqon = function(eventName, selector, method) {
            var _ref2;
            if (this.$el.on != null) {
                return (_ref2 = this.$el).on.apply(_ref2, arguments);
            } else {
                if (!(method != null)) {
                    method = selector;
                    selector = void 0;
                }
                if (selector != null) {
                    return this.$el.delegate(selector, eventName, method);
                } else {
                    return this.$el.bind(eventName, method);
                }
            }
        };

        BaseView.prototype.jqoff = function(eventName) {
            var _ref2;
            if (this.$el.off != null) {
                return (_ref2 = this.$el).off.apply(_ref2, arguments);
            } else {
                this.$el.undelegate();
                return this.$el.unbind(eventName);
            }
        };

        BaseView.prototype.undelegateEvents = function() {
            return this.jqoff(".delegateEvents" + this.cid);
        };

        BaseView.prototype.remove = function() {
            this.undelegateEvents();
            return this.$el.remove();
        };

        return BaseView;

    })();

    _Message = (function(_super) {

        __extends(_Message, _super);

        function _Message() {
            return _Message.__super__.constructor.apply(this, arguments);
        }

        _Message.prototype.defaults = {
            hideAfter: 10,
            scroll: true,
            closeButtonText: "&times;",
            escapeText: false
        };

        _Message.prototype.initialize = function(opts) {
            if (opts == null) {
                opts = {};
            }
            this.shown = false;
            this.rendered = false;
            this.messenger = opts.messenger;
            return this.options = $.extend({}, this.options, opts, this.defaults);
        };

        _Message.prototype.show = function() {
            var wasShown;
            if (!this.rendered) {
                this.render();
            }
            this.$message.removeClass('messenger-hidden');
            wasShown = this.shown;
            this.shown = true;
            if (!wasShown) {
                return this.trigger('show');
            }
        };

        _Message.prototype.hide = function() {
            var wasShown;
            if (!this.rendered) {
                return;
            }
            this.$message.addClass('messenger-hidden');
            wasShown = this.shown;
            this.shown = false;
            if (wasShown) {
                return this.trigger('hide');
            }
        };

        _Message.prototype.cancel = function() {
            return this.hide();
        };

        _Message.prototype.update = function(opts) {
            var _ref2,
                _this = this;
            if (_.isString(opts)) {
                opts = {
                    message: opts
                };
            }
            $.extend(this.options, opts);
            this.lastUpdate = new Date();
            this.rendered = false;
            this.events = (_ref2 = this.options.events) != null ? _ref2 : {};
            this.render();
            this.actionsToEvents();
            this.delegateEvents();
            this.checkClickable();
            if (this.options.hideAfter) {
                this.$message.addClass('messenger-will-hide-after');
                if (this._hideTimeout != null) {
                    clearTimeout(this._hideTimeout);
                }
                this._hideTimeout = setTimeout(function() {
                    return _this.hide();
                }, this.options.hideAfter * 1000);
            } else {
                this.$message.removeClass('messenger-will-hide-after');
            }
            if (this.options.hideOnNavigate) {
                this.$message.addClass('messenger-will-hide-on-navigate');
                if ((typeof Backbone !== "undefined" && Backbone !== null ? Backbone.history : void 0) != null) {
                    Backbone.history.on('route', function() {
                        return _this.hide();
                    });
                }
            } else {
                this.$message.removeClass('messenger-will-hide-on-navigate');
            }
            return this.trigger('update', this);
        };

        _Message.prototype.scrollTo = function() {
            if (!this.options.scroll) {
                return;
            }
            return $.scrollTo(this.$el, {
                duration: 400,
                offset: {
                    left: 0,
                    top: -20
                }
            });
        };

        _Message.prototype.timeSinceUpdate = function() {
            if (this.lastUpdate) {
                return (new Date) - this.lastUpdate;
            } else {
                return null;
            }
        };

        _Message.prototype.actionsToEvents = function() {
            var act, name, _ref2, _results,
                _this = this;
            _ref2 = this.options.actions;
            _results = [];
            for (name in _ref2) {
                act = _ref2[name];
                _results.push(this.events["click [data-action=\"" + name + "\"] a"] = (function(act) {
                    return function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        _this.trigger("action:" + name, act, e);
                        return act.action.call(_this, e, _this);
                    };
                })(act));
            }
            return _results;
        };

        _Message.prototype.checkClickable = function() {
            var evt, name, _ref2, _results;
            _ref2 = this.events;
            _results = [];
            for (name in _ref2) {
                evt = _ref2[name];
                if (name === 'click') {
                    _results.push(this.$message.addClass('messenger-clickable'));
                } else {
                    _results.push(void 0);
                }
            }
            return _results;
        };

        _Message.prototype.undelegateEvents = function() {
            var _ref2;
            _Message.__super__.undelegateEvents.apply(this, arguments);
            return (_ref2 = this.$message) != null ? _ref2.removeClass('messenger-clickable') : void 0;
        };

        _Message.prototype.parseActions = function() {
            var act, actions, n_act, name, _ref2, _ref3;
            actions = [];
            _ref2 = this.options.actions;
            for (name in _ref2) {
                act = _ref2[name];
                n_act = $.extend({}, act);
                n_act.name = name;
                if ((_ref3 = n_act.label) == null) {
                    n_act.label = name;
                }
                actions.push(n_act);
            }
            return actions;
        };

        _Message.prototype.template = function(opts) {
            var $action, $actions, $cancel, $link, $message, $text, action, _i, _len, _ref2,
                _this = this;
            $message = $("<div class='messenger-message message alert " + opts.type + " message-" + opts.type + " alert-" + opts.type + "'>");
            if (opts.showCloseButton) {
                $cancel = $('<button type="button" class="messenger-close" data-dismiss="alert">');
                $cancel.html(opts.closeButtonText);
                $cancel.click(function() {
                    var _base;
                    _this.cancel();
                    if (typeof (_base = _this.options).onClickClose === "function") {
                        _base.onClickClose();
                    }
                    return true;
                });
                $message.append($cancel);
            }
            if (opts.escapeText) {
                $text = $('<div class="messenger-message-inner"></div>').text(opts.message);
            } else {
                $text = $("<div class=\"messenger-message-inner\">" + opts.message + "</div>");
            }
            $message.append($text);
            if (opts.actions.length) {
                $actions = $('<div class="messenger-actions">');
            }
            _ref2 = opts.actions;
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                action = _ref2[_i];
                $action = $('<span>');
                $action.attr('data-action', "" + action.name);
                $link = $('<a>');
                $link.html(action.label);
                $action.append($('<span class="messenger-phrase">'));
                $action.append($link);
                $actions.append($action);
            }
            $message.append($actions);
            return $message;
        };

        _Message.prototype.render = function() {
            var opts;
            if (this.rendered) {
                return;
            }
            if (!this._hasSlot) {
                this.setElement(this.messenger._reserveMessageSlot(this));
                this._hasSlot = true;
            }
            opts = $.extend({}, this.options, {
                actions: this.parseActions()
            });
            this.$message = $(this.template(opts));
            this.$el.html(this.$message);
            this.shown = true;
            this.rendered = true;
            return this.trigger('render');
        };

        return _Message;

    })(BaseView);

    RetryingMessage = (function(_super) {

        __extends(RetryingMessage, _super);

        function RetryingMessage() {
            return RetryingMessage.__super__.constructor.apply(this, arguments);
        }

        RetryingMessage.prototype.initialize = function() {
            RetryingMessage.__super__.initialize.apply(this, arguments);
            return this._timers = {};
        };

        RetryingMessage.prototype.cancel = function() {
            this.clearTimers();
            this.hide();
            if ((this._actionInstance != null) && (this._actionInstance.abort != null)) {
                return this._actionInstance.abort();
            }
        };

        RetryingMessage.prototype.clearTimers = function() {
            var name, timer, _ref2, _ref3;
            _ref2 = this._timers;
            for (name in _ref2) {
                timer = _ref2[name];
                clearTimeout(timer);
            }
            this._timers = {};
            return (_ref3 = this.$message) != null ? _ref3.removeClass('messenger-retry-soon messenger-retry-later') : void 0;
        };

        RetryingMessage.prototype.render = function() {
            var action, name, _ref2, _results;
            RetryingMessage.__super__.render.apply(this, arguments);
            this.clearTimers();
            _ref2 = this.options.actions;
            _results = [];
            for (name in _ref2) {
                action = _ref2[name];
                if (action.auto) {
                    _results.push(this.startCountdown(name, action));
                } else {
                    _results.push(void 0);
                }
            }
            return _results;
        };

        RetryingMessage.prototype.renderPhrase = function(action, time) {
            var phrase;
            phrase = action.phrase.replace('TIME', this.formatTime(time));
            return phrase;
        };

        RetryingMessage.prototype.formatTime = function(time) {
            var pluralize;
            pluralize = function(num, str) {
                num = Math.floor(num);
                if (num !== 1) {
                    str = str + 's';
                }
                return 'in ' + num + ' ' + str;
            };
            if (Math.floor(time) === 0) {
                return 'now...';
            }
            if (time < 60) {
                return pluralize(time, 'second');
            }
            time /= 60;
            if (time < 60) {
                return pluralize(time, 'minute');
            }
            time /= 60;
            return pluralize(time, 'hour');
        };

        RetryingMessage.prototype.startCountdown = function(name, action) {
            var $phrase, remaining, tick, _ref2,
                _this = this;
            if (this._timers[name] != null) {
                return;
            }
            $phrase = this.$message.find("[data-action='" + name + "'] .messenger-phrase");
            remaining = (_ref2 = action.delay) != null ? _ref2 : 3;
            if (remaining <= 10) {
                this.$message.removeClass('messenger-retry-later');
                this.$message.addClass('messenger-retry-soon');
            } else {
                this.$message.removeClass('messenger-retry-soon');
                this.$message.addClass('messenger-retry-later');
            }
            tick = function() {
                var delta;
                $phrase.text(_this.renderPhrase(action, remaining));
                if (remaining > 0) {
                    delta = Math.min(remaining, 1);
                    remaining -= delta;
                    return _this._timers[name] = setTimeout(tick, delta * 1000);
                } else {
                    _this.$message.removeClass('messenger-retry-soon messenger-retry-later');
                    delete _this._timers[name];
                    return action.action();
                }
            };
            return tick();
        };

        return RetryingMessage;

    })(_Message);

    _Messenger = (function(_super) {

        __extends(_Messenger, _super);

        function _Messenger() {
            return _Messenger.__super__.constructor.apply(this, arguments);
        }

        _Messenger.prototype.tagName = 'ul';

        _Messenger.prototype.className = 'messenger';

        _Messenger.prototype.messageDefaults = {
            type: 'info'
        };

        _Messenger.prototype.initialize = function(options) {
            this.options = options != null ? options : {};
            this.history = [];
            return this.messageDefaults = $.extend({}, this.messageDefaults, this.options.messageDefaults);
        };

        _Messenger.prototype.render = function() {
            return this.updateMessageSlotClasses();
        };

        _Messenger.prototype.findById = function(id) {
            return _.filter(this.history, function(rec) {
                return rec.msg.options.id === id;
            });
        };

        _Messenger.prototype._reserveMessageSlot = function(msg) {
            var $slot, dmsg,
                _this = this;
            $slot = $('<li>');
            $slot.addClass('messenger-message-slot');
            this.$el.prepend($slot);
            this.history.push({
                msg: msg,
                $slot: $slot
            });
            this._enforceIdConstraint(msg);
            msg.on('update', function() {
                return _this._enforceIdConstraint(msg);
            });
            while (this.options.maxMessages && this.history.length > this.options.maxMessages) {
                dmsg = this.history.shift();
                dmsg.msg.remove();
                dmsg.$slot.remove();
            }
            return $slot;
        };

        _Messenger.prototype._enforceIdConstraint = function(msg) {
            var entry, _i, _len, _msg, _ref2;
            if (msg.options.id == null) {
                return;
            }
            _ref2 = this.history;
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                entry = _ref2[_i];
                _msg = entry.msg;
                if ((_msg.options.id != null) && _msg.options.id === msg.options.id && msg !== _msg) {
                    if (msg.options.singleton) {
                        msg.hide();
                        return;
                    } else {
                        _msg.hide();
                    }
                }
            }
        };

        _Messenger.prototype.newMessage = function(opts) {
            var msg, _ref2, _ref3, _ref4,
                _this = this;
            if (opts == null) {
                opts = {};
            }
            opts.messenger = this;
            _Message = (_ref2 = (_ref3 = Messenger.themes[(_ref4 = opts.theme) != null ? _ref4 : this.options.theme]) != null ? _ref3.Message : void 0) != null ? _ref2 : RetryingMessage;
            msg = new _Message(opts);
            msg.on('show', function() {
                if (opts.scrollTo && _this.$el.css('position') !== 'fixed') {
                    return msg.scrollTo();
                }
            });
            msg.on('hide show render', this.updateMessageSlotClasses, this);
            return msg;
        };

        _Messenger.prototype.updateMessageSlotClasses = function() {
            var anyShown, last, rec, willBeFirst, _i, _len, _ref2;
            willBeFirst = true;
            last = null;
            anyShown = false;
            _ref2 = this.history;
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                rec = _ref2[_i];
                rec.$slot.removeClass('messenger-first messenger-last messenger-shown');
                if (rec.msg.shown && rec.msg.rendered) {
                    rec.$slot.addClass('messenger-shown');
                    anyShown = true;
                    last = rec;
                    if (willBeFirst) {
                        willBeFirst = false;
                        rec.$slot.addClass('messenger-first');
                    }
                }
            }
            if (last != null) {
                last.$slot.addClass('messenger-last');
            }
            return this.$el["" + (anyShown ? 'remove' : 'add') + "Class"]('messenger-empty');
        };

        _Messenger.prototype.hideAll = function() {
            var rec, _i, _len, _ref2, _results;
            _ref2 = this.history;
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                rec = _ref2[_i];
                _results.push(rec.msg.hide());
            }
            return _results;
        };

        _Messenger.prototype.post = function(opts) {
            var msg;
            if (_.isString(opts)) {
                opts = {
                    message: opts
                };
            }
            opts = $.extend(true, {}, this.messageDefaults, opts);
            msg = this.newMessage(opts);
            msg.update(opts);
            return msg;
        };

        return _Messenger;

    })(BaseView);

    ActionMessenger = (function(_super) {

        __extends(ActionMessenger, _super);

        function ActionMessenger() {
            return ActionMessenger.__super__.constructor.apply(this, arguments);
        }

        ActionMessenger.prototype.doDefaults = {
            progressMessage: null,
            successMessage: null,
            errorMessage: "Error connecting to the server.",
            showSuccessWithoutError: true,
            retry: {
                auto: true,
                allow: true
            },
            action: $.ajax
        };

        ActionMessenger.prototype.hookBackboneAjax = function(msgr_opts) {
            var _ajax,
                _this = this;
            if (msgr_opts == null) {
                msgr_opts = {};
            }
            if (!(window.Backbone != null)) {
                throw 'Expected Backbone to be defined';
            }
            msgr_opts = _.defaults(msgr_opts, {
                id: 'BACKBONE_ACTION',
                errorMessage: false,
                successMessage: "Request completed successfully.",
                showSuccessWithoutError: false
            });
            _ajax = function(options) {
                var sync_msgr_opts;
                sync_msgr_opts = _.extend({}, msgr_opts, options.messenger);
                return _this["do"](sync_msgr_opts, options);
            };
            if (Backbone.ajax != null) {
                if (Backbone.ajax._withoutMessenger) {
                    Backbone.ajax = Backbone.ajax._withoutMessenger;
                }
                if (!(msgr_opts.action != null) || msgr_opts.action === this.doDefaults.action) {
                    msgr_opts.action = Backbone.ajax;
                }
                _ajax._withoutMessenger = Backbone.ajax;
                return Backbone.ajax = _ajax;
            } else {
                return Backbone.sync = _.wrap(Backbone.sync, function() {
                    var args, _old_ajax, _old_sync;
                    _old_sync = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
                    _old_ajax = $.ajax;
                    $.ajax = _ajax;
                    _old_sync.call.apply(_old_sync, [this].concat(__slice.call(args)));
                    return $.ajax = _old_ajax;
                });
            }
        };

        ActionMessenger.prototype._getHandlerResponse = function(returnVal) {
            if (returnVal === false) {
                return false;
            }
            if (returnVal === true || !(returnVal != null)) {
                return true;
            }
            return returnVal;
        };

        ActionMessenger.prototype._parseEvents = function(events) {
            var desc, firstSpace, func, label, out, type, _ref2;
            if (events == null) {
                events = {};
            }
            out = {};
            for (label in events) {
                func = events[label];
                firstSpace = label.indexOf(' ');
                type = label.substring(0, firstSpace);
                desc = label.substring(firstSpace + 1);
                if ((_ref2 = out[type]) == null) {
                    out[type] = {};
                }
                out[type][desc] = func;
            }
            return out;
        };

        ActionMessenger.prototype._normalizeResponse = function() {
            var data, elem, resp, type, xhr, _i, _len;
            resp = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            type = null;
            xhr = null;
            data = null;
            for (_i = 0, _len = resp.length; _i < _len; _i++) {
                elem = resp[_i];
                if (elem === 'success' || elem === 'timeout' || elem === 'abort') {
                    type = elem;
                } else if (((elem != null ? elem.readyState : void 0) != null) && ((elem != null ? elem.responseText : void 0) != null)) {
                    xhr = elem;
                } else if (_.isObject(elem)) {
                    data = elem;
                }
            }
            return [type, data, xhr];
        };

        ActionMessenger.prototype.run = function() {
            var args, events, getMessageText, handler, handlers, m_opts, msg, old, opts, type, _ref2,
                _this = this;
            m_opts = arguments[0], opts = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
            if (opts == null) {
                opts = {};
            }
            m_opts = $.extend(true, {}, this.messageDefaults, this.doDefaults, m_opts != null ? m_opts : {});
            events = this._parseEvents(m_opts.events);
            getMessageText = function(type, xhr) {
                var message;
                message = m_opts[type + 'Message'];
                if (_.isFunction(message)) {
                    return message.call(_this, type, xhr);
                }
                return message;
            };
            msg = (_ref2 = m_opts.messageInstance) != null ? _ref2 : this.newMessage(m_opts);
            if (m_opts.id != null) {
                msg.options.id = m_opts.id;
            }
            if (m_opts.progressMessage != null) {
                msg.update($.extend({}, m_opts, {
                    message: getMessageText('progress', null),
                    type: 'info'
                }));
            }
            handlers = {};
            _.each(['error', 'success'], function(type) {
                var originalHandler;
                originalHandler = opts[type];
                return handlers[type] = function() {
                    var data, defaultOpts, handlerResp, msgOpts, reason, resp, responseOpts, xhr, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
                    resp = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    _ref3 = _this._normalizeResponse.apply(_this, resp), reason = _ref3[0], data = _ref3[1], xhr = _ref3[2];
                    if (type === 'success' && !(msg.errorCount != null) && m_opts.showSuccessWithoutError === false) {
                        m_opts['successMessage'] = null;
                    }
                    if (type === 'error') {
                        if ((_ref4 = m_opts.errorCount) == null) {
                            m_opts.errorCount = 0;
                        }
                        m_opts.errorCount += 1;
                    }
                    handlerResp = m_opts.returnsPromise ? resp[0] : typeof originalHandler === "function" ? originalHandler.apply(null, resp) : void 0;
                    responseOpts = _this._getHandlerResponse(handlerResp);
                    if (_.isString(responseOpts)) {
                        responseOpts = {
                            message: responseOpts
                        };
                    }
                    if (type === 'error' && ((xhr != null ? xhr.status : void 0) === 0 || reason === 'abort')) {
                        msg.hide();
                        return;
                    }
                    if (type === 'error' && ((m_opts.ignoredErrorCodes != null) && (_ref5 = xhr != null ? xhr.status : void 0, __indexOf.call(m_opts.ignoredErrorCodes, _ref5) >= 0))) {
                        msg.hide();
                        return;
                    }
                    defaultOpts = {
                        message: getMessageText(type, xhr),
                        type: type,
                        events: (_ref6 = events[type]) != null ? _ref6 : {},
                        hideOnNavigate: type === 'success'
                    };
                    msgOpts = $.extend({}, m_opts, defaultOpts, responseOpts);
                    if (typeof ((_ref7 = msgOpts.retry) != null ? _ref7.allow : void 0) === 'number') {
                        msgOpts.retry.allow--;
                    }
                    if (type === 'error' && (xhr != null ? xhr.status : void 0) >= 500 && ((_ref8 = msgOpts.retry) != null ? _ref8.allow : void 0)) {
                        if (msgOpts.retry.delay == null) {
                            if (msgOpts.errorCount < 4) {
                                msgOpts.retry.delay = 10;
                            } else {
                                msgOpts.retry.delay = 5 * 60;
                            }
                        }
                        if (msgOpts.hideAfter) {
                            if ((_ref9 = msgOpts._hideAfter) == null) {
                                msgOpts._hideAfter = msgOpts.hideAfter;
                            }
                            msgOpts.hideAfter = msgOpts._hideAfter + msgOpts.retry.delay;
                        }
                        msgOpts._retryActions = true;
                        msgOpts.actions = {
                            retry: {
                                label: 'retry now',
                                phrase: 'Retrying TIME',
                                auto: msgOpts.retry.auto,
                                delay: msgOpts.retry.delay,
                                action: function() {
                                    msgOpts.messageInstance = msg;
                                    return setTimeout(function() {
                                        return _this["do"].apply(_this, [msgOpts, opts].concat(__slice.call(args)));
                                    }, 0);
                                }
                            },
                            cancel: {
                                action: function() {
                                    return msg.cancel();
                                }
                            }
                        };
                    } else if (msgOpts._retryActions) {
                        delete msgOpts.actions.retry;
                        delete msgOpts.actions.cancel;
                        delete m_opts._retryActions;
                    }
                    msg.update(msgOpts);
                    if (responseOpts && msgOpts.message) {
                        Messenger(_.extend({}, _this.options, {
                            instance: _this
                        }));
                        return msg.show();
                    } else {
                        return msg.hide();
                    }
                };
            });
            if (!m_opts.returnsPromise) {
                for (type in handlers) {
                    handler = handlers[type];
                    old = opts[type];
                    opts[type] = handler;
                }
            }
            msg._actionInstance = m_opts.action.apply(m_opts, [opts].concat(__slice.call(args)));
            if (m_opts.returnsPromise) {
                msg._actionInstance.then(handlers.success, handlers.error);
            }
            return msg;
        };

        ActionMessenger.prototype["do"] = ActionMessenger.prototype.run;

        ActionMessenger.prototype.ajax = function() {
            var args, m_opts;
            m_opts = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            m_opts.action = $.ajax;
            return this.run.apply(this, [m_opts].concat(__slice.call(args)));
        };

        ActionMessenger.prototype.expectPromise = function(action, m_opts) {
            m_opts = _.extend({}, m_opts, {
                action: action,
                returnsPromise: true
            });
            return this.run(m_opts);
        };

        ActionMessenger.prototype.error = function(m_opts) {
            if (m_opts == null) {
                m_opts = {};
            }
            if (typeof m_opts === 'string') {
                m_opts = {
                    message: m_opts
                };
            }
            m_opts.type = 'error';
            return this.post(m_opts);
        };

        ActionMessenger.prototype.info = function(m_opts) {
            if (m_opts == null) {
                m_opts = {};
            }
            if (typeof m_opts === 'string') {
                m_opts = {
                    message: m_opts
                };
            }
            m_opts.type = 'info';
            return this.post(m_opts);
        };

        ActionMessenger.prototype.success = function(m_opts) {
            if (m_opts == null) {
                m_opts = {};
            }
            if (typeof m_opts === 'string') {
                m_opts = {
                    message: m_opts
                };
            }
            m_opts.type = 'success';
            return this.post(m_opts);
        };

        return ActionMessenger;

    })(_Messenger);

    $.fn.messenger = function() {
        var $el, args, func, instance, opts, _ref2, _ref3, _ref4;
        func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (func == null) {
            func = {};
        }
        $el = this;
        if (!(func != null) || !_.isString(func)) {
            opts = func;
            if (!($el.data('messenger') != null)) {
                _Messenger = (_ref2 = (_ref3 = Messenger.themes[opts.theme]) != null ? _ref3.Messenger : void 0) != null ? _ref2 : ActionMessenger;
                $el.data('messenger', instance = new _Messenger($.extend({
                    el: $el
                }, opts)));
                instance.render();
            }
            return $el.data('messenger');
        } else {
            return (_ref4 = $el.data('messenger'))[func].apply(_ref4, args);
        }
    };

    window.Messenger._call = function(opts) {
        var $el, $parent, choosen_loc, chosen_loc, classes, defaultOpts, inst, loc, locations, _i, _len;
        defaultOpts = {
            extraClasses: 'messenger-fixed messenger-on-bottom messenger-on-right',
            theme: 'future',
            maxMessages: 9,
            parentLocations: ['body']
        };
        opts = $.extend(defaultOpts, $._messengerDefaults, Messenger.options, opts);
        if (opts.theme != null) {
            opts.extraClasses += " messenger-theme-" + opts.theme;
        }
        inst = opts.instance || Messenger.instance;
        if (opts.instance == null) {
            locations = opts.parentLocations;
            $parent = null;
            choosen_loc = null;
            for (_i = 0, _len = locations.length; _i < _len; _i++) {
                loc = locations[_i];
                $parent = $(loc);
                if ($parent.length) {
                    chosen_loc = loc;
                    break;
                }
            }
            if (!inst) {
                $el = $('<ul>');
                $parent.prepend($el);
                inst = $el.messenger(opts);
                inst._location = chosen_loc;
                Messenger.instance = inst;
            } else if (!$(inst._location).is($(chosen_loc))) {
                inst.$el.detach();
                $parent.prepend(inst.$el);
            }
        }
        if (inst._addedClasses != null) {
            inst.$el.removeClass(inst._addedClasses);
        }
        inst.$el.addClass(classes = "" + inst.className + " " + opts.extraClasses);
        inst._addedClasses = classes;
        return inst;
    };

    $.extend(Messenger, {
        Message: RetryingMessage,
        Messenger: ActionMessenger,
        themes: (_ref2 = Messenger.themes) != null ? _ref2 : {}
    });

    $.globalMessenger = window.Messenger = Messenger;

}).call(this);

// flat theme
(function() {
    var $, FlatMessage, spinner_template,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

    $ = jQuery;

    spinner_template = '<div class="messenger-spinner">\n    <span class="messenger-spinner-side messenger-spinner-side-left">\n        <span class="messenger-spinner-fill"></span>\n    </span>\n    <span class="messenger-spinner-side messenger-spinner-side-right">\n        <span class="messenger-spinner-fill"></span>\n    </span>\n</div>';

    FlatMessage = (function(_super) {

        __extends(FlatMessage, _super);

        function FlatMessage() {
            return FlatMessage.__super__.constructor.apply(this, arguments);
        }

        FlatMessage.prototype.template = function(opts) {
            var $message;
            $message = FlatMessage.__super__.template.apply(this, arguments);
            $message.append($(spinner_template));
            return $message;
        };

        return FlatMessage;

    })(window.Messenger.Message);

    window.Messenger.themes.flat = {
        Message: FlatMessage
    };

}).call(this);

/* http://prismjs.com/download.html?themes=prism&languages=markup+css+clike+javascript+abap+actionscript+ada+apacheconf+apl+applescript+asciidoc+aspnet+autoit+autohotkey+bash+basic+batch+c+brainfuck+bro+bison+csharp+cpp+coffeescript+ruby+css-extras+d+dart+diff+docker+eiffel+elixir+erlang+fsharp+fortran+gherkin+git+glsl+go+graphql+groovy+haml+handlebars+haskell+haxe+http+icon+inform7+ini+j+jade+java+json+julia+keyman+kotlin+latex+less+livescript+lolcode+lua+makefile+markdown+matlab+mel+mizar+monkey+nasm+nginx+nim+nix+nsis+objectivec+ocaml+oz+parigp+parser+pascal+perl+php+php-extras+powershell+processing+prolog+properties+protobuf+puppet+pure+python+q+qore+r+jsx+rest+rip+roboconf+crystal+rust+sas+sass+scss+scala+scheme+smalltalk+smarty+sql+stylus+swift+tcl+textile+twig+typescript+verilog+vhdl+vim+wiki+xojo+yaml */
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-(\w+)\b/i,t=0,n=_self.Prism={util:{encode:function(e){return e instanceof a?new a(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e){var t=n.util.type(e);switch(t){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=n.util.clone(e[r]));return a;case"Array":return e.map&&e.map(function(e){return n.util.clone(e)})}return e}},languages:{extend:function(e,t){var a=n.util.clone(n.languages[e]);for(var r in t)a[r]=t[r];return a},insertBefore:function(e,t,a,r){r=r||n.languages;var i=r[e];if(2==arguments.length){a=arguments[1];for(var l in a)a.hasOwnProperty(l)&&(i[l]=a[l]);return i}var o={};for(var s in i)if(i.hasOwnProperty(s)){if(s==t)for(var l in a)a.hasOwnProperty(l)&&(o[l]=a[l]);o[s]=i[s]}return n.languages.DFS(n.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=o)}),r[e]=o},DFS:function(e,t,a,r){r=r||{};for(var i in e)e.hasOwnProperty(i)&&(t.call(e,i,e[i],a||i),"Object"!==n.util.type(e[i])||r[n.util.objId(e[i])]?"Array"!==n.util.type(e[i])||r[n.util.objId(e[i])]||(r[n.util.objId(e[i])]=!0,n.languages.DFS(e[i],t,i,r)):(r[n.util.objId(e[i])]=!0,n.languages.DFS(e[i],t,null,r)))}},plugins:{},highlightAll:function(e,t){var a={callback:t,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var r,i=a.elements||document.querySelectorAll(a.selector),l=0;r=i[l++];)n.highlightElement(r,e===!0,a.callback)},highlightElement:function(t,a,r){for(var i,l,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(i=(o.className.match(e)||[,""])[1].toLowerCase(),l=n.languages[i]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+i,o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+i);var s=t.textContent,u={element:t,language:i,grammar:l,code:s};if(n.hooks.run("before-sanity-check",u),!u.code||!u.grammar)return n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),a&&_self.Worker){var c=new Worker(n.filename);c.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},c.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,r){var i=n.tokenize(e,t);return a.stringify(n.util.encode(i),r)},tokenize:function(e,t){var a=n.Token,r=[e],i=t.rest;if(i){for(var l in i)t[l]=i[l];delete t.rest}e:for(var l in t)if(t.hasOwnProperty(l)&&t[l]){var o=t[l];o="Array"===n.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var u=o[s],c=u.inside,g=!!u.lookbehind,h=!!u.greedy,f=0,d=u.alias;if(h&&!u.pattern.global){var p=u.pattern.toString().match(/[imuy]*$/)[0];u.pattern=RegExp(u.pattern.source,p+"g")}u=u.pattern||u;for(var m=0,y=0;m<r.length;y+=(r[m].matchedStr||r[m]).length,++m){var v=r[m];if(r.length>e.length)break e;if(!(v instanceof a)){u.lastIndex=0;var b=u.exec(v),k=1;if(!b&&h&&m!=r.length-1){if(u.lastIndex=y,b=u.exec(e),!b)break;for(var w=b.index+(g?b[1].length:0),_=b.index+b[0].length,A=m,S=y,P=r.length;P>A&&_>S;++A)S+=(r[A].matchedStr||r[A]).length,w>=S&&(++m,y=S);if(r[m]instanceof a||r[A-1].greedy)continue;k=A-m,v=e.slice(y,S),b.index-=y}if(b){g&&(f=b[1].length);var w=b.index+f,b=b[0].slice(f),_=w+b.length,x=v.slice(0,w),O=v.slice(_),j=[m,k];x&&j.push(x);var N=new a(l,c?n.tokenize(b,c):b,d,b,h);j.push(N),O&&j.push(O),Array.prototype.splice.apply(r,j)}}}}}return r},hooks:{all:{},add:function(e,t){var a=n.hooks.all;a[e]=a[e]||[],a[e].push(t)},run:function(e,t){var a=n.hooks.all[e];if(a&&a.length)for(var r,i=0;r=a[i++];)r(t)}}},a=n.Token=function(e,t,n,a,r){this.type=e,this.content=t,this.alias=n,this.matchedStr=a||null,this.greedy=!!r};if(a.stringify=function(e,t,r){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return a.stringify(n,t,e)}).join("");var i={type:e.type,content:a.stringify(e.content,t,r),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:r};if("comment"==i.type&&(i.attributes.spellcheck="true"),e.alias){var l="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(i.classes,l)}n.hooks.run("wrap",i);var o="";for(var s in i.attributes)o+=(o?" ":"")+s+'="'+(i.attributes[s]||"")+'"';return"<"+i.tag+' class="'+i.classes.join(" ")+'"'+(o?" "+o:"")+">"+i.content+"</"+i.tag+">"},!_self.document)return _self.addEventListener?(_self.addEventListener("message",function(e){var t=JSON.parse(e.data),a=t.language,r=t.code,i=t.immediateClose;_self.postMessage(n.highlight(r,n.languages[a],a)),i&&_self.close()},!1),_self.Prism):_self.Prism;var r=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return r&&(n.filename=r.src,document.addEventListener&&!r.hasAttribute("data-manual")&&("loading"!==document.readyState?window.requestAnimationFrame?window.requestAnimationFrame(n.highlightAll):window.setTimeout(n.highlightAll,16):document.addEventListener("DOMContentLoaded",n.highlightAll))),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
Prism.languages.markup={comment:/<!--[\w\W]*?-->/,prolog:/<\?[\w\W]+?\?>/,doctype:/<!DOCTYPE[\w\W]+?>/,cdata:/<!\[CDATA\[[\w\W]*?]]>/i,tag:{pattern:/<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,inside:{tag:{pattern:/^<\/?[^\s>\/]+/i,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"attr-value":{pattern:/=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,inside:{punctuation:/[=>"']/}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:/&#?[\da-z]{1,8};/i},Prism.hooks.add("wrap",function(a){"entity"===a.type&&(a.attributes.title=a.content.replace(/&amp;/,"&"))}),Prism.languages.xml=Prism.languages.markup,Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup;
Prism.languages.css={comment:/\/\*[\w\W]*?\*\//,atrule:{pattern:/@[\w-]+?.*?(;|(?=\s*\{))/i,inside:{rule:/@[\w-]+/}},url:/url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,selector:/[^\{\}\s][^\{\};]*?(?=\s*\{)/,string:{pattern:/("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,greedy:!0},property:/(\b|\B)[\w-]+(?=\s*:)/i,important:/\B!important\b/i,"function":/[-a-z0-9]+(?=\()/i,punctuation:/[(){};:]/},Prism.languages.css.atrule.inside.rest=Prism.util.clone(Prism.languages.css),Prism.languages.markup&&(Prism.languages.insertBefore("markup","tag",{style:{pattern:/(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,lookbehind:!0,inside:Prism.languages.css,alias:"language-css"}}),Prism.languages.insertBefore("inside","attr-value",{"style-attr":{pattern:/\s*style=("|').*?\1/i,inside:{"attr-name":{pattern:/^\s*style/i,inside:Prism.languages.markup.tag.inside},punctuation:/^\s*=\s*['"]|['"]\s*$/,"attr-value":{pattern:/.+/i,inside:Prism.languages.css}},alias:"language-css"}},Prism.languages.markup.tag));
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0}],string:{pattern:/(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,lookbehind:!0,inside:{punctuation:/(\.|\\)/}},keyword:/\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(true|false)\b/,"function":/[a-z0-9_]+(?=\()/i,number:/\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
Prism.languages.javascript=Prism.languages.extend("clike",{keyword:/\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,number:/\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,"function":/[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/}),Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:/(^|[^\/])\/(?!\/)(\[.+?]|\\.|[^\/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,lookbehind:!0,greedy:!0}}),Prism.languages.insertBefore("javascript","string",{"template-string":{pattern:/`(?:\\\\|\\?[^\\])*?`/,greedy:!0,inside:{interpolation:{pattern:/\$\{[^}]+\}/,inside:{"interpolation-punctuation":{pattern:/^\$\{|\}$/,alias:"punctuation"},rest:Prism.languages.javascript}},string:/[\s\S]+/}}}),Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{script:{pattern:/(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,lookbehind:!0,inside:Prism.languages.javascript,alias:"language-javascript"}}),Prism.languages.js=Prism.languages.javascript;
Prism.languages.abap={comment:/^\*.*/m,string:/(`|')(\\?.)*?\1/m,"string-template":{pattern:/(\||\})(\\?.)*?(?=\||\{)/,lookbehind:!0,alias:"string"},"eol-comment":{pattern:/(^|\s)".*/m,lookbehind:!0,alias:"comment"},keyword:{pattern:/(\s|\.|^)(?:SCIENTIFIC_WITH_LEADING_ZERO|SCALE_PRESERVING_SCIENTIFIC|RMC_COMMUNICATION_FAILURE|END-ENHANCEMENT-SECTION|MULTIPLY-CORRESPONDING|SUBTRACT-CORRESPONDING|VERIFICATION-MESSAGE|DIVIDE-CORRESPONDING|ENHANCEMENT-SECTION|CURRENCY_CONVERSION|RMC_SYSTEM_FAILURE|START-OF-SELECTION|MOVE-CORRESPONDING|RMC_INVALID_STATUS|CUSTOMER-FUNCTION|END-OF-DEFINITION|ENHANCEMENT-POINT|SYSTEM-EXCEPTIONS|ADD-CORRESPONDING|SCALE_PRESERVING|SELECTION-SCREEN|CURSOR-SELECTION|END-OF-SELECTION|LOAD-OF-PROGRAM|SCROLL-BOUNDARY|SELECTION-TABLE|EXCEPTION-TABLE|IMPLEMENTATIONS|PARAMETER-TABLE|RIGHT-JUSTIFIED|UNIT_CONVERSION|AUTHORITY-CHECK|LIST-PROCESSING|SIGN_AS_POSTFIX|COL_BACKGROUND|IMPLEMENTATION|INTERFACE-POOL|TRANSFORMATION|IDENTIFICATION|ENDENHANCEMENT|LINE-SELECTION|INITIALIZATION|LEFT-JUSTIFIED|SELECT-OPTIONS|SELECTION-SETS|COMMUNICATION|CORRESPONDING|DECIMAL_SHIFT|PRINT-CONTROL|VALUE-REQUEST|CHAIN-REQUEST|FUNCTION-POOL|FIELD-SYMBOLS|FUNCTIONALITY|INVERTED-DATE|SELECTION-SET|CLASS-METHODS|OUTPUT-LENGTH|CLASS-CODING|COL_NEGATIVE|ERRORMESSAGE|FIELD-GROUPS|HELP-REQUEST|NO-EXTENSION|NO-TOPOFPAGE|REDEFINITION|DISPLAY-MODE|ENDINTERFACE|EXIT-COMMAND|FIELD-SYMBOL|NO-SCROLLING|SHORTDUMP-ID|ACCESSPOLICY|CLASS-EVENTS|COL_POSITIVE|DECLARATIONS|ENHANCEMENTS|FILTER-TABLE|SWITCHSTATES|SYNTAX-CHECK|TRANSPORTING|ASYNCHRONOUS|SYNTAX-TRACE|TOKENIZATION|USER-COMMAND|WITH-HEADING|ABAP-SOURCE|BREAK-POINT|CHAIN-INPUT|COMPRESSION|FIXED-POINT|NEW-SECTION|NON-UNICODE|OCCURRENCES|RESPONSIBLE|SYSTEM-CALL|TRACE-TABLE|ABBREVIATED|CHAR-TO-HEX|END-OF-FILE|ENDFUNCTION|ENVIRONMENT|ASSOCIATION|COL_HEADING|EDITOR-CALL|END-OF-PAGE|ENGINEERING|IMPLEMENTED|INTENSIFIED|RADIOBUTTON|SYSTEM-EXIT|TOP-OF-PAGE|TRANSACTION|APPLICATION|CONCATENATE|DESTINATION|ENHANCEMENT|IMMEDIATELY|NO-GROUPING|PRECOMPILED|REPLACEMENT|TITLE-LINES|ACTIVATION|BYTE-ORDER|CLASS-POOL|CONNECTION|CONVERSION|DEFINITION|DEPARTMENT|EXPIRATION|INHERITING|MESSAGE-ID|NO-HEADING|PERFORMING|QUEUE-ONLY|RIGHTSPACE|SCIENTIFIC|STATUSINFO|STRUCTURES|SYNCPOINTS|WITH-TITLE|ATTRIBUTES|BOUNDARIES|CLASS-DATA|COL_NORMAL|DD\/MM\/YYYY|DESCENDING|INTERFACES|LINE-COUNT|MM\/DD\/YYYY|NON-UNIQUE|PRESERVING|SELECTIONS|STATEMENTS|SUBROUTINE|TRUNCATION|TYPE-POOLS|ARITHMETIC|BACKGROUND|ENDPROVIDE|EXCEPTIONS|IDENTIFIER|INDEX-LINE|OBLIGATORY|PARAMETERS|PERCENTAGE|PUSHBUTTON|RESOLUTION|COMPONENTS|DEALLOCATE|DISCONNECT|DUPLICATES|FIRST-LINE|HEAD-LINES|NO-DISPLAY|OCCURRENCE|RESPECTING|RETURNCODE|SUBMATCHES|TRACE-FILE|ASCENDING|BYPASSING|ENDMODULE|EXCEPTION|EXCLUDING|EXPORTING|INCREMENT|MATCHCODE|PARAMETER|PARTIALLY|PREFERRED|REFERENCE|REPLACING|RETURNING|SELECTION|SEPARATED|SPECIFIED|STATEMENT|TIMESTAMP|TYPE-POOL|ACCEPTING|APPENDAGE|ASSIGNING|COL_GROUP|COMPARING|CONSTANTS|DANGEROUS|IMPORTING|INSTANCES|LEFTSPACE|LOG-POINT|QUICKINFO|READ-ONLY|SCROLLING|SQLSCRIPT|STEP-LOOP|TOP-LINES|TRANSLATE|APPENDING|AUTHORITY|CHARACTER|COMPONENT|CONDITION|DIRECTORY|DUPLICATE|MESSAGING|RECEIVING|SUBSCREEN|ACCORDING|COL_TOTAL|END-LINES|ENDMETHOD|ENDSELECT|EXPANDING|EXTENSION|INCLUDING|INFOTYPES|INTERFACE|INTERVALS|LINE-SIZE|PF-STATUS|PROCEDURE|PROTECTED|REQUESTED|RESUMABLE|RIGHTPLUS|SAP-SPOOL|SECONDARY|STRUCTURE|SUBSTRING|TABLEVIEW|NUMOFCHAR|ADJACENT|ANALYSIS|ASSIGNED|BACKWARD|CHANNELS|CHECKBOX|CONTINUE|CRITICAL|DATAINFO|DD\/MM\/YY|DURATION|ENCODING|ENDCLASS|FUNCTION|LEFTPLUS|LINEFEED|MM\/DD\/YY|OVERFLOW|RECEIVED|SKIPPING|SORTABLE|STANDARD|SUBTRACT|SUPPRESS|TABSTRIP|TITLEBAR|TRUNCATE|UNASSIGN|WHENEVER|ANALYZER|COALESCE|COMMENTS|CONDENSE|DECIMALS|DEFERRED|ENDWHILE|EXPLICIT|KEYWORDS|MESSAGES|POSITION|PRIORITY|RECEIVER|RENAMING|TIMEZONE|TRAILING|ALLOCATE|CENTERED|CIRCULAR|CONTROLS|CURRENCY|DELETING|DESCRIBE|DISTANCE|ENDCATCH|EXPONENT|EXTENDED|GENERATE|IGNORING|INCLUDES|INTERNAL|MAJOR-ID|MODIFIER|NEW-LINE|OPTIONAL|PROPERTY|ROLLBACK|STARTING|SUPPLIED|ABSTRACT|CHANGING|CONTEXTS|CREATING|CUSTOMER|DATABASE|DAYLIGHT|DEFINING|DISTINCT|DIVISION|ENABLING|ENDCHAIN|ESCAPING|HARMLESS|IMPLICIT|INACTIVE|LANGUAGE|MINOR-ID|MULTIPLY|NEW-PAGE|NO-TITLE|POS_HIGH|SEPARATE|TEXTPOOL|TRANSFER|SELECTOR|DBMAXLEN|ITERATOR|SELECTOR|ARCHIVE|BIT-XOR|BYTE-CO|COLLECT|COMMENT|CURRENT|DEFAULT|DISPLAY|ENDFORM|EXTRACT|LEADING|LISTBOX|LOCATOR|MEMBERS|METHODS|NESTING|POS_LOW|PROCESS|PROVIDE|RAISING|RESERVE|SECONDS|SUMMARY|VISIBLE|BETWEEN|BIT-AND|BYTE-CS|CLEANUP|COMPUTE|CONTROL|CONVERT|DATASET|ENDCASE|FORWARD|HEADERS|HOTSPOT|INCLUDE|INVERSE|KEEPING|NO-ZERO|OBJECTS|OVERLAY|PADDING|PATTERN|PROGRAM|REFRESH|SECTION|SUMMING|TESTING|VERSION|WINDOWS|WITHOUT|BIT-NOT|BYTE-CA|BYTE-NA|CASTING|CONTEXT|COUNTRY|DYNAMIC|ENABLED|ENDLOOP|EXECUTE|FRIENDS|HANDLER|HEADING|INITIAL|\*-INPUT|LOGFILE|MAXIMUM|MINIMUM|NO-GAPS|NO-SIGN|PRAGMAS|PRIMARY|PRIVATE|REDUCED|REPLACE|REQUEST|RESULTS|UNICODE|WARNING|ALIASES|BYTE-CN|BYTE-NS|CALLING|COL_KEY|COLUMNS|CONNECT|ENDEXEC|ENTRIES|EXCLUDE|FILTERS|FURTHER|HELP-ID|LOGICAL|MAPPING|MESSAGE|NAMETAB|OPTIONS|PACKAGE|PERFORM|RECEIVE|STATICS|VARYING|BINDING|CHARLEN|GREATER|XSTRLEN|ACCEPT|APPEND|DETAIL|ELSEIF|ENDING|ENDTRY|FORMAT|FRAMES|GIVING|HASHED|HEADER|IMPORT|INSERT|MARGIN|MODULE|NATIVE|OBJECT|OFFSET|REMOTE|RESUME|SAVING|SIMPLE|SUBMIT|TABBED|TOKENS|UNIQUE|UNPACK|UPDATE|WINDOW|YELLOW|ACTUAL|ASPECT|CENTER|CURSOR|DELETE|DIALOG|DIVIDE|DURING|ERRORS|EVENTS|EXTEND|FILTER|HANDLE|HAVING|IGNORE|LITTLE|MEMORY|NO-GAP|OCCURS|OPTION|PERSON|PLACES|PUBLIC|REDUCE|REPORT|RESULT|SINGLE|SORTED|SWITCH|SYNTAX|TARGET|VALUES|WRITER|ASSERT|BLOCKS|BOUNDS|BUFFER|CHANGE|COLUMN|COMMIT|CONCAT|COPIES|CREATE|DDMMYY|DEFINE|ENDIAN|ESCAPE|EXPAND|KERNEL|LAYOUT|LEGACY|LEVELS|MMDDYY|NUMBER|OUTPUT|RANGES|READER|RETURN|SCREEN|SEARCH|SELECT|SHARED|SOURCE|STABLE|STATIC|SUBKEY|SUFFIX|TABLES|UNWIND|YYMMDD|ASSIGN|BACKUP|BEFORE|BINARY|BIT-OR|BLANKS|CLIENT|CODING|COMMON|DEMAND|DYNPRO|EXCEPT|EXISTS|EXPORT|FIELDS|GLOBAL|GROUPS|LENGTH|LOCALE|MEDIUM|METHOD|MODIFY|NESTED|OTHERS|REJECT|SCROLL|SUPPLY|SYMBOL|ENDFOR|STRLEN|ALIGN|BEGIN|BOUND|ENDAT|ENTRY|EVENT|FINAL|FLUSH|GRANT|INNER|SHORT|USING|WRITE|AFTER|BLACK|BLOCK|CLOCK|COLOR|COUNT|DUMMY|EMPTY|ENDDO|ENDON|GREEN|INDEX|INOUT|LEAVE|LEVEL|LINES|MODIF|ORDER|OUTER|RANGE|RESET|RETRY|RIGHT|SMART|SPLIT|STYLE|TABLE|THROW|UNDER|UNTIL|UPPER|UTF-8|WHERE|ALIAS|BLANK|CLEAR|CLOSE|EXACT|FETCH|FIRST|FOUND|GROUP|LLANG|LOCAL|OTHER|REGEX|SPOOL|TITLE|TYPES|VALID|WHILE|ALPHA|BOXED|CATCH|CHAIN|CHECK|CLASS|COVER|ENDIF|EQUIV|FIELD|FLOOR|FRAME|INPUT|LOWER|MATCH|NODES|PAGES|PRINT|RAISE|ROUND|SHIFT|SPACE|SPOTS|STAMP|STATE|TASKS|TIMES|TRMAC|ULINE|UNION|VALUE|WIDTH|EQUAL|LOG10|TRUNC|BLOB|CASE|CEIL|CLOB|COND|EXIT|FILE|GAPS|HOLD|INCL|INTO|KEEP|KEYS|LAST|LINE|LONG|LPAD|MAIL|MODE|OPEN|PINK|READ|ROWS|TEST|THEN|ZERO|AREA|BACK|BADI|BYTE|CAST|EDIT|EXEC|FAIL|FIND|FKEQ|FONT|FREE|GKEQ|HIDE|INIT|ITNO|LATE|LOOP|MAIN|MARK|MOVE|NEXT|NULL|RISK|ROLE|UNIT|WAIT|ZONE|BASE|CALL|CODE|DATA|DATE|FKGE|GKGE|HIGH|KIND|LEFT|LIST|MASK|MESH|NAME|NODE|PACK|PAGE|POOL|SEND|SIGN|SIZE|SOME|STOP|TASK|TEXT|TIME|USER|VARY|WITH|WORD|BLUE|CONV|COPY|DEEP|ELSE|FORM|FROM|HINT|ICON|JOIN|LIKE|LOAD|ONLY|PART|SCAN|SKIP|SORT|TYPE|UNIX|VIEW|WHEN|WORK|ACOS|ASIN|ATAN|COSH|EACH|FRAC|LESS|RTTI|SINH|SQRT|TANH|AVG|BIT|DIV|ISO|LET|OUT|PAD|SQL|ALL|CI_|CPI|END|LOB|LPI|MAX|MIN|NEW|OLE|RUN|SET|\?TO|YES|ABS|ADD|AND|BIG|FOR|HDB|JOB|LOW|NOT|SAP|TRY|VIA|XML|ANY|GET|IDS|KEY|MOD|OFF|PUT|RAW|RED|REF|SUM|TAB|XSD|CNT|COS|EXP|LOG|SIN|TAN|XOR|AT|CO|CP|DO|GT|ID|IF|NS|OR|BT|CA|CS|GE|NA|NB|EQ|IN|LT|NE|NO|OF|ON|PF|TO|AS|BY|CN|IS|LE|NP|UP|E|I|M|O|Z|C|X)\b/i,lookbehind:!0},number:/\b\d+\b/,operator:{pattern:/(\s)(?:\*\*?|<[=>]?|>=?|\?=|[-+\/=])(?=\s)/,lookbehind:!0},"string-operator":{pattern:/(\s)&&?(?=\s)/,lookbehind:!0,alias:"keyword"},"token-operator":[{pattern:/(\w)(?:->?|=>|[~|{}])(?=\w)/,lookbehind:!0,alias:"punctuation"},{pattern:/[|{}]/,alias:"punctuation"}],punctuation:/[,.:()]/};
Prism.languages.actionscript=Prism.languages.extend("javascript",{keyword:/\b(?:as|break|case|catch|class|const|default|delete|do|else|extends|finally|for|function|if|implements|import|in|instanceof|interface|internal|is|native|new|null|package|private|protected|public|return|super|switch|this|throw|try|typeof|use|var|void|while|with|dynamic|each|final|get|include|namespace|native|override|set|static)\b/,operator:/\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/}),Prism.languages.actionscript["class-name"].alias="function",Prism.languages.markup&&Prism.languages.insertBefore("actionscript","string",{xml:{pattern:/(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\\1|\\?(?!\1)[\w\W])*\2)*\s*\/?>/,lookbehind:!0,inside:{rest:Prism.languages.markup}}});
Prism.languages.ada={comment:/--.*/,string:/"(?:""|[^"\r\f\n])*"/i,number:[{pattern:/\b[0-9](?:_?[0-9])*#[0-9A-F](?:_?[0-9A-F])*(?:\.[0-9A-F](?:_?[0-9A-F])*)?#(?:E[+-]?[0-9](?:_?[0-9])*)?/i},{pattern:/\b[0-9](?:_?[0-9])*(?:\.[0-9](?:_?[0-9])*)?(?:E[+-]?[0-9](?:_?[0-9])*)?\b/i}],"attr-name":/\b'\w+/i,keyword:/\b(?:abort|abs|abstract|accept|access|aliased|all|and|array|at|begin|body|case|constant|declare|delay|delta|digits|do|else|new|return|elsif|end|entry|exception|exit|for|function|generic|goto|if|in|interface|is|limited|loop|mod|not|null|of|others|out|overriding|package|pragma|private|procedure|protected|raise|range|record|rem|renames|requeue|reverse|select|separate|some|subtype|synchronized|tagged|task|terminate|then|type|until|use|when|while|with|xor)\b/i,"boolean":/\b(?:true|false)\b/i,operator:/<[=>]?|>=?|=>?|:=|\/=?|\*\*?|[&+-]/,punctuation:/\.\.?|[,;():]/,"char":/'.'/,variable:/\b[a-z](?:[_a-z\d])*\b/i};
Prism.languages.apacheconf={comment:/#.*/,"directive-inline":{pattern:/^(\s*)\b(AcceptFilter|AcceptPathInfo|AccessFileName|Action|AddAlt|AddAltByEncoding|AddAltByType|AddCharset|AddDefaultCharset|AddDescription|AddEncoding|AddHandler|AddIcon|AddIconByEncoding|AddIconByType|AddInputFilter|AddLanguage|AddModuleInfo|AddOutputFilter|AddOutputFilterByType|AddType|Alias|AliasMatch|Allow|AllowCONNECT|AllowEncodedSlashes|AllowMethods|AllowOverride|AllowOverrideList|Anonymous|Anonymous_LogEmail|Anonymous_MustGiveEmail|Anonymous_NoUserID|Anonymous_VerifyEmail|AsyncRequestWorkerFactor|AuthBasicAuthoritative|AuthBasicFake|AuthBasicProvider|AuthBasicUseDigestAlgorithm|AuthDBDUserPWQuery|AuthDBDUserRealmQuery|AuthDBMGroupFile|AuthDBMType|AuthDBMUserFile|AuthDigestAlgorithm|AuthDigestDomain|AuthDigestNonceLifetime|AuthDigestProvider|AuthDigestQop|AuthDigestShmemSize|AuthFormAuthoritative|AuthFormBody|AuthFormDisableNoStore|AuthFormFakeBasicAuth|AuthFormLocation|AuthFormLoginRequiredLocation|AuthFormLoginSuccessLocation|AuthFormLogoutLocation|AuthFormMethod|AuthFormMimetype|AuthFormPassword|AuthFormProvider|AuthFormSitePassphrase|AuthFormSize|AuthFormUsername|AuthGroupFile|AuthLDAPAuthorizePrefix|AuthLDAPBindAuthoritative|AuthLDAPBindDN|AuthLDAPBindPassword|AuthLDAPCharsetConfig|AuthLDAPCompareAsUser|AuthLDAPCompareDNOnServer|AuthLDAPDereferenceAliases|AuthLDAPGroupAttribute|AuthLDAPGroupAttributeIsDN|AuthLDAPInitialBindAsUser|AuthLDAPInitialBindPattern|AuthLDAPMaxSubGroupDepth|AuthLDAPRemoteUserAttribute|AuthLDAPRemoteUserIsDN|AuthLDAPSearchAsUser|AuthLDAPSubGroupAttribute|AuthLDAPSubGroupClass|AuthLDAPUrl|AuthMerging|AuthName|AuthnCacheContext|AuthnCacheEnable|AuthnCacheProvideFor|AuthnCacheSOCache|AuthnCacheTimeout|AuthnzFcgiCheckAuthnProvider|AuthnzFcgiDefineProvider|AuthType|AuthUserFile|AuthzDBDLoginToReferer|AuthzDBDQuery|AuthzDBDRedirectQuery|AuthzDBMType|AuthzSendForbiddenOnFailure|BalancerGrowth|BalancerInherit|BalancerMember|BalancerPersist|BrowserMatch|BrowserMatchNoCase|BufferedLogs|BufferSize|CacheDefaultExpire|CacheDetailHeader|CacheDirLength|CacheDirLevels|CacheDisable|CacheEnable|CacheFile|CacheHeader|CacheIgnoreCacheControl|CacheIgnoreHeaders|CacheIgnoreNoLastMod|CacheIgnoreQueryString|CacheIgnoreURLSessionIdentifiers|CacheKeyBaseURL|CacheLastModifiedFactor|CacheLock|CacheLockMaxAge|CacheLockPath|CacheMaxExpire|CacheMaxFileSize|CacheMinExpire|CacheMinFileSize|CacheNegotiatedDocs|CacheQuickHandler|CacheReadSize|CacheReadTime|CacheRoot|CacheSocache|CacheSocacheMaxSize|CacheSocacheMaxTime|CacheSocacheMinTime|CacheSocacheReadSize|CacheSocacheReadTime|CacheStaleOnError|CacheStoreExpired|CacheStoreNoStore|CacheStorePrivate|CGIDScriptTimeout|CGIMapExtension|CharsetDefault|CharsetOptions|CharsetSourceEnc|CheckCaseOnly|CheckSpelling|ChrootDir|ContentDigest|CookieDomain|CookieExpires|CookieName|CookieStyle|CookieTracking|CoreDumpDirectory|CustomLog|Dav|DavDepthInfinity|DavGenericLockDB|DavLockDB|DavMinTimeout|DBDExptime|DBDInitSQL|DBDKeep|DBDMax|DBDMin|DBDParams|DBDPersist|DBDPrepareSQL|DBDriver|DefaultIcon|DefaultLanguage|DefaultRuntimeDir|DefaultType|Define|DeflateBufferSize|DeflateCompressionLevel|DeflateFilterNote|DeflateInflateLimitRequestBody|DeflateInflateRatioBurst|DeflateInflateRatioLimit|DeflateMemLevel|DeflateWindowSize|Deny|DirectoryCheckHandler|DirectoryIndex|DirectoryIndexRedirect|DirectorySlash|DocumentRoot|DTracePrivileges|DumpIOInput|DumpIOOutput|EnableExceptionHook|EnableMMAP|EnableSendfile|Error|ErrorDocument|ErrorLog|ErrorLogFormat|Example|ExpiresActive|ExpiresByType|ExpiresDefault|ExtendedStatus|ExtFilterDefine|ExtFilterOptions|FallbackResource|FileETag|FilterChain|FilterDeclare|FilterProtocol|FilterProvider|FilterTrace|ForceLanguagePriority|ForceType|ForensicLog|GprofDir|GracefulShutdownTimeout|Group|Header|HeaderName|HeartbeatAddress|HeartbeatListen|HeartbeatMaxServers|HeartbeatStorage|HeartbeatStorage|HostnameLookups|IdentityCheck|IdentityCheckTimeout|ImapBase|ImapDefault|ImapMenu|Include|IncludeOptional|IndexHeadInsert|IndexIgnore|IndexIgnoreReset|IndexOptions|IndexOrderDefault|IndexStyleSheet|InputSed|ISAPIAppendLogToErrors|ISAPIAppendLogToQuery|ISAPICacheFile|ISAPIFakeAsync|ISAPILogNotSupported|ISAPIReadAheadBuffer|KeepAlive|KeepAliveTimeout|KeptBodySize|LanguagePriority|LDAPCacheEntries|LDAPCacheTTL|LDAPConnectionPoolTTL|LDAPConnectionTimeout|LDAPLibraryDebug|LDAPOpCacheEntries|LDAPOpCacheTTL|LDAPReferralHopLimit|LDAPReferrals|LDAPRetries|LDAPRetryDelay|LDAPSharedCacheFile|LDAPSharedCacheSize|LDAPTimeout|LDAPTrustedClientCert|LDAPTrustedGlobalCert|LDAPTrustedMode|LDAPVerifyServerCert|LimitInternalRecursion|LimitRequestBody|LimitRequestFields|LimitRequestFieldSize|LimitRequestLine|LimitXMLRequestBody|Listen|ListenBackLog|LoadFile|LoadModule|LogFormat|LogLevel|LogMessage|LuaAuthzProvider|LuaCodeCache|LuaHookAccessChecker|LuaHookAuthChecker|LuaHookCheckUserID|LuaHookFixups|LuaHookInsertFilter|LuaHookLog|LuaHookMapToStorage|LuaHookTranslateName|LuaHookTypeChecker|LuaInherit|LuaInputFilter|LuaMapHandler|LuaOutputFilter|LuaPackageCPath|LuaPackagePath|LuaQuickHandler|LuaRoot|LuaScope|MaxConnectionsPerChild|MaxKeepAliveRequests|MaxMemFree|MaxRangeOverlaps|MaxRangeReversals|MaxRanges|MaxRequestWorkers|MaxSpareServers|MaxSpareThreads|MaxThreads|MergeTrailers|MetaDir|MetaFiles|MetaSuffix|MimeMagicFile|MinSpareServers|MinSpareThreads|MMapFile|ModemStandard|ModMimeUsePathInfo|MultiviewsMatch|Mutex|NameVirtualHost|NoProxy|NWSSLTrustedCerts|NWSSLUpgradeable|Options|Order|OutputSed|PassEnv|PidFile|PrivilegesMode|Protocol|ProtocolEcho|ProxyAddHeaders|ProxyBadHeader|ProxyBlock|ProxyDomain|ProxyErrorOverride|ProxyExpressDBMFile|ProxyExpressDBMType|ProxyExpressEnable|ProxyFtpDirCharset|ProxyFtpEscapeWildcards|ProxyFtpListOnWildcard|ProxyHTMLBufSize|ProxyHTMLCharsetOut|ProxyHTMLDocType|ProxyHTMLEnable|ProxyHTMLEvents|ProxyHTMLExtended|ProxyHTMLFixups|ProxyHTMLInterp|ProxyHTMLLinks|ProxyHTMLMeta|ProxyHTMLStripComments|ProxyHTMLURLMap|ProxyIOBufferSize|ProxyMaxForwards|ProxyPass|ProxyPassInherit|ProxyPassInterpolateEnv|ProxyPassMatch|ProxyPassReverse|ProxyPassReverseCookieDomain|ProxyPassReverseCookiePath|ProxyPreserveHost|ProxyReceiveBufferSize|ProxyRemote|ProxyRemoteMatch|ProxyRequests|ProxySCGIInternalRedirect|ProxySCGISendfile|ProxySet|ProxySourceAddress|ProxyStatus|ProxyTimeout|ProxyVia|ReadmeName|ReceiveBufferSize|Redirect|RedirectMatch|RedirectPermanent|RedirectTemp|ReflectorHeader|RemoteIPHeader|RemoteIPInternalProxy|RemoteIPInternalProxyList|RemoteIPProxiesHeader|RemoteIPTrustedProxy|RemoteIPTrustedProxyList|RemoveCharset|RemoveEncoding|RemoveHandler|RemoveInputFilter|RemoveLanguage|RemoveOutputFilter|RemoveType|RequestHeader|RequestReadTimeout|Require|RewriteBase|RewriteCond|RewriteEngine|RewriteMap|RewriteOptions|RewriteRule|RLimitCPU|RLimitMEM|RLimitNPROC|Satisfy|ScoreBoardFile|Script|ScriptAlias|ScriptAliasMatch|ScriptInterpreterSource|ScriptLog|ScriptLogBuffer|ScriptLogLength|ScriptSock|SecureListen|SeeRequestTail|SendBufferSize|ServerAdmin|ServerAlias|ServerLimit|ServerName|ServerPath|ServerRoot|ServerSignature|ServerTokens|Session|SessionCookieName|SessionCookieName2|SessionCookieRemove|SessionCryptoCipher|SessionCryptoDriver|SessionCryptoPassphrase|SessionCryptoPassphraseFile|SessionDBDCookieName|SessionDBDCookieName2|SessionDBDCookieRemove|SessionDBDDeleteLabel|SessionDBDInsertLabel|SessionDBDPerUser|SessionDBDSelectLabel|SessionDBDUpdateLabel|SessionEnv|SessionExclude|SessionHeader|SessionInclude|SessionMaxAge|SetEnv|SetEnvIf|SetEnvIfExpr|SetEnvIfNoCase|SetHandler|SetInputFilter|SetOutputFilter|SSIEndTag|SSIErrorMsg|SSIETag|SSILastModified|SSILegacyExprParser|SSIStartTag|SSITimeFormat|SSIUndefinedEcho|SSLCACertificateFile|SSLCACertificatePath|SSLCADNRequestFile|SSLCADNRequestPath|SSLCARevocationCheck|SSLCARevocationFile|SSLCARevocationPath|SSLCertificateChainFile|SSLCertificateFile|SSLCertificateKeyFile|SSLCipherSuite|SSLCompression|SSLCryptoDevice|SSLEngine|SSLFIPS|SSLHonorCipherOrder|SSLInsecureRenegotiation|SSLOCSPDefaultResponder|SSLOCSPEnable|SSLOCSPOverrideResponder|SSLOCSPResponderTimeout|SSLOCSPResponseMaxAge|SSLOCSPResponseTimeSkew|SSLOCSPUseRequestNonce|SSLOpenSSLConfCmd|SSLOptions|SSLPassPhraseDialog|SSLProtocol|SSLProxyCACertificateFile|SSLProxyCACertificatePath|SSLProxyCARevocationCheck|SSLProxyCARevocationFile|SSLProxyCARevocationPath|SSLProxyCheckPeerCN|SSLProxyCheckPeerExpire|SSLProxyCheckPeerName|SSLProxyCipherSuite|SSLProxyEngine|SSLProxyMachineCertificateChainFile|SSLProxyMachineCertificateFile|SSLProxyMachineCertificatePath|SSLProxyProtocol|SSLProxyVerify|SSLProxyVerifyDepth|SSLRandomSeed|SSLRenegBufferSize|SSLRequire|SSLRequireSSL|SSLSessionCache|SSLSessionCacheTimeout|SSLSessionTicketKeyFile|SSLSRPUnknownUserSeed|SSLSRPVerifierFile|SSLStaplingCache|SSLStaplingErrorCacheTimeout|SSLStaplingFakeTryLater|SSLStaplingForceURL|SSLStaplingResponderTimeout|SSLStaplingResponseMaxAge|SSLStaplingResponseTimeSkew|SSLStaplingReturnResponderErrors|SSLStaplingStandardCacheTimeout|SSLStrictSNIVHostCheck|SSLUserName|SSLUseStapling|SSLVerifyClient|SSLVerifyDepth|StartServers|StartThreads|Substitute|Suexec|SuexecUserGroup|ThreadLimit|ThreadsPerChild|ThreadStackSize|TimeOut|TraceEnable|TransferLog|TypesConfig|UnDefine|UndefMacro|UnsetEnv|Use|UseCanonicalName|UseCanonicalPhysicalPort|User|UserDir|VHostCGIMode|VHostCGIPrivs|VHostGroup|VHostPrivs|VHostSecure|VHostUser|VirtualDocumentRoot|VirtualDocumentRootIP|VirtualScriptAlias|VirtualScriptAliasIP|WatchdogInterval|XBitHack|xml2EncAlias|xml2EncDefault|xml2StartParse)\b/im,lookbehind:!0,alias:"property"},"directive-block":{pattern:/<\/?\b(AuthnProviderAlias|AuthzProviderAlias|Directory|DirectoryMatch|Else|ElseIf|Files|FilesMatch|If|IfDefine|IfModule|IfVersion|Limit|LimitExcept|Location|LocationMatch|Macro|Proxy|RequireAll|RequireAny|RequireNone|VirtualHost)\b *.*>/i,inside:{"directive-block":{pattern:/^<\/?\w+/,inside:{punctuation:/^<\/?/},alias:"tag"},"directive-block-parameter":{pattern:/.*[^>]/,inside:{punctuation:/:/,string:{pattern:/("|').*\1/,inside:{variable:/(\$|%)\{?(\w\.?(\+|\-|:)?)+\}?/}}},alias:"attr-value"},punctuation:/>/},alias:"tag"},"directive-flags":{pattern:/\[(\w,?)+\]/,alias:"keyword"},string:{pattern:/("|').*\1/,inside:{variable:/(\$|%)\{?(\w\.?(\+|\-|:)?)+\}?/}},variable:/(\$|%)\{?(\w\.?(\+|\-|:)?)+\}?/,regex:/\^?.*\$|\^.*\$?/};
Prism.languages.apl={comment:/(?:|#[! ]).*$/m,string:/'(?:[^'\r\n]|'')*'/,number:/?(?:\d*\.?\d+(?:e[+]?\d+)?||)(?:j?(?:\d*\.?\d+(?:e[\+]?\d+)?||))?/i,statement:/:[A-Z][a-z][A-Za-z]*\b/,"system-function":{pattern:/[A-Z]+/i,alias:"function"},constant:/[#]/,"function":/[-+|?*!<=> ~,]/,"monadic-operator":{pattern:/[\\\/&]/,alias:"operator"},"dyadic-operator":{pattern:/[. ]/,alias:"operator"},assignment:{pattern://,alias:"keyword"},punctuation:/[\[;\]()]/,dfn:{pattern:/[{}:]/,alias:"builtin"}};
Prism.languages.applescript={comment:[/\(\*(?:\(\*[\w\W]*?\*\)|[\w\W])*?\*\)/,/--.+/,/#.+/],string:/"(?:\\?.)*?"/,number:/\b-?\d*\.?\d+([Ee]-?\d+)?\b/,operator:[/[&= *+\-\/^]|[<>]=?/,/\b(?:(?:start|begin|end)s? with|(?:(?:does not|doesn't) contain|contains?)|(?:is|isn't|is not) (?:in|contained by)|(?:(?:is|isn't|is not) )?(?:greater|less) than(?: or equal)?(?: to)?|(?:(?:does not|doesn't) come|comes) (?:before|after)|(?:is|isn't|is not) equal(?: to)?|(?:(?:does not|doesn't) equal|equals|equal to|isn't|is not)|(?:a )?(?:ref(?: to)?|reference to)|(?:and|or|div|mod|as|not))\b/],keyword:/\b(?:about|above|after|against|apart from|around|aside from|at|back|before|beginning|behind|below|beneath|beside|between|but|by|considering|continue|copy|does|eighth|else|end|equal|error|every|exit|false|fifth|first|for|fourth|from|front|get|given|global|if|ignoring|in|instead of|into|is|it|its|last|local|me|middle|my|ninth|of|on|onto|out of|over|prop|property|put|repeat|return|returning|second|set|seventh|since|sixth|some|tell|tenth|that|the|then|third|through|thru|timeout|times|to|transaction|true|try|until|where|while|whose|with|without)\b/,"class":{pattern:/\b(?:alias|application|boolean|class|constant|date|file|integer|list|number|POSIX file|real|record|reference|RGB color|script|text|centimetres|centimeters|feet|inches|kilometres|kilometers|metres|meters|miles|yards|square feet|square kilometres|square kilometers|square metres|square meters|square miles|square yards|cubic centimetres|cubic centimeters|cubic feet|cubic inches|cubic metres|cubic meters|cubic yards|gallons|litres|liters|quarts|grams|kilograms|ounces|pounds|degrees Celsius|degrees Fahrenheit|degrees Kelvin)\b/,alias:"builtin"},punctuation:/[{}():,]/};
!function(a){var i={pattern:/(^[ \t]*)\[(?!\[)(?:(["'$`])(?:(?!\2)[^\\]|\\.)*\2|\[(?:[^\]\\]|\\.)*\]|[^\]\\]|\\.)*\]/m,lookbehind:!0,inside:{quoted:{pattern:/([$`])(?:(?!\1)[^\\]|\\.)*\1/,inside:{punctuation:/^[$`]|[$`]$/}},interpreted:{pattern:/'(?:[^'\\]|\\.)*'/,inside:{punctuation:/^'|'$/}},string:/"(?:[^"\\]|\\.)*"/,variable:/\w+(?==)/,punctuation:/^\[|\]$|,/,operator:/=/,"attr-value":/(?!^\s+$).+/}};a.languages.asciidoc={"comment-block":{pattern:/^(\/{4,})(?:\r?\n|\r)(?:.*(?:\r?\n|\r))*?\1/m,alias:"comment"},table:{pattern:/^\|={3,}(?:(?:\r?\n|\r).*)*?(?:\r?\n|\r)\|={3,}$/m,inside:{specifiers:{pattern:/(?!\|)(?:(?:(?:\d+(?:\.\d+)?|\.\d+)[+*])?(?:[<^>](?:\.[<^>])?|\.[<^>])?[a-z]*)(?=\|)/,alias:"attr-value"},punctuation:{pattern:/(^|[^\\])[|!]=*/,lookbehind:!0}}},"passthrough-block":{pattern:/^(\+{4,})(?:\r?\n|\r)(?:.*(?:\r?\n|\r))*?\1$/m,inside:{punctuation:/^\++|\++$/}},"literal-block":{pattern:/^(-{4,}|\.{4,})(?:\r?\n|\r)(?:.*(?:\r?\n|\r))*?\1$/m,inside:{punctuation:/^(?:-+|\.+)|(?:-+|\.+)$/}},"other-block":{pattern:/^(--|\*{4,}|_{4,}|={4,})(?:\r?\n|\r)(?:.*(?:\r?\n|\r))*?\1$/m,inside:{punctuation:/^(?:-+|\*+|_+|=+)|(?:-+|\*+|_+|=+)$/}},"list-punctuation":{pattern:/(^[ \t]*)(?:-|\*{1,5}|\.{1,5}|(?:[a-z]|\d+)\.|[xvi]+\))(?= )/im,lookbehind:!0,alias:"punctuation"},"list-label":{pattern:/(^[ \t]*)[a-z\d].+(?::{2,4}|;;)(?=\s)/im,lookbehind:!0,alias:"symbol"},"indented-block":{pattern:/((\r?\n|\r)\2)([ \t]+)\S.*(?:(?:\r?\n|\r)\3.+)*(?=\2{2}|$)/,lookbehind:!0},comment:/^\/\/.*/m,title:{pattern:/^.+(?:\r?\n|\r)(?:={3,}|-{3,}|~{3,}|\^{3,}|\+{3,})$|^={1,5} +.+|^\.(?![\s.]).*/m,alias:"important",inside:{punctuation:/^(?:\.|=+)|(?:=+|-+|~+|\^+|\++)$/}},"attribute-entry":{pattern:/^:[^:\r\n]+:(?: .*?(?: \+(?:\r?\n|\r).*?)*)?$/m,alias:"tag"},attributes:i,hr:{pattern:/^'{3,}$/m,alias:"punctuation"},"page-break":{pattern:/^<{3,}$/m,alias:"punctuation"},admonition:{pattern:/^(?:TIP|NOTE|IMPORTANT|WARNING|CAUTION):/m,alias:"keyword"},callout:[{pattern:/(^[ \t]*)<?\d*>/m,lookbehind:!0,alias:"symbol"},{pattern:/<\d+>/,alias:"symbol"}],macro:{pattern:/\b[a-z\d][a-z\d-]*::?(?:(?:\S+)??\[(?:[^\]\\"]|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,inside:{"function":/^[a-z\d-]+(?=:)/,punctuation:/^::?/,attributes:{pattern:/(?:\[(?:[^\]\\"]|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,inside:i.inside}}},inline:{pattern:/(^|[^\\])(?:(?:\B\[(?:[^\]\\"]|(["'])(?:(?!\2)[^\\]|\\.)*\2|\\.)*\])?(?:\b_(?!\s)(?: _|[^_\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: _|[^_\\\r\n]|\\.)+)*_\b|\B``(?!\s).+?(?:(?:\r?\n|\r).+?)*''\B|\B`(?!\s)(?: ['`]|.)+?(?:(?:\r?\n|\r)(?: ['`]|.)+?)*['`]\B|\B(['*+#])(?!\s)(?: \3|(?!\3)[^\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: \3|(?!\3)[^\\\r\n]|\\.)+)*\3\B)|(?:\[(?:[^\]\\"]|(["'])(?:(?!\4)[^\\]|\\.)*\4|\\.)*\])?(?:(__|\*\*|\+\+\+?|##|\$\$|[~^]).+?(?:(?:\r?\n|\r).+?)*\5|\{[^}\r\n]+\}|\[\[\[?.+?(?:(?:\r?\n|\r).+?)*\]?\]\]|<<.+?(?:(?:\r?\n|\r).+?)*>>|\(\(\(?.+?(?:(?:\r?\n|\r).+?)*\)?\)\)))/m,lookbehind:!0,inside:{attributes:i,url:{pattern:/^(?:\[\[\[?.+?\]?\]\]|<<.+?>>)$/,inside:{punctuation:/^(?:\[\[\[?|<<)|(?:\]\]\]?|>>)$/}},"attribute-ref":{pattern:/^\{.+\}$/,inside:{variable:{pattern:/(^\{)[a-z\d,+_-]+/,lookbehind:!0},operator:/^[=?!#%@$]|!(?=[:}])/,punctuation:/^\{|\}$|::?/}},italic:{pattern:/^(['_])[\s\S]+\1$/,inside:{punctuation:/^(?:''?|__?)|(?:''?|__?)$/}},bold:{pattern:/^\*[\s\S]+\*$/,inside:{punctuation:/^\*\*?|\*\*?$/}},punctuation:/^(?:``?|\+{1,3}|##?|\$\$|[~^]|\(\(\(?)|(?:''?|\+{1,3}|##?|\$\$|[~^`]|\)?\)\))$/}},replacement:{pattern:/\((?:C|TM|R)\)/,alias:"builtin"},entity:/&#?[\da-z]{1,8};/i,"line-continuation":{pattern:/(^| )\+$/m,lookbehind:!0,alias:"punctuation"}},i.inside.interpreted.inside.rest={macro:a.languages.asciidoc.macro,inline:a.languages.asciidoc.inline,replacement:a.languages.asciidoc.replacement,entity:a.languages.asciidoc.entity},a.languages.asciidoc["passthrough-block"].inside.rest={macro:a.languages.asciidoc.macro},a.languages.asciidoc["literal-block"].inside.rest={callout:a.languages.asciidoc.callout},a.languages.asciidoc.table.inside.rest={"comment-block":a.languages.asciidoc["comment-block"],"passthrough-block":a.languages.asciidoc["passthrough-block"],"literal-block":a.languages.asciidoc["literal-block"],"other-block":a.languages.asciidoc["other-block"],"list-punctuation":a.languages.asciidoc["list-punctuation"],"indented-block":a.languages.asciidoc["indented-block"],comment:a.languages.asciidoc.comment,title:a.languages.asciidoc.title,"attribute-entry":a.languages.asciidoc["attribute-entry"],attributes:a.languages.asciidoc.attributes,hr:a.languages.asciidoc.hr,"page-break":a.languages.asciidoc["page-break"],admonition:a.languages.asciidoc.admonition,"list-label":a.languages.asciidoc["list-label"],callout:a.languages.asciidoc.callout,macro:a.languages.asciidoc.macro,inline:a.languages.asciidoc.inline,replacement:a.languages.asciidoc.replacement,entity:a.languages.asciidoc.entity,"line-continuation":a.languages.asciidoc["line-continuation"]},a.languages.asciidoc["other-block"].inside.rest={table:a.languages.asciidoc.table,"list-punctuation":a.languages.asciidoc["list-punctuation"],"indented-block":a.languages.asciidoc["indented-block"],comment:a.languages.asciidoc.comment,"attribute-entry":a.languages.asciidoc["attribute-entry"],attributes:a.languages.asciidoc.attributes,hr:a.languages.asciidoc.hr,"page-break":a.languages.asciidoc["page-break"],admonition:a.languages.asciidoc.admonition,"list-label":a.languages.asciidoc["list-label"],macro:a.languages.asciidoc.macro,inline:a.languages.asciidoc.inline,replacement:a.languages.asciidoc.replacement,entity:a.languages.asciidoc.entity,"line-continuation":a.languages.asciidoc["line-continuation"]},a.languages.asciidoc.title.inside.rest={macro:a.languages.asciidoc.macro,inline:a.languages.asciidoc.inline,replacement:a.languages.asciidoc.replacement,entity:a.languages.asciidoc.entity},a.hooks.add("wrap",function(a){"entity"===a.type&&(a.attributes.title=a.content.replace(/&amp;/,"&"))})}(Prism);
Prism.languages.aspnet=Prism.languages.extend("markup",{"page-directive tag":{pattern:/<%\s*@.*%>/i,inside:{"page-directive tag":/<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,rest:Prism.languages.markup.tag.inside}},"directive tag":{pattern:/<%.*%>/i,inside:{"directive tag":/<%\s*?[$=%#:]{0,2}|%>/i,rest:Prism.languages.csharp}}}),Prism.languages.aspnet.tag.pattern=/<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,Prism.languages.insertBefore("inside","punctuation",{"directive tag":Prism.languages.aspnet["directive tag"]},Prism.languages.aspnet.tag.inside["attr-value"]),Prism.languages.insertBefore("aspnet","comment",{"asp comment":/<%--[\w\W]*?--%>/}),Prism.languages.insertBefore("aspnet",Prism.languages.javascript?"script":"tag",{"asp script":{pattern:/(<script(?=.*runat=['"]?server['"]?)[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,lookbehind:!0,inside:Prism.languages.csharp||{}}});
Prism.languages.autoit={comment:[/;.*/,{pattern:/(^\s*)#(?:comments-start|cs)[\s\S]*?^\s*#(?:comments-end|ce)/m,lookbehind:!0}],url:{pattern:/(^\s*#include\s+)(?:<[^\r\n>]+>|"[^\r\n"]+")/m,lookbehind:!0},string:{pattern:/(["'])(?:\1\1|(?!\1)[^\r\n])*\1/,inside:{variable:/([%$@])\w+\1/}},directive:{pattern:/(^\s*)#\w+/m,lookbehind:!0,alias:"keyword"},"function":/\b\w+(?=\()/,variable:/[$@]\w+/,keyword:/\b(?:Case|Const|Continue(?:Case|Loop)|Default|Dim|Do|Else(?:If)?|End(?:Func|If|Select|Switch|With)|Enum|Exit(?:Loop)?|For|Func|Global|If|In|Local|Next|Null|ReDim|Select|Static|Step|Switch|Then|To|Until|Volatile|WEnd|While|With)\b/i,number:/\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,"boolean":/\b(?:True|False)\b/i,operator:/<[=>]?|[-+*\/=&>]=?|[?^]|\b(?:And|Or|Not)\b/i,punctuation:/[\[\]().,:]/};
Prism.languages.autohotkey={comment:{pattern:/(^[^";\n]*("[^"\n]*?"[^"\n]*?)*)(;.*$|^\s*\/\*[\s\S]*\n\*\/)/m,lookbehind:!0},string:/"(([^"\n\r]|"")*)"/m,"function":/[^\(\); \t,\n\+\*\-=\?>:\\\/<&%\[\]]+?(?=\()/m,tag:/^[ \t]*[^\s:]+?(?=:(?:[^:]|$))/m,variable:/%\w+%/,number:/\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?)\b/,operator:/\?|\/\/?=?|:=|\|[=|]?|&[=&]?|\+[=+]?|-[=-]?|\*[=*]?|<(?:<=?|>|=)?|>>?=?|[.^!=~]=?|\b(?:AND|NOT|OR)\b/,punctuation:/[\{}[\]\(\):,]/,"boolean":/\b(true|false)\b/,selector:/\b(AutoTrim|BlockInput|Break|Click|ClipWait|Continue|Control|ControlClick|ControlFocus|ControlGet|ControlGetFocus|ControlGetPos|ControlGetText|ControlMove|ControlSend|ControlSendRaw|ControlSetText|CoordMode|Critical|DetectHiddenText|DetectHiddenWindows|Drive|DriveGet|DriveSpaceFree|EnvAdd|EnvDiv|EnvGet|EnvMult|EnvSet|EnvSub|EnvUpdate|Exit|ExitApp|FileAppend|FileCopy|FileCopyDir|FileCreateDir|FileCreateShortcut|FileDelete|FileEncoding|FileGetAttrib|FileGetShortcut|FileGetSize|FileGetTime|FileGetVersion|FileInstall|FileMove|FileMoveDir|FileRead|FileReadLine|FileRecycle|FileRecycleEmpty|FileRemoveDir|FileSelectFile|FileSelectFolder|FileSetAttrib|FileSetTime|FormatTime|GetKeyState|Gosub|Goto|GroupActivate|GroupAdd|GroupClose|GroupDeactivate|Gui|GuiControl|GuiControlGet|Hotkey|ImageSearch|IniDelete|IniRead|IniWrite|Input|InputBox|KeyWait|ListHotkeys|ListLines|ListVars|Loop|Menu|MouseClick|MouseClickDrag|MouseGetPos|MouseMove|MsgBox|OnExit|OutputDebug|Pause|PixelGetColor|PixelSearch|PostMessage|Process|Progress|Random|RegDelete|RegRead|RegWrite|Reload|Repeat|Return|Run|RunAs|RunWait|Send|SendEvent|SendInput|SendMessage|SendMode|SendPlay|SendRaw|SetBatchLines|SetCapslockState|SetControlDelay|SetDefaultMouseSpeed|SetEnv|SetFormat|SetKeyDelay|SetMouseDelay|SetNumlockState|SetScrollLockState|SetStoreCapslockMode|SetTimer|SetTitleMatchMode|SetWinDelay|SetWorkingDir|Shutdown|Sleep|Sort|SoundBeep|SoundGet|SoundGetWaveVolume|SoundPlay|SoundSet|SoundSetWaveVolume|SplashImage|SplashTextOff|SplashTextOn|SplitPath|StatusBarGetText|StatusBarWait|StringCaseSense|StringGetPos|StringLeft|StringLen|StringLower|StringMid|StringReplace|StringRight|StringSplit|StringTrimLeft|StringTrimRight|StringUpper|Suspend|SysGet|Thread|ToolTip|Transform|TrayTip|URLDownloadToFile|WinActivate|WinActivateBottom|WinClose|WinGet|WinGetActiveStats|WinGetActiveTitle|WinGetClass|WinGetPos|WinGetText|WinGetTitle|WinHide|WinKill|WinMaximize|WinMenuSelectItem|WinMinimize|WinMinimizeAll|WinMinimizeAllUndo|WinMove|WinRestore|WinSet|WinSetTitle|WinShow|WinWait|WinWaitActive|WinWaitClose|WinWaitNotActive)\b/i,constant:/\b(a_ahkpath|a_ahkversion|a_appdata|a_appdatacommon|a_autotrim|a_batchlines|a_caretx|a_carety|a_computername|a_controldelay|a_cursor|a_dd|a_ddd|a_dddd|a_defaultmousespeed|a_desktop|a_desktopcommon|a_detecthiddentext|a_detecthiddenwindows|a_endchar|a_eventinfo|a_exitreason|a_formatfloat|a_formatinteger|a_gui|a_guievent|a_guicontrol|a_guicontrolevent|a_guiheight|a_guiwidth|a_guix|a_guiy|a_hour|a_iconfile|a_iconhidden|a_iconnumber|a_icontip|a_index|a_ipaddress1|a_ipaddress2|a_ipaddress3|a_ipaddress4|a_isadmin|a_iscompiled|a_iscritical|a_ispaused|a_issuspended|a_isunicode|a_keydelay|a_language|a_lasterror|a_linefile|a_linenumber|a_loopfield|a_loopfileattrib|a_loopfiledir|a_loopfileext|a_loopfilefullpath|a_loopfilelongpath|a_loopfilename|a_loopfileshortname|a_loopfileshortpath|a_loopfilesize|a_loopfilesizekb|a_loopfilesizemb|a_loopfiletimeaccessed|a_loopfiletimecreated|a_loopfiletimemodified|a_loopreadline|a_loopregkey|a_loopregname|a_loopregsubkey|a_loopregtimemodified|a_loopregtype|a_mday|a_min|a_mm|a_mmm|a_mmmm|a_mon|a_mousedelay|a_msec|a_mydocuments|a_now|a_nowutc|a_numbatchlines|a_ostype|a_osversion|a_priorhotkey|programfiles|a_programfiles|a_programs|a_programscommon|a_screenheight|a_screenwidth|a_scriptdir|a_scriptfullpath|a_scriptname|a_sec|a_space|a_startmenu|a_startmenucommon|a_startup|a_startupcommon|a_stringcasesense|a_tab|a_temp|a_thisfunc|a_thishotkey|a_thislabel|a_thismenu|a_thismenuitem|a_thismenuitempos|a_tickcount|a_timeidle|a_timeidlephysical|a_timesincepriorhotkey|a_timesincethishotkey|a_titlematchmode|a_titlematchmodespeed|a_username|a_wday|a_windelay|a_windir|a_workingdir|a_yday|a_year|a_yweek|a_yyyy|clipboard|clipboardall|comspec|errorlevel)\b/i,builtin:/\b(abs|acos|asc|asin|atan|ceil|chr|class|cos|dllcall|exp|fileexist|Fileopen|floor|il_add|il_create|il_destroy|instr|substr|isfunc|islabel|IsObject|ln|log|lv_add|lv_delete|lv_deletecol|lv_getcount|lv_getnext|lv_gettext|lv_insert|lv_insertcol|lv_modify|lv_modifycol|lv_setimagelist|mod|onmessage|numget|numput|registercallback|regexmatch|regexreplace|round|sin|tan|sqrt|strlen|sb_seticon|sb_setparts|sb_settext|strsplit|tv_add|tv_delete|tv_getchild|tv_getcount|tv_getnext|tv_get|tv_getparent|tv_getprev|tv_getselection|tv_gettext|tv_modify|varsetcapacity|winactive|winexist|__New|__Call|__Get|__Set)\b/i,symbol:/\b(alt|altdown|altup|appskey|backspace|browser_back|browser_favorites|browser_forward|browser_home|browser_refresh|browser_search|browser_stop|bs|capslock|ctrl|ctrlbreak|ctrldown|ctrlup|del|delete|down|end|enter|esc|escape|f1|f10|f11|f12|f13|f14|f15|f16|f17|f18|f19|f2|f20|f21|f22|f23|f24|f3|f4|f5|f6|f7|f8|f9|home|ins|insert|joy1|joy10|joy11|joy12|joy13|joy14|joy15|joy16|joy17|joy18|joy19|joy2|joy20|joy21|joy22|joy23|joy24|joy25|joy26|joy27|joy28|joy29|joy3|joy30|joy31|joy32|joy4|joy5|joy6|joy7|joy8|joy9|joyaxes|joybuttons|joyinfo|joyname|joypov|joyr|joyu|joyv|joyx|joyy|joyz|lalt|launch_app1|launch_app2|launch_mail|launch_media|lbutton|lcontrol|lctrl|left|lshift|lwin|lwindown|lwinup|mbutton|media_next|media_play_pause|media_prev|media_stop|numlock|numpad0|numpad1|numpad2|numpad3|numpad4|numpad5|numpad6|numpad7|numpad8|numpad9|numpadadd|numpadclear|numpaddel|numpaddiv|numpaddot|numpaddown|numpadend|numpadenter|numpadhome|numpadins|numpadleft|numpadmult|numpadpgdn|numpadpgup|numpadright|numpadsub|numpadup|pgdn|pgup|printscreen|ralt|rbutton|rcontrol|rctrl|right|rshift|rwin|rwindown|rwinup|scrolllock|shift|shiftdown|shiftup|space|tab|up|volume_down|volume_mute|volume_up|wheeldown|wheelleft|wheelright|wheelup|xbutton1|xbutton2)\b/i,important:/#\b(AllowSameLineComments|ClipboardTimeout|CommentFlag|ErrorStdOut|EscapeChar|HotkeyInterval|HotkeyModifierTimeout|Hotstring|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Include|IncludeAgain|InstallKeybdHook|InstallMouseHook|KeyHistory|LTrim|MaxHotkeysPerInterval|MaxMem|MaxThreads|MaxThreadsBuffer|MaxThreadsPerHotkey|NoEnv|NoTrayIcon|Persistent|SingleInstance|UseHook|WinActivateForce)\b/i,keyword:/\b(Abort|AboveNormal|Add|ahk_class|ahk_group|ahk_id|ahk_pid|All|Alnum|Alpha|AltSubmit|AltTab|AltTabAndMenu|AltTabMenu|AltTabMenuDismiss|AlwaysOnTop|AutoSize|Background|BackgroundTrans|BelowNormal|between|BitAnd|BitNot|BitOr|BitShiftLeft|BitShiftRight|BitXOr|Bold|Border|Button|ByRef|Checkbox|Checked|CheckedGray|Choose|ChooseString|Close|Color|ComboBox|Contains|ControlList|Count|Date|DateTime|Days|DDL|Default|DeleteAll|Delimiter|Deref|Destroy|Digit|Disable|Disabled|DropDownList|Edit|Eject|Else|Enable|Enabled|Error|Exist|Expand|ExStyle|FileSystem|First|Flash|Float|FloatFast|Focus|Font|for|global|Grid|Group|GroupBox|GuiClose|GuiContextMenu|GuiDropFiles|GuiEscape|GuiSize|Hdr|Hidden|Hide|High|HKCC|HKCR|HKCU|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKLM|HKU|Hours|HScroll|Icon|IconSmall|ID|IDLast|If|IfEqual|IfExist|IfGreater|IfGreaterOrEqual|IfInString|IfLess|IfLessOrEqual|IfMsgBox|IfNotEqual|IfNotExist|IfNotInString|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Ignore|ImageList|in|Integer|IntegerFast|Interrupt|is|italic|Join|Label|LastFound|LastFoundExist|Limit|Lines|List|ListBox|ListView|local|Lock|Logoff|Low|Lower|Lowercase|MainWindow|Margin|Maximize|MaximizeBox|MaxSize|Minimize|MinimizeBox|MinMax|MinSize|Minutes|MonthCal|Mouse|Move|Multi|NA|No|NoActivate|NoDefault|NoHide|NoIcon|NoMainWindow|norm|Normal|NoSort|NoSortHdr|NoStandard|Not|NoTab|NoTimers|Number|Off|Ok|On|OwnDialogs|Owner|Parse|Password|Picture|Pixel|Pos|Pow|Priority|ProcessName|Radio|Range|Read|ReadOnly|Realtime|Redraw|REG_BINARY|REG_DWORD|REG_EXPAND_SZ|REG_MULTI_SZ|REG_SZ|Region|Relative|Rename|Report|Resize|Restore|Retry|RGB|Screen|Seconds|Section|Serial|SetLabel|ShiftAltTab|Show|Single|Slider|SortDesc|Standard|static|Status|StatusBar|StatusCD|strike|Style|Submit|SysMenu|Tab2|TabStop|Text|Theme|Tile|ToggleCheck|ToggleEnable|ToolWindow|Top|Topmost|TransColor|Transparent|Tray|TreeView|TryAgain|Type|UnCheck|underline|Unicode|Unlock|UpDown|Upper|Uppercase|UseErrorLevel|Vis|VisFirst|Visible|VScroll|Wait|WaitClose|WantCtrlA|WantF2|WantReturn|While|Wrap|Xdigit|xm|xp|xs|Yes|ym|yp|ys)\b/i};
!function(e){var t={variable:[{pattern:/\$?\(\([\w\W]+?\)\)/,inside:{variable:[{pattern:/(^\$\(\([\w\W]+)\)\)/,lookbehind:!0},/^\$\(\(/],number:/\b-?(?:0x[\dA-Fa-f]+|\d*\.?\d+(?:[Ee]-?\d+)?)\b/,operator:/--?|-=|\+\+?|\+=|!=?|~|\*\*?|\*=|\/=?|%=?|<<=?|>>=?|<=?|>=?|==?|&&?|&=|\^=?|\|\|?|\|=|\?|:/,punctuation:/\(\(?|\)\)?|,|;/}},{pattern:/\$\([^)]+\)|`[^`]+`/,inside:{variable:/^\$\(|^`|\)$|`$/}},/\$(?:[a-z0-9_#\?\*!@]+|\{[^}]+\})/i]};e.languages.bash={shebang:{pattern:/^#!\s*\/bin\/bash|^#!\s*\/bin\/sh/,alias:"important"},comment:{pattern:/(^|[^"{\\])#.*/,lookbehind:!0},string:[{pattern:/((?:^|[^<])<<\s*)(?:"|')?(\w+?)(?:"|')?\s*\r?\n(?:[\s\S])*?\r?\n\2/g,lookbehind:!0,greedy:!0,inside:t},{pattern:/(["'])(?:\\\\|\\?[^\\])*?\1/g,greedy:!0,inside:t}],variable:t.variable,"function":{pattern:/(^|\s|;|\||&)(?:alias|apropos|apt-get|aptitude|aspell|awk|basename|bash|bc|bg|builtin|bzip2|cal|cat|cd|cfdisk|chgrp|chmod|chown|chroot|chkconfig|cksum|clear|cmp|comm|command|cp|cron|crontab|csplit|cut|date|dc|dd|ddrescue|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|enable|env|ethtool|eval|exec|expand|expect|export|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|getopts|git|grep|groupadd|groupdel|groupmod|groups|gzip|hash|head|help|hg|history|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|jobs|join|kill|killall|less|link|ln|locate|logname|logout|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|make|man|mkdir|mkfifo|mkisofs|mknod|more|most|mount|mtools|mtr|mv|mmv|nano|netstat|nice|nl|nohup|notify-send|npm|nslookup|open|op|passwd|paste|pathchk|ping|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd|quota|quotacheck|quotactl|ram|rar|rcp|read|readarray|readonly|reboot|rename|renice|remsync|rev|rm|rmdir|rsync|screen|scp|sdiff|sed|seq|service|sftp|shift|shopt|shutdown|sleep|slocate|sort|source|split|ssh|stat|strace|su|sudo|sum|suspend|sync|tail|tar|tee|test|time|timeout|times|touch|top|traceroute|trap|tr|tsort|tty|type|ulimit|umask|umount|unalias|uname|unexpand|uniq|units|unrar|unshar|uptime|useradd|userdel|usermod|users|uuencode|uudecode|v|vdir|vi|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yes|zip)(?=$|\s|;|\||&)/,lookbehind:!0},keyword:{pattern:/(^|\s|;|\||&)(?:let|:|\.|if|then|else|elif|fi|for|break|continue|while|in|case|function|select|do|done|until|echo|exit|return|set|declare)(?=$|\s|;|\||&)/,lookbehind:!0},"boolean":{pattern:/(^|\s|;|\||&)(?:true|false)(?=$|\s|;|\||&)/,lookbehind:!0},operator:/&&?|\|\|?|==?|!=?|<<<?|>>|<=?|>=?|=~/,punctuation:/\$?\(\(?|\)\)?|\.\.|[{}[\];]/};var a=t.variable[1].inside;a["function"]=e.languages.bash["function"],a.keyword=e.languages.bash.keyword,a.boolean=e.languages.bash.boolean,a.operator=e.languages.bash.operator,a.punctuation=e.languages.bash.punctuation}(Prism);
Prism.languages.basic={string:/"(?:""|[!#$%&'()*,\/:;<=>?^_ +\-.A-Z\d])*"/i,comment:{pattern:/(?:!|REM\b).+/i,inside:{keyword:/^REM/i}},number:/(?:\b|\B[.-])(?:\d+\.?\d*)(?:E[+-]?\d+)?/i,keyword:/\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SHARED|SINGLE|SELECT CASE|SHELL|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,"function":/\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,operator:/<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,punctuation:/[,;:()]/};
!function(e){var r=/%%?[~:\w]+%?|!\S+!/,t={pattern:/\/[a-z?]+(?=[ :]|$):?|-[a-z]\b|--[a-z-]+\b/im,alias:"attr-name",inside:{punctuation:/:/}},n=/"[^"]*"/,i=/(?:\b|-)\d+\b/;e.languages.batch={comment:[/^::.*/m,{pattern:/((?:^|[&(])[ \t]*)rem\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,lookbehind:!0}],label:{pattern:/^:.*/m,alias:"property"},command:[{pattern:/((?:^|[&(])[ \t]*)for(?: ?\/[a-z?](?:[ :](?:"[^"]*"|\S+))?)* \S+ in \([^)]+\) do/im,lookbehind:!0,inside:{keyword:/^for\b|\b(?:in|do)\b/i,string:n,parameter:t,variable:r,number:i,punctuation:/[()',]/}},{pattern:/((?:^|[&(])[ \t]*)if(?: ?\/[a-z?](?:[ :](?:"[^"]*"|\S+))?)* (?:not )?(?:cmdextversion \d+|defined \w+|errorlevel \d+|exist \S+|(?:"[^"]*"|\S+)?(?:==| (?:equ|neq|lss|leq|gtr|geq) )(?:"[^"]*"|\S+))/im,lookbehind:!0,inside:{keyword:/^if\b|\b(?:not|cmdextversion|defined|errorlevel|exist)\b/i,string:n,parameter:t,variable:r,number:i,operator:/\^|==|\b(?:equ|neq|lss|leq|gtr|geq)\b/i}},{pattern:/((?:^|[&()])[ \t]*)else\b/im,lookbehind:!0,inside:{keyword:/^else\b/i}},{pattern:/((?:^|[&(])[ \t]*)set(?: ?\/[a-z](?:[ :](?:"[^"]*"|\S+))?)* (?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,lookbehind:!0,inside:{keyword:/^set\b/i,string:n,parameter:t,variable:[r,/\w+(?=(?:[*\/%+\-&^|]|<<|>>)?=)/],number:i,operator:/[*\/%+\-&^|]=?|<<=?|>>=?|[!~_=]/,punctuation:/[()',]/}},{pattern:/((?:^|[&(])[ \t]*@?)\w+\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,lookbehind:!0,inside:{keyword:/^\w+\b/i,string:n,parameter:t,label:{pattern:/(^\s*):\S+/m,lookbehind:!0,alias:"property"},variable:r,number:i,operator:/\^/}}],operator:/[&@]/,punctuation:/[()']/}}(Prism);
Prism.languages.c=Prism.languages.extend("clike",{keyword:/\b(asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,operator:/\-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*\/]/,number:/\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)[ful]*\b/i}),Prism.languages.insertBefore("c","string",{macro:{pattern:/(^\s*)#\s*[a-z]+([^\r\n\\]|\\.|\\(?:\r\n?|\n))*/im,lookbehind:!0,alias:"property",inside:{string:{pattern:/(#\s*include\s*)(<.+?>|("|')(\\?.)+?\3)/,lookbehind:!0},directive:{pattern:/(#\s*)\b(define|elif|else|endif|error|ifdef|ifndef|if|import|include|line|pragma|undef|using)\b/,lookbehind:!0,alias:"keyword"}}},constant:/\b(__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|stdin|stdout|stderr)\b/}),delete Prism.languages.c["class-name"],delete Prism.languages.c["boolean"];
Prism.languages.brainfuck={pointer:{pattern:/<|>/,alias:"keyword"},increment:{pattern:/\+/,alias:"inserted"},decrement:{pattern:/-/,alias:"deleted"},branching:{pattern:/\[|\]/,alias:"important"},operator:/[.,]/,comment:/\S+/};
Prism.languages.bro={comment:{pattern:/(^|[^\\$])#.*/,lookbehind:!0,inside:{italic:/\b(TODO|FIXME|XXX)\b/}},string:{pattern:/(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"boolean":/\b(T|F)\b/,"function":{pattern:/(?:function|hook|event) [a-zA-Z0-9_]+(::[a-zA-Z0-9_]+)?/,inside:{keyword:/^(?:function|hook|event)/}},variable:{pattern:/(?:global|local) [a-zA-Z0-9_]+/i,inside:{keyword:/(?:global|local)/}},builtin:/(@(load(-(sigs|plugin))?|unload|prefixes|ifn?def|else|(end)?if|DIR|FILENAME))|(&?(redef|priority|log|optional|default|add_func|delete_func|expire_func|read_expire|write_expire|create_expire|synchronized|persistent|rotate_interval|rotate_size|encrypt|raw_output|mergeable|group|error_handler|type_column))/,constant:{pattern:/const [a-zA-Z0-9_]+/i,inside:{keyword:/const/}},keyword:/\b(break|next|continue|alarm|using|of|add|delete|export|print|return|schedule|when|timeout|addr|any|bool|count|double|enum|file|int|interval|pattern|opaque|port|record|set|string|subnet|table|time|vector|for|if|else|in|module|function)\b/,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&|\|\|?|\?|\*|\/|~|\^|%/,number:/\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,punctuation:/[{}[\];(),.:]/};
Prism.languages.bison=Prism.languages.extend("c",{}),Prism.languages.insertBefore("bison","comment",{bison:{pattern:/^[\s\S]*?%%[\s\S]*?%%/,inside:{c:{pattern:/%\{[\s\S]*?%\}|\{(?:\{[^}]*\}|[^{}])*\}/,inside:{delimiter:{pattern:/^%?\{|%?\}$/,alias:"punctuation"},"bison-variable":{pattern:/[$@](?:<[^\s>]+>)?[\w$]+/,alias:"variable",inside:{punctuation:/<|>/}},rest:Prism.languages.c}},comment:Prism.languages.c.comment,string:Prism.languages.c.string,property:/\S+(?=:)/,keyword:/%\w+/,number:{pattern:/(^|[^@])\b(?:0x[\da-f]+|\d+)/i,lookbehind:!0},punctuation:/%[%?]|[|:;\[\]<>]/}}});
Prism.languages.csharp=Prism.languages.extend("clike",{keyword:/\b(abstract|as|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|do|double|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|goto|if|implicit|in|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|private|protected|public|readonly|ref|return|sbyte|sealed|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|virtual|void|volatile|while|add|alias|ascending|async|await|descending|dynamic|from|get|global|group|into|join|let|orderby|partial|remove|select|set|value|var|where|yield)\b/,string:[/@("|')(\1\1|\\\1|\\?(?!\1)[\s\S])*\1/,/("|')(\\?.)*?\1/],number:/\b-?(0x[\da-f]+|\d*\.?\d+f?)\b/i}),Prism.languages.insertBefore("csharp","keyword",{"generic-method":{pattern:/[a-z0-9_]+\s*<[^>\r\n]+?>\s*(?=\()/i,alias:"function",inside:{keyword:Prism.languages.csharp.keyword,punctuation:/[<>(),.:]/}},preprocessor:{pattern:/(^\s*)#.*/m,lookbehind:!0,alias:"property",inside:{directive:{pattern:/(\s*#)\b(define|elif|else|endif|endregion|error|if|line|pragma|region|undef|warning)\b/,lookbehind:!0,alias:"keyword"}}}});
Prism.languages.cpp=Prism.languages.extend("c",{keyword:/\b(alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,"boolean":/\b(true|false)\b/,operator:/[-+]{1,2}|!=?|<{1,2}=?|>{1,2}=?|\->|:{1,2}|={1,2}|\^|~|%|&{1,2}|\|?\||\?|\*|\/|\b(and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/}),Prism.languages.insertBefore("cpp","keyword",{"class-name":{pattern:/(class\s+)[a-z0-9_]+/i,lookbehind:!0}});
!function(e){var t=/#(?!\{).+/,n={pattern:/#\{[^}]+\}/,alias:"variable"};e.languages.coffeescript=e.languages.extend("javascript",{comment:t,string:[{pattern:/'(?:\\?[^\\])*?'/,greedy:!0},{pattern:/"(?:\\?[^\\])*?"/,greedy:!0,inside:{interpolation:n}}],keyword:/\b(and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,"class-member":{pattern:/@(?!\d)\w+/,alias:"variable"}}),e.languages.insertBefore("coffeescript","comment",{"multiline-comment":{pattern:/###[\s\S]+?###/,alias:"comment"},"block-regex":{pattern:/\/{3}[\s\S]*?\/{3}/,alias:"regex",inside:{comment:t,interpolation:n}}}),e.languages.insertBefore("coffeescript","string",{"inline-javascript":{pattern:/`(?:\\?[\s\S])*?`/,inside:{delimiter:{pattern:/^`|`$/,alias:"punctuation"},rest:e.languages.javascript}},"multiline-string":[{pattern:/'''[\s\S]*?'''/,greedy:!0,alias:"string"},{pattern:/"""[\s\S]*?"""/,greedy:!0,alias:"string",inside:{interpolation:n}}]}),e.languages.insertBefore("coffeescript","keyword",{property:/(?!\d)\w+(?=\s*:(?!:))/}),delete e.languages.coffeescript["template-string"]}(Prism);
!function(e){e.languages.ruby=e.languages.extend("clike",{comment:/#(?!\{[^\r\n]*?\}).*/,keyword:/\b(alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|false|for|if|in|module|new|next|nil|not|or|raise|redo|require|rescue|retry|return|self|super|then|throw|true|undef|unless|until|when|while|yield)\b/});var n={pattern:/#\{[^}]+\}/,inside:{delimiter:{pattern:/^#\{|\}$/,alias:"tag"},rest:e.util.clone(e.languages.ruby)}};e.languages.insertBefore("ruby","keyword",{regex:[{pattern:/%r([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1[gim]{0,3}/,inside:{interpolation:n}},{pattern:/%r\((?:[^()\\]|\\[\s\S])*\)[gim]{0,3}/,inside:{interpolation:n}},{pattern:/%r\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}[gim]{0,3}/,inside:{interpolation:n}},{pattern:/%r\[(?:[^\[\]\\]|\\[\s\S])*\][gim]{0,3}/,inside:{interpolation:n}},{pattern:/%r<(?:[^<>\\]|\\[\s\S])*>[gim]{0,3}/,inside:{interpolation:n}},{pattern:/(^|[^\/])\/(?!\/)(\[.+?]|\\.|[^\/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/,lookbehind:!0}],variable:/[@$]+[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\b)/,symbol:/:[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\b)/}),e.languages.insertBefore("ruby","number",{builtin:/\b(Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|File|Fixnum|Fload|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\b/,constant:/\b[A-Z][a-zA-Z_0-9]*(?:[?!]|\b)/}),e.languages.ruby.string=[{pattern:/%[qQiIwWxs]?([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1/,inside:{interpolation:n}},{pattern:/%[qQiIwWxs]?\((?:[^()\\]|\\[\s\S])*\)/,inside:{interpolation:n}},{pattern:/%[qQiIwWxs]?\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}/,inside:{interpolation:n}},{pattern:/%[qQiIwWxs]?\[(?:[^\[\]\\]|\\[\s\S])*\]/,inside:{interpolation:n}},{pattern:/%[qQiIwWxs]?<(?:[^<>\\]|\\[\s\S])*>/,inside:{interpolation:n}},{pattern:/("|')(#\{[^}]+\}|\\(?:\r?\n|\r)|\\?.)*?\1/,inside:{interpolation:n}}]}(Prism);
Prism.languages.css.selector={pattern:/[^\{\}\s][^\{\}]*(?=\s*\{)/,inside:{"pseudo-element":/:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,"pseudo-class":/:[-\w]+(?:\(.*\))?/,"class":/\.[-:\.\w]+/,id:/#[-:\.\w]+/,attribute:/\[[^\]]+\]/}},Prism.languages.insertBefore("css","function",{hexcode:/#[\da-f]{3,6}/i,entity:/\\[\da-f]{1,8}/i,number:/[\d%\.]+/});
Prism.languages.d=Prism.languages.extend("clike",{string:[/\b[rx]"(\\.|[^\\"])*"[cwd]?/,/\bq"(?:\[[\s\S]*?\]|\([\s\S]*?\)|<[\s\S]*?>|\{[\s\S]*?\})"/,/\bq"([_a-zA-Z][_a-zA-Z\d]*)(?:\r?\n|\r)[\s\S]*?(?:\r?\n|\r)\1"/,/\bq"(.)[\s\S]*?\1"/,/'(?:\\'|\\?[^']+)'/,/(["`])(\\.|(?!\1)[^\\])*\1[cwd]?/],number:[/\b0x\.?[a-f\d_]+(?:(?!\.\.)\.[a-f\d_]*)?(?:p[+-]?[a-f\d_]+)?[ulfi]*/i,{pattern:/((?:\.\.)?)(?:\b0b\.?|\b|\.)\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:e[+-]?\d[\d_]*)?[ulfi]*/i,lookbehind:!0}],keyword:/\$|\b(?:abstract|alias|align|asm|assert|auto|body|bool|break|byte|case|cast|catch|cdouble|cent|cfloat|char|class|const|continue|creal|dchar|debug|default|delegate|delete|deprecated|do|double|else|enum|export|extern|false|final|finally|float|for|foreach|foreach_reverse|function|goto|idouble|if|ifloat|immutable|import|inout|int|interface|invariant|ireal|lazy|long|macro|mixin|module|new|nothrow|null|out|override|package|pragma|private|protected|public|pure|real|ref|return|scope|shared|short|static|struct|super|switch|synchronized|template|this|throw|true|try|typedef|typeid|typeof|ubyte|ucent|uint|ulong|union|unittest|ushort|version|void|volatile|wchar|while|with|__(?:(?:FILE|MODULE|LINE|FUNCTION|PRETTY_FUNCTION|DATE|EOF|TIME|TIMESTAMP|VENDOR|VERSION)__|gshared|traits|vector|parameters)|string|wstring|dstring|size_t|ptrdiff_t)\b/,operator:/\|[|=]?|&[&=]?|\+[+=]?|-[-=]?|\.?\.\.|=[>=]?|!(?:i[ns]\b|<>?=?|>=?|=)?|\bi[ns]\b|(?:<[<>]?|>>?>?|\^\^|[*\/%^~])=?/}),Prism.languages.d.comment=[/^\s*#!.+/,{pattern:/(^|[^\\])\/\+(?:\/\+[\w\W]*?\+\/|[\w\W])*?\+\//,lookbehind:!0}].concat(Prism.languages.d.comment),Prism.languages.insertBefore("d","comment",{"token-string":{pattern:/\bq\{(?:|\{[^}]*\}|[^}])*\}/,alias:"string"}}),Prism.languages.insertBefore("d","keyword",{property:/\B@\w*/}),Prism.languages.insertBefore("d","function",{register:{pattern:/\b(?:[ABCD][LHX]|E[ABCD]X|E?(?:BP|SP|DI|SI)|[ECSDGF]S|CR[0234]|DR[012367]|TR[3-7]|X?MM[0-7]|R[ABCD]X|[BS]PL|R[BS]P|[DS]IL|R[DS]I|R(?:[89]|1[0-5])[BWD]?|XMM(?:[89]|1[0-5])|YMM(?:1[0-5]|\d))\b|\bST(?:\([0-7]\)|\b)/,alias:"variable"}});
Prism.languages.dart=Prism.languages.extend("clike",{string:[/r?("""|''')[\s\S]*?\1/,/r?("|')(\\?.)*?\1/],keyword:[/\b(?:async|sync|yield)\*/,/\b(?:abstract|assert|async|await|break|case|catch|class|const|continue|default|deferred|do|dynamic|else|enum|export|external|extends|factory|final|finally|for|get|if|implements|import|in|library|new|null|operator|part|rethrow|return|set|static|super|switch|this|throw|try|typedef|var|void|while|with|yield)\b/],operator:/\bis!|\b(?:as|is)\b|\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?/}),Prism.languages.insertBefore("dart","function",{metadata:{pattern:/@\w+/,alias:"symbol"}});
Prism.languages.diff={coord:[/^(?:\*{3}|-{3}|\+{3}).*$/m,/^@@.*@@$/m,/^\d+.*$/m],deleted:/^[-<].*$/m,inserted:/^[+>].*$/m,diff:{pattern:/^!(?!!).+$/m,alias:"important"}};
Prism.languages.docker={keyword:{pattern:/(^\s*)(?:ONBUILD|FROM|MAINTAINER|RUN|EXPOSE|ENV|ADD|COPY|VOLUME|USER|WORKDIR|CMD|LABEL|ENTRYPOINT)(?=\s)/im,lookbehind:!0},string:/("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*?\1/,comment:/#.*/,punctuation:/---|\.\.\.|[:[\]{}\-,|>?]/};
Prism.languages.eiffel={string:[/"([^[]*)\[[\s\S]+?\]\1"/,/"([^{]*)\{[\s\S]+?\}\1"/,/"(?:%\s+%|%"|.)*?"/],comment:/--.*/,"char":/'(?:%'|.)+?'/,keyword:/\b(?:across|agent|alias|all|and|attached|as|assign|attribute|check|class|convert|create|Current|debug|deferred|detachable|do|else|elseif|end|ensure|expanded|export|external|feature|from|frozen|if|implies|inherit|inspect|invariant|like|local|loop|not|note|obsolete|old|once|or|Precursor|redefine|rename|require|rescue|Result|retry|select|separate|some|then|undefine|until|variant|Void|when|xor)\b/i,"boolean":/\b(?:True|False)\b/i,number:[/\b0[xcb][\da-f](?:_*[\da-f])*\b/i,/(?:\d(?:_*\d)*)?\.(?:(?:\d(?:_*\d)*)?[eE][+-]?)?\d(?:_*\d)*|\d(?:_*\d)*\.?/],punctuation:/:=|<<|>>|\(\||\|\)|->|\.(?=\w)|[{}[\];(),:?]/,operator:/\\\\|\|\.\.\||\.\.|\/[~\/=]?|[><]=?|[-+*^=~]/};
Prism.languages.elixir={comment:{pattern:/(^|[^#])#(?![{#]).*/m,lookbehind:!0},regex:/~[rR](?:("""|'''|[\/|"'])(?:\\.|(?!\1)[^\\])+\1|\((?:\\\)|[^)])+\)|\[(?:\\\]|[^\]])+\]|\{(?:\\\}|[^}])+\}|<(?:\\>|[^>])+>)[uismxfr]*/,string:[{pattern:/~[cCsSwW](?:("""|'''|[\/|"'])(?:\\.|(?!\1)[^\\])+\1|\((?:\\\)|[^)])+\)|\[(?:\\\]|[^\]])+\]|\{(?:\\\}|#\{[^}]+\}|[^}])+\}|<(?:\\>|[^>])+>)[csa]?/,inside:{}},{pattern:/("""|''')[\s\S]*?\1/,inside:{}},{pattern:/("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,inside:{}}],atom:{pattern:/(^|[^:]):\w+/,lookbehind:!0,alias:"symbol"},"attr-name":/\w+:(?!:)/,capture:{pattern:/(^|[^&])&(?:[^&\s\d()][^\s()]*|(?=\())/,lookbehind:!0,alias:"function"},argument:{pattern:/(^|[^&])&\d+/,lookbehind:!0,alias:"variable"},attribute:{pattern:/@[\S]+/,alias:"variable"},number:/\b(?:0[box][a-f\d_]+|\d[\d_]*)(?:\.[\d_]+)?(?:e[+-]?[\d_]+)?\b/i,keyword:/\b(?:after|alias|and|case|catch|cond|def(?:callback|exception|impl|module|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|require|rescue|try|unless|use|when)\b/,"boolean":/\b(?:true|false|nil)\b/,operator:[/\bin\b|&&?|\|[|>]?|\\\\|::|\.\.\.?|\+\+?|-[->]?|<[-=>]|>=|!==?|\B!|=(?:==?|[>~])?|[*\/^]/,{pattern:/([^<])<(?!<)/,lookbehind:!0},{pattern:/([^>])>(?!>)/,lookbehind:!0}],punctuation:/<<|>>|[.,%\[\]{}()]/},Prism.languages.elixir.string.forEach(function(e){e.inside={interpolation:{pattern:/#\{[^}]+\}/,inside:{delimiter:{pattern:/^#\{|\}$/,alias:"punctuation"},rest:Prism.util.clone(Prism.languages.elixir)}}}});
Prism.languages.erlang={comment:/%.+/,string:/"(?:\\?.)*?"/,"quoted-function":{pattern:/'(?:\\.|[^'\\])+'(?=\()/,alias:"function"},"quoted-atom":{pattern:/'(?:\\.|[^'\\])+'/,alias:"atom"},"boolean":/\b(?:true|false)\b/,keyword:/\b(?:fun|when|case|of|end|if|receive|after|try|catch)\b/,number:[/\$\\?./,/\d+#[a-z0-9]+/i,/(?:\b|-)\d*\.?\d+([Ee][+-]?\d+)?\b/],"function":/\b[a-z][\w@]*(?=\()/,variable:{pattern:/(^|[^@])(?:\b|\?)[A-Z_][\w@]*/,lookbehind:!0},operator:[/[=\/<>:]=|=[:\/]=|\+\+?|--?|[=*\/!]|\b(?:bnot|div|rem|band|bor|bxor|bsl|bsr|not|and|or|xor|orelse|andalso)\b/,{pattern:/(^|[^<])<(?!<)/,lookbehind:!0},{pattern:/(^|[^>])>(?!>)/,lookbehind:!0}],atom:/\b[a-z][\w@]*/,punctuation:/[()[\]{}:;,.#|]|<<|>>/};
Prism.languages.fsharp=Prism.languages.extend("clike",{comment:[{pattern:/(^|[^\\])\(\*[\w\W]*?\*\)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0}],keyword:/\b(?:let|return|use|yield)(?:!\B|\b)|\b(abstract|and|as|assert|base|begin|class|default|delegate|do|done|downcast|downto|elif|else|end|exception|extern|false|finally|for|fun|function|global|if|in|inherit|inline|interface|internal|lazy|match|member|module|mutable|namespace|new|not|null|of|open|or|override|private|public|rec|select|static|struct|then|to|true|try|type|upcast|val|void|when|while|with|asr|land|lor|lsl|lsr|lxor|mod|sig|atomic|break|checked|component|const|constraint|constructor|continue|eager|event|external|fixed|functor|include|method|mixin|object|parallel|process|protected|pure|sealed|tailcall|trait|virtual|volatile)\b/,string:/(?:"""[\s\S]*?"""|@"(?:""|[^"])*"|("|')(?:\\\1|\\?(?!\1)[\s\S])*\1)B?/,number:[/\b-?0x[\da-fA-F]+(un|lf|LF)?\b/,/\b-?0b[01]+(y|uy)?\b/,/\b-?(\d*\.?\d+|\d+\.)([fFmM]|[eE][+-]?\d+)?\b/,/\b-?\d+(y|uy|s|us|l|u|ul|L|UL|I)?\b/]}),Prism.languages.insertBefore("fsharp","keyword",{preprocessor:{pattern:/^[^\r\n\S]*#.*/m,alias:"property",inside:{directive:{pattern:/(\s*#)\b(else|endif|if|light|line|nowarn)\b/,lookbehind:!0,alias:"keyword"}}}});
Prism.languages.fortran={"quoted-number":{pattern:/[BOZ](['"])[A-F0-9]+\1/i,alias:"number"},string:{pattern:/(?:\w+_)?(['"])(?:\1\1|&(?:\r\n?|\n)(?:\s*!.+(?:\r\n?|\n))?|(?!\1).)*(?:\1|&)/,inside:{comment:{pattern:/(&(?:\r\n?|\n)\s*)!.*/,lookbehind:!0}}},comment:/!.*/,"boolean":/\.(?:TRUE|FALSE)\.(?:_\w+)?/i,number:/(?:\b|[+-])(?:\d+(?:\.\d*)?|\.\d+)(?:[ED][+-]?\d+)?(?:_\w+)?/i,keyword:[/\b(?:INTEGER|REAL|DOUBLE ?PRECISION|COMPLEX|CHARACTER|LOGICAL)\b/i,/\b(?:END ?)?(?:BLOCK ?DATA|DO|FILE|FORALL|FUNCTION|IF|INTERFACE|MODULE(?! PROCEDURE)|PROGRAM|SELECT|SUBROUTINE|TYPE|WHERE)\b/i,/\b(?:ALLOCATABLE|ALLOCATE|BACKSPACE|CALL|CASE|CLOSE|COMMON|CONTAINS|CONTINUE|CYCLE|DATA|DEALLOCATE|DIMENSION|DO|END|EQUIVALENCE|EXIT|EXTERNAL|FORMAT|GO ?TO|IMPLICIT(?: NONE)?|INQUIRE|INTENT|INTRINSIC|MODULE PROCEDURE|NAMELIST|NULLIFY|OPEN|OPTIONAL|PARAMETER|POINTER|PRINT|PRIVATE|PUBLIC|READ|RETURN|REWIND|SAVE|SELECT|STOP|TARGET|WHILE|WRITE)\b/i,/\b(?:ASSIGNMENT|DEFAULT|ELEMENTAL|ELSE|ELSEWHERE|ELSEIF|ENTRY|IN|INCLUDE|INOUT|KIND|NULL|ONLY|OPERATOR|OUT|PURE|RECURSIVE|RESULT|SEQUENCE|STAT|THEN|USE)\b/i],operator:[/\*\*|\/\/|=>|[=\/]=|[<>]=?|::|[+\-*=%]|\.(?:EQ|NE|LT|LE|GT|GE|NOT|AND|OR|EQV|NEQV)\.|\.[A-Z]+\./i,{pattern:/(^|(?!\().)\/(?!\))/,lookbehind:!0}],punctuation:/\(\/|\/\)|[(),;:&]/};
Prism.languages.gherkin={pystring:{pattern:/("""|''')[\s\S]+?\1/,alias:"string"},comment:{pattern:/((^|\r?\n|\r)[ \t]*)#.*/,lookbehind:!0},tag:{pattern:/((^|\r?\n|\r)[ \t]*)@\S*/,lookbehind:!0},feature:{pattern:/((^|\r?\n|\r)[ \t]*)(Ability|Ahoy matey!|Arwedd|Aspekt|Besigheid Behoefte|Business Need|Caracteristica|Caracterstica|Egenskab|Egenskap|Eiginleiki|Feature|Fa|Fitur|Fonctionnalit|Fonksyonalite|Funcionalidade|Funcionalitat|Functionalitate|Funcionalitate|Funcionalitate|Functionaliteit|Fungsi|Funkcia|Funkcija|Funkcionalitte|Funkcionalnost|Funkcja|Funksie|Funktionalitt|Funktionalitit|Funzionalit |Hwaet|Hwt|Jellemz|Karakteristik|laH|Lastnost|Mak|Mogucnost|Mogunost|Moznosti|Monosti|OH HAI|Omadus|Ominaisuus|Osobina|zellik|perbogh|poQbogh malja'|Potrzeba biznesowa|Poadavek|Poiadavka|Pretty much|Qap|Qu'meH 'ut|Savyb|Tnh nng|Trajto|Vermo|Vlastnos|Waciwo|Znailnost|||||||||||| ||||  || || ||||||||||):([^:]+(?:\r?\n|\r|$))*/,lookbehind:!0,inside:{important:{pattern:/(:)[^\r\n]+/,lookbehind:!0},keyword:/[^:\r\n]+:/}},scenario:{pattern:/((^|\r?\n|\r)[ \t]*)(Abstract Scenario|Abstrakt Scenario|Achtergrond|Aer|r|Agtergrond|All y'all|Antecedentes|Antecedents|Atburars|Atburarsir|Awww, look mate|B4|Background|Baggrund|Bakgrund|Bakgrunn|Bakgrunnur|Beispiele|Beispiller|Bi cnh|Cefndir|Cenario|Cenrio|Cenario de Fundo|Cenrio de Fundo|Cenarios|Cenrios|Contesto|Context|Contexte|Contexto|Conto|Contoh|Contone|Dmi|Dasar|Dead men tell no tales|Delineacao do Cenario|Delineao do Cenrio|Dis is what went down|D liu|Dyagram senaryo|Dyagram Senaryo|Egzanp|Ejemplos|Eksempler|Ekzemploj|Enghreifftiau|Esbozo do escenario|Escenari|Escenario|Esempi|Esquema de l'escenari|Esquema del escenario|Esquema do Cenario|Esquema do Cenrio|Examples|EXAMPLZ|Exempel|Exemple|Exemples|Exemplos|First off|Fono|Forgatknyv|Forgatknyv vzlat|Fundo|Gemi|ghantoH|Grundlage|Hannergrond|Httr|Heave to|Istorik|Juhtumid|Keadaan|Khung kch bn|Khung tnh hung|Kch bn|Koncept|Konsep skenario|Kontks|Kontekst|Kontekstas|Konteksts|Kontext|Konturo de la scenaro|Latar Belakang|lut|lut chovnatlh|lutmey|Lsing Atburarsar|Lsing Dma|Menggariskan Senario|MISHUN|MISHUN SRSLY|mo'|Nrt Scenra|Nrt Scne|Nrt Scenru|Oris scenarija|rnekler|Osnova|Osnova Scenra|Osnova scne|Osnutek|Ozadje|Paraugs|Pavyzdiai|Pldk|Piemri|Plan du scnario|Plan du Scnario|Plan senaryo|Plan Senaryo|Plang vum Szenario|Pozad|Pozadie|Pozadina|Prklady|Pklady|Primer|Primeri|Primjeri|Przykady|Raamstsenaarium|Reckon it's like|Rerefons|Scenr|Scn|Scenarie|Scenarij|Scenarijai|Scenarijaus ablonas|Scenariji|Scenrijs|Scenrijs pc parauga|Scenarijus|Scenario|Scnario|Scenario Amlinellol|Scenario Outline|Scenario Template|Scenariomal|Scenariomall|Scenarios|Scenariu|Scenariusz|Scenaro|Schema dello scenario|Se e|Se the|Se e|Senario|Senaryo|Senaryo deskripsyon|Senaryo Deskripsyon|Senaryo tasla|Shiver me timbers|Situcija|Situai|Situasie|Situasie Uiteensetting|Skenario|Skenario konsep|Skica|Structura scenariu|Structur scenariu|Struktura scenarija|Stsenaarium|Swa|Swa hwaer swa|Swa hwr swa|Szablon scenariusza|Szenario|Szenariogrundriss|Tapaukset|Tapaus|Tapausaihio|Taust|Tausta|Template Keadaan|Template Senario|Template Situai|The thing of it is|Tnh hung|Variantai|Voorbeelde|Voorbeelden|Wharrimean is|Yo\-ho\-ho|You'll wanna|Zaoenia| |  ||||||||||||||||||   || | | || | ||||||||  ||| || |||| ||   || ||| | ||| |  |||||||||||||||||| |||||||||||||||| | |):[^:\r\n]*/,lookbehind:!0,inside:{important:{pattern:/(:)[^\r\n]*/,lookbehind:!0},keyword:/[^:\r\n]+:/}},"table-body":{pattern:/((?:\r?\n|\r)[ \t]*\|.+\|[^\r\n]*)+/,lookbehind:!0,inside:{outline:{pattern:/<[^>]+?>/,alias:"variable"},td:{pattern:/\s*[^\s|][^|]*/,alias:"string"},punctuation:/\|/}},"table-head":{pattern:/((?:\r?\n|\r)[ \t]*\|.+\|[^\r\n]*)/,inside:{th:{pattern:/\s*[^\s|][^|]*/,alias:"variable"},punctuation:/\|/}},atrule:{pattern:/((?:\r?\n|\r)[ \t]+)('ach|'a|'ej|7|a|A tak|A taktie|A tie|A zrove|Aber|Ac|Adott|Akkor|Ak|Aleshores|Ale|Ali|Allora|Alors|Als|Ama|Amennyiben|Amikor|Ampak|an|AN|Ananging|And y'all|And|Angenommen|Anrhegedig a|An|Apabila|Ats|Atesa|Atunci|Avast!|Aye|A|awer|Bagi|Banjur|Bet|Bit|Blimey!|Buh|But at the end of the day I reckon|But y'all|But|BUT|Cal|Cnd|Cando|Cand|Ce|Cuando|e|a e|a|Dadas|Dada|Dados|Dado|DaH ghu' bejlu'|dann|Dann|Dano|Dan|Dar|Dat fiind|Data|Date fiind|Date|Dati fiind|Dati|Dai fiind|Dai fiind|Dato|DEN|Den youse gotta|Dengan|De|Diberi|Diyelim ki|Donada|Donat|Donitao|Do|Dun|Duota|urh|Eeldades|Ef|Eer ki|Entao|Ento|Entn|Entonces|En|Epi|E|s|Etant donne|Etant donn|Et|tant donnes|tant donne|tant donn|Etant donnes|Etant donns|tant donns|Fakat|Gangway!|Gdy|Gegeben seien|Gegeben sei|Gegeven|Gegewe|ghu' noblu'|Gitt|Given y'all|Given|Givet|Givun|Ha|Cho|I CAN HAZ|In|Ir|It's just unbelievable|I|Ja|Jeli|Jeeli|Kadar|Kada|Kad|Kai|Kaj|Kdy|Ke|Kemudian|Ketika|Khi|Kiedy|Ko|Kuid|Kui|Kun|Lan|latlh|Le sa a|Let go and haul|Le|L sa a|L|Logo|Lorsqu'<|Lorsque|m|Maar|Mais|Majc|Majd|Maka|Manawa|Mas|Ma|Menawa|Men|Mutta|Nalikaning|Nalika|Nanging|Nr|Nr|Nato|Nhng|Niin|Njuk|O zaman|Og|Och|Oletetaan|Onda|Ond|Oraz|Pak|Pero|Per|Podano|Pokia|Pokud|Potem|Potom|Privzeto|Pryd|qaSDI'|Quando|Quand|Quan|S|Sed|Se|Siis|Sipoze ke|Sipoze Ke|Sipoze|Si|i|i|Soit|Stel|Tada|Tad|Takrat|Tak|Tapi|Ter|Tetapi|Tha the|Tha|Then y'all|Then|Th|Thurh|Toda|Too right|ugeholl|Und|Un|V |vaj|Vendar|Ve|wann|Wanneer|WEN|Wenn|When y'all|When|Wtedy|Wun|Y'know|Yeah nah|Yna|Youse know like when|Youse know when youse got|Y|Za predpokladu|Za pedpokladu|Zadani|Zadano|Zadan|Zadate|Zadato|Zakadajc|Zaradi|Zatati|a e|a||egar|urh|||||| |||||||||||||||||||||  ||||||||||||, |||||||||||||| |||||||| |||||||| |||||||||||||||||||| ||||| ||||||||||||||<| <|<|<|<| <|<|<|<|<| <|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<)(?=[ \t]+)/,lookbehind:!0},string:{pattern:/("(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*')/,inside:{outline:{pattern:/<[^>]+?>/,alias:"variable"}}},outline:{pattern:/<[^>]+?>/,alias:"variable"}};
Prism.languages.git={comment:/^#.*/m,deleted:/^[-].*/m,inserted:/^\+.*/m,string:/("|')(\\?.)*?\1/m,command:{pattern:/^.*\$ git .*$/m,inside:{parameter:/\s(--|-)\w+/m}},coord:/^@@.*@@$/m,commit_sha1:/^commit \w{40}$/m};
Prism.languages.glsl=Prism.languages.extend("clike",{comment:[/\/\*[\w\W]*?\*\//,/\/\/(?:\\(?:\r\n|[\s\S])|.)*/],number:/\b(?:0x[\da-f]+|(?:\.\d+|\d+\.?\d*)(?:e[+-]?\d+)?)[ulf]*\b/i,keyword:/\b(?:attribute|const|uniform|varying|buffer|shared|coherent|volatile|restrict|readonly|writeonly|atomic_uint|layout|centroid|flat|smooth|noperspective|patch|sample|break|continue|do|for|while|switch|case|default|if|else|subroutine|in|out|inout|float|double|int|void|bool|true|false|invariant|precise|discard|return|d?mat[234](?:x[234])?|[ibdu]?vec[234]|uint|lowp|mediump|highp|precision|[iu]?sampler[123]D|[iu]?samplerCube|sampler[12]DShadow|samplerCubeShadow|[iu]?sampler[12]DArray|sampler[12]DArrayShadow|[iu]?sampler2DRect|sampler2DRectShadow|[iu]?samplerBuffer|[iu]?sampler2DMS(?:Array)?|[iu]?samplerCubeArray|samplerCubeArrayShadow|[iu]?image[123]D|[iu]?image2DRect|[iu]?imageCube|[iu]?imageBuffer|[iu]?image[12]DArray|[iu]?imageCubeArray|[iu]?image2DMS(?:Array)?|struct|common|partition|active|asm|class|union|enum|typedef|template|this|resource|goto|inline|noinline|public|static|extern|external|interface|long|short|half|fixed|unsigned|superp|input|output|hvec[234]|fvec[234]|sampler3DRect|filter|sizeof|cast|namespace|using)\b/}),Prism.languages.insertBefore("glsl","comment",{preprocessor:{pattern:/(^[ \t]*)#(?:(?:define|undef|if|ifdef|ifndef|else|elif|endif|error|pragma|extension|version|line)\b)?/m,lookbehind:!0,alias:"builtin"}});
Prism.languages.go=Prism.languages.extend("clike",{keyword:/\b(break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,builtin:/\b(bool|byte|complex(64|128)|error|float(32|64)|rune|string|u?int(8|16|32|64|)|uintptr|append|cap|close|complex|copy|delete|imag|len|make|new|panic|print(ln)?|real|recover)\b/,"boolean":/\b(_|iota|nil|true|false)\b/,operator:/[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,number:/\b(-?(0x[a-f\d]+|(\d+\.?\d*|\.\d+)(e[-+]?\d+)?)i?)\b/i,string:/("|'|`)(\\?.|\r|\n)*?\1/}),delete Prism.languages.go["class-name"];
Prism.languages.graphql={comment:/#.*/,string:{pattern:/"(?:\\.|[^\\"])*"/,greedy:!0},number:/(?:\B-|\b)\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b/,"boolean":/\b(?:true|false)\b/,variable:/\$[a-z_]\w*/i,directive:{pattern:/@[a-z_]\w*/i,alias:"function"},"attr-name":/[a-z_]\w*(?=\s*:)/i,keyword:[{pattern:/(fragment\s+(?!on)[a-z_]\w*\s+|\.\.\.\s*)on\b/,lookbehind:!0},/\b(?:query|fragment|mutation)\b/],operator:/!|=|\.{3}/,punctuation:/[!(){}\[\]:=,]/};
Prism.languages.groovy=Prism.languages.extend("clike",{keyword:/\b(as|def|in|abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,string:[{pattern:/("""|''')[\W\w]*?\1|(\$\/)(\$\/\$|[\W\w])*?\/\$/,greedy:!0},{pattern:/("|'|\/)(?:\\?.)*?\1/,greedy:!0}],number:/\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?[\d]+)?)[glidf]?\b/i,operator:{pattern:/(^|[^.])(~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.{1,2}(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,lookbehind:!0},punctuation:/\.+|[{}[\];(),:$]/}),Prism.languages.insertBefore("groovy","string",{shebang:{pattern:/#!.+/,alias:"comment"}}),Prism.languages.insertBefore("groovy","punctuation",{"spock-block":/\b(setup|given|when|then|and|cleanup|expect|where):/}),Prism.languages.insertBefore("groovy","function",{annotation:{alias:"punctuation",pattern:/(^|[^.])@\w+/,lookbehind:!0}}),Prism.hooks.add("wrap",function(e){if("groovy"===e.language&&"string"===e.type){var t=e.content[0];if("'"!=t){var n=/([^\\])(\$(\{.*?\}|[\w\.]+))/;"$"===t&&(n=/([^\$])(\$(\{.*?\}|[\w\.]+))/),e.content=e.content.replace(/&amp;/g,"&").replace(/&lt;/g,"<"),e.content=Prism.highlight(e.content,{expression:{pattern:n,lookbehind:!0,inside:Prism.languages.groovy}}),e.classes.push("/"===t?"regex":"gstring")}}});
!function(e){e.languages.haml={"multiline-comment":{pattern:/((?:^|\r?\n|\r)([\t ]*))(?:\/|-#).*((?:\r?\n|\r)\2[\t ]+.+)*/,lookbehind:!0,alias:"comment"},"multiline-code":[{pattern:/((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*,[\t ]*((?:\r?\n|\r)\2[\t ]+.*,[\t ]*)*((?:\r?\n|\r)\2[\t ]+.+)/,lookbehind:!0,inside:{rest:e.languages.ruby}},{pattern:/((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*\|[\t ]*((?:\r?\n|\r)\2[\t ]+.*\|[\t ]*)*/,lookbehind:!0,inside:{rest:e.languages.ruby}}],filter:{pattern:/((?:^|\r?\n|\r)([\t ]*)):[\w-]+((?:\r?\n|\r)(?:\2[\t ]+.+|\s*?(?=\r?\n|\r)))+/,lookbehind:!0,inside:{"filter-name":{pattern:/^:[\w-]+/,alias:"variable"}}},markup:{pattern:/((?:^|\r?\n|\r)[\t ]*)<.+/,lookbehind:!0,inside:{rest:e.languages.markup}},doctype:{pattern:/((?:^|\r?\n|\r)[\t ]*)!!!(?: .+)?/,lookbehind:!0},tag:{pattern:/((?:^|\r?\n|\r)[\t ]*)[%.#][\w\-#.]*[\w\-](?:\([^)]+\)|\{(?:\{[^}]+\}|[^}])+\}|\[[^\]]+\])*[\/<>]*/,lookbehind:!0,inside:{attributes:[{pattern:/(^|[^#])\{(?:\{[^}]+\}|[^}])+\}/,lookbehind:!0,inside:{rest:e.languages.ruby}},{pattern:/\([^)]+\)/,inside:{"attr-value":{pattern:/(=\s*)(?:"(?:\\?.)*?"|[^)\s]+)/,lookbehind:!0},"attr-name":/[\w:-]+(?=\s*!?=|\s*[,)])/,punctuation:/[=(),]/}},{pattern:/\[[^\]]+\]/,inside:{rest:e.languages.ruby}}],punctuation:/[<>]/}},code:{pattern:/((?:^|\r?\n|\r)[\t ]*(?:[~-]|[&!]?=)).+/,lookbehind:!0,inside:{rest:e.languages.ruby}},interpolation:{pattern:/#\{[^}]+\}/,inside:{delimiter:{pattern:/^#\{|\}$/,alias:"punctuation"},rest:e.languages.ruby}},punctuation:{pattern:/((?:^|\r?\n|\r)[\t ]*)[~=\-&!]+/,lookbehind:!0}};for(var t="((?:^|\\r?\\n|\\r)([\\t ]*)):{{filter_name}}((?:\\r?\\n|\\r)(?:\\2[\\t ]+.+|\\s*?(?=\\r?\\n|\\r)))+",r=["css",{filter:"coffee",language:"coffeescript"},"erb","javascript","less","markdown","ruby","scss","textile"],n={},a=0,i=r.length;i>a;a++){var l=r[a];l="string"==typeof l?{filter:l,language:l}:l,e.languages[l.language]&&(n["filter-"+l.filter]={pattern:RegExp(t.replace("{{filter_name}}",l.filter)),lookbehind:!0,inside:{"filter-name":{pattern:/^:[\w-]+/,alias:"variable"},rest:e.languages[l.language]}})}e.languages.insertBefore("haml","filter",n)}(Prism);
!function(e){var a=/\{\{\{[\w\W]+?\}\}\}|\{\{[\w\W]+?\}\}/g;e.languages.handlebars=e.languages.extend("markup",{handlebars:{pattern:a,inside:{delimiter:{pattern:/^\{\{\{?|\}\}\}?$/i,alias:"punctuation"},string:/(["'])(\\?.)*?\1/,number:/\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee][+-]?\d+)?)\b/,"boolean":/\b(true|false)\b/,block:{pattern:/^(\s*~?\s*)[#\/]\S+?(?=\s*~?\s*$|\s)/i,lookbehind:!0,alias:"keyword"},brackets:{pattern:/\[[^\]]+\]/,inside:{punctuation:/\[|\]/,variable:/[\w\W]+/}},punctuation:/[!"#%&'()*+,.\/;<=>@\[\\\]^`{|}~]/,variable:/[^!"#%&'()*+,.\/;<=>@\[\\\]^`{|}~\s]+/}}}),e.languages.insertBefore("handlebars","tag",{"handlebars-comment":{pattern:/\{\{![\w\W]*?\}\}/,alias:["handlebars","comment"]}}),e.hooks.add("before-highlight",function(e){"handlebars"===e.language&&(e.tokenStack=[],e.code=e.code.replace(a,function(a){return e.tokenStack.push(a),"___HANDLEBARS"+e.tokenStack.length+"___"}))}),e.hooks.add("after-highlight",function(a){if("handlebars"===a.language){for(var n,t=0;n=a.tokenStack[t];t++)a.highlightedCode=a.highlightedCode.replace("___HANDLEBARS"+(t+1)+"___",e.highlight(n,a.grammar,"handlebars").replace(/\$/g,"$$$$"));a.element.innerHTML=a.highlightedCode}})}(Prism);
Prism.languages.haskell={comment:{pattern:/(^|[^-!#$%*+=?&@|~.:<>^\\\/])(--[^-!#$%*+=?&@|~.:<>^\\\/].*|{-[\w\W]*?-})/m,lookbehind:!0},"char":/'([^\\']|\\([abfnrtv\\"'&]|\^[A-Z@[\]\^_]|NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|\d+|o[0-7]+|x[0-9a-fA-F]+))'/,string:{pattern:/"([^\\"]|\\([abfnrtv\\"'&]|\^[A-Z@[\]\^_]|NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|\d+|o[0-7]+|x[0-9a-fA-F]+)|\\\s+\\)*"/,greedy:!0},keyword:/\b(case|class|data|deriving|do|else|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b/,import_statement:{pattern:/(\r?\n|\r|^)\s*import\s+(qualified\s+)?([A-Z][_a-zA-Z0-9']*)(\.[A-Z][_a-zA-Z0-9']*)*(\s+as\s+([A-Z][_a-zA-Z0-9']*)(\.[A-Z][_a-zA-Z0-9']*)*)?(\s+hiding\b)?/m,inside:{keyword:/\b(import|qualified|as|hiding)\b/}},builtin:/\b(abs|acos|acosh|all|and|any|appendFile|approxRational|asTypeOf|asin|asinh|atan|atan2|atanh|basicIORun|break|catch|ceiling|chr|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|denominator|digitToInt|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldl|foldl1|foldr|foldr1|fromDouble|fromEnum|fromInt|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|group|head|id|inRange|index|init|intToDigit|interact|ioError|isAlpha|isAlphaNum|isAscii|isControl|isDenormalized|isDigit|isHexDigit|isIEEE|isInfinite|isLower|isNaN|isNegativeZero|isOctDigit|isPrint|isSpace|isUpper|iterate|last|lcm|length|lex|lexDigits|lexLitChar|lines|log|logBase|lookup|map|mapM|mapM_|max|maxBound|maximum|maybe|min|minBound|minimum|mod|negate|not|notElem|null|numerator|odd|or|ord|otherwise|pack|pi|pred|primExitWith|print|product|properFraction|putChar|putStr|putStrLn|quot|quotRem|range|rangeSize|read|readDec|readFile|readFloat|readHex|readIO|readInt|readList|readLitChar|readLn|readOct|readParen|readSigned|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequence_|show|showChar|showInt|showList|showLitChar|showParen|showSigned|showString|shows|showsPrec|significand|signum|sin|sinh|snd|sort|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|threadToIOResult|toEnum|toInt|toInteger|toLower|toRational|toUpper|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)\b/,number:/\b(\d+(\.\d+)?(e[+-]?\d+)?|0o[0-7]+|0x[0-9a-f]+)\b/i,operator:/\s\.\s|[-!#$%*+=?&@|~.:<>^\\\/]*\.[-!#$%*+=?&@|~.:<>^\\\/]+|[-!#$%*+=?&@|~.:<>^\\\/]+\.[-!#$%*+=?&@|~.:<>^\\\/]*|[-!#$%*+=?&@|~:<>^\\\/]+|`([A-Z][_a-zA-Z0-9']*\.)*[_a-z][_a-zA-Z0-9']*`/,hvariable:/\b([A-Z][_a-zA-Z0-9']*\.)*[_a-z][_a-zA-Z0-9']*\b/,constant:/\b([A-Z][_a-zA-Z0-9']*\.)*[A-Z][_a-zA-Z0-9']*\b/,punctuation:/[{}[\];(),.:]/};
Prism.languages.haxe=Prism.languages.extend("clike",{string:{pattern:/(["'])(?:(?!\1)[^\\]|\\[\s\S])*\1/,inside:{interpolation:{pattern:/(^|[^\\])\$(?:\w+|\{[^}]+\})/,lookbehind:!0,inside:{interpolation:{pattern:/^\$\w*/,alias:"variable"}}}}},keyword:/\bthis\b|\b(?:abstract|as|break|case|cast|catch|class|continue|default|do|dynamic|else|enum|extends|extern|from|for|function|if|implements|import|in|inline|interface|macro|new|null|override|public|private|return|static|super|switch|throw|to|try|typedef|using|var|while)(?!\.)\b/,operator:/\.{3}|\+\+?|-[->]?|[=!]=?|&&?|\|\|?|<[<=]?|>[>=]?|[*\/%~^]/}),Prism.languages.insertBefore("haxe","class-name",{regex:{pattern:/~\/(?:[^\/\\\r\n]|\\.)+\/[igmsu]*/}}),Prism.languages.insertBefore("haxe","keyword",{preprocessor:{pattern:/#\w+/,alias:"builtin"},metadata:{pattern:/@:?\w+/,alias:"symbol"},reification:{pattern:/\$(?:\w+|(?=\{))/,alias:"variable"}}),Prism.languages.haxe.string.inside.interpolation.inside.rest=Prism.util.clone(Prism.languages.haxe),delete Prism.languages.haxe["class-name"];
Prism.languages.http={"request-line":{pattern:/^(POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\b\shttps?:\/\/\S+\sHTTP\/[0-9.]+/m,inside:{property:/^(POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\b/,"attr-name":/:\w+/}},"response-status":{pattern:/^HTTP\/1.[01] [0-9]+.*/m,inside:{property:{pattern:/(^HTTP\/1.[01] )[0-9]+.*/i,lookbehind:!0}}},"header-name":{pattern:/^[\w-]+:(?=.)/m,alias:"keyword"}};var httpLanguages={"application/json":Prism.languages.javascript,"application/xml":Prism.languages.markup,"text/xml":Prism.languages.markup,"text/html":Prism.languages.markup};for(var contentType in httpLanguages)if(httpLanguages[contentType]){var options={};options[contentType]={pattern:new RegExp("(content-type:\\s*"+contentType+"[\\w\\W]*?)(?:\\r?\\n|\\r){2}[\\w\\W]*","i"),lookbehind:!0,inside:{rest:httpLanguages[contentType]}},Prism.languages.insertBefore("http","header-name",options)};
Prism.languages.icon={comment:/#.*/,string:/(["'])(?:(?!\1)[^\\\r\n]|\\.|_(?:\r?\n|\r))*\1/,number:/\b(?:\d+r[a-z\d]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b|\.\d+\b/i,"builtin-keyword":{pattern:/&(?:allocated|ascii|clock|collections|cset|current|date|dateline|digits|dump|e|error(?:number|text|value)?|errout|fail|features|file|host|input|lcase|letters|level|line|main|null|output|phi|pi|pos|progname|random|regions|source|storage|subject|time|trace|ucase|version)\b/,alias:"variable"},directive:{pattern:/\$\w+/,alias:"builtin"},keyword:/\b(?:break|by|case|create|default|do|else|end|every|fail|global|if|initial|invocable|link|local|next|not|of|procedure|record|repeat|return|static|suspend|then|to|until|while)\b/,"function":/(?!\d)\w+(?=\s*[({]|\s*!\s*\[)/,operator:/[+-]:(?!=)|(?:[\/?@^%&]|\+\+?|--?|==?=?|~==?=?|\*\*?|\|\|\|?|<(?:->?|<?=?)|>>?=?)(?::=)?|:(?:=:?)?|[!.\\|~]/,punctuation:/[\[\](){},;]/};
Prism.languages.inform7={string:{pattern:/"[^"]*"/,inside:{substitution:{pattern:/\[[^\]]+\]/,inside:{delimiter:{pattern:/\[|\]/,alias:"punctuation"}}}}},comment:/\[[^\]]+\]/,title:{pattern:/^[ \t]*(?:volume|book|part(?! of)|chapter|section|table)\b.+/im,alias:"important"},number:{pattern:/(^|[^-])(?:(?:\b|-)\d+(?:\.\d+)?(?:\^\d+)?\w*|\b(?:one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve))\b(?!-)/i,lookbehind:!0},verb:{pattern:/(^|[^-])\b(?:applying to|are|attacking|answering|asking|be(?:ing)?|burning|buying|called|carries|carry(?! out)|carrying|climbing|closing|conceal(?:s|ing)?|consulting|contain(?:s|ing)?|cutting|drinking|dropping|eating|enclos(?:es?|ing)|entering|examining|exiting|getting|giving|going|ha(?:ve|s|ving)|hold(?:s|ing)?|impl(?:y|ies)|incorporat(?:es?|ing)|inserting|is|jumping|kissing|listening|locking|looking|mean(?:s|ing)?|opening|provid(?:es?|ing)|pulling|pushing|putting|relat(?:es?|ing)|removing|searching|see(?:s|ing)?|setting|showing|singing|sleeping|smelling|squeezing|switching|support(?:s|ing)?|swearing|taking|tasting|telling|thinking|throwing|touching|turning|tying|unlock(?:s|ing)?|var(?:y|ies|ying)|waiting|waking|waving|wear(?:s|ing)?)\b(?!-)/i,lookbehind:!0,alias:"operator"},keyword:{pattern:/(^|[^-])\b(?:after|before|carry out|check|continue the action|definition(?= *:)|do nothing|else|end (?:if|unless|the story)|every turn|if|include|instead(?: of)?|let|move|no|now|otherwise|repeat|report|resume the story|rule for|running through|say(?:ing)?|stop the action|test|try(?:ing)?|understand|unless|use|when|while|yes)\b(?!-)/i,lookbehind:!0},property:{pattern:/(^|[^-])\b(?:adjacent(?! to)|carried|closed|concealed|contained|dark|described|edible|empty|enclosed|enterable|even|female|fixed in place|full|handled|held|improper-named|incorporated|inedible|invisible|lighted|lit|lock(?:able|ed)|male|marked for listing|mentioned|negative|neuter|non-(?:empty|full|recurring)|odd|opaque|open(?:able)?|plural-named|portable|positive|privately-named|proper-named|provided|publically-named|pushable between rooms|recurring|related|rubbing|scenery|seen|singular-named|supported|swinging|switch(?:able|ed(?: on| off)?)|touch(?:able|ed)|transparent|unconcealed|undescribed|unlit|unlocked|unmarked for listing|unmentioned|unopenable|untouchable|unvisited|variable|visible|visited|wearable|worn)\b(?!-)/i,lookbehind:!0,alias:"symbol"},position:{pattern:/(^|[^-])\b(?:above|adjacent to|back side of|below|between|down|east|everywhere|front side|here|in|inside(?: from)?|north(?:east|west)?|nowhere|on(?: top of)?|other side|outside(?: from)?|parts? of|regionally in|south(?:east|west)?|through|up|west|within)\b(?!-)/i,lookbehind:!0,alias:"keyword"},type:{pattern:/(^|[^-])\b(?:actions?|activit(?:y|ies)|actors?|animals?|backdrops?|containers?|devices?|directions?|doors?|holders?|kinds?|lists?|m[ae]n|nobody|nothing|nouns?|numbers?|objects?|people|persons?|player(?:'s holdall)?|regions?|relations?|rooms?|rule(?:book)?s?|scenes?|someone|something|supporters?|tables?|texts?|things?|time|vehicles?|wom[ae]n)\b(?!-)/i,lookbehind:!0,alias:"variable"},punctuation:/[.,:;(){}]/},Prism.languages.inform7.string.inside.substitution.inside.rest=Prism.util.clone(Prism.languages.inform7),Prism.languages.inform7.string.inside.substitution.inside.rest.text={pattern:/\S(?:\s*\S)*/,alias:"comment"};
Prism.languages.ini={comment:/^[ \t]*;.*$/m,important:/\[.*?\]/,constant:/^[ \t]*[^\s=]+?(?=[ \t]*=)/m,"attr-value":{pattern:/=.*/,inside:{punctuation:/^[=]/}}};
Prism.languages.j={comment:/\bNB\..*/,string:/'(?:''|[^'\r\n])*'/,keyword:/\b(?:(?:adverb|conjunction|CR|def|define|dyad|LF|monad|noun|verb)\b|(?:assert|break|case|catch[dt]?|continue|do|else|elseif|end|fcase|for|for_\w+|goto_\w+|if|label_\w+|return|select|throw|try|while|whilst)\.)/,verb:{pattern:/(?!\^:|;\.|[=!][.:])(?:\{(?:\.|::?)?|p(?:\.\.?|:)|[=!\]]|[<>+*\-%$|,#][.:]?|[\^?]\.?|[;\[]:?|[~}"i][.:]|[ACeEIjLor]\.|(?:[_\/\\qsux]|_?\d):)/,alias:"keyword"},number:/\b_?(?:(?!\d:)\d+(?:\.\d+)?(?:(?:[ejpx]|ad|ar)_?\d+(?:\.\d+)?)*(?:b_?[\da-z]+(?:\.[\da-z]+)?)?|_(?!\.))/,adverb:{pattern:/[~}]|[\/\\]\.?|[bfM]\.|t[.:]/,alias:"builtin"},operator:/[=a][.:]|_\./,conjunction:{pattern:/&(?:\.:?|:)?|[.:@][.:]?|[!D][.:]|[;dHT]\.|`:?|[\^LS]:|"/,alias:"variable"},punctuation:/[()]/};
!function(e){e.languages.jade={comment:{pattern:/(^([\t ]*))\/\/.*((?:\r?\n|\r)\2[\t ]+.+)*/m,lookbehind:!0},"multiline-script":{pattern:/(^([\t ]*)script\b.*\.[\t ]*)((?:\r?\n|\r(?!\n))(?:\2[\t ]+.+|\s*?(?=\r?\n|\r)))+/m,lookbehind:!0,inside:{rest:e.languages.javascript}},filter:{pattern:/(^([\t ]*)):.+((?:\r?\n|\r(?!\n))(?:\2[\t ]+.+|\s*?(?=\r?\n|\r)))+/m,lookbehind:!0,inside:{"filter-name":{pattern:/^:[\w-]+/,alias:"variable"}}},"multiline-plain-text":{pattern:/(^([\t ]*)[\w\-#.]+\.[\t ]*)((?:\r?\n|\r(?!\n))(?:\2[\t ]+.+|\s*?(?=\r?\n|\r)))+/m,lookbehind:!0},markup:{pattern:/(^[\t ]*)<.+/m,lookbehind:!0,inside:{rest:e.languages.markup}},doctype:{pattern:/((?:^|\n)[\t ]*)doctype(?: .+)?/,lookbehind:!0},"flow-control":{pattern:/(^[\t ]*)(?:if|unless|else|case|when|default|each|while)\b(?: .+)?/m,lookbehind:!0,inside:{each:{pattern:/^each .+? in\b/,inside:{keyword:/\b(?:each|in)\b/,punctuation:/,/}},branch:{pattern:/^(?:if|unless|else|case|when|default|while)\b/,alias:"keyword"},rest:e.languages.javascript}},keyword:{pattern:/(^[\t ]*)(?:block|extends|include|append|prepend)\b.+/m,lookbehind:!0},mixin:[{pattern:/(^[\t ]*)mixin .+/m,lookbehind:!0,inside:{keyword:/^mixin/,"function":/\w+(?=\s*\(|\s*$)/,punctuation:/[(),.]/}},{pattern:/(^[\t ]*)\+.+/m,lookbehind:!0,inside:{name:{pattern:/^\+\w+/,alias:"function"},rest:e.languages.javascript}}],script:{pattern:/(^[\t ]*script(?:(?:&[^(]+)?\([^)]+\))*[\t ]+).+/m,lookbehind:!0,inside:{rest:e.languages.javascript}},"plain-text":{pattern:/(^[\t ]*(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?[\t ]+).+/m,lookbehind:!0},tag:{pattern:/(^[\t ]*)(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?:?/m,lookbehind:!0,inside:{attributes:[{pattern:/&[^(]+\([^)]+\)/,inside:{rest:e.languages.javascript}},{pattern:/\([^)]+\)/,inside:{"attr-value":{pattern:/(=\s*)(?:\{[^}]*\}|[^,)\r\n]+)/,lookbehind:!0,inside:{rest:e.languages.javascript}},"attr-name":/[\w-]+(?=\s*!?=|\s*[,)])/,punctuation:/[!=(),]+/}}],punctuation:/:/}},code:[{pattern:/(^[\t ]*(?:-|!?=)).+/m,lookbehind:!0,inside:{rest:e.languages.javascript}}],punctuation:/[.\-!=|]+/};for(var t="(^([\\t ]*)):{{filter_name}}((?:\\r?\\n|\\r(?!\\n))(?:\\2[\\t ]+.+|\\s*?(?=\\r?\\n|\\r)))+",n=[{filter:"atpl",language:"twig"},{filter:"coffee",language:"coffeescript"},"ejs","handlebars","hogan","less","livescript","markdown","mustache","plates",{filter:"sass",language:"scss"},"stylus","swig"],a={},i=0,r=n.length;r>i;i++){var s=n[i];s="string"==typeof s?{filter:s,language:s}:s,e.languages[s.language]&&(a["filter-"+s.filter]={pattern:RegExp(t.replace("{{filter_name}}",s.filter),"m"),lookbehind:!0,inside:{"filter-name":{pattern:/^:[\w-]+/,alias:"variable"},rest:e.languages[s.language]}})}e.languages.insertBefore("jade","filter",a)}(Prism);
Prism.languages.java=Prism.languages.extend("clike",{keyword:/\b(abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/,number:/\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp\-]+\b|\b\d*\.?\d+(?:e[+-]?\d+)?[df]?\b/i,operator:{pattern:/(^|[^.])(?:\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\|[|=]?|\*=?|\/=?|%=?|\^=?|[?:~])/m,lookbehind:!0}}),Prism.languages.insertBefore("java","function",{annotation:{alias:"punctuation",pattern:/(^|[^.])@\w+/,lookbehind:!0}});
Prism.languages.json={property:/".*?"(?=\s*:)/gi,string:/"(?!:)(\\?[^"])*?"(?!:)/g,number:/\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?)\b/g,punctuation:/[{}[\]);,]/g,operator:/:/g,"boolean":/\b(true|false)\b/gi,"null":/\bnull\b/gi},Prism.languages.jsonp=Prism.languages.json;
Prism.languages.julia={comment:{pattern:/(^|[^\\])#.*/,lookbehind:!0},string:/"""[\s\S]+?"""|'''[\s\S]+?'''|("|')(\\?.)*?\1/,keyword:/\b(abstract|baremodule|begin|bitstype|break|catch|ccall|const|continue|do|else|elseif|end|export|finally|for|function|global|if|immutable|import|importall|let|local|macro|module|print|println|quote|return|try|type|typealias|using|while)\b/,"boolean":/\b(true|false)\b/,number:/\b-?(0[box])?(?:[\da-f]+\.?\d*|\.\d+)(?:[efp][+-]?\d+)?j?\b/i,operator:/\+=?|-=?|\*=?|\/[\/=]?|\\=?|\^=?|%=?|=?|!=?=?|&=?|\|[=>]?|\$=?|<(?:<=?|[=:])?|>(?:=|>>?=?)?|==?=?|[~ ]/,punctuation:/[{}[\];(),.:]/};
Prism.languages.keyman={comment:/\bc\s.*/i,"function":/\[\s*((CTRL|SHIFT|ALT|LCTRL|RCTRL|LALT|RALT|CAPS|NCAPS)\s+)*([TKU]_[a-z0-9_?]+|".+?"|'.+?')\s*\]/i,string:/("|')((?!\1).)*\1/,bold:[/&(baselayout|bitmap|capsononly|capsalwaysoff|shiftfreescaps|copyright|ethnologuecode|hotkey|includecodes|keyboardversion|kmw_embedcss|kmw_embedjs|kmw_helpfile|kmw_helptext|kmw_rtl|language|layer|layoutfile|message|mnemoniclayout|name|oldcharposmatching|platform|targets|version|visualkeyboard|windowslanguages)\b/i,/\b(bitmap|bitmaps|caps on only|caps always off|shift frees caps|copyright|hotkey|language|layout|message|name|version)\b/i],keyword:/\b(any|baselayout|beep|call|context|deadkey|dk|if|index|layer|notany|nul|outs|platform|return|reset|save|set|store|use)\b/i,atrule:/\b(ansi|begin|unicode|group|using keys|match|nomatch)\b/i,number:/\b(U\+[\dA-F]+|d\d+|x[\da-f]+|\d+)\b/i,operator:/[+>\\,()]/,tag:/\$(keyman|kmfl|weaver|keymanweb|keymanonly):/i};
!function(n){n.languages.kotlin=n.languages.extend("clike",{keyword:{pattern:/(^|[^.])\b(?:abstract|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|else|enum|final|finally|for|fun|get|if|import|in|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|out|override|package|private|protected|public|reified|return|sealed|set|super|tailrec|this|throw|to|try|val|var|when|where|while)\b/,lookbehind:!0},"function":[/\w+(?=\s*\()/,{pattern:/(\.)\w+(?=\s*\{)/,lookbehind:!0}],number:/\b(?:0[bx][\da-fA-F]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?[fFL]?)\b/,operator:/\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/}),delete n.languages.kotlin["class-name"],n.languages.insertBefore("kotlin","string",{"raw-string":{pattern:/(["'])\1\1[\s\S]*?\1{3}/,alias:"string"}}),n.languages.insertBefore("kotlin","keyword",{annotation:{pattern:/\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,alias:"builtin"}}),n.languages.insertBefore("kotlin","function",{label:{pattern:/\w+@|@\w+/,alias:"symbol"}});var e=[{pattern:/\$\{[^}]+\}/,inside:{delimiter:{pattern:/^\$\{|\}$/,alias:"variable"},rest:n.util.clone(n.languages.kotlin)}},{pattern:/\$\w+/,alias:"variable"}];n.languages.kotlin.string.inside=n.languages.kotlin["raw-string"].inside={interpolation:e}}(Prism);
!function(a){var e=/\\([^a-z()[\]]|[a-z\*]+)/i,n={"equation-command":{pattern:e,alias:"regex"}};a.languages.latex={comment:/%.*/m,cdata:{pattern:/(\\begin\{((?:verbatim|lstlisting)\*?)\})([\w\W]*?)(?=\\end\{\2\})/,lookbehind:!0},equation:[{pattern:/\$(?:\\?[\w\W])*?\$|\\\((?:\\?[\w\W])*?\\\)|\\\[(?:\\?[\w\W])*?\\\]/,inside:n,alias:"string"},{pattern:/(\\begin\{((?:equation|math|eqnarray|align|multline|gather)\*?)\})([\w\W]*?)(?=\\end\{\2\})/,lookbehind:!0,inside:n,alias:"string"}],keyword:{pattern:/(\\(?:begin|end|ref|cite|label|usepackage|documentclass)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,lookbehind:!0},url:{pattern:/(\\url\{)[^}]+(?=\})/,lookbehind:!0},headline:{pattern:/(\\(?:part|chapter|section|subsection|frametitle|subsubsection|paragraph|subparagraph|subsubparagraph|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\}(?:\[[^\]]+\])?)/,lookbehind:!0,alias:"class-name"},"function":{pattern:e,alias:"selector"},punctuation:/[[\]{}&]/}}(Prism);
Prism.languages.less=Prism.languages.extend("css",{comment:[/\/\*[\w\W]*?\*\//,{pattern:/(^|[^\\])\/\/.*/,lookbehind:!0}],atrule:{pattern:/@[\w-]+?(?:\([^{}]+\)|[^(){};])*?(?=\s*\{)/i,inside:{punctuation:/[:()]/}},selector:{pattern:/(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\([^{}]*\)|[^{};@])*?(?=\s*\{)/,inside:{variable:/@+[\w-]+/}},property:/(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/i,punctuation:/[{}();:,]/,operator:/[+\-*\/]/}),Prism.languages.insertBefore("less","punctuation",{"function":Prism.languages.less.function}),Prism.languages.insertBefore("less","property",{variable:[{pattern:/@[\w-]+\s*:/,inside:{punctuation:/:/}},/@@?[\w-]+/],"mixin-usage":{pattern:/([{;]\s*)[.#](?!\d)[\w-]+.*?(?=[(;])/,lookbehind:!0,alias:"function"}});
Prism.languages.livescript={"interpolated-string":{pattern:/("""|")(?:\\[\s\S]|(?!\1)[^\\])*\1/,greedy:!0,inside:{variable:{pattern:/(^|[^\\])#[a-z_](?:-?[a-z]|\d)*/m,lookbehind:!0},interpolation:{pattern:/(^|[^\\])#\{[^}]+\}/m,lookbehind:!0,inside:{"interpolation-punctuation":{pattern:/^#\{|\}$/,alias:"variable"}}},string:/[\s\S]+/}},comment:[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//,lookbehind:!0,greedy:!0},{pattern:/(^|[^\\])#.*/,lookbehind:!0,greedy:!0}],string:[{pattern:/('''|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,greedy:!0},{pattern:/<\[[\s\S]*?\]>/,greedy:!0},/\\[^\s,;\])}]+/],regex:[{pattern:/\/\/(\[.+?]|\\.|(?!\/\/)[^\\])+\/\/[gimyu]{0,5}/,greedy:!0,inside:{comment:{pattern:/(^|[^\\])#.*/,lookbehind:!0}}},{pattern:/\/(\[.+?]|\\.|[^\/\\\r\n])+\/[gimyu]{0,5}/,greedy:!0}],keyword:{pattern:/(^|(?!-).)\b(?:break|case|catch|class|const|continue|default|do|else|extends|fallthrough|finally|for(?: ever)?|function|if|implements|it|let|loop|new|null|otherwise|own|return|super|switch|that|then|this|throw|try|unless|until|var|void|when|while|yield)(?!-)\b/m,lookbehind:!0},"keyword-operator":{pattern:/(^|[^-])\b(?:(?:delete|require|typeof)!|(?:and|by|delete|export|from|import(?: all)?|in|instanceof|is(?:nt| not)?|not|of|or|til|to|typeof|with|xor)(?!-)\b)/m,lookbehind:!0,alias:"operator"},"boolean":{pattern:/(^|[^-])\b(?:false|no|off|on|true|yes)(?!-)\b/m,lookbehind:!0},argument:{pattern:/(^|(?!\.&\.)[^&])&(?!&)\d*/m,lookbehind:!0,alias:"variable"},number:/\b(?:\d+~[\da-z]+|\d[\d_]*(?:\.\d[\d_]*)?(?:[a-z]\w*)?)/i,identifier:/[a-z_](?:-?[a-z]|\d)*/i,operator:[{pattern:/( )\.(?= )/,lookbehind:!0},/\.(?:[=~]|\.\.?)|\.(?:[&|^]|<<|>>>?)\.|:(?:=|:=?)|&&|\|[|>]|<(?:<<?<?|--?!?|~~?!?|[|=?])?|>[>=?]?|-(?:->?|>)?|\+\+?|@@?|%%?|\*\*?|!(?:~?=|--?>|~?~>)?|~(?:~?>|=)?|==?|\^\^?|[\/?]/],punctuation:/[(){}\[\]|.,:;`]/},Prism.languages.livescript["interpolated-string"].inside.interpolation.inside.rest=Prism.languages.livescript;
Prism.languages.lolcode={comment:[/\bOBTW\s+[\s\S]*?\s+TLDR\b/,/\bBTW.+/],string:{pattern:/"(?::.|[^"])*"/,inside:{variable:/:\{[^}]+\}/,symbol:[/:\([a-f\d]+\)/i,/:\[[^\]]+\]/,/:[)>o":]/]}},number:/(-|\b)\d*\.?\d+/,symbol:{pattern:/(^|\s)(?:A )?(?:YARN|NUMBR|NUMBAR|TROOF|BUKKIT|NOOB)(?=\s|,|$)/,lookbehind:!0,inside:{keyword:/A(?=\s)/}},label:{pattern:/((?:^|\s)(?:IM IN YR|IM OUTTA YR) )[a-zA-Z]\w*/,lookbehind:!0,alias:"string"},"function":{pattern:/((?:^|\s)(?:I IZ|HOW IZ I|IZ) )[a-zA-Z]\w*/,lookbehind:!0},keyword:[{pattern:/(^|\s)(?:O HAI IM|KTHX|HAI|KTHXBYE|I HAS A|ITZ(?: A)?|R|AN|MKAY|SMOOSH|MAEK|IS NOW(?: A)?|VISIBLE|GIMMEH|O RLY\?|YA RLY|NO WAI|OIC|MEBBE|WTF\?|OMG|OMGWTF|GTFO|IM IN YR|IM OUTTA YR|FOUND YR|YR|TIL|WILE|UPPIN|NERFIN|I IZ|HOW IZ I|IF U SAY SO|SRS|HAS A|LIEK(?: A)?|IZ)(?=\s|,|$)/,lookbehind:!0},/'Z(?=\s|,|$)/],"boolean":{pattern:/(^|\s)(?:WIN|FAIL)(?=\s|,|$)/,lookbehind:!0},variable:{pattern:/(^|\s)IT(?=\s|,|$)/,lookbehind:!0},operator:{pattern:/(^|\s)(?:NOT|BOTH SAEM|DIFFRINT|(?:SUM|DIFF|PRODUKT|QUOSHUNT|MOD|BIGGR|SMALLR|BOTH|EITHER|WON|ALL|ANY) OF)(?=\s|,|$)/,lookbehind:!0},punctuation:/\.{3}||,|!/};
Prism.languages.lua={comment:/^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,string:{pattern:/(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[\s\S]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,greedy:!0},number:/\b0x[a-f\d]+\.?[a-f\d]*(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|\.?\d*(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,keyword:/\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,"function":/(?!\d)\w+(?=\s*(?:[({]))/,operator:[/[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,{pattern:/(^|[^.])\.\.(?!\.)/,lookbehind:!0}],punctuation:/[\[\](){},;]|\.+|:+/};
Prism.languages.makefile={comment:{pattern:/(^|[^\\])#(?:\\(?:\r\n|[\s\S])|.)*/,lookbehind:!0},string:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,builtin:/\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,symbol:{pattern:/^[^:=\r\n]+(?=\s*:(?!=))/m,inside:{variable:/\$+(?:[^(){}:#=\s]+|(?=[({]))/}},variable:/\$+(?:[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,keyword:[/-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,{pattern:/(\()(?:addsuffix|abspath|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:s|list)?)(?=[ \t])/,lookbehind:!0}],operator:/(?:::|[?:+!])?=|[|@]/,punctuation:/[:;(){}]/};
Prism.languages.markdown=Prism.languages.extend("markup",{}),Prism.languages.insertBefore("markdown","prolog",{blockquote:{pattern:/^>(?:[\t ]*>)*/m,alias:"punctuation"},code:[{pattern:/^(?: {4}|\t).+/m,alias:"keyword"},{pattern:/``.+?``|`[^`\n]+`/,alias:"keyword"}],title:[{pattern:/\w+.*(?:\r?\n|\r)(?:==+|--+)/,alias:"important",inside:{punctuation:/==+$|--+$/}},{pattern:/(^\s*)#+.+/m,lookbehind:!0,alias:"important",inside:{punctuation:/^#+|#+$/}}],hr:{pattern:/(^\s*)([*-])([\t ]*\2){2,}(?=\s*$)/m,lookbehind:!0,alias:"punctuation"},list:{pattern:/(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,lookbehind:!0,alias:"punctuation"},"url-reference":{pattern:/!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,inside:{variable:{pattern:/^(!?\[)[^\]]+/,lookbehind:!0},string:/(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,punctuation:/^[\[\]!:]|[<>]/},alias:"url"},bold:{pattern:/(^|[^\\])(\*\*|__)(?:(?:\r?\n|\r)(?!\r?\n|\r)|.)+?\2/,lookbehind:!0,inside:{punctuation:/^\*\*|^__|\*\*$|__$/}},italic:{pattern:/(^|[^\\])([*_])(?:(?:\r?\n|\r)(?!\r?\n|\r)|.)+?\2/,lookbehind:!0,inside:{punctuation:/^[*_]|[*_]$/}},url:{pattern:/!?\[[^\]]+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)| ?\[[^\]\n]*\])/,inside:{variable:{pattern:/(!?\[)[^\]]+(?=\]$)/,lookbehind:!0},string:{pattern:/"(?:\\.|[^"\\])*"(?=\)$)/}}}}),Prism.languages.markdown.bold.inside.url=Prism.util.clone(Prism.languages.markdown.url),Prism.languages.markdown.italic.inside.url=Prism.util.clone(Prism.languages.markdown.url),Prism.languages.markdown.bold.inside.italic=Prism.util.clone(Prism.languages.markdown.italic),Prism.languages.markdown.italic.inside.bold=Prism.util.clone(Prism.languages.markdown.bold);
Prism.languages.matlab={string:/\B'(?:''|[^'\n])*'/,comment:[/%\{[\s\S]*?\}%/,/%.+/],number:/\b-?(?:\d*\.?\d+(?:[eE][+-]?\d+)?(?:[ij])?|[ij])\b/,keyword:/\b(?:break|case|catch|continue|else|elseif|end|for|function|if|inf|NaN|otherwise|parfor|pause|pi|return|switch|try|while)\b/,"function":/(?!\d)\w+(?=\s*\()/,operator:/\.?[*^\/\\']|[+\-:@]|[<>=~]=?|&&?|\|\|?/,punctuation:/\.{3}|[.,;\[\](){}!]/};
Prism.languages.mel={comment:/\/\/.*/,code:{pattern:/`(?:\\.|[^\\`\r\n])*`/,alias:"italic",inside:{delimiter:{pattern:/^`|`$/,alias:"punctuation"}}},string:/"(?:\\.|[^\\"\r\n])*"/,variable:/\$\w+/,number:/(?:\b|-)(?:0x[\da-fA-F]+|\d+\.?\d*)/,flag:{pattern:/-[^\d\W]\w*/,alias:"operator"},keyword:/\b(?:break|case|continue|default|do|else|float|for|global|if|in|int|matrix|proc|return|string|switch|vector|while)\b/,"function":/\w+(?=\()|\b(?:about|abs|addAttr|addAttributeEditorNodeHelp|addDynamic|addNewShelfTab|addPP|addPanelCategory|addPrefixToName|advanceToNextDrivenKey|affectedNet|affects|aimConstraint|air|alias|aliasAttr|align|alignCtx|alignCurve|alignSurface|allViewFit|ambientLight|angle|angleBetween|animCone|animCurveEditor|animDisplay|animView|annotate|appendStringArray|applicationName|applyAttrPreset|applyTake|arcLenDimContext|arcLengthDimension|arclen|arrayMapper|art3dPaintCtx|artAttrCtx|artAttrPaintVertexCtx|artAttrSkinPaintCtx|artAttrTool|artBuildPaintMenu|artFluidAttrCtx|artPuttyCtx|artSelectCtx|artSetPaintCtx|artUserPaintCtx|assignCommand|assignInputDevice|assignViewportFactories|attachCurve|attachDeviceAttr|attachSurface|attrColorSliderGrp|attrCompatibility|attrControlGrp|attrEnumOptionMenu|attrEnumOptionMenuGrp|attrFieldGrp|attrFieldSliderGrp|attrNavigationControlGrp|attrPresetEditWin|attributeExists|attributeInfo|attributeMenu|attributeQuery|autoKeyframe|autoPlace|bakeClip|bakeFluidShading|bakePartialHistory|bakeResults|bakeSimulation|basename|basenameEx|batchRender|bessel|bevel|bevelPlus|binMembership|bindSkin|blend2|blendShape|blendShapeEditor|blendShapePanel|blendTwoAttr|blindDataType|boneLattice|boundary|boxDollyCtx|boxZoomCtx|bufferCurve|buildBookmarkMenu|buildKeyframeMenu|button|buttonManip|CBG|cacheFile|cacheFileCombine|cacheFileMerge|cacheFileTrack|camera|cameraView|canCreateManip|canvas|capitalizeString|catch|catchQuiet|ceil|changeSubdivComponentDisplayLevel|changeSubdivRegion|channelBox|character|characterMap|characterOutlineEditor|characterize|chdir|checkBox|checkBoxGrp|checkDefaultRenderGlobals|choice|circle|circularFillet|clamp|clear|clearCache|clip|clipEditor|clipEditorCurrentTimeCtx|clipSchedule|clipSchedulerOutliner|clipTrimBefore|closeCurve|closeSurface|cluster|cmdFileOutput|cmdScrollFieldExecuter|cmdScrollFieldReporter|cmdShell|coarsenSubdivSelectionList|collision|color|colorAtPoint|colorEditor|colorIndex|colorIndexSliderGrp|colorSliderButtonGrp|colorSliderGrp|columnLayout|commandEcho|commandLine|commandPort|compactHairSystem|componentEditor|compositingInterop|computePolysetVolume|condition|cone|confirmDialog|connectAttr|connectControl|connectDynamic|connectJoint|connectionInfo|constrain|constrainValue|constructionHistory|container|containsMultibyte|contextInfo|control|convertFromOldLayers|convertIffToPsd|convertLightmap|convertSolidTx|convertTessellation|convertUnit|copyArray|copyFlexor|copyKey|copySkinWeights|cos|cpButton|cpCache|cpClothSet|cpCollision|cpConstraint|cpConvClothToMesh|cpForces|cpGetSolverAttr|cpPanel|cpProperty|cpRigidCollisionFilter|cpSeam|cpSetEdit|cpSetSolverAttr|cpSolver|cpSolverTypes|cpTool|cpUpdateClothUVs|createDisplayLayer|createDrawCtx|createEditor|createLayeredPsdFile|createMotionField|createNewShelf|createNode|createRenderLayer|createSubdivRegion|cross|crossProduct|ctxAbort|ctxCompletion|ctxEditMode|ctxTraverse|currentCtx|currentTime|currentTimeCtx|currentUnit|curve|curveAddPtCtx|curveCVCtx|curveEPCtx|curveEditorCtx|curveIntersect|curveMoveEPCtx|curveOnSurface|curveSketchCtx|cutKey|cycleCheck|cylinder|dagPose|date|defaultLightListCheckBox|defaultNavigation|defineDataServer|defineVirtualDevice|deformer|deg_to_rad|delete|deleteAttr|deleteShadingGroupsAndMaterials|deleteShelfTab|deleteUI|deleteUnusedBrushes|delrandstr|detachCurve|detachDeviceAttr|detachSurface|deviceEditor|devicePanel|dgInfo|dgdirty|dgeval|dgtimer|dimWhen|directKeyCtx|directionalLight|dirmap|dirname|disable|disconnectAttr|disconnectJoint|diskCache|displacementToPoly|displayAffected|displayColor|displayCull|displayLevelOfDetail|displayPref|displayRGBColor|displaySmoothness|displayStats|displayString|displaySurface|distanceDimContext|distanceDimension|doBlur|dolly|dollyCtx|dopeSheetEditor|dot|dotProduct|doubleProfileBirailSurface|drag|dragAttrContext|draggerContext|dropoffLocator|duplicate|duplicateCurve|duplicateSurface|dynCache|dynControl|dynExport|dynExpression|dynGlobals|dynPaintEditor|dynParticleCtx|dynPref|dynRelEdPanel|dynRelEditor|dynamicLoad|editAttrLimits|editDisplayLayerGlobals|editDisplayLayerMembers|editRenderLayerAdjustment|editRenderLayerGlobals|editRenderLayerMembers|editor|editorTemplate|effector|emit|emitter|enableDevice|encodeString|endString|endsWith|env|equivalent|equivalentTol|erf|error|eval|evalDeferred|evalEcho|event|exactWorldBoundingBox|exclusiveLightCheckBox|exec|executeForEachObject|exists|exp|expression|expressionEditorListen|extendCurve|extendSurface|extrude|fcheck|fclose|feof|fflush|fgetline|fgetword|file|fileBrowserDialog|fileDialog|fileExtension|fileInfo|filetest|filletCurve|filter|filterCurve|filterExpand|filterStudioImport|findAllIntersections|findAnimCurves|findKeyframe|findMenuItem|findRelatedSkinCluster|finder|firstParentOf|fitBspline|flexor|floatEq|floatField|floatFieldGrp|floatScrollBar|floatSlider|floatSlider2|floatSliderButtonGrp|floatSliderGrp|floor|flow|fluidCacheInfo|fluidEmitter|fluidVoxelInfo|flushUndo|fmod|fontDialog|fopen|formLayout|format|fprint|frameLayout|fread|freeFormFillet|frewind|fromNativePath|fwrite|gamma|gauss|geometryConstraint|getApplicationVersionAsFloat|getAttr|getClassification|getDefaultBrush|getFileList|getFluidAttr|getInputDeviceRange|getMayaPanelTypes|getModifiers|getPanel|getParticleAttr|getPluginResource|getenv|getpid|glRender|glRenderEditor|globalStitch|gmatch|goal|gotoBindPose|grabColor|gradientControl|gradientControlNoAttr|graphDollyCtx|graphSelectContext|graphTrackCtx|gravity|grid|gridLayout|group|groupObjectsByName|HfAddAttractorToAS|HfAssignAS|HfBuildEqualMap|HfBuildFurFiles|HfBuildFurImages|HfCancelAFR|HfConnectASToHF|HfCreateAttractor|HfDeleteAS|HfEditAS|HfPerformCreateAS|HfRemoveAttractorFromAS|HfSelectAttached|HfSelectAttractors|HfUnAssignAS|hardenPointCurve|hardware|hardwareRenderPanel|headsUpDisplay|headsUpMessage|help|helpLine|hermite|hide|hilite|hitTest|hotBox|hotkey|hotkeyCheck|hsv_to_rgb|hudButton|hudSlider|hudSliderButton|hwReflectionMap|hwRender|hwRenderLoad|hyperGraph|hyperPanel|hyperShade|hypot|iconTextButton|iconTextCheckBox|iconTextRadioButton|iconTextRadioCollection|iconTextScrollList|iconTextStaticLabel|ikHandle|ikHandleCtx|ikHandleDisplayScale|ikSolver|ikSplineHandleCtx|ikSystem|ikSystemInfo|ikfkDisplayMethod|illustratorCurves|image|imfPlugins|inheritTransform|insertJoint|insertJointCtx|insertKeyCtx|insertKnotCurve|insertKnotSurface|instance|instanceable|instancer|intField|intFieldGrp|intScrollBar|intSlider|intSliderGrp|interToUI|internalVar|intersect|iprEngine|isAnimCurve|isConnected|isDirty|isParentOf|isSameObject|isTrue|isValidObjectName|isValidString|isValidUiName|isolateSelect|itemFilter|itemFilterAttr|itemFilterRender|itemFilterType|joint|jointCluster|jointCtx|jointDisplayScale|jointLattice|keyTangent|keyframe|keyframeOutliner|keyframeRegionCurrentTimeCtx|keyframeRegionDirectKeyCtx|keyframeRegionDollyCtx|keyframeRegionInsertKeyCtx|keyframeRegionMoveKeyCtx|keyframeRegionScaleKeyCtx|keyframeRegionSelectKeyCtx|keyframeRegionSetKeyCtx|keyframeRegionTrackCtx|keyframeStats|lassoContext|lattice|latticeDeformKeyCtx|launch|launchImageEditor|layerButton|layeredShaderPort|layeredTexturePort|layout|layoutDialog|lightList|lightListEditor|lightListPanel|lightlink|lineIntersection|linearPrecision|linstep|listAnimatable|listAttr|listCameras|listConnections|listDeviceAttachments|listHistory|listInputDeviceAxes|listInputDeviceButtons|listInputDevices|listMenuAnnotation|listNodeTypes|listPanelCategories|listRelatives|listSets|listTransforms|listUnselected|listerEditor|loadFluid|loadNewShelf|loadPlugin|loadPluginLanguageResources|loadPrefObjects|localizedPanelLabel|lockNode|loft|log|longNameOf|lookThru|ls|lsThroughFilter|lsType|lsUI|Mayatomr|mag|makeIdentity|makeLive|makePaintable|makeRoll|makeSingleSurface|makeTubeOn|makebot|manipMoveContext|manipMoveLimitsCtx|manipOptions|manipRotateContext|manipRotateLimitsCtx|manipScaleContext|manipScaleLimitsCtx|marker|match|max|memory|menu|menuBarLayout|menuEditor|menuItem|menuItemToShelf|menuSet|menuSetPref|messageLine|min|minimizeApp|mirrorJoint|modelCurrentTimeCtx|modelEditor|modelPanel|mouse|movIn|movOut|move|moveIKtoFK|moveKeyCtx|moveVertexAlongDirection|multiProfileBirailSurface|mute|nParticle|nameCommand|nameField|namespace|namespaceInfo|newPanelItems|newton|nodeCast|nodeIconButton|nodeOutliner|nodePreset|nodeType|noise|nonLinear|normalConstraint|normalize|nurbsBoolean|nurbsCopyUVSet|nurbsCube|nurbsEditUV|nurbsPlane|nurbsSelect|nurbsSquare|nurbsToPoly|nurbsToPolygonsPref|nurbsToSubdiv|nurbsToSubdivPref|nurbsUVSet|nurbsViewDirectionVector|objExists|objectCenter|objectLayer|objectType|objectTypeUI|obsoleteProc|oceanNurbsPreviewPlane|offsetCurve|offsetCurveOnSurface|offsetSurface|openGLExtension|openMayaPref|optionMenu|optionMenuGrp|optionVar|orbit|orbitCtx|orientConstraint|outlinerEditor|outlinerPanel|overrideModifier|paintEffectsDisplay|pairBlend|palettePort|paneLayout|panel|panelConfiguration|panelHistory|paramDimContext|paramDimension|paramLocator|parent|parentConstraint|particle|particleExists|particleInstancer|particleRenderInfo|partition|pasteKey|pathAnimation|pause|pclose|percent|performanceOptions|pfxstrokes|pickWalk|picture|pixelMove|planarSrf|plane|play|playbackOptions|playblast|plugAttr|plugNode|pluginInfo|pluginResourceUtil|pointConstraint|pointCurveConstraint|pointLight|pointMatrixMult|pointOnCurve|pointOnSurface|pointPosition|poleVectorConstraint|polyAppend|polyAppendFacetCtx|polyAppendVertex|polyAutoProjection|polyAverageNormal|polyAverageVertex|polyBevel|polyBlendColor|polyBlindData|polyBoolOp|polyBridgeEdge|polyCacheMonitor|polyCheck|polyChipOff|polyClipboard|polyCloseBorder|polyCollapseEdge|polyCollapseFacet|polyColorBlindData|polyColorDel|polyColorPerVertex|polyColorSet|polyCompare|polyCone|polyCopyUV|polyCrease|polyCreaseCtx|polyCreateFacet|polyCreateFacetCtx|polyCube|polyCut|polyCutCtx|polyCylinder|polyCylindricalProjection|polyDelEdge|polyDelFacet|polyDelVertex|polyDuplicateAndConnect|polyDuplicateEdge|polyEditUV|polyEditUVShell|polyEvaluate|polyExtrudeEdge|polyExtrudeFacet|polyExtrudeVertex|polyFlipEdge|polyFlipUV|polyForceUV|polyGeoSampler|polyHelix|polyInfo|polyInstallAction|polyLayoutUV|polyListComponentConversion|polyMapCut|polyMapDel|polyMapSew|polyMapSewMove|polyMergeEdge|polyMergeEdgeCtx|polyMergeFacet|polyMergeFacetCtx|polyMergeUV|polyMergeVertex|polyMirrorFace|polyMoveEdge|polyMoveFacet|polyMoveFacetUV|polyMoveUV|polyMoveVertex|polyNormal|polyNormalPerVertex|polyNormalizeUV|polyOptUvs|polyOptions|polyOutput|polyPipe|polyPlanarProjection|polyPlane|polyPlatonicSolid|polyPoke|polyPrimitive|polyPrism|polyProjection|polyPyramid|polyQuad|polyQueryBlindData|polyReduce|polySelect|polySelectConstraint|polySelectConstraintMonitor|polySelectCtx|polySelectEditCtx|polySeparate|polySetToFaceNormal|polySewEdge|polyShortestPathCtx|polySmooth|polySoftEdge|polySphere|polySphericalProjection|polySplit|polySplitCtx|polySplitEdge|polySplitRing|polySplitVertex|polyStraightenUVBorder|polySubdivideEdge|polySubdivideFacet|polyToSubdiv|polyTorus|polyTransfer|polyTriangulate|polyUVSet|polyUnite|polyWedgeFace|popen|popupMenu|pose|pow|preloadRefEd|print|progressBar|progressWindow|projFileViewer|projectCurve|projectTangent|projectionContext|projectionManip|promptDialog|propModCtx|propMove|psdChannelOutliner|psdEditTextureFile|psdExport|psdTextureFile|putenv|pwd|python|querySubdiv|quit|rad_to_deg|radial|radioButton|radioButtonGrp|radioCollection|radioMenuItemCollection|rampColorPort|rand|randomizeFollicles|randstate|rangeControl|readTake|rebuildCurve|rebuildSurface|recordAttr|recordDevice|redo|reference|referenceEdit|referenceQuery|refineSubdivSelectionList|refresh|refreshAE|registerPluginResource|rehash|reloadImage|removeJoint|removeMultiInstance|removePanelCategory|rename|renameAttr|renameSelectionList|renameUI|render|renderGlobalsNode|renderInfo|renderLayerButton|renderLayerParent|renderLayerPostProcess|renderLayerUnparent|renderManip|renderPartition|renderQualityNode|renderSettings|renderThumbnailUpdate|renderWindowEditor|renderWindowSelectContext|renderer|reorder|reorderDeformers|requires|reroot|resampleFluid|resetAE|resetPfxToPolyCamera|resetTool|resolutionNode|retarget|reverseCurve|reverseSurface|revolve|rgb_to_hsv|rigidBody|rigidSolver|roll|rollCtx|rootOf|rot|rotate|rotationInterpolation|roundConstantRadius|rowColumnLayout|rowLayout|runTimeCommand|runup|sampleImage|saveAllShelves|saveAttrPreset|saveFluid|saveImage|saveInitialState|saveMenu|savePrefObjects|savePrefs|saveShelf|saveToolSettings|scale|scaleBrushBrightness|scaleComponents|scaleConstraint|scaleKey|scaleKeyCtx|sceneEditor|sceneUIReplacement|scmh|scriptCtx|scriptEditorInfo|scriptJob|scriptNode|scriptTable|scriptToShelf|scriptedPanel|scriptedPanelType|scrollField|scrollLayout|sculpt|searchPathArray|seed|selLoadSettings|select|selectContext|selectCurveCV|selectKey|selectKeyCtx|selectKeyframeRegionCtx|selectMode|selectPref|selectPriority|selectType|selectedNodes|selectionConnection|separator|setAttr|setAttrEnumResource|setAttrMapping|setAttrNiceNameResource|setConstraintRestPosition|setDefaultShadingGroup|setDrivenKeyframe|setDynamic|setEditCtx|setEditor|setFluidAttr|setFocus|setInfinity|setInputDeviceMapping|setKeyCtx|setKeyPath|setKeyframe|setKeyframeBlendshapeTargetWts|setMenuMode|setNodeNiceNameResource|setNodeTypeFlag|setParent|setParticleAttr|setPfxToPolyCamera|setPluginResource|setProject|setStampDensity|setStartupMessage|setState|setToolTo|setUITemplate|setXformManip|sets|shadingConnection|shadingGeometryRelCtx|shadingLightRelCtx|shadingNetworkCompare|shadingNode|shapeCompare|shelfButton|shelfLayout|shelfTabLayout|shellField|shortNameOf|showHelp|showHidden|showManipCtx|showSelectionInTitle|showShadingGroupAttrEditor|showWindow|sign|simplify|sin|singleProfileBirailSurface|size|sizeBytes|skinCluster|skinPercent|smoothCurve|smoothTangentSurface|smoothstep|snap2to2|snapKey|snapMode|snapTogetherCtx|snapshot|soft|softMod|softModCtx|sort|sound|soundControl|source|spaceLocator|sphere|sphrand|spotLight|spotLightPreviewPort|spreadSheetEditor|spring|sqrt|squareSurface|srtContext|stackTrace|startString|startsWith|stitchAndExplodeShell|stitchSurface|stitchSurfacePoints|strcmp|stringArrayCatenate|stringArrayContains|stringArrayCount|stringArrayInsertAtIndex|stringArrayIntersector|stringArrayRemove|stringArrayRemoveAtIndex|stringArrayRemoveDuplicates|stringArrayRemoveExact|stringArrayToString|stringToStringArray|strip|stripPrefixFromName|stroke|subdAutoProjection|subdCleanTopology|subdCollapse|subdDuplicateAndConnect|subdEditUV|subdListComponentConversion|subdMapCut|subdMapSewMove|subdMatchTopology|subdMirror|subdToBlind|subdToPoly|subdTransferUVsToCache|subdiv|subdivCrease|subdivDisplaySmoothness|substitute|substituteAllString|substituteGeometry|substring|surface|surfaceSampler|surfaceShaderList|swatchDisplayPort|switchTable|symbolButton|symbolCheckBox|sysFile|system|tabLayout|tan|tangentConstraint|texLatticeDeformContext|texManipContext|texMoveContext|texMoveUVShellContext|texRotateContext|texScaleContext|texSelectContext|texSelectShortestPathCtx|texSmudgeUVContext|texWinToolCtx|text|textCurves|textField|textFieldButtonGrp|textFieldGrp|textManip|textScrollList|textToShelf|textureDisplacePlane|textureHairColor|texturePlacementContext|textureWindow|threadCount|threePointArcCtx|timeControl|timePort|timerX|toNativePath|toggle|toggleAxis|toggleWindowVisibility|tokenize|tokenizeList|tolerance|tolower|toolButton|toolCollection|toolDropped|toolHasOptions|toolPropertyWindow|torus|toupper|trace|track|trackCtx|transferAttributes|transformCompare|transformLimits|translator|trim|trunc|truncateFluidCache|truncateHairCache|tumble|tumbleCtx|turbulence|twoPointArcCtx|uiRes|uiTemplate|unassignInputDevice|undo|undoInfo|ungroup|uniform|unit|unloadPlugin|untangleUV|untitledFileName|untrim|upAxis|updateAE|userCtx|uvLink|uvSnapshot|validateShelfName|vectorize|view2dToolCtx|viewCamera|viewClipPlane|viewFit|viewHeadOn|viewLookAt|viewManip|viewPlace|viewSet|visor|volumeAxis|vortex|waitCursor|warning|webBrowser|webBrowserPrefs|whatIs|window|windowPref|wire|wireContext|workspace|wrinkle|wrinkleContext|writeTake|xbmLangPathList|xform)\b/,operator:[/\+[+=]?|-[-=]?|&&|\|\||[<>]=|[*\/!=]=?|[%^]/,{pattern:/(^|[^<])<(?!<)/,lookbehind:!0},{pattern:/(^|[^>])>(?!>)/,lookbehind:!0}],punctuation:/<<|>>|[.,:;?\[\](){}]/},Prism.languages.mel.code.inside.rest=Prism.util.clone(Prism.languages.mel);
Prism.languages.mizar={comment:/::.+/,keyword:/@proof\b|\b(?:according|aggregate|all|and|antonym|are|as|associativity|assume|asymmetry|attr|be|begin|being|by|canceled|case|cases|clusters?|coherence|commutativity|compatibility|connectedness|consider|consistency|constructors|contradiction|correctness|def|deffunc|define|definitions?|defpred|do|does|equals|end|environ|ex|exactly|existence|for|from|func|given|hence|hereby|holds|idempotence|identity|iff?|implies|involutiveness|irreflexivity|is|it|let|means|mode|non|not|notations?|now|of|or|otherwise|over|per|pred|prefix|projectivity|proof|provided|qua|reconsider|redefine|reduce|reducibility|reflexivity|registrations?|requirements|reserve|sch|schemes?|section|selector|set|sethood|st|struct|such|suppose|symmetry|synonym|take|that|the|then|theorems?|thesis|thus|to|transitivity|uniqueness|vocabular(?:y|ies)|when|where|with|wrt)\b/,parameter:{pattern:/\$(?:10|\d)/,alias:"variable"},variable:/\w+(?=:)/,number:/(?:\b|-)\d+\b/,operator:/\.\.\.|->|&|\.?=/,punctuation:/\(#|#\)|[,:;\[\](){}]/};
Prism.languages.monkey={string:/"[^"\r\n]*"/,comment:[/^#Rem\s+[\s\S]*?^#End/im,/'.+/],preprocessor:{pattern:/(^[ \t]*)#.+/m,lookbehind:!0,alias:"comment"},"function":/\w+(?=\()/,"type-char":{pattern:/(\w)[?%#$]/,lookbehind:!0,alias:"variable"},number:{pattern:/((?:\.\.)?)(?:(?:\b|\B-\.?|\B\.)\d+((?!\.\.)\.\d*)?|\$[\da-f]+)/i,lookbehind:!0},keyword:/\b(?:Void|Strict|Public|Private|Property|Bool|Int|Float|String|Array|Object|Continue|Exit|Import|Extern|New|Self|Super|Try|Catch|Eachin|True|False|Extends|Abstract|Final|Select|Case|Default|Const|Local|Global|Field|Method|Function|Class|End|If|Then|Else|ElseIf|EndIf|While|Wend|Repeat|Until|Forever|For|To|Step|Next|Return|Module|Interface|Implements|Inline|Throw|Null)\b/i,operator:/\.\.|<[=>]?|>=?|:?=|(?:[+\-*\/&~|]|\b(?:Mod|Shl|Shr)\b)=?|\b(?:And|Not|Or)\b/i,punctuation:/[.,:;()\[\]]/};
Prism.languages.nasm={comment:/;.*$/m,string:/("|'|`)(\\?.)*?\1/m,label:{pattern:/(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,lookbehind:!0,alias:"function"},keyword:[/\[?BITS (16|32|64)\]?/m,{pattern:/(^\s*)section\s*[a-zA-Z\.]+:?/im,lookbehind:!0},/(?:extern|global)[^;\r\n]*/im,/(?:CPU|FLOAT|DEFAULT).*$/m],register:{pattern:/\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(bp|sp|si|di)|[cdefgs]s)\b/i,alias:"variable"},number:/(\b|-|(?=\$))(0[hx][\da-f]*\.?[\da-f]+(p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|\d*\.?\d+(\.?e[+-]?\d+)?[dt]?)\b/i,operator:/[\[\]*+\-\/%<>=&|$!]/};
Prism.languages.nginx=Prism.languages.extend("clike",{comment:{pattern:/(^|[^"{\\])#.*/,lookbehind:!0},keyword:/\b(?:CONTENT_|DOCUMENT_|GATEWAY_|HTTP_|HTTPS|if_not_empty|PATH_|QUERY_|REDIRECT_|REMOTE_|REQUEST_|SCGI|SCRIPT_|SERVER_|http|server|events|location|include|accept_mutex|accept_mutex_delay|access_log|add_after_body|add_before_body|add_header|addition_types|aio|alias|allow|ancient_browser|ancient_browser_value|auth|auth_basic|auth_basic_user_file|auth_http|auth_http_header|auth_http_timeout|autoindex|autoindex_exact_size|autoindex_localtime|break|charset|charset_map|charset_types|chunked_transfer_encoding|client_body_buffer_size|client_body_in_file_only|client_body_in_single_buffer|client_body_temp_path|client_body_timeout|client_header_buffer_size|client_header_timeout|client_max_body_size|connection_pool_size|create_full_put_path|daemon|dav_access|dav_methods|debug_connection|debug_points|default_type|deny|devpoll_changes|devpoll_events|directio|directio_alignment|disable_symlinks|empty_gif|env|epoll_events|error_log|error_page|expires|fastcgi_buffer_size|fastcgi_buffers|fastcgi_busy_buffers_size|fastcgi_cache|fastcgi_cache_bypass|fastcgi_cache_key|fastcgi_cache_lock|fastcgi_cache_lock_timeout|fastcgi_cache_methods|fastcgi_cache_min_uses|fastcgi_cache_path|fastcgi_cache_purge|fastcgi_cache_use_stale|fastcgi_cache_valid|fastcgi_connect_timeout|fastcgi_hide_header|fastcgi_ignore_client_abort|fastcgi_ignore_headers|fastcgi_index|fastcgi_intercept_errors|fastcgi_keep_conn|fastcgi_max_temp_file_size|fastcgi_next_upstream|fastcgi_no_cache|fastcgi_param|fastcgi_pass|fastcgi_pass_header|fastcgi_read_timeout|fastcgi_redirect_errors|fastcgi_send_timeout|fastcgi_split_path_info|fastcgi_store|fastcgi_store_access|fastcgi_temp_file_write_size|fastcgi_temp_path|flv|geo|geoip_city|geoip_country|google_perftools_profiles|gzip|gzip_buffers|gzip_comp_level|gzip_disable|gzip_http_version|gzip_min_length|gzip_proxied|gzip_static|gzip_types|gzip_vary|if|if_modified_since|ignore_invalid_headers|image_filter|image_filter_buffer|image_filter_jpeg_quality|image_filter_sharpen|image_filter_transparency|imap_capabilities|imap_client_buffer|include|index|internal|ip_hash|keepalive|keepalive_disable|keepalive_requests|keepalive_timeout|kqueue_changes|kqueue_events|large_client_header_buffers|limit_conn|limit_conn_log_level|limit_conn_zone|limit_except|limit_rate|limit_rate_after|limit_req|limit_req_log_level|limit_req_zone|limit_zone|lingering_close|lingering_time|lingering_timeout|listen|location|lock_file|log_format|log_format_combined|log_not_found|log_subrequest|map|map_hash_bucket_size|map_hash_max_size|master_process|max_ranges|memcached_buffer_size|memcached_connect_timeout|memcached_next_upstream|memcached_pass|memcached_read_timeout|memcached_send_timeout|merge_slashes|min_delete_depth|modern_browser|modern_browser_value|mp4|mp4_buffer_size|mp4_max_buffer_size|msie_padding|msie_refresh|multi_accept|open_file_cache|open_file_cache_errors|open_file_cache_min_uses|open_file_cache_valid|open_log_file_cache|optimize_server_names|override_charset|pcre_jit|perl|perl_modules|perl_require|perl_set|pid|pop3_auth|pop3_capabilities|port_in_redirect|post_action|postpone_output|protocol|proxy|proxy_buffer|proxy_buffer_size|proxy_buffering|proxy_buffers|proxy_busy_buffers_size|proxy_cache|proxy_cache_bypass|proxy_cache_key|proxy_cache_lock|proxy_cache_lock_timeout|proxy_cache_methods|proxy_cache_min_uses|proxy_cache_path|proxy_cache_use_stale|proxy_cache_valid|proxy_connect_timeout|proxy_cookie_domain|proxy_cookie_path|proxy_headers_hash_bucket_size|proxy_headers_hash_max_size|proxy_hide_header|proxy_http_version|proxy_ignore_client_abort|proxy_ignore_headers|proxy_intercept_errors|proxy_max_temp_file_size|proxy_method|proxy_next_upstream|proxy_no_cache|proxy_pass|proxy_pass_error_message|proxy_pass_header|proxy_pass_request_body|proxy_pass_request_headers|proxy_read_timeout|proxy_redirect|proxy_redirect_errors|proxy_send_lowat|proxy_send_timeout|proxy_set_body|proxy_set_header|proxy_ssl_session_reuse|proxy_store|proxy_store_access|proxy_temp_file_write_size|proxy_temp_path|proxy_timeout|proxy_upstream_fail_timeout|proxy_upstream_max_fails|random_index|read_ahead|real_ip_header|recursive_error_pages|request_pool_size|reset_timedout_connection|resolver|resolver_timeout|return|rewrite|root|rtsig_overflow_events|rtsig_overflow_test|rtsig_overflow_threshold|rtsig_signo|satisfy|satisfy_any|secure_link_secret|send_lowat|send_timeout|sendfile|sendfile_max_chunk|server|server_name|server_name_in_redirect|server_names_hash_bucket_size|server_names_hash_max_size|server_tokens|set|set_real_ip_from|smtp_auth|smtp_capabilities|so_keepalive|source_charset|split_clients|ssi|ssi_silent_errors|ssi_types|ssi_value_length|ssl|ssl_certificate|ssl_certificate_key|ssl_ciphers|ssl_client_certificate|ssl_crl|ssl_dhparam|ssl_engine|ssl_prefer_server_ciphers|ssl_protocols|ssl_session_cache|ssl_session_timeout|ssl_verify_client|ssl_verify_depth|starttls|stub_status|sub_filter|sub_filter_once|sub_filter_types|tcp_nodelay|tcp_nopush|timeout|timer_resolution|try_files|types|types_hash_bucket_size|types_hash_max_size|underscores_in_headers|uninitialized_variable_warn|upstream|use|user|userid|userid_domain|userid_expires|userid_name|userid_p3p|userid_path|userid_service|valid_referers|variables_hash_bucket_size|variables_hash_max_size|worker_connections|worker_cpu_affinity|worker_priority|worker_processes|worker_rlimit_core|worker_rlimit_nofile|worker_rlimit_sigpending|working_directory|xclient|xml_entities|xslt_entities|xslt_stylesheet|xslt_types)\b/i}),Prism.languages.insertBefore("nginx","keyword",{variable:/\$[a-z_]+/i});
Prism.languages.nim={comment:/#.*/,string:/(?:(?:\b(?!\d)(?:\w|\\x[8-9a-fA-F][0-9a-fA-F])+)?(?:"""[\s\S]*?"""(?!")|"(?:\\[\s\S]|""|[^"\\])*")|'(?:\\(?:\d+|x[\da-fA-F]{2}|.)|[^'])')/,number:/\b(?:0[xXoObB][\da-fA-F_]+|\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:[eE][+-]?\d[\d_]*)?)(?:'?[iuf]\d*)?/,keyword:/\b(?:addr|as|asm|atomic|bind|block|break|case|cast|concept|const|continue|converter|defer|discard|distinct|do|elif|else|end|enum|except|export|finally|for|from|func|generic|if|import|include|interface|iterator|let|macro|method|mixin|nil|object|out|proc|ptr|raise|ref|return|static|template|try|tuple|type|using|var|when|while|with|without|yield)\b/,"function":{pattern:/(?:(?!\d)(?:\w|\\x[8-9a-fA-F][0-9a-fA-F])+|`[^`\r\n]+`)\*?(?:\[[^\]]+\])?(?=\s*\()/,inside:{operator:/\*$/}},ignore:{pattern:/`[^`\r\n]+`/,inside:{punctuation:/`/}},operator:{pattern:/(^|[({\[](?=\.\.)|(?![({\[]\.).)(?:(?:[=+\-*\/<>@$~&%|!?^:\\]|\.\.|\.(?![)}\]]))+|\b(?:and|div|of|or|in|is|isnot|mod|not|notin|shl|shr|xor)\b)/m,lookbehind:!0},punctuation:/[({\[]\.|\.[)}\]]|[`(){}\[\],:]/};
Prism.languages.nix={comment:/\/\*[\s\S]*?\*\/|#.*/,string:{pattern:/"(?:[^"\\]|\\[\s\S])*"|''(?:(?!'')[\s\S]|''(?:'|\\|\$\{))*''/,inside:{interpolation:{pattern:/(^|(?:^|(?!'').)[^\\])\$\{(?:[^}]|\{[^}]*\})*}/,lookbehind:!0,inside:{antiquotation:{pattern:/^\$(?=\{)/,alias:"variable"}}}}},url:[/\b(?:[a-z]{3,7}:\/\/)[\w\-+%~\/.:#=?&]+/,{pattern:/([^\/])(?:[\w\-+%~.:#=?&]*(?!\/\/)[\w\-+%~\/.:#=?&])?(?!\/\/)\/[\w\-+%~\/.:#=?&]*/,lookbehind:!0}],antiquotation:{pattern:/\$(?=\{)/,alias:"variable"},number:/\b\d+\b/,keyword:/\b(?:assert|builtins|else|if|in|inherit|let|null|or|then|with)\b/,"function":/\b(?:abort|add|all|any|attrNames|attrValues|baseNameOf|compareVersions|concatLists|currentSystem|deepSeq|derivation|dirOf|div|elem(?:At)?|fetch(?:url|Tarball)|filter(?:Source)?|fromJSON|genList|getAttr|getEnv|hasAttr|hashString|head|import|intersectAttrs|is(?:Attrs|Bool|Function|Int|List|Null|String)|length|lessThan|listToAttrs|map|mul|parseDrvName|pathExists|read(?:Dir|File)|removeAttrs|replaceStrings|seq|sort|stringLength|sub(?:string)?|tail|throw|to(?:File|JSON|Path|String|XML)|trace|typeOf)\b|\bfoldl'\B/,"boolean":/\b(?:true|false)\b/,operator:/[=!<>]=?|\+\+?|\|\||&&|\/\/|->?|[?@]/,punctuation:/[{}()[\].,:;]/},Prism.languages.nix.string.inside.interpolation.inside.rest=Prism.util.clone(Prism.languages.nix);
Prism.languages.nsis={comment:{pattern:/(^|[^\\])(\/\*[\w\W]*?\*\/|[#;].*)/,lookbehind:!0},string:/("|')(\\?.)*?\1/,keyword:/\b(Abort|Add(BrandingImage|Size)|AdvSplash|Allow(RootDirInstall|SkipFiles)|AutoCloseWindow|Banner|BG(Font|Gradient|Image)|BrandingText|BringToFront|Call(InstDLL)?|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|CRCCheck|Create(Directory|Font|ShortCut)|Delete(INISec|INIStr|RegKey|RegValue)?|Detail(Print|sButtonText)|Dialer|Dir(Text|Var|Verify)|EnableWindow|Enum(RegKey|RegValue)|Exch|Exec(Shell|Wait)?|ExpandEnvStrings|File(BufSize|Close|ErrorText|Open|Read|ReadByte|ReadUTF16LE|ReadWord|WriteUTF16LE|Seek|Write|WriteByte|WriteWord)?|Find(Close|First|Next|Window)|FlushINI|Get(CurInstType|CurrentAddress|DlgItem|DLLVersion(Local)?|ErrorLevel|FileTime(Local)?|FullPathName|Function(Address|End)?|InstDirError|LabelAddress|TempFileName)|Goto|HideWindow|Icon|If(Abort|Errors|FileExists|RebootFlag|Silent)|InitPluginsDir|Install(ButtonText|Colors|Dir(RegKey)?)|InstProgressFlags|Inst(Type(GetText|SetText)?)|Int(CmpU?|Fmt|Op)|IsWindow|Lang(DLL|String)|License(BkColor|Data|ForceSelection|LangString|Text)|LoadLanguageFile|LockWindow|Log(Set|Text)|Manifest(DPIAware|SupportedOS)|Math|MessageBox|MiscButtonText|Name|Nop|ns(Dialogs|Exec)|NSISdl|OutFile|Page(Callbacks)?|Pop|Push|Quit|Read(EnvStr|INIStr|RegDWORD|RegStr)|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|RMDir|SearchPath|Section(End|GetFlags|GetInstTypes|GetSize|GetText|Group|In|SetFlags|SetInstTypes|SetSize|SetText)?|SendMessage|Set(AutoClose|BrandingImage|Compress|Compressor(DictSize)?|CtlColors|CurInstType|DatablockOptimize|DateSave|Details(Print|View)|ErrorLevel|Errors|FileAttributes|Font|OutPath|Overwrite|PluginUnload|RebootFlag|RegView|ShellVarContext|Silent)|Show(InstDetails|UninstDetails|Window)|Silent(Install|UnInstall)|Sleep|SpaceTexts|Splash|StartMenu|Str(CmpS?|Cpy|Len)|SubCaption|System|Unicode|Uninstall(ButtonText|Caption|Icon|SubCaption|Text)|UninstPage|UnRegDLL|UserInfo|Var|VI(AddVersionKey|FileVersion|ProductVersion)|VPatch|WindowIcon|Write(INIStr|RegBin|RegDWORD|RegExpandStr|RegStr|Uninstaller)|XPStyle)\b/,property:/\b(admin|all|auto|both|colored|false|force|hide|highest|lastused|leave|listonly|none|normal|notset|off|on|open|print|show|silent|silentlog|smooth|textonly|true|user|ARCHIVE|FILE_(ATTRIBUTE_ARCHIVE|ATTRIBUTE_NORMAL|ATTRIBUTE_OFFLINE|ATTRIBUTE_READONLY|ATTRIBUTE_SYSTEM|ATTRIBUTE_TEMPORARY)|HK(CR|CU|DD|LM|PD|U)|HKEY_(CLASSES_ROOT|CURRENT_CONFIG|CURRENT_USER|DYN_DATA|LOCAL_MACHINE|PERFORMANCE_DATA|USERS)|ID(ABORT|CANCEL|IGNORE|NO|OK|RETRY|YES)|MB_(ABORTRETRYIGNORE|DEFBUTTON1|DEFBUTTON2|DEFBUTTON3|DEFBUTTON4|ICONEXCLAMATION|ICONINFORMATION|ICONQUESTION|ICONSTOP|OK|OKCANCEL|RETRYCANCEL|RIGHT|RTLREADING|SETFOREGROUND|TOPMOST|USERICON|YESNO)|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SYSTEM|TEMPORARY)\b/,variable:/\$[({]?[-_\w]+[)}]?/i,number:/\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?)\b/,operator:/--?|\+\+?|<=?|>=?|==?=?|&&?|\|?\||[?*\/~^%]/,punctuation:/[{}[\];(),.:]/,important:/!(addincludedir|addplugindir|appendfile|cd|define|delfile|echo|else|endif|error|execute|finalize|getdllversionsystem|ifdef|ifmacrodef|ifmacrondef|ifndef|if|include|insertmacro|macroend|macro|makensis|packhdr|searchparse|searchreplace|tempfile|undef|verbose|warning)\b/i};
Prism.languages.objectivec=Prism.languages.extend("c",{keyword:/\b(asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|in|self|super)\b|(@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,string:/("|')(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|@"(\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,operator:/-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/});
Prism.languages.ocaml={comment:/\(\*[\s\S]*?\*\)/,string:[/"(?:\\.|[^\\\r\n"])*"/,/(['`])(?:\\(?:\d+|x[\da-f]+|.)|(?!\1)[^\\\r\n])\1/i],number:/\b-?(?:0x[\da-f][\da-f_]+|(?:0[bo])?\d[\d_]*\.?[\d_]*(?:e[+-]?[\d_]+)?)/i,type:{pattern:/\B['`][a-z\d_]*/i,alias:"variable"},directive:{pattern:/\B#[a-z\d_]+/i,alias:"function"},keyword:/\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|object|of|open|prefix|private|rec|then|sig|struct|to|try|type|val|value|virtual|where|while|with)\b/,"boolean":/\b(?:false|true)\b/,operator:/:=|[=<>@^|&+\-*\/$%!?~][!$%&\*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lxor|lsl|lsr|mod|nor|or)\b/,punctuation:/[(){}\[\]|_.,:;]/};
Prism.languages.oz={comment:/\/\*[\s\S]*?\*\/|%.*/,string:/"(?:[^"\\]|\\[\s\S])*"/,atom:{pattern:/'(?:[^'\\]|\\.)*'/,alias:"builtin"},keyword:/[$_]|\[\]|\b(?:at|attr|case|catch|choice|class|cond|declare|define|dis|else(?:case|if)?|end|export|fail|false|feat|finally|from|fun|functor|if|import|in|local|lock|meth|nil|not|of|or|prepare|proc|prop|raise|require|self|skip|then|thread|true|try|unit)\b/,"function":[/[a-z][A-Za-z\d]*(?=\()/,{pattern:/(\{)[A-Z][A-Za-z\d]*/,lookbehind:!0}],number:/\b(?:0[bx][\da-f]+|\d+\.?\d*(?:e~?\d+)?\b)|&(?:[^\\]|\\(?:\d{3}|.))/i,variable:/\b[A-Z][A-Za-z\d]*|`(?:[^`\\]|\\.)+`/,"attr-name":/\w+(?=:)/,operator:/:(?:=|::?)|<[-:=]?|=(?:=|<?:?)|>=?:?|\\=:?|!!?|[|#+\-*\/,~^@]|\b(?:andthen|div|mod|orelse)\b/,punctuation:/[\[\](){}.:;?]/};
Prism.languages.parigp={comment:/\/\*[\s\S]*?\*\/|\\\\.*/,string:/"(?:[^"\\]|\\.)*"/,keyword:function(){var r=["breakpoint","break","dbg_down","dbg_err","dbg_up","dbg_x","forcomposite","fordiv","forell","forpart","forprime","forstep","forsubgroup","forvec","for","iferr","if","local","my","next","return","until","while"];return r=r.map(function(r){return r.split("").join(" *")}).join("|"),RegExp("\\b(?:"+r+")\\b")}(),"function":/\w[\w ]*?(?= *\()/,number:{pattern:/((?:\. *\. *)?)(?:\d(?: *\d)*(?: *(?!\. *\.)\.(?: *\d)*)?|\. *\d(?: *\d)*)(?: *e *[+-]? *\d(?: *\d)*)?/i,lookbehind:!0},operator:/\. *\.|[*\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\+(?: *[+=])?|-(?: *[-=>])?|<(?:(?: *<)?(?: *=)?| *>)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\(?: *\/)?(?: *=)?|&(?: *&)?|\| *\||['#~^]/,punctuation:/[\[\]{}().,:;|]/};
Prism.languages.parser=Prism.languages.extend("markup",{keyword:{pattern:/(^|[^^])(?:\^(?:case|eval|for|if|switch|throw)\b|@(?:BASE|CLASS|GET(?:_DEFAULT)?|OPTIONS|SET_DEFAULT|USE)\b)/,lookbehind:!0},variable:{pattern:/(^|[^^])\B\$(?:\w+|(?=[.\{]))(?:(?:\.|::?)\w+)*(?:\.|::?)?/,lookbehind:!0,inside:{punctuation:/\.|:+/}},"function":{pattern:/(^|[^^])\B[@^]\w+(?:(?:\.|::?)\w+)*(?:\.|::?)?/,lookbehind:!0,inside:{keyword:{pattern:/(^@)(?:GET_|SET_)/,lookbehind:!0},punctuation:/\.|:+/}},escape:{pattern:/\^(?:[$^;@()\[\]{}"':]|#[a-f\d]*)/i,alias:"builtin"},punctuation:/[\[\](){};]/}),Prism.languages.insertBefore("parser","keyword",{"parser-comment":{pattern:/(\s)#.*/,lookbehind:!0,alias:"comment"},expression:{pattern:/(^|[^^])\((?:[^()]|\((?:[^()]|\((?:[^()])*\))*\))*\)/,lookbehind:!0,inside:{string:{pattern:/(^|[^^])(["'])(?:(?!\2)[^^]|\^[\s\S])*\2/,lookbehind:!0},keyword:Prism.languages.parser.keyword,variable:Prism.languages.parser.variable,"function":Prism.languages.parser.function,"boolean":/\b(?:true|false)\b/,number:/\b(?:0x[a-f\d]+|\d+\.?\d*(?:e[+-]?\d+)?)\b/i,escape:Prism.languages.parser.escape,operator:/[~+*\/\\%]|!(?:\|\|?|=)?|&&?|\|\|?|==|<[<=]?|>[>=]?|-[fd]?|\b(?:def|eq|ge|gt|in|is|le|lt|ne)\b/,punctuation:Prism.languages.parser.punctuation}}}),Prism.languages.insertBefore("inside","punctuation",{expression:Prism.languages.parser.expression,keyword:Prism.languages.parser.keyword,variable:Prism.languages.parser.variable,"function":Prism.languages.parser.function,escape:Prism.languages.parser.escape,"parser-punctuation":{pattern:Prism.languages.parser.punctuation,alias:"punctuation"}},Prism.languages.parser.tag.inside["attr-value"]);
Prism.languages.pascal={comment:[/\(\*[\s\S]+?\*\)/,/\{[\s\S]+?\}/,/\/\/.*/],string:/(?:'(?:''|[^'\r\n])*'|#[&$%]?[a-f\d]+)+|\^[a-z]/i,keyword:[{pattern:/(^|[^&])\b(?:absolute|array|asm|begin|case|const|constructor|destructor|do|downto|else|end|file|for|function|goto|if|implementation|inherited|inline|interface|label|nil|object|of|operator|packed|procedure|program|record|reintroduce|repeat|self|set|string|then|to|type|unit|until|uses|var|while|with)\b/i,lookbehind:!0},{pattern:/(^|[^&])\b(?:dispose|exit|false|new|true)\b/i,lookbehind:!0},{pattern:/(^|[^&])\b(?:class|dispinterface|except|exports|finalization|finally|initialization|inline|library|on|out|packed|property|raise|resourcestring|threadvar|try)\b/i,lookbehind:!0},{pattern:/(^|[^&])\b(?:absolute|abstract|alias|assembler|bitpacked|break|cdecl|continue|cppdecl|cvar|default|deprecated|dynamic|enumerator|experimental|export|external|far|far16|forward|generic|helper|implements|index|interrupt|iochecks|local|message|name|near|nodefault|noreturn|nostackframe|oldfpccall|otherwise|overload|override|pascal|platform|private|protected|public|published|read|register|reintroduce|result|safecall|saveregisters|softfloat|specialize|static|stdcall|stored|strict|unaligned|unimplemented|varargs|virtual|write)\b/i,lookbehind:!0}],number:[/[+-]?(?:[&%]\d+|\$[a-f\d]+)/i,/([+-]|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?/i],operator:[/\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=]/i,{pattern:/(^|[^&])\b(?:and|as|div|exclude|in|include|is|mod|not|or|shl|shr|xor)\b/,lookbehind:!0}],punctuation:/\(\.|\.\)|[()\[\]:;,.]/};
Prism.languages.perl={comment:[{pattern:/(^\s*)=\w+[\s\S]*?=cut.*/m,lookbehind:!0},{pattern:/(^|[^\\$])#.*/,lookbehind:!0}],string:[/\b(?:q|qq|qx|qw)\s*([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1/,/\b(?:q|qq|qx|qw)\s+([a-zA-Z0-9])(?:[^\\]|\\[\s\S])*?\1/,/\b(?:q|qq|qx|qw)\s*\((?:[^()\\]|\\[\s\S])*\)/,/\b(?:q|qq|qx|qw)\s*\{(?:[^{}\\]|\\[\s\S])*\}/,/\b(?:q|qq|qx|qw)\s*\[(?:[^[\]\\]|\\[\s\S])*\]/,/\b(?:q|qq|qx|qw)\s*<(?:[^<>\\]|\\[\s\S])*>/,/("|`)(?:[^\\]|\\[\s\S])*?\1/,/'(?:[^'\\\r\n]|\\.)*'/],regex:[/\b(?:m|qr)\s*([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1[msixpodualngc]*/,/\b(?:m|qr)\s+([a-zA-Z0-9])(?:[^\\]|\\.)*?\1[msixpodualngc]*/,/\b(?:m|qr)\s*\((?:[^()\\]|\\[\s\S])*\)[msixpodualngc]*/,/\b(?:m|qr)\s*\{(?:[^{}\\]|\\[\s\S])*\}[msixpodualngc]*/,/\b(?:m|qr)\s*\[(?:[^[\]\\]|\\[\s\S])*\][msixpodualngc]*/,/\b(?:m|qr)\s*<(?:[^<>\\]|\\[\s\S])*>[msixpodualngc]*/,{pattern:/(^|[^-]\b)(?:s|tr|y)\s*([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\2(?:[^\\]|\\[\s\S])*?\2[msixpodualngcer]*/,lookbehind:!0},{pattern:/(^|[^-]\b)(?:s|tr|y)\s+([a-zA-Z0-9])(?:[^\\]|\\[\s\S])*?\2(?:[^\\]|\\[\s\S])*?\2[msixpodualngcer]*/,lookbehind:!0},{pattern:/(^|[^-]\b)(?:s|tr|y)\s*\((?:[^()\\]|\\[\s\S])*\)\s*\((?:[^()\\]|\\[\s\S])*\)[msixpodualngcer]*/,lookbehind:!0},{pattern:/(^|[^-]\b)(?:s|tr|y)\s*\{(?:[^{}\\]|\\[\s\S])*\}\s*\{(?:[^{}\\]|\\[\s\S])*\}[msixpodualngcer]*/,lookbehind:!0},{pattern:/(^|[^-]\b)(?:s|tr|y)\s*\[(?:[^[\]\\]|\\[\s\S])*\]\s*\[(?:[^[\]\\]|\\[\s\S])*\][msixpodualngcer]*/,lookbehind:!0},{pattern:/(^|[^-]\b)(?:s|tr|y)\s*<(?:[^<>\\]|\\[\s\S])*>\s*<(?:[^<>\\]|\\[\s\S])*>[msixpodualngcer]*/,lookbehind:!0},/\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(lt|gt|le|ge|eq|ne|cmp|not|and|or|xor|x)\b))/],variable:[/[&*$@%]\{\^[A-Z]+\}/,/[&*$@%]\^[A-Z_]/,/[&*$@%]#?(?=\{)/,/[&*$@%]#?((::)*'?(?!\d)[\w$]+)+(::)*/i,/[&*$@%]\d+/,/(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/],filehandle:{pattern:/<(?![<=])\S*>|\b_\b/,alias:"symbol"},vstring:{pattern:/v\d+(\.\d+)*|\d+(\.\d+){2,}/,alias:"string"},"function":{pattern:/sub [a-z0-9_]+/i,inside:{keyword:/sub/}},keyword:/\b(any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|say|state|sub|switch|undef|unless|until|use|when|while)\b/,number:/\b-?(0x[\dA-Fa-f](_?[\dA-Fa-f])*|0b[01](_?[01])*|(\d(_?\d)*)?\.?\d(_?\d)*([Ee][+-]?\d+)?)\b/,operator:/-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(lt|gt|le|ge|eq|ne|cmp|not|and|or|xor)\b/,punctuation:/[{}[\];(),:]/};
Prism.languages.php=Prism.languages.extend("clike",{keyword:/\b(and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\b/i,constant:/\b[A-Z0-9_]{2,}\b/,comment:{pattern:/(^|[^\\])(?:\/\*[\w\W]*?\*\/|\/\/.*)/,lookbehind:!0,greedy:!0}}),Prism.languages.insertBefore("php","class-name",{"shell-comment":{pattern:/(^|[^\\])#.*/,lookbehind:!0,alias:"comment"}}),Prism.languages.insertBefore("php","keyword",{delimiter:/\?>|<\?(?:php)?/i,variable:/\$\w+\b/i,"package":{pattern:/(\\|namespace\s+|use\s+)[\w\\]+/,lookbehind:!0,inside:{punctuation:/\\/}}}),Prism.languages.insertBefore("php","operator",{property:{pattern:/(->)[\w]+/,lookbehind:!0}}),Prism.languages.markup&&(Prism.hooks.add("before-highlight",function(e){"php"===e.language&&(e.tokenStack=[],e.code=e.code.replace(/(?:<\?php|<\?)[\w\W]*?(?:\?>)/gi,function(n){return e.tokenStack.push(n),"{{{PHP"+e.tokenStack.length+"}}}"}))}),Prism.hooks.add("after-highlight",function(e){if("php"===e.language){for(var n,a=0;n=e.tokenStack[a];a++)e.highlightedCode=e.highlightedCode.replace("{{{PHP"+(a+1)+"}}}",Prism.highlight(n,e.grammar,"php").replace(/\$/g,"$$$$"));e.element.innerHTML=e.highlightedCode}}),Prism.hooks.add("wrap",function(e){"php"===e.language&&"markup"===e.type&&(e.content=e.content.replace(/(\{\{\{PHP[0-9]+\}\}\})/g,'<span class="token php">$1</span>'))}),Prism.languages.insertBefore("php","comment",{markup:{pattern:/<[^?]\/?(.*?)>/,inside:Prism.languages.markup},php:/\{\{\{PHP[0-9]+\}\}\}/}));
Prism.languages.insertBefore("php","variable",{"this":/\$this\b/,global:/\$(?:_(?:SERVER|GET|POST|FILES|REQUEST|SESSION|ENV|COOKIE)|GLOBALS|HTTP_RAW_POST_DATA|argc|argv|php_errormsg|http_response_header)/,scope:{pattern:/\b[\w\\]+::/,inside:{keyword:/(static|self|parent)/,punctuation:/(::|\\)/}}});
Prism.languages.powershell={comment:[{pattern:/(^|[^`])<#[\w\W]*?#>/,lookbehind:!0},{pattern:/(^|[^`])#.*/,lookbehind:!0}],string:[{pattern:/"(`?[\w\W])*?"/,greedy:!0,inside:{"function":{pattern:/[^`]\$\(.*?\)/,inside:{}}}},{pattern:/'([^']|'')*'/,greedy:!0}],namespace:/\[[a-z][\w\W]*?\]/i,"boolean":/\$(true|false)\b/i,variable:/\$\w+\b/i,"function":[/\b(Add-(Computer|Content|History|Member|PSSnapin|Type)|Checkpoint-Computer|Clear-(Content|EventLog|History|Item|ItemProperty|Variable)|Compare-Object|Complete-Transaction|Connect-PSSession|ConvertFrom-(Csv|Json|StringData)|Convert-Path|ConvertTo-(Csv|Html|Json|Xml)|Copy-(Item|ItemProperty)|Debug-Process|Disable-(ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)|Disconnect-PSSession|Enable-(ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)|Enter-PSSession|Exit-PSSession|Export-(Alias|Clixml|Console|Csv|FormatData|ModuleMember|PSSession)|ForEach-Object|Format-(Custom|List|Table|Wide)|Get-(Alias|ChildItem|Command|ComputerRestorePoint|Content|ControlPanelItem|Culture|Date|Event|EventLog|EventSubscriber|FormatData|Help|History|Host|HotFix|Item|ItemProperty|Job|Location|Member|Module|Process|PSBreakpoint|PSCallStack|PSDrive|PSProvider|PSSession|PSSessionConfiguration|PSSnapin|Random|Service|TraceSource|Transaction|TypeData|UICulture|Unique|Variable|WmiObject)|Group-Object|Import-(Alias|Clixml|Csv|LocalizedData|Module|PSSession)|Invoke-(Command|Expression|History|Item|RestMethod|WebRequest|WmiMethod)|Join-Path|Limit-EventLog|Measure-(Command|Object)|Move-(Item|ItemProperty)|New-(Alias|Event|EventLog|Item|ItemProperty|Module|ModuleManifest|Object|PSDrive|PSSession|PSSessionConfigurationFile|PSSessionOption|PSTransportOption|Service|TimeSpan|Variable|WebServiceProxy)|Out-(Default|File|GridView|Host|Null|Printer|String)|Pop-Location|Push-Location|Read-Host|Receive-(Job|PSSession)|Register-(EngineEvent|ObjectEvent|PSSessionConfiguration|WmiEvent)|Remove-(Computer|Event|EventLog|Item|ItemProperty|Job|Module|PSBreakpoint|PSDrive|PSSession|PSSnapin|TypeData|Variable|WmiObject)|Rename-(Computer|Item|ItemProperty)|Reset-ComputerMachinePassword|Resolve-Path|Restart-(Computer|Service)|Restore-Computer|Resume-(Job|Service)|Save-Help|Select-(Object|String|Xml)|Send-MailMessage|Set-(Alias|Content|Date|Item|ItemProperty|Location|PSBreakpoint|PSDebug|PSSessionConfiguration|Service|StrictMode|TraceSource|Variable|WmiInstance)|Show-(Command|ControlPanelItem|EventLog)|Sort-Object|Split-Path|Start-(Job|Process|Service|Sleep|Transaction)|Stop-(Computer|Job|Process|Service)|Suspend-(Job|Service)|Tee-Object|Test-(ComputerSecureChannel|Connection|ModuleManifest|Path|PSSessionConfigurationFile)|Trace-Command|Unblock-File|Undo-Transaction|Unregister-(Event|PSSessionConfiguration)|Update-(FormatData|Help|List|TypeData)|Use-Transaction|Wait-(Event|Job|Process)|Where-Object|Write-(Debug|Error|EventLog|Host|Output|Progress|Verbose|Warning))\b/i,/\b(ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i],keyword:/\b(Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,operator:{pattern:/(\W?)(!|-(eq|ne|gt|ge|lt|le|sh[lr]|not|b?(and|x?or)|(Not)?(Like|Match|Contains|In)|Replace|Join|is(Not)?|as)\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,lookbehind:!0},punctuation:/[|{}[\];(),.]/},Prism.languages.powershell.string[0].inside.boolean=Prism.languages.powershell.boolean,Prism.languages.powershell.string[0].inside.variable=Prism.languages.powershell.variable,Prism.languages.powershell.string[0].inside.function.inside=Prism.util.clone(Prism.languages.powershell);
Prism.languages.processing=Prism.languages.extend("clike",{keyword:/\b(?:break|catch|case|class|continue|default|else|extends|final|for|if|implements|import|new|null|private|public|return|static|super|switch|this|try|void|while)\b/,operator:/<[<=]?|>[>=]?|&&?|\|\|?|[%?]|[!=+\-*\/]=?/}),Prism.languages.insertBefore("processing","number",{constant:/\b(?!XML\b)[A-Z][A-Z\d_]+\b/,type:{pattern:/\b(?:boolean|byte|char|color|double|float|int|XML|[A-Z][A-Za-z\d_]*)\b/,alias:"variable"}}),Prism.languages.processing["function"].pattern=/[a-z0-9_]+(?=\s*\()/i,Prism.languages.processing["class-name"].alias="variable";
Prism.languages.prolog={comment:[/%.+/,/\/\*[\s\S]*?\*\//],string:/(["'])(?:\1\1|\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,builtin:/\b(?:fx|fy|xf[xy]?|yfx?)\b/,variable:/\b[A-Z_]\w*/,"function":/\b[a-z]\w*(?:(?=\()|\/\d+)/,number:/\b\d+\.?\d*/,operator:/[:\\=><\-?*@\/;+^|!$.]+|\b(?:is|mod|not|xor)\b/,punctuation:/[(){}\[\],]/};
Prism.languages.properties={comment:/^[ \t]*[#!].*$/m,"attr-value":{pattern:/(^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+?(?: *[=:] *| ))(?:\\(?:\r\n|[\s\S])|.)+/m,lookbehind:!0},"attr-name":/^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+?(?= *[ =:]| )/m,punctuation:/[=:]/};
Prism.languages.protobuf=Prism.languages.extend("clike",{keyword:/\b(package|import|message|enum)\b/,builtin:/\b(required|repeated|optional|reserved)\b/,primitive:{pattern:/\b(double|float|int32|int64|uint32|uint64|sint32|sint64|fixed32|fixed64|sfixed32|sfixed64|bool|string|bytes)\b/,alias:"symbol"}});
!function(e){e.languages.puppet={heredoc:[{pattern:/(@\("([^"\r\n\/):]+)"(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r))*?[ \t]*\|?[ \t]*-?[ \t]*\2/,lookbehind:!0,alias:"string",inside:{punctuation:/(?=\S).*\S(?= *$)/}},{pattern:/(@\(([^"\r\n\/):]+)(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r))*?[ \t]*\|?[ \t]*-?[ \t]*\2/,lookbehind:!0,alias:"string",inside:{punctuation:/(?=\S).*\S(?= *$)/}},{pattern:/@\("?(?:[^"\r\n\/):]+)"?(?:\/[nrts$uL]*)?\)/,alias:"string",inside:{punctuation:{pattern:/(\().+?(?=\))/,lookbehind:!0}}}],"multiline-comment":{pattern:/(^|[^\\])\/\*[\s\S]*?\*\//,lookbehind:!0,alias:"comment"},regex:{pattern:/((?:\bnode\s+|[~=\(\[\{,]\s*|[=+]>\s*|^\s*))\/(?:[^\/\\]|\\[\s\S])+\/(?:[imx]+\b|\B)/,lookbehind:!0,inside:{"extended-regex":{pattern:/^\/(?:[^\/\\]|\\[\s\S])+\/[im]*x[im]*$/,inside:{comment:/#.*/}}}},comment:{pattern:/(^|[^\\])#.*/,lookbehind:!0},string:{pattern:/(["'])(?:\$\{(?:[^'"}]|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}|(?!\1)[^\\]|\\[\s\S])*\1/,inside:{"double-quoted":{pattern:/^"[\s\S]*"$/,inside:{}}}},variable:{pattern:/\$(?:::)?\w+(?:::\w+)*/,inside:{punctuation:/::/}},"attr-name":/(?:\w+|\*)(?=\s*=>)/,"function":[{pattern:/(\.)(?!\d)\w+/,lookbehind:!0},/\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\b|\b(?!\d)\w+(?=\()/],number:/\b(?:0x[a-f\d]+|\d+(?:\.\d+)?(?:e-?\d+)?)\b/i,"boolean":/\b(?:true|false)\b/,keyword:/\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\b/,datatype:{pattern:/\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\b/,alias:"symbol"},operator:/=[=~>]?|![=~]?|<(?:<\|?|[=~|-])?|>[>=]?|->?|~>|\|>?>?|[*\/%+?]|\b(?:and|in|or)\b/,punctuation:/[\[\]{}().,;]|:+/};var n=[{pattern:/(^|[^\\])\$\{(?:[^'"{}]|\{[^}]*\}|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}/,lookbehind:!0,inside:{"short-variable":{pattern:/(^\$\{)(?!\w+\()(?:::)?\w+(?:::\w+)*/,lookbehind:!0,alias:"variable",inside:{punctuation:/::/}},delimiter:{pattern:/^\$/,alias:"variable"},rest:e.util.clone(e.languages.puppet)}},{pattern:/(^|[^\\])\$(?:::)?\w+(?:::\w+)*/,lookbehind:!0,alias:"variable",inside:{punctuation:/::/}}];e.languages.puppet.heredoc[0].inside.interpolation=n,e.languages.puppet.string.inside["double-quoted"].inside.interpolation=n}(Prism);
!function(e){e.languages.pure={"inline-lang":{pattern:/%<[\s\S]+?%>/,inside:{lang:{pattern:/(^%< *)-\*-.+?-\*-/,lookbehind:!0,alias:"comment"},delimiter:{pattern:/^%<.*|%>$/,alias:"punctuation"}}},comment:[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0},/#!.+/],string:/"(?:\\.|[^"\\\r\n])*"/,number:{pattern:/((?:\.\.)?)(?:\b(?:inf|nan)\b|\b0x[\da-f]+|(?:\b(?:0b)?\d+(?:\.\d)?|\B\.\d)\d*(?:e[+-]?\d+)?L?)/i,lookbehind:!0},keyword:/\b(?:ans|break|bt|case|catch|cd|clear|const|def|del|dump|else|end|exit|extern|false|force|help|if|infix[lr]?|interface|let|ls|mem|namespace|nonfix|NULL|of|otherwise|outfix|override|postfix|prefix|private|public|pwd|quit|run|save|show|stats|then|throw|trace|true|type|underride|using|when|with)\b/,"function":/\b(?:abs|add_(?:(?:fundef|interface|macdef|typedef)(?:_at)?|addr|constdef|vardef)|all|any|applp?|arity|bigintp?|blob(?:_crc|_size|p)?|boolp?|byte_(?:matrix|pointer)|byte_c?string(?:_pointer)?|calloc|cat|catmap|ceil|char[ps]?|check_ptrtag|chr|clear_sentry|clearsym|closurep?|cmatrixp?|cols?|colcat(?:map)?|colmap|colrev|colvector(?:p|seq)?|complex(?:_float_(?:matrix|pointer)|_matrix(?:_view)?|_pointer|p)?|conj|cookedp?|cst|cstring(?:_(?:dup|list|vector))?|curry3?|cyclen?|del_(?:constdef|fundef|interface|macdef|typedef|vardef)|delete|diag(?:mat)?|dim|dmatrixp?|do|double(?:_matrix(?:_view)?|_pointer|p)?|dowith3?|drop|dropwhile|eval(?:cmd)?|exactp|filter|fix|fixity|flip|float(?:_matrix|_pointer)|floor|fold[lr]1?|frac|free|funp?|functionp?|gcd|get(?:_(?:byte|constdef|double|float|fundef|int(?:64)?|interface(?:_typedef)?|long|macdef|pointer|ptrtag|short|sentry|string|typedef|vardef))?|globsym|hash|head|id|im|imatrixp?|index|inexactp|infp|init|insert|int(?:_matrix(?:_view)?|_pointer|p)?|int64_(?:matrix|pointer)|integerp?|iteraten?|iterwhile|join|keys?|lambdap?|last(?:err(?:pos)?)?|lcd|list[2p]?|listmap|make_ptrtag|malloc|map|matcat|matrixp?|max|member|min|nanp|nargs|nmatrixp?|null|numberp?|ord|pack(?:ed)?|pointer(?:_cast|_tag|_type|p)?|pow|pred|ptrtag|put(?:_(?:byte|double|float|int(?:64)?|long|pointer|short|string))?|rationalp?|re|realp?|realloc|recordp?|redim|reduce(?:_with)?|refp?|repeatn?|reverse|rlistp?|round|rows?|rowcat(?:map)?|rowmap|rowrev|rowvector(?:p|seq)?|same|scan[lr]1?|sentry|sgn|short_(?:matrix|pointer)|slice|smatrixp?|sort|split|str|strcat|stream|stride|string(?:_(?:dup|list|vector)|p)?|subdiag(?:mat)?|submat|subseq2?|substr|succ|supdiag(?:mat)?|symbolp?|tail|take|takewhile|thunkp?|transpose|trunc|tuplep?|typep|ubyte|uint(?:64)?|ulong|uncurry3?|unref|unzip3?|update|ushort|vals?|varp?|vector(?:p|seq)?|void|zip3?|zipwith3?)\b/,special:{pattern:/\b__[a-z]+__\b/i,alias:"builtin"},operator:/(?=\b_|[^_])[!"#$%&'*+,\-.\/:<=>?@\\^_`|~\u00a1-\u00bf\u00d7-\u00f7\u20d0-\u2bff]+|\b(?:and|div|mod|not|or)\b/,punctuation:/[(){}\[\];,|]/};var t=["c",{lang:"c++",alias:"cpp"},"fortran","ats","dsp"],a="%< *-\\*- *{lang}\\d* *-\\*-[\\s\\S]+?%>";t.forEach(function(t){var r=t;if("string"!=typeof t&&(r=t.alias,t=t.lang),e.languages[r]){var i={};i["inline-lang-"+r]={pattern:RegExp(a.replace("{lang}",t.replace(/([.+*?\/\\(){}\[\]])/g,"\\$1")),"i"),inside:e.util.clone(e.languages.pure["inline-lang"].inside)},i["inline-lang-"+r].inside.rest=e.util.clone(e.languages[r]),e.languages.insertBefore("pure","inline-lang",i)}}),e.languages.c&&(e.languages.pure["inline-lang"].inside.rest=e.util.clone(e.languages.c))}(Prism);
Prism.languages.python={"triple-quoted-string":{pattern:/"""[\s\S]+?"""|'''[\s\S]+?'''/,alias:"string"},comment:{pattern:/(^|[^\\])#.*/,lookbehind:!0},string:{pattern:/("|')(?:\\\\|\\?[^\\\r\n])*?\1/,greedy:!0},"function":{pattern:/((?:^|\s)def[ \t]+)[a-zA-Z_][a-zA-Z0-9_]*(?=\()/g,lookbehind:!0},"class-name":{pattern:/(\bclass\s+)[a-z0-9_]+/i,lookbehind:!0},keyword:/\b(?:as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\b/,"boolean":/\b(?:True|False)\b/,number:/\b-?(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i,operator:/[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:or|and|not)\b/,punctuation:/[{}[\];(),.:]/};
Prism.languages.q={string:/"(?:\\.|[^"\\\r\n])*"/,comment:[{pattern:/([\t )\]}])\/.*/,lookbehind:!0},{pattern:/(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,lookbehind:!0},/^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,/^#!.+/m],symbol:/`(?::\S+|[\w.]*)/,datetime:{pattern:/0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,alias:"number"},number:/\b-?(?![01]:)(?:0[wn]|0W[hj]?|0N[hje]?|0x[\da-fA-F]+|\d+\.?\d*(?:e[+-]?\d+)?[hjfeb]?)/,keyword:/\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,adverb:{pattern:/['\/\\]:?|\beach\b/,alias:"function"},verb:{pattern:/(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?_~=|$&#@^]):?/,alias:"operator"},punctuation:/[(){}\[\];.]/};
Prism.languages.qore=Prism.languages.extend("clike",{comment:{pattern:/(^|[^\\])(?:\/\*[\w\W]*?\*\/|(?:\/\/|#).*)/,lookbehind:!0},string:/("|')(\\(?:\r\n|[\s\S])|(?!\1)[^\\])*\1/,variable:/\$(?!\d)\w+\b/,keyword:/\b(?:abstract|any|assert|binary|bool|boolean|break|byte|case|catch|char|class|code|const|continue|data|default|do|double|else|enum|extends|final|finally|float|for|goto|hash|if|implements|import|inherits|instanceof|int|interface|long|my|native|new|nothing|null|object|our|own|private|reference|rethrow|return|short|soft(?:int|float|number|bool|string|date|list)|static|strictfp|string|sub|super|switch|synchronized|this|throw|throws|transient|try|void|volatile|while)\b/,number:/\b(?:0b[01]+|0x[\da-f]*\.?[\da-fp\-]+|\d*\.?\d+e?\d*[df]|\d*\.?\d+)\b/i,"boolean":/\b(?:true|false)\b/i,operator:{pattern:/(^|[^\.])(?:\+[+=]?|-[-=]?|[!=](?:==?|~)?|>>?=?|<(?:=>?|<=?)?|&[&=]?|\|[|=]?|[*\/%^]=?|[~?])/,lookbehind:!0},"function":/\$?\b(?!\d)\w+(?=\()/});
Prism.languages.r={comment:/#.*/,string:/(['"])(?:\\?.)*?\1/,"percent-operator":{pattern:/%[^%\s]*%/,alias:"operator"},"boolean":/\b(?:TRUE|FALSE)\b/,ellipsis:/\.\.(?:\.|\d+)/,number:[/\b(?:NaN|Inf)\b/,/\b(?:0x[\dA-Fa-f]+(?:\.\d*)?|\d*\.?\d+)(?:[EePp][+-]?\d+)?[iL]?\b/],keyword:/\b(?:if|else|repeat|while|function|for|in|next|break|NULL|NA|NA_integer_|NA_real_|NA_complex_|NA_character_)\b/,operator:/->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,punctuation:/[(){}\[\],;]/};
!function(a){var e=a.util.clone(a.languages.javascript);a.languages.jsx=a.languages.extend("markup",e),a.languages.jsx.tag.pattern=/<\/?[\w\.:-]+\s*(?:\s+[\w\.:-]+(?:=(?:("|')(\\?[\w\W])*?\1|[^\s'">=]+|(\{[\w\W]*?\})))?\s*)*\/?>/i,a.languages.jsx.tag.inside["attr-value"].pattern=/=[^\{](?:('|")[\w\W]*?(\1)|[^\s>]+)/i;var s=a.util.clone(a.languages.jsx);delete s.punctuation,s=a.languages.insertBefore("jsx","operator",{punctuation:/=(?={)|[{}[\];(),.:]/},{jsx:s}),a.languages.insertBefore("inside","attr-value",{script:{pattern:/=(\{(?:\{[^}]*\}|[^}])+\})/i,inside:s,alias:"language-javascript"}},a.languages.jsx.tag)}(Prism);
Prism.languages.rest={table:[{pattern:/(\s*)(?:\+[=-]+)+\+(?:\r?\n|\r)(?:\1(?:[+|].+)+[+|](?:\r?\n|\r))+\1(?:\+[=-]+)+\+/,lookbehind:!0,inside:{punctuation:/\||(?:\+[=-]+)+\+/}},{pattern:/(\s*)(?:=+ +)+=+((?:\r?\n|\r)\1.+)+(?:\r?\n|\r)\1(?:=+ +)+=+(?=(?:\r?\n|\r){2}|\s*$)/,lookbehind:!0,inside:{punctuation:/[=-]+/}}],"substitution-def":{pattern:/(^\s*\.\. )\|(?:[^|\s](?:[^|]*[^|\s])?)\| [^:]+::/m,lookbehind:!0,inside:{substitution:{pattern:/^\|(?:[^|\s]|[^|\s][^|]*[^|\s])\|/,alias:"attr-value",inside:{punctuation:/^\||\|$/}},directive:{pattern:/( +)[^:]+::/,lookbehind:!0,alias:"function",inside:{punctuation:/::$/}}}},"link-target":[{pattern:/(^\s*\.\. )\[[^\]]+\]/m,lookbehind:!0,alias:"string",inside:{punctuation:/^\[|\]$/}},{pattern:/(^\s*\.\. )_(?:`[^`]+`|(?:[^:\\]|\\.)+):/m,lookbehind:!0,alias:"string",inside:{punctuation:/^_|:$/}}],directive:{pattern:/(^\s*\.\. )[^:]+::/m,lookbehind:!0,alias:"function",inside:{punctuation:/::$/}},comment:{pattern:/(^\s*\.\.)(?:(?: .+)?(?:(?:\r?\n|\r).+)+| .+)(?=(?:\r?\n|\r){2}|$)/m,lookbehind:!0},title:[{pattern:/^(([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+)(?:\r?\n|\r).+(?:\r?\n|\r)\1$/m,inside:{punctuation:/^[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+|[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,important:/.+/}},{pattern:/(^|(?:\r?\n|\r){2}).+(?:\r?\n|\r)([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+(?=\r?\n|\r|$)/,lookbehind:!0,inside:{punctuation:/[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,important:/.+/}}],hr:{pattern:/((?:\r?\n|\r){2})([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2{3,}(?=(?:\r?\n|\r){2})/,lookbehind:!0,alias:"punctuation"},field:{pattern:/(^\s*):[^:\r\n]+:(?= )/m,lookbehind:!0,alias:"attr-name"},"command-line-option":{pattern:/(^\s*)(?:[+-][a-z\d]|(?:\-\-|\/)[a-z\d-]+)(?:[ =](?:[a-z][a-z\d_-]*|<[^<>]+>))?(?:, (?:[+-][a-z\d]|(?:\-\-|\/)[a-z\d-]+)(?:[ =](?:[a-z][a-z\d_-]*|<[^<>]+>))?)*(?=(?:\r?\n|\r)? {2,}\S)/im,lookbehind:!0,alias:"symbol"},"literal-block":{pattern:/::(?:\r?\n|\r){2}([ \t]+).+(?:(?:\r?\n|\r)\1.+)*/,inside:{"literal-block-punctuation":{pattern:/^::/,alias:"punctuation"}}},"quoted-literal-block":{pattern:/::(?:\r?\n|\r){2}([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]).*(?:(?:\r?\n|\r)\1.*)*/,inside:{"literal-block-punctuation":{pattern:/^(?:::|([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\1*)/m,alias:"punctuation"}}},"list-bullet":{pattern:/(^\s*)(?:[*+\-]|\(?(?:\d+|[a-z]|[ivxdclm]+)\)|(?:\d+|[a-z]|[ivxdclm]+)\.)(?= )/im,lookbehind:!0,alias:"punctuation"},"doctest-block":{pattern:/(^\s*)>>> .+(?:(?:\r?\n|\r).+)*/m,lookbehind:!0,inside:{punctuation:/^>>>/}},inline:[{pattern:/(^|[\s\-:\/'"<(\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\*\*?|``?|\|)(?!\s).*?[^\s]\2(?=[\s\-.,:;!?\\\/'")\]}]|$))/m,lookbehind:!0,inside:{bold:{pattern:/(^\*\*).+(?=\*\*$)/,lookbehind:!0},italic:{pattern:/(^\*).+(?=\*$)/,lookbehind:!0},"inline-literal":{pattern:/(^``).+(?=``$)/,lookbehind:!0,alias:"symbol"},role:{pattern:/^:[^:]+:|:[^:]+:$/,alias:"function",inside:{punctuation:/^:|:$/}},"interpreted-text":{pattern:/(^`).+(?=`$)/,lookbehind:!0,alias:"attr-value"},substitution:{pattern:/(^\|).+(?=\|$)/,lookbehind:!0,alias:"attr-value"},punctuation:/\*\*?|``?|\|/}}],link:[{pattern:/\[[^\]]+\]_(?=[\s\-.,:;!?\\\/'")\]}]|$)/,alias:"string",inside:{punctuation:/^\[|\]_$/}},{pattern:/(?:\b[a-z\d](?:[_.:+]?[a-z\d]+)*_?_|`[^`]+`_?_|_`[^`]+`)(?=[\s\-.,:;!?\\\/'")\]}]|$)/i,alias:"string",inside:{punctuation:/^_?`|`$|`?_?_$/}}],punctuation:{pattern:/(^\s*)(?:\|(?= |$)|(?:---?||\.\.|__)(?= )|\.\.$)/m,lookbehind:!0}};
Prism.languages.rip={comment:/#.*/,keyword:/(?:=>|->)|\b(?:class|if|else|switch|case|return|exit|try|catch|finally|raise)\b/,builtin:/@|\bSystem\b/,"boolean":/\b(?:true|false)\b/,date:/\b\d{4}-\d{2}-\d{2}\b/,time:/\b\d{2}:\d{2}:\d{2}\b/,datetime:/\b\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\b/,character:/\B`[^\s`'",.:;#\/\\()<>\[\]{}]\b/,regex:{pattern:/(^|[^\/])\/(?!\/)(\[.+?]|\\.|[^\/\\\r\n])+\/(?=\s*($|[\r\n,.;})]))/,lookbehind:!0},symbol:/:[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/,string:/("|')(\\?.)*?\1/,number:/[+-]?(?:(?:\d+\.\d+)|(?:\d+))/,punctuation:/(?:\.{2,3})|[`,.:;=\/\\()<>\[\]{}]/,reference:/[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/};
Prism.languages.roboconf={comment:/#.*/,keyword:{pattern:/(^|\s)(?:(?:facet|instance of)(?=[ \t]+[\w-]+[ \t]*\{)|(?:external|import)\b)/,lookbehind:!0},component:{pattern:/[\w-]+(?=[ \t]*\{)/,alias:"variable"},property:/[\w.-]+(?=[ \t]*:)/,value:{pattern:/(=[ \t]*)[^,;]+/,lookbehind:!0,alias:"attr-value"},optional:{pattern:/\(optional\)/,alias:"builtin"},wildcard:{pattern:/(\.)\*/,lookbehind:!0,alias:"operator"},punctuation:/[{},.;:=]/};
!function(e){e.languages.crystal=e.languages.extend("ruby",{keyword:[/\b(?:abstract|alias|as|asm|begin|break|case|class|def|do|else|elsif|end|ensure|enum|extend|for|fun|if|ifdef|include|instance_sizeof|lib|macro|module|next|of|out|pointerof|private|protected|rescue|return|require|self|sizeof|struct|super|then|type|typeof|union|unless|until|when|while|with|yield|__DIR__|__FILE__|__LINE__)\b/,{pattern:/(\.\s*)(?:is_a|responds_to)\?/,lookbehind:!0}],number:/\b(?:0b[01_]*[01]|0o[0-7_]*[0-7]|0x[0-9a-fA-F_]*[0-9a-fA-F]|(?:[0-9](?:[0-9_]*[0-9])?)(?:\.[0-9_]*[0-9])?(?:[eE][+-]?[0-9_]*[0-9])?)(?:_(?:[uif](?:8|16|32|64))?)?\b/});var t=e.util.clone(e.languages.crystal);e.languages.insertBefore("crystal","string",{attribute:{pattern:/@\[.+?\]/,alias:"attr-name",inside:{delimiter:{pattern:/^@\[|\]$/,alias:"tag"},rest:t}},expansion:[{pattern:/\{\{.+?\}\}/,inside:{delimiter:{pattern:/^\{\{|\}\}$/,alias:"tag"},rest:t}},{pattern:/\{%.+?%\}/,inside:{delimiter:{pattern:/^\{%|%\}$/,alias:"tag"},rest:t}}]})}(Prism);
Prism.languages.rust={comment:[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0}],string:[/b?r(#*)"(?:\\?.)*?"\1/,/b?("|')(?:\\?.)*?\1/],keyword:/\b(?:abstract|alignof|as|be|box|break|const|continue|crate|do|else|enum|extern|false|final|fn|for|if|impl|in|let|loop|match|mod|move|mut|offsetof|once|override|priv|pub|pure|ref|return|sizeof|static|self|struct|super|true|trait|type|typeof|unsafe|unsized|use|virtual|where|while|yield)\b/,attribute:{pattern:/#!?\[.+?\]/,alias:"attr-name"},"function":[/[a-z0-9_]+(?=\s*\()/i,/[a-z0-9_]+!(?=\s*\(|\[)/i],"macro-rules":{pattern:/[a-z0-9_]+!/i,alias:"function"},number:/\b-?(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(\d(_?\d)*)?\.?\d(_?\d)*([Ee][+-]?\d+)?)(?:_?(?:[iu](?:8|16|32|64)?|f32|f64))?\b/,"closure-params":{pattern:/\|[^|]*\|(?=\s*[{-])/,inside:{punctuation:/[\|:,]/,operator:/[&*]/}},punctuation:/[{}[\];(),:]|\.+|->/,operator:/[-+*\/%!^=]=?|@|&[&=]?|\|[|=]?|<<?=?|>>?=?/};
Prism.languages.sas={datalines:{pattern:/^\s*(?:(?:data)?lines|cards);[\s\S]+?(?:\r?\n|\r);/im,alias:"string",inside:{keyword:{pattern:/^(\s*)(?:(?:data)?lines|cards)/i,lookbehind:!0},punctuation:/;/}},comment:[{pattern:/(^\s*|;\s*)\*.*;/m,lookbehind:!0},/\/\*[\s\S]+?\*\//],datetime:{pattern:/'[^']+'(?:dt?|t)\b/i,alias:"number"},string:/(["'])(?:\1\1|(?!\1)[\s\S])*\1/,keyword:/\b(?:data|else|format|if|input|proc\s\w+|quit|run|then)\b/i,number:/(?:\B-|\b)(?:[\da-f]+x|\d+(?:\.\d+)?(?:e[+-]?\d+)?)/i,operator:/\*\*?|\|\|?|!!?|?|<[>=]?|>[<=]?|[-+\/=&]|[~^]=?|\b(?:eq|ne|gt|lt|ge|le|in|not)\b/i,punctuation:/[$%@.(){}\[\];,\\]/};
!function(e){e.languages.sass=e.languages.extend("css",{comment:{pattern:/^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t]+.+)*/m,lookbehind:!0}}),e.languages.insertBefore("sass","atrule",{"atrule-line":{pattern:/^(?:[ \t]*)[@+=].+/m,inside:{atrule:/(?:@[\w-]+|[+=])/m}}}),delete e.languages.sass.atrule;var a=/((\$[-_\w]+)|(#\{\$[-_\w]+\}))/i,t=[/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|or|not)\b/,{pattern:/(\s+)-(?=\s)/,lookbehind:!0}];e.languages.insertBefore("sass","property",{"variable-line":{pattern:/^[ \t]*\$.+/m,inside:{punctuation:/:/,variable:a,operator:t}},"property-line":{pattern:/^[ \t]*(?:[^:\s]+ *:.*|:[^:\s]+.*)/m,inside:{property:[/[^:\s]+(?=\s*:)/,{pattern:/(:)[^:\s]+/,lookbehind:!0}],punctuation:/:/,variable:a,operator:t,important:e.languages.sass.important}}}),delete e.languages.sass.property,delete e.languages.sass.important,delete e.languages.sass.selector,e.languages.insertBefore("sass","punctuation",{selector:{pattern:/([ \t]*)\S(?:,?[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,?[^,\r\n]+)*)*/,lookbehind:!0}})}(Prism);
Prism.languages.scss=Prism.languages.extend("css",{comment:{pattern:/(^|[^\\])(?:\/\*[\w\W]*?\*\/|\/\/.*)/,lookbehind:!0},atrule:{pattern:/@[\w-]+(?:\([^()]+\)|[^(])*?(?=\s+[{;])/,inside:{rule:/@[\w-]+/}},url:/(?:[-a-z]+-)*url(?=\()/i,selector:{pattern:/(?=\S)[^@;\{\}\(\)]?([^@;\{\}\(\)]|&|#\{\$[-_\w]+\})+(?=\s*\{(\}|\s|[^\}]+(:|\{)[^\}]+))/m,inside:{parent:{pattern:/&/,alias:"important"},placeholder:/%[-_\w]+/,variable:/\$[-_\w]+|#\{\$[-_\w]+\}/}}}),Prism.languages.insertBefore("scss","atrule",{keyword:[/@(?:if|else(?: if)?|for|each|while|import|extend|debug|warn|mixin|include|function|return|content)/i,{pattern:/( +)(?:from|through)(?= )/,lookbehind:!0}]}),Prism.languages.scss.property={pattern:/(?:[\w-]|\$[-_\w]+|#\{\$[-_\w]+\})+(?=\s*:)/i,inside:{variable:/\$[-_\w]+|#\{\$[-_\w]+\}/}},Prism.languages.insertBefore("scss","important",{variable:/\$[-_\w]+|#\{\$[-_\w]+\}/}),Prism.languages.insertBefore("scss","function",{placeholder:{pattern:/%[-_\w]+/,alias:"selector"},statement:{pattern:/\B!(?:default|optional)\b/i,alias:"keyword"},"boolean":/\b(?:true|false)\b/,"null":/\bnull\b/,operator:{pattern:/(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|or|not)(?=\s)/,lookbehind:!0}}),Prism.languages.scss.atrule.inside.rest=Prism.util.clone(Prism.languages.scss);
Prism.languages.scala=Prism.languages.extend("java",{keyword:/<-|=>|\b(?:abstract|case|catch|class|def|do|else|extends|final|finally|for|forSome|if|implicit|import|lazy|match|new|null|object|override|package|private|protected|return|sealed|self|super|this|throw|trait|try|type|val|var|while|with|yield)\b/,string:[{pattern:/"""[\W\w]*?"""/,greedy:!0},{pattern:/("|')(?:\\\\|\\?[^\\\r\n])*?\1/,greedy:!0}],builtin:/\b(?:String|Int|Long|Short|Byte|Boolean|Double|Float|Char|Any|AnyRef|AnyVal|Unit|Nothing)\b/,number:/\b(?:0x[\da-f]*\.?[\da-f]+|\d*\.?\d+e?\d*[dfl]?)\b/i,symbol:/'[^\d\s\\]\w*/}),delete Prism.languages.scala["class-name"],delete Prism.languages.scala["function"];
Prism.languages.scheme={comment:/;.*/,string:/"(?:[^"\\\r\n]|\\.)*?"|'[^('\s]*/,keyword:{pattern:/(\()(?:define(?:-syntax|-library|-values)?|(?:case-)?lambda|let(?:\*|rec)?(?:-values)?|else|if|cond|begin|delay(?:-force)?|parameterize|guard|set!|(?:quasi-)?quote|syntax-rules)/,lookbehind:!0},builtin:{pattern:/(\()(?:(?:cons|car|cdr|list|call-with-current-continuation|call\/cc|append|abs|apply|eval)\b|null\?|pair\?|boolean\?|eof-object\?|char\?|procedure\?|number\?|port\?|string\?|vector\?|symbol\?|bytevector\?)/,lookbehind:!0},number:{pattern:/(\s|\))[-+]?[0-9]*\.?[0-9]+(?:\s*[-+]\s*[0-9]*\.?[0-9]+i)?\b/,lookbehind:!0},"boolean":/#[tf]/,operator:{pattern:/(\()(?:[-+*%\/]|[<>]=?|=>?)/,lookbehind:!0},"function":{pattern:/(\()[^\s()]*(?=\s)/,lookbehind:!0},punctuation:/[()]/};
Prism.languages.smalltalk={comment:/"(?:""|[^"])+"/,string:/'(?:''|[^'])+'/,symbol:/#[\da-z]+|#(?:-|([+\/\\*~<>=@%|&?!])\1?)|#(?=\()/i,"block-arguments":{pattern:/(\[\s*):[^\[|]*?\|/,lookbehind:!0,inside:{variable:/:[\da-z]+/i,punctuation:/\|/}},"temporary-variables":{pattern:/\|[^|]+\|/,inside:{variable:/[\da-z]+/i,punctuation:/\|/}},keyword:/\b(?:nil|true|false|self|super|new)\b/,character:{pattern:/\$./,alias:"string"},number:[/\d+r-?[\dA-Z]+(?:\.[\dA-Z]+)?(?:e-?\d+)?/,/(?:\B-|\b)\d+(?:\.\d+)?(?:e-?\d+)?/],operator:/[<=]=?|:=|~[~=]|\/\/?|\\\\|>[>=]?|[!^+\-*&|,@]/,punctuation:/[.;:?\[\](){}]/};
!function(e){var t=/\{\*[\w\W]+?\*\}|\{[\w\W]+?\}/g,a="{literal}",n="{/literal}",r=!1;e.languages.smarty=e.languages.extend("markup",{smarty:{pattern:t,inside:{delimiter:{pattern:/^\{|\}$/i,alias:"punctuation"},string:/(["'])(?:\\?.)*?\1/,number:/\b-?(?:0x[\dA-Fa-f]+|\d*\.?\d+(?:[Ee][-+]?\d+)?)\b/,variable:[/\$(?!\d)\w+/,/#(?!\d)\w+#/,{pattern:/(\.|->)(?!\d)\w+/,lookbehind:!0},{pattern:/(\[)(?!\d)\w+(?=\])/,lookbehind:!0}],"function":[{pattern:/(\|\s*)@?(?!\d)\w+/,lookbehind:!0},/^\/?(?!\d)\w+/,/(?!\d)\w+(?=\()/],"attr-name":{pattern:/\w+\s*=\s*(?:(?!\d)\w+)?/,inside:{variable:{pattern:/(=\s*)(?!\d)\w+/,lookbehind:!0},operator:/=/}},punctuation:[/[\[\]().,:`]|\->/],operator:[/[+\-*\/%]|==?=?|[!<>]=?|&&|\|\|?/,/\bis\s+(?:not\s+)?(?:div|even|odd)(?:\s+by)?\b/,/\b(?:eq|neq?|gt|lt|gt?e|lt?e|not|mod|or|and)\b/],keyword:/\b(?:false|off|on|no|true|yes)\b/}}}),e.languages.insertBefore("smarty","tag",{"smarty-comment":{pattern:/\{\*[\w\W]*?\*\}/,alias:["smarty","comment"]}}),e.hooks.add("before-highlight",function(e){"smarty"===e.language&&(e.tokenStack=[],e.code=e.code.replace(t,function(t){return t===n&&(r=!1),r?t:(t===a&&(r=!0),e.tokenStack.push(t),"___SMARTY"+e.tokenStack.length+"___")}))}),e.hooks.add("after-highlight",function(t){if("smarty"===t.language){for(var a,n=0;a=t.tokenStack[n];n++)t.highlightedCode=t.highlightedCode.replace("___SMARTY"+(n+1)+"___",e.highlight(a,t.grammar,"smarty").replace(/\$/g,"$$$$"));t.element.innerHTML=t.highlightedCode}})}(Prism);
Prism.languages.sql={comment:{pattern:/(^|[^\\])(?:\/\*[\w\W]*?\*\/|(?:--|\/\/|#).*)/,lookbehind:!0},string:{pattern:/(^|[^@\\])("|')(?:\\?[\s\S])*?\2/,lookbehind:!0},variable:/@[\w.$]+|@("|'|`)(?:\\?[\s\S])+?\1/,"function":/\b(?:COUNT|SUM|AVG|MIN|MAX|FIRST|LAST|UCASE|LCASE|MID|LEN|ROUND|NOW|FORMAT)(?=\s*\()/i,keyword:/\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR VARYING|CHARACTER (?:SET|VARYING)|CHARSET|CHECK|CHECKPOINT|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMN|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS|CONTAINSTABLE|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|DATA(?:BASES?)?|DATE(?:TIME)?|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITER(?:S)?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE(?: PRECISION)?|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE KEY|ELSE|ENABLE|ENCLOSED BY|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPE(?:D BY)?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTO|INVOKER|ISOLATION LEVEL|JOIN|KEYS?|KILL|LANGUAGE SQL|LAST|LEFT|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MODIFIES SQL DATA|MODIFY|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL(?: CHAR VARYING| CHARACTER(?: VARYING)?| VARCHAR)?|NATURAL|NCHAR(?: VARCHAR)?|NEXT|NO(?: SQL|CHECK|CYCLE)?|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READ(?:S SQL DATA|TEXT)?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEATABLE|REPLICATION|REQUIRE|RESTORE|RESTRICT|RETURNS?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE MODE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|START(?:ING BY)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED BY|TEXT(?:SIZE)?|THEN|TIMESTAMP|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNPIVOT|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?)\b/i,"boolean":/\b(?:TRUE|FALSE|NULL)\b/i,number:/\b-?(?:0x)?\d*\.?[\da-f]+\b/,operator:/[-+*\/=%^~]|&&?|\|?\||!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|IN|LIKE|NOT|OR|IS|DIV|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,punctuation:/[;[\]()`,.]/};
!function(n){var t={url:/url\((["']?).*?\1\)/i,string:/("|')(?:[^\\\r\n]|\\(?:\r\n|[\s\S]))*?\1/,interpolation:null,func:null,important:/\B!(?:important|optional)\b/i,keyword:{pattern:/(^|\s+)(?:(?:if|else|for|return|unless)(?=\s+|$)|@[\w-]+)/,lookbehind:!0},hexcode:/#[\da-f]{3,6}/i,number:/\b\d+(?:\.\d+)?%?/,"boolean":/\b(?:true|false)\b/,operator:[/~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.+|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/],punctuation:/[{}()\[\];:,]/};t.interpolation={pattern:/\{[^\r\n}:]+\}/,alias:"variable",inside:n.util.clone(t)},t.func={pattern:/[\w-]+\([^)]*\).*/,inside:{"function":/^[^(]+/,rest:n.util.clone(t)}},n.languages.stylus={comment:{pattern:/(^|[^\\])(\/\*[\w\W]*?\*\/|\/\/.*)/,lookbehind:!0},"atrule-declaration":{pattern:/(^\s*)@.+/m,lookbehind:!0,inside:{atrule:/^@[\w-]+/,rest:t}},"variable-declaration":{pattern:/(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:(?:\{[^}]*\}|.+)|$)/m,lookbehind:!0,inside:{variable:/^\S+/,rest:t}},statement:{pattern:/(^[ \t]*)(?:if|else|for|return|unless)[ \t]+.+/m,lookbehind:!0,inside:{keyword:/^\S+/,rest:t}},"property-declaration":{pattern:/((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)[^{\r\n]*(?:;|[^{\r\n,](?=$)(?!(\r?\n|\r)(?:\{|\2[ \t]+)))/m,lookbehind:!0,inside:{property:{pattern:/^[^\s:]+/,inside:{interpolation:t.interpolation}},rest:t}},selector:{pattern:/(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\))?|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\))?|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t]+)))/m,lookbehind:!0,inside:{interpolation:t.interpolation,punctuation:/[{},]/}},func:t.func,string:t.string,interpolation:t.interpolation,punctuation:/[{}()\[\];:.]/}}(Prism);
Prism.languages.swift=Prism.languages.extend("clike",{string:{pattern:/("|')(\\(?:\((?:[^()]|\([^)]+\))+\)|\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0,inside:{interpolation:{pattern:/\\\((?:[^()]|\([^)]+\))+\)/,inside:{delimiter:{pattern:/^\\\(|\)$/,alias:"variable"}}}}},keyword:/\b(as|associativity|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic(?:Type)?|else|enum|extension|fallthrough|final|for|func|get|guard|if|import|in|infix|init|inout|internal|is|lazy|left|let|mutating|new|none|nonmutating|operator|optional|override|postfix|precedence|prefix|private|Protocol|public|repeat|required|rethrows|return|right|safe|self|Self|set|static|struct|subscript|super|switch|throws?|try|Type|typealias|unowned|unsafe|var|weak|where|while|willSet|__(?:COLUMN__|FILE__|FUNCTION__|LINE__))\b/,number:/\b([\d_]+(\.[\de_]+)?|0x[a-f0-9_]+(\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,constant:/\b(nil|[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,atrule:/@\b(IB(?:Outlet|Designable|Action|Inspectable)|class_protocol|exported|noreturn|NS(?:Copying|Managed)|objc|UIApplicationMain|auto_closure)\b/,builtin:/\b([A-Z]\S+|abs|advance|alignof(?:Value)?|assert|contains|count(?:Elements)?|debugPrint(?:ln)?|distance|drop(?:First|Last)|dump|enumerate|equal|filter|find|first|getVaList|indices|isEmpty|join|last|lexicographicalCompare|map|max(?:Element)?|min(?:Element)?|numericCast|overlaps|partition|print(?:ln)?|reduce|reflect|reverse|sizeof(?:Value)?|sort(?:ed)?|split|startsWith|stride(?:of(?:Value)?)?|suffix|swap|toDebugString|toString|transcode|underestimateCount|unsafeBitCast|with(?:ExtendedLifetime|Unsafe(?:MutablePointers?|Pointers?)|VaList))\b/}),Prism.languages.swift.string.inside.interpolation.inside.rest=Prism.util.clone(Prism.languages.swift);
Prism.languages.tcl={comment:{pattern:/(^|[^\\])#.*/,lookbehind:!0},string:/"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"/,variable:[{pattern:/(\$)(?:::)?(?:[a-zA-Z0-9]+::)*[a-zA-Z0-9_]+/,lookbehind:!0},{pattern:/(\$){[^}]+}/,lookbehind:!0},{pattern:/(^\s*set[ \t]+)(?:::)?(?:[a-zA-Z0-9]+::)*[a-zA-Z0-9_]+/m,lookbehind:!0}],"function":{pattern:/(^\s*proc[ \t]+)[^\s]+/m,lookbehind:!0},builtin:[{pattern:/(^\s*)(?:proc|return|class|error|eval|exit|for|foreach|if|switch|while|break|continue)\b/m,lookbehind:!0},/\b(elseif|else)\b/],scope:{pattern:/(^\s*)(global|upvar|variable)\b/m,lookbehind:!0,alias:"constant"},keyword:{pattern:/(^\s*|\[)(after|append|apply|array|auto_(?:execok|import|load|mkindex|qualify|reset)|automkindex_old|bgerror|binary|catch|cd|chan|clock|close|concat|dde|dict|encoding|eof|exec|expr|fblocked|fconfigure|fcopy|file(?:event|name)?|flush|gets|glob|history|http|incr|info|interp|join|lappend|lassign|lindex|linsert|list|llength|load|lrange|lrepeat|lreplace|lreverse|lsearch|lset|lsort|math(?:func|op)|memory|msgcat|namespace|open|package|parray|pid|pkg_mkIndex|platform|puts|pwd|re_syntax|read|refchan|regexp|registry|regsub|rename|Safe_Base|scan|seek|set|socket|source|split|string|subst|Tcl|tcl(?:_endOfWord|_findLibrary|startOf(?:Next|Previous)Word|wordBreak(?:After|Before)|test|vars)|tell|time|tm|trace|unknown|unload|unset|update|uplevel|vwait)\b/m,lookbehind:!0},operator:/!=?|\*\*?|==|&&?|\|\|?|<[=<]?|>[=>]?|[-+~\/%?^]|\b(?:eq|ne|in|ni)\b/,punctuation:/[{}()\[\]]/};
!function(e){var i="(?:\\([^|)]+\\)|\\[[^\\]]+\\]|\\{[^}]+\\})+",n={css:{pattern:/\{[^}]+\}/,inside:{rest:e.languages.css}},"class-id":{pattern:/(\()[^)]+(?=\))/,lookbehind:!0,alias:"attr-value"},lang:{pattern:/(\[)[^\]]+(?=\])/,lookbehind:!0,alias:"attr-value"},punctuation:/[\\\/]\d+|\S/};e.languages.textile=e.languages.extend("markup",{phrase:{pattern:/(^|\r|\n)\S[\s\S]*?(?=$|\r?\n\r?\n|\r\r)/,lookbehind:!0,inside:{"block-tag":{pattern:RegExp("^[a-z]\\w*(?:"+i+"|[<>=()])*\\."),inside:{modifier:{pattern:RegExp("(^[a-z]\\w*)(?:"+i+"|[<>=()])+(?=\\.)"),lookbehind:!0,inside:e.util.clone(n)},tag:/^[a-z]\w*/,punctuation:/\.$/}},list:{pattern:RegExp("^[*#]+(?:"+i+")?\\s+.+","m"),inside:{modifier:{pattern:RegExp("(^[*#]+)"+i),lookbehind:!0,inside:e.util.clone(n)},punctuation:/^[*#]+/}},table:{pattern:RegExp("^(?:(?:"+i+"|[<>=()^~])+\\.\\s*)?(?:\\|(?:(?:"+i+"|[<>=()^~_]|[\\\\/]\\d+)+\\.)?[^|]*)+\\|","m"),inside:{modifier:{pattern:RegExp("(^|\\|(?:\\r?\\n|\\r)?)(?:"+i+"|[<>=()^~_]|[\\\\/]\\d+)+(?=\\.)"),lookbehind:!0,inside:e.util.clone(n)},punctuation:/\||^\./}},inline:{pattern:RegExp("(\\*\\*|__|\\?\\?|[*_%@+\\-^~])(?:"+i+")?.+?\\1"),inside:{bold:{pattern:RegExp("((^\\*\\*?)(?:"+i+")?).+?(?=\\2)"),lookbehind:!0},italic:{pattern:RegExp("((^__?)(?:"+i+")?).+?(?=\\2)"),lookbehind:!0},cite:{pattern:RegExp("(^\\?\\?(?:"+i+")?).+?(?=\\?\\?)"),lookbehind:!0,alias:"string"},code:{pattern:RegExp("(^@(?:"+i+")?).+?(?=@)"),lookbehind:!0,alias:"keyword"},inserted:{pattern:RegExp("(^\\+(?:"+i+")?).+?(?=\\+)"),lookbehind:!0},deleted:{pattern:RegExp("(^-(?:"+i+")?).+?(?=-)"),lookbehind:!0},span:{pattern:RegExp("(^%(?:"+i+")?).+?(?=%)"),lookbehind:!0},modifier:{pattern:RegExp("(^\\*\\*|__|\\?\\?|[*_%@+\\-^~])"+i),lookbehind:!0,inside:e.util.clone(n)},punctuation:/[*_%?@+\-^~]+/}},"link-ref":{pattern:/^\[[^\]]+\]\S+$/m,inside:{string:{pattern:/(\[)[^\]]+(?=\])/,lookbehind:!0},url:{pattern:/(\])\S+$/,lookbehind:!0},punctuation:/[\[\]]/}},link:{pattern:RegExp('"(?:'+i+')?[^"]+":.+?(?=[^\\w/]?(?:\\s|$))'),inside:{text:{pattern:RegExp('(^"(?:'+i+')?)[^"]+(?=")'),lookbehind:!0},modifier:{pattern:RegExp('(^")'+i),lookbehind:!0,inside:e.util.clone(n)},url:{pattern:/(:).+/,lookbehind:!0},punctuation:/[":]/}},image:{pattern:RegExp("!(?:"+i+"|[<>=()])*[^!\\s()]+(?:\\([^)]+\\))?!(?::.+?(?=[^\\w/]?(?:\\s|$)))?"),inside:{source:{pattern:RegExp("(^!(?:"+i+"|[<>=()])*)[^!\\s()]+(?:\\([^)]+\\))?(?=!)"),lookbehind:!0,alias:"url"},modifier:{pattern:RegExp("(^!)(?:"+i+"|[<>=()])+"),lookbehind:!0,inside:e.util.clone(n)},url:{pattern:/(:).+/,lookbehind:!0},punctuation:/[!:]/}},footnote:{pattern:/\b\[\d+\]/,alias:"comment",inside:{punctuation:/\[|\]/}},acronym:{pattern:/\b[A-Z\d]+\([^)]+\)/,inside:{comment:{pattern:/(\()[^)]+(?=\))/,lookbehind:!0},punctuation:/[()]/}},mark:{pattern:/\b\((TM|R|C)\)/,alias:"comment",inside:{punctuation:/[()]/}}}}});var t={inline:e.util.clone(e.languages.textile.phrase.inside.inline),link:e.util.clone(e.languages.textile.phrase.inside.link),image:e.util.clone(e.languages.textile.phrase.inside.image),footnote:e.util.clone(e.languages.textile.phrase.inside.footnote),acronym:e.util.clone(e.languages.textile.phrase.inside.acronym),mark:e.util.clone(e.languages.textile.phrase.inside.mark)};e.languages.textile.tag.pattern=/<\/?(?!\d)[a-z0-9]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,e.languages.textile.phrase.inside.inline.inside.bold.inside=t,e.languages.textile.phrase.inside.inline.inside.italic.inside=t,e.languages.textile.phrase.inside.inline.inside.inserted.inside=t,e.languages.textile.phrase.inside.inline.inside.deleted.inside=t,e.languages.textile.phrase.inside.inline.inside.span.inside=t,e.languages.textile.phrase.inside.table.inside.inline=t.inline,e.languages.textile.phrase.inside.table.inside.link=t.link,e.languages.textile.phrase.inside.table.inside.image=t.image,e.languages.textile.phrase.inside.table.inside.footnote=t.footnote,e.languages.textile.phrase.inside.table.inside.acronym=t.acronym,e.languages.textile.phrase.inside.table.inside.mark=t.mark}(Prism);
Prism.languages.twig={comment:/\{#[\s\S]*?#\}/,tag:{pattern:/\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}/,inside:{ld:{pattern:/^(?:\{\{\-?|\{%\-?\s*\w+)/,inside:{punctuation:/^(?:\{\{|\{%)\-?/,keyword:/\w+/}},rd:{pattern:/\-?(?:%\}|\}\})$/,inside:{punctuation:/.*/}},string:{pattern:/("|')(?:\\?.)*?\1/,inside:{punctuation:/^['"]|['"]$/}},keyword:/\b(?:even|if|odd)\b/,"boolean":/\b(?:true|false|null)\b/,number:/\b-?(?:0x[\dA-Fa-f]+|\d*\.?\d+([Ee][-+]?\d+)?)\b/,operator:[{pattern:/(\s)(?:and|b\-and|b\-xor|b\-or|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,lookbehind:!0},/[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/],property:/\b[a-zA-Z_][a-zA-Z0-9_]*\b/,punctuation:/[()\[\]{}:.,]/}},other:{pattern:/\S(?:[\s\S]*\S)?/,inside:Prism.languages.markup}};
Prism.languages.typescript=Prism.languages.extend("javascript",{keyword:/\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield|module|declare|constructor|string|Function|any|number|boolean|Array|enum)\b/});
Prism.languages.verilog={comment:/\/\/.*|\/\*[\w\W]*?\*\//,string:/"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,property:/\B\$\w+\b/,constant:/\B`\w+\b/,"function":/[a-z\d_]+(?=\()/i,keyword:/\b(?:alias|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|class|case|casex|casez|cell|chandle|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endspecify|endsequence|endtable|endtask|enum|event|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|import|incdir|include|initial|inout|input|inside|instance|int|integer|interface|intersect|join|join_any|join_none|large|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|new|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_onevent|pulsestyle_ondetect|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|release|repeat|return|rnmos|rpmos|rtran|rtranif0|rtranif1|scalared|sequence|shortint|shortreal|showcancelled|signed|small|solve|specify|specparam|static|string|strong0|strong1|struct|super|supply0|supply1|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unsigned|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b/,important:/\b(?:always_latch|always_comb|always_ff|always)\b ?@?/,number:/\B##?\d+|(?:\b\d+)?'[odbh] ?[\da-fzx_?]+|\b\d*[._]?\d+(?:e[-+]?\d+)?/i,operator:/[-+{}^~%*\/?=!<>&|]+/,punctuation:/[[\];(),.:]/};
Prism.languages.vhdl={comment:/--.+/,"vhdl-vectors":{pattern:/\b[oxb]"[\da-f_]+"|"[01uxzwlh-]+"/i,alias:"number"},"quoted-function":{pattern:/"\S+?"(?=\()/,alias:"function"},string:/"(?:[^\\\r\n]|\\?(?:\r\n|[\s\S]))*?"/,constant:/\b(?:use|library)\b/i,keyword:/\b(?:'active|'ascending|'base|'delayed|'driving|'driving_value|'event|'high|'image|'instance_name|'last_active|'last_event|'last_value|'left|'leftof|'length|'low|'path_name|'pos|'pred|'quiet|'range|'reverse_range|'right|'rightof|'simple_name|'stable|'succ|'transaction|'val|'value|access|after|alias|all|architecture|array|assert|attribute|begin|block|body|buffer|bus|case|component|configuration|constant|disconnect|downto|else|elsif|end|entity|exit|file|for|function|generate|generic|group|guarded|if|impure|in|inertial|inout|is|label|library|linkage|literal|loop|map|new|next|null|of|on|open|others|out|package|port|postponed|procedure|process|pure|range|record|register|reject|report|return|select|severity|shared|signal|subtype|then|to|transport|type|unaffected|units|until|use|variable|wait|when|while|with)\b/i,"boolean":/\b(?:true|false)\b/i,"function":/[a-z0-9_]+(?=\()/i,number:/'[01uxzwlh-]'|\b(?:\d+#[\da-f_.]+#|\d[\d_.]*)(?:e[-+]?\d+)?/i,operator:/[<>]=?|:=|[-+*\/&=]|\b(?:abs|not|mod|rem|sll|srl|sla|sra|rol|ror|and|or|nand|xnor|xor|nor)\b/i,punctuation:/[{}[\];(),.:]/};
Prism.languages.vim={string:/"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\r\n]|'')*'/,comment:/".*/,"function":/\w+(?=\()/,keyword:/\b(?:ab|abbreviate|abc|abclear|abo|aboveleft|al|all|arga|argadd|argd|argdelete|argdo|arge|argedit|argg|argglobal|argl|arglocal|ar|args|argu|argument|as|ascii|bad|badd|ba|ball|bd|bdelete|be|bel|belowright|bf|bfirst|bl|blast|bm|bmodified|bn|bnext|bN|bNext|bo|botright|bp|bprevious|brea|break|breaka|breakadd|breakd|breakdel|breakl|breaklist|br|brewind|bro|browse|bufdo|b|buffer|buffers|bun|bunload|bw|bwipeout|ca|cabbrev|cabc|cabclear|caddb|caddbuffer|cad|caddexpr|caddf|caddfile|cal|call|cat|catch|cb|cbuffer|cc|ccl|cclose|cd|ce|center|cex|cexpr|cf|cfile|cfir|cfirst|cgetb|cgetbuffer|cgete|cgetexpr|cg|cgetfile|c|change|changes|chd|chdir|che|checkpath|checkt|checktime|cla|clast|cl|clist|clo|close|cmapc|cmapclear|cnew|cnewer|cn|cnext|cN|cNext|cnf|cnfile|cNfcNfile|cnorea|cnoreabbrev|col|colder|colo|colorscheme|comc|comclear|comp|compiler|conf|confirm|con|continue|cope|copen|co|copy|cpf|cpfile|cp|cprevious|cq|cquit|cr|crewind|cuna|cunabbrev|cu|cunmap|cw|cwindow|debugg|debuggreedy|delc|delcommand|d|delete|delf|delfunction|delm|delmarks|diffg|diffget|diffoff|diffpatch|diffpu|diffput|diffsplit|diffthis|diffu|diffupdate|dig|digraphs|di|display|dj|djump|dl|dlist|dr|drop|ds|dsearch|dsp|dsplit|earlier|echoe|echoerr|echom|echomsg|echon|e|edit|el|else|elsei|elseif|em|emenu|endfo|endfor|endf|endfunction|endfun|en|endif|endt|endtry|endw|endwhile|ene|enew|ex|exi|exit|exu|exusage|f|file|files|filetype|fina|finally|fin|find|fini|finish|fir|first|fix|fixdel|fo|fold|foldc|foldclose|folddoc|folddoclosed|foldd|folddoopen|foldo|foldopen|for|fu|fun|function|go|goto|gr|grep|grepa|grepadd|ha|hardcopy|h|help|helpf|helpfind|helpg|helpgrep|helpt|helptags|hid|hide|his|history|ia|iabbrev|iabc|iabclear|if|ij|ijump|il|ilist|imapc|imapclear|in|inorea|inoreabbrev|isearch|isp|isplit|iuna|iunabbrev|iu|iunmap|j|join|ju|jumps|k|keepalt|keepj|keepjumps|kee|keepmarks|laddb|laddbuffer|lad|laddexpr|laddf|laddfile|lan|language|la|last|later|lb|lbuffer|lc|lcd|lch|lchdir|lcl|lclose|let|left|lefta|leftabove|lex|lexpr|lf|lfile|lfir|lfirst|lgetb|lgetbuffer|lgete|lgetexpr|lg|lgetfile|lgr|lgrep|lgrepa|lgrepadd|lh|lhelpgrep|l|list|ll|lla|llast|lli|llist|lmak|lmake|lm|lmap|lmapc|lmapclear|lnew|lnewer|lne|lnext|lN|lNext|lnf|lnfile|lNf|lNfile|ln|lnoremap|lo|loadview|loc|lockmarks|lockv|lockvar|lol|lolder|lop|lopen|lpf|lpfile|lp|lprevious|lr|lrewind|ls|lt|ltag|lu|lunmap|lv|lvimgrep|lvimgrepa|lvimgrepadd|lw|lwindow|mak|make|ma|mark|marks|mat|match|menut|menutranslate|mk|mkexrc|mks|mksession|mksp|mkspell|mkvie|mkview|mkv|mkvimrc|mod|mode|m|move|mzf|mzfile|mz|mzscheme|nbkey|new|n|next|N|Next|nmapc|nmapclear|noh|nohlsearch|norea|noreabbrev|nu|number|nun|nunmap|omapc|omapclear|on|only|o|open|opt|options|ou|ounmap|pc|pclose|ped|pedit|pe|perl|perld|perldo|po|pop|popu|popu|popup|pp|ppop|pre|preserve|prev|previous|p|print|P|Print|profd|profdel|prof|profile|promptf|promptfind|promptr|promptrepl|ps|psearch|pta|ptag|ptf|ptfirst|ptj|ptjump|ptl|ptlast|ptn|ptnext|ptN|ptNext|ptp|ptprevious|ptr|ptrewind|pts|ptselect|pu|put|pw|pwd|pyf|pyfile|py|python|qa|qall|q|quit|quita|quitall|r|read|rec|recover|redi|redir|red|redo|redr|redraw|redraws|redrawstatus|reg|registers|res|resize|ret|retab|retu|return|rew|rewind|ri|right|rightb|rightbelow|rub|ruby|rubyd|rubydo|rubyf|rubyfile|ru|runtime|rv|rviminfo|sal|sall|san|sandbox|sa|sargument|sav|saveas|sba|sball|sbf|sbfirst|sbl|sblast|sbm|sbmodified|sbn|sbnext|sbN|sbNext|sbp|sbprevious|sbr|sbrewind|sb|sbuffer|scripte|scriptencoding|scrip|scriptnames|se|set|setf|setfiletype|setg|setglobal|setl|setlocal|sf|sfind|sfir|sfirst|sh|shell|sign|sil|silent|sim|simalt|sla|slast|sl|sleep|sm|smagic|sm|smap|smapc|smapclear|sme|smenu|sn|snext|sN|sNext|sni|sniff|sno|snomagic|snor|snoremap|snoreme|snoremenu|sor|sort|so|source|spelld|spelldump|spe|spellgood|spelli|spellinfo|spellr|spellrepall|spellu|spellundo|spellw|spellwrong|sp|split|spr|sprevious|sre|srewind|sta|stag|startg|startgreplace|star|startinsert|startr|startreplace|stj|stjump|st|stop|stopi|stopinsert|sts|stselect|sun|sunhide|sunm|sunmap|sus|suspend|sv|sview|syncbind|t|tab|tabc|tabclose|tabd|tabdo|tabe|tabedit|tabf|tabfind|tabfir|tabfirst|tabl|tablast|tabm|tabmove|tabnew|tabn|tabnext|tabN|tabNext|tabo|tabonly|tabp|tabprevious|tabr|tabrewind|tabs|ta|tag|tags|tc|tcl|tcld|tcldo|tclf|tclfile|te|tearoff|tf|tfirst|th|throw|tj|tjump|tl|tlast|tm|tm|tmenu|tn|tnext|tN|tNext|to|topleft|tp|tprevious|tr|trewind|try|ts|tselect|tu|tu|tunmenu|una|unabbreviate|u|undo|undoj|undojoin|undol|undolist|unh|unhide|unlet|unlo|unlockvar|unm|unmap|up|update|verb|verbose|ve|version|vert|vertical|vie|view|vim|vimgrep|vimgrepa|vimgrepadd|vi|visual|viu|viusage|vmapc|vmapclear|vne|vnew|vs|vsplit|vu|vunmap|wa|wall|wh|while|winc|wincmd|windo|winp|winpos|win|winsize|wn|wnext|wN|wNext|wp|wprevious|wq|wqa|wqall|w|write|ws|wsverb|wv|wviminfo|X|xa|xall|x|xit|xm|xmap|xmapc|xmapclear|xme|xmenu|XMLent|XMLns|xn|xnoremap|xnoreme|xnoremenu|xu|xunmap|y|yank)\b/,builtin:/\b(?:autocmd|acd|ai|akm|aleph|allowrevins|altkeymap|ambiwidth|ambw|anti|antialias|arab|arabic|arabicshape|ari|arshape|autochdir|autoindent|autoread|autowrite|autowriteall|aw|awa|background|backspace|backup|backupcopy|backupdir|backupext|backupskip|balloondelay|ballooneval|balloonexpr|bdir|bdlay|beval|bex|bexpr|bg|bh|bin|binary|biosk|bioskey|bk|bkc|bomb|breakat|brk|browsedir|bs|bsdir|bsk|bt|bufhidden|buflisted|buftype|casemap|ccv|cdpath|cedit|cfu|ch|charconvert|ci|cin|cindent|cink|cinkeys|cino|cinoptions|cinw|cinwords|clipboard|cmdheight|cmdwinheight|cmp|cms|columns|com|comments|commentstring|compatible|complete|completefunc|completeopt|consk|conskey|copyindent|cot|cpo|cpoptions|cpt|cscopepathcomp|cscopeprg|cscopequickfix|cscopetag|cscopetagorder|cscopeverbose|cspc|csprg|csqf|cst|csto|csverb|cuc|cul|cursorcolumn|cursorline|cwh|debug|deco|def|define|delcombine|dex|dg|dict|dictionary|diff|diffexpr|diffopt|digraph|dip|dir|directory|dy|ea|ead|eadirection|eb|ed|edcompatible|ef|efm|ei|ek|enc|encoding|endofline|eol|ep|equalalways|equalprg|errorbells|errorfile|errorformat|esckeys|et|eventignore|expandtab|exrc|fcl|fcs|fdc|fde|fdi|fdl|fdls|fdm|fdn|fdo|fdt|fen|fenc|fencs|fex|ff|ffs|fileencoding|fileencodings|fileformat|fileformats|fillchars|fk|fkmap|flp|fml|fmr|foldcolumn|foldenable|foldexpr|foldignore|foldlevel|foldlevelstart|foldmarker|foldmethod|foldminlines|foldnestmax|foldtext|formatexpr|formatlistpat|formatoptions|formatprg|fp|fs|fsync|ft|gcr|gd|gdefault|gfm|gfn|gfs|gfw|ghr|gp|grepformat|grepprg|gtl|gtt|guicursor|guifont|guifontset|guifontwide|guiheadroom|guioptions|guipty|guitablabel|guitabtooltip|helpfile|helpheight|helplang|hf|hh|hi|hidden|highlight|hk|hkmap|hkmapp|hkp|hl|hlg|hls|hlsearch|ic|icon|iconstring|ignorecase|im|imactivatekey|imak|imc|imcmdline|imd|imdisable|imi|iminsert|ims|imsearch|inc|include|includeexpr|incsearch|inde|indentexpr|indentkeys|indk|inex|inf|infercase|insertmode|isf|isfname|isi|isident|isk|iskeyword|isprint|joinspaces|js|key|keymap|keymodel|keywordprg|km|kmp|kp|langmap|langmenu|laststatus|lazyredraw|lbr|lcs|linebreak|lines|linespace|lisp|lispwords|listchars|loadplugins|lpl|lsp|lz|macatsui|magic|makeef|makeprg|matchpairs|matchtime|maxcombine|maxfuncdepth|maxmapdepth|maxmem|maxmempattern|maxmemtot|mco|mef|menuitems|mfd|mh|mis|mkspellmem|ml|mls|mm|mmd|mmp|mmt|modeline|modelines|modifiable|modified|more|mouse|mousef|mousefocus|mousehide|mousem|mousemodel|mouses|mouseshape|mouset|mousetime|mp|mps|msm|mzq|mzquantum|nf|nrformats|numberwidth|nuw|odev|oft|ofu|omnifunc|opendevice|operatorfunc|opfunc|osfiletype|pa|para|paragraphs|paste|pastetoggle|patchexpr|patchmode|path|pdev|penc|pex|pexpr|pfn|ph|pheader|pi|pm|pmbcs|pmbfn|popt|preserveindent|previewheight|previewwindow|printdevice|printencoding|printexpr|printfont|printheader|printmbcharset|printmbfont|printoptions|prompt|pt|pumheight|pvh|pvw|qe|quoteescape|readonly|remap|report|restorescreen|revins|rightleft|rightleftcmd|rl|rlc|ro|rs|rtp|ruf|ruler|rulerformat|runtimepath|sbo|sc|scb|scr|scroll|scrollbind|scrolljump|scrolloff|scrollopt|scs|sect|sections|secure|sel|selection|selectmode|sessionoptions|sft|shcf|shellcmdflag|shellpipe|shellquote|shellredir|shellslash|shelltemp|shelltype|shellxquote|shiftround|shiftwidth|shm|shortmess|shortname|showbreak|showcmd|showfulltag|showmatch|showmode|showtabline|shq|si|sidescroll|sidescrolloff|siso|sj|slm|smartcase|smartindent|smarttab|smc|smd|softtabstop|sol|spc|spell|spellcapcheck|spellfile|spelllang|spellsuggest|spf|spl|splitbelow|splitright|sps|sr|srr|ss|ssl|ssop|stal|startofline|statusline|stl|stmp|su|sua|suffixes|suffixesadd|sw|swapfile|swapsync|swb|swf|switchbuf|sws|sxq|syn|synmaxcol|syntax|tabline|tabpagemax|tabstop|tagbsearch|taglength|tagrelative|tagstack|tal|tb|tbi|tbidi|tbis|tbs|tenc|term|termbidi|termencoding|terse|textauto|textmode|textwidth|tgst|thesaurus|tildeop|timeout|timeoutlen|title|titlelen|titleold|titlestring|toolbar|toolbariconsize|top|tpm|tsl|tsr|ttimeout|ttimeoutlen|ttm|tty|ttybuiltin|ttyfast|ttym|ttymouse|ttyscroll|ttytype|tw|tx|uc|ul|undolevels|updatecount|updatetime|ut|vb|vbs|vdir|verbosefile|vfile|viewdir|viewoptions|viminfo|virtualedit|visualbell|vop|wak|warn|wb|wc|wcm|wd|weirdinvert|wfh|wfw|whichwrap|wi|wig|wildchar|wildcharm|wildignore|wildmenu|wildmode|wildoptions|wim|winaltkeys|window|winfixheight|winfixwidth|winheight|winminheight|winminwidth|winwidth|wiv|wiw|wm|wmh|wmnu|wmw|wop|wrap|wrapmargin|wrapscan|writeany|writebackup|writedelay|ww|noacd|noai|noakm|noallowrevins|noaltkeymap|noanti|noantialias|noar|noarab|noarabic|noarabicshape|noari|noarshape|noautochdir|noautoindent|noautoread|noautowrite|noautowriteall|noaw|noawa|nobackup|noballooneval|nobeval|nobin|nobinary|nobiosk|nobioskey|nobk|nobl|nobomb|nobuflisted|nocf|noci|nocin|nocindent|nocompatible|noconfirm|noconsk|noconskey|nocopyindent|nocp|nocscopetag|nocscopeverbose|nocst|nocsverb|nocuc|nocul|nocursorcolumn|nocursorline|nodeco|nodelcombine|nodg|nodiff|nodigraph|nodisable|noea|noeb|noed|noedcompatible|noek|noendofline|noeol|noequalalways|noerrorbells|noesckeys|noet|noex|noexpandtab|noexrc|nofen|nofk|nofkmap|nofoldenable|nogd|nogdefault|noguipty|nohid|nohidden|nohk|nohkmap|nohkmapp|nohkp|nohls|noic|noicon|noignorecase|noim|noimc|noimcmdline|noimd|noincsearch|noinf|noinfercase|noinsertmode|nois|nojoinspaces|nojs|nolazyredraw|nolbr|nolinebreak|nolisp|nolist|noloadplugins|nolpl|nolz|noma|nomacatsui|nomagic|nomh|noml|nomod|nomodeline|nomodifiable|nomodified|nomore|nomousef|nomousefocus|nomousehide|nonu|nonumber|noodev|noopendevice|nopaste|nopi|nopreserveindent|nopreviewwindow|noprompt|nopvw|noreadonly|noremap|norestorescreen|norevins|nori|norightleft|norightleftcmd|norl|norlc|noro|nors|noru|noruler|nosb|nosc|noscb|noscrollbind|noscs|nosecure|nosft|noshellslash|noshelltemp|noshiftround|noshortname|noshowcmd|noshowfulltag|noshowmatch|noshowmode|nosi|nosm|nosmartcase|nosmartindent|nosmarttab|nosmd|nosn|nosol|nospell|nosplitbelow|nosplitright|nospr|nosr|nossl|nosta|nostartofline|nostmp|noswapfile|noswf|nota|notagbsearch|notagrelative|notagstack|notbi|notbidi|notbs|notermbidi|noterse|notextauto|notextmode|notf|notgst|notildeop|notimeout|notitle|noto|notop|notr|nottimeout|nottybuiltin|nottyfast|notx|novb|novisualbell|nowa|nowarn|nowb|noweirdinvert|nowfh|nowfw|nowildmenu|nowinfixheight|nowinfixwidth|nowiv|nowmnu|nowrap|nowrapscan|nowrite|nowriteany|nowritebackup|nows|invacd|invai|invakm|invallowrevins|invaltkeymap|invanti|invantialias|invar|invarab|invarabic|invarabicshape|invari|invarshape|invautochdir|invautoindent|invautoread|invautowrite|invautowriteall|invaw|invawa|invbackup|invballooneval|invbeval|invbin|invbinary|invbiosk|invbioskey|invbk|invbl|invbomb|invbuflisted|invcf|invci|invcin|invcindent|invcompatible|invconfirm|invconsk|invconskey|invcopyindent|invcp|invcscopetag|invcscopeverbose|invcst|invcsverb|invcuc|invcul|invcursorcolumn|invcursorline|invdeco|invdelcombine|invdg|invdiff|invdigraph|invdisable|invea|inveb|inved|invedcompatible|invek|invendofline|inveol|invequalalways|inverrorbells|invesckeys|invet|invex|invexpandtab|invexrc|invfen|invfk|invfkmap|invfoldenable|invgd|invgdefault|invguipty|invhid|invhidden|invhk|invhkmap|invhkmapp|invhkp|invhls|invhlsearch|invic|invicon|invignorecase|invim|invimc|invimcmdline|invimd|invincsearch|invinf|invinfercase|invinsertmode|invis|invjoinspaces|invjs|invlazyredraw|invlbr|invlinebreak|invlisp|invlist|invloadplugins|invlpl|invlz|invma|invmacatsui|invmagic|invmh|invml|invmod|invmodeline|invmodifiable|invmodified|invmore|invmousef|invmousefocus|invmousehide|invnu|invnumber|invodev|invopendevice|invpaste|invpi|invpreserveindent|invpreviewwindow|invprompt|invpvw|invreadonly|invremap|invrestorescreen|invrevins|invri|invrightleft|invrightleftcmd|invrl|invrlc|invro|invrs|invru|invruler|invsb|invsc|invscb|invscrollbind|invscs|invsecure|invsft|invshellslash|invshelltemp|invshiftround|invshortname|invshowcmd|invshowfulltag|invshowmatch|invshowmode|invsi|invsm|invsmartcase|invsmartindent|invsmarttab|invsmd|invsn|invsol|invspell|invsplitbelow|invsplitright|invspr|invsr|invssl|invsta|invstartofline|invstmp|invswapfile|invswf|invta|invtagbsearch|invtagrelative|invtagstack|invtbi|invtbidi|invtbs|invtermbidi|invterse|invtextauto|invtextmode|invtf|invtgst|invtildeop|invtimeout|invtitle|invto|invtop|invtr|invttimeout|invttybuiltin|invttyfast|invtx|invvb|invvisualbell|invwa|invwarn|invwb|invweirdinvert|invwfh|invwfw|invwildmenu|invwinfixheight|invwinfixwidth|invwiv|invwmnu|invwrap|invwrapscan|invwrite|invwriteany|invwritebackup|invws|t_AB|t_AF|t_al|t_AL|t_bc|t_cd|t_ce|t_Ce|t_cl|t_cm|t_Co|t_cs|t_Cs|t_CS|t_CV|t_da|t_db|t_dl|t_DL|t_EI|t_F1|t_F2|t_F3|t_F4|t_F5|t_F6|t_F7|t_F8|t_F9|t_fs|t_IE|t_IS|t_k1|t_K1|t_k2|t_k3|t_K3|t_k4|t_K4|t_k5|t_K5|t_k6|t_K6|t_k7|t_K7|t_k8|t_K8|t_k9|t_K9|t_KA|t_kb|t_kB|t_KB|t_KC|t_kd|t_kD|t_KD|t_ke|t_KE|t_KF|t_KG|t_kh|t_KH|t_kI|t_KI|t_KJ|t_KK|t_kl|t_KL|t_kN|t_kP|t_kr|t_ks|t_ku|t_le|t_mb|t_md|t_me|t_mr|t_ms|t_nd|t_op|t_RI|t_RV|t_Sb|t_se|t_Sf|t_SI|t_so|t_sr|t_te|t_ti|t_ts|t_ue|t_us|t_ut|t_vb|t_ve|t_vi|t_vs|t_WP|t_WS|t_xs|t_ZH|t_ZR)\b/,number:/\b(?:0x[\da-f]+|\d+(?:\.\d+)?)\b/i,operator:/\|\||&&|[-+.]=?|[=!](?:[=~][#?]?)?|[<>]=?[#?]?|[*\/%?]|\b(?:is(?:not)?)\b/,punctuation:/[{}[\](),;:]/};
Prism.languages.wiki=Prism.languages.extend("markup",{"block-comment":{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//,lookbehind:!0,alias:"comment"},heading:{pattern:/^(=+).+?\1/m,inside:{punctuation:/^=+|=+$/,important:/.+/}},emphasis:{pattern:/('{2,5}).+?\1/,inside:{"bold italic":{pattern:/(''''').+?(?=\1)/,lookbehind:!0},bold:{pattern:/(''')[^'](?:.*?[^'])?(?=\1)/,lookbehind:!0},italic:{pattern:/('')[^'](?:.*?[^'])?(?=\1)/,lookbehind:!0},punctuation:/^''+|''+$/}},hr:{pattern:/^-{4,}/m,alias:"punctuation"},url:[/ISBN +(?:97[89][ -]?)?(?:\d[ -]?){9}[\dx]\b|(?:RFC|PMID) +\d+/i,/\[\[.+?\]\]|\[.+?\]/],variable:[/__[A-Z]+__/,/\{{3}.+?\}{3}/,/\{\{.+?}}/],symbol:[/^#redirect/im,/~{3,5}/],"table-tag":{pattern:/((?:^|[|!])[|!])[^|\r\n]+\|(?!\|)/m,lookbehind:!0,inside:{"table-bar":{pattern:/\|$/,alias:"punctuation"},rest:Prism.languages.markup.tag.inside}},punctuation:/^(?:\{\||\|\}|\|-|[*#:;!|])|\|\||!!/m}),Prism.languages.insertBefore("wiki","tag",{nowiki:{pattern:/<(nowiki|pre|source)\b[\w\W]*?>[\w\W]*?<\/\1>/i,inside:{tag:{pattern:/<(?:nowiki|pre|source)\b[\w\W]*?>|<\/(?:nowiki|pre|source)>/i,inside:Prism.languages.markup.tag.inside}}}});
Prism.languages.xojo={comment:{pattern:/(?:'|\/\/|Rem\b).+/i,inside:{keyword:/^Rem/i}},string:{pattern:/"(?:""|[^"])*"/,greedy:!0},number:[/(?:\b|\B[.-])(?:\d+\.?\d*)(?:E[+-]?\d+)?/i,/&[bchou][a-z\d]+/i],symbol:/#(?:If|Else|ElseIf|Endif|Pragma)\b/i,keyword:/\b(?:AddHandler|App|Array|As(?:signs)?|By(?:Ref|Val)|Break|Call|Case|Catch|Const|Continue|CurrentMethodName|Declare|Dim|Do(?:wnTo)?|Each|Else(?:If)?|End|Exit|Extends|False|Finally|For|Global|If|In|Lib|Loop|Me|Next|Nil|Optional|ParamArray|Raise(?:Event)?|ReDim|Rem|RemoveHandler|Return|Select|Self|Soft|Static|Step|Super|Then|To|True|Try|Ubound|Until|Using|Wend|While)\b/i,operator:/<[=>]?|>=?|[+\-*\/\\^=]|\b(?:AddressOf|And|Ctype|IsA?|Mod|New|Not|Or|Xor|WeakAddressOf)\b/i,punctuation:/[.,;:()]/};
Prism.languages.yaml={scalar:{pattern:/([\-:]\s*(![^\s]+)?[ \t]*[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)[^\r\n]+(?:\3[^\r\n]+)*)/,lookbehind:!0,alias:"string"},comment:/#.*/,key:{pattern:/(\s*(?:^|[:\-,[{\r\n?])[ \t]*(![^\s]+)?[ \t]*)[^\r\n{[\]},#\s]+?(?=\s*:\s)/,lookbehind:!0,alias:"atrule"},directive:{pattern:/(^[ \t]*)%.+/m,lookbehind:!0,alias:"important"},datetime:{pattern:/([:\-,[{]\s*(![^\s]+)?[ \t]*)(\d{4}-\d\d?-\d\d?([tT]|[ \t]+)\d\d?:\d{2}:\d{2}(\.\d*)?[ \t]*(Z|[-+]\d\d?(:\d{2})?)?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(:\d{2}(\.\d*)?)?)(?=[ \t]*($|,|]|}))/m,lookbehind:!0,alias:"number"},"boolean":{pattern:/([:\-,[{]\s*(![^\s]+)?[ \t]*)(true|false)[ \t]*(?=$|,|]|})/im,lookbehind:!0,alias:"important"},"null":{pattern:/([:\-,[{]\s*(![^\s]+)?[ \t]*)(null|~)[ \t]*(?=$|,|]|})/im,lookbehind:!0,alias:"important"},string:{pattern:/([:\-,[{]\s*(![^\s]+)?[ \t]*)("(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')(?=[ \t]*($|,|]|}))/m,lookbehind:!0},number:{pattern:/([:\-,[{]\s*(![^\s]+)?[ \t]*)[+\-]?(0x[\da-f]+|0o[0-7]+|(\d+\.?\d*|\.?\d+)(e[\+\-]?\d+)?|\.inf|\.nan)[ \t]*(?=$|,|]|})/im,lookbehind:!0},tag:/![^\s]+/,important:/[&*][\w]+/,punctuation:/---|[:[\]{}\-,|>?]|\.\.\./};

/* jquery Tocify - v1.9.0 - 2013-10-01
* http://www.gregfranko.com/jquery.tocify.js/
* Copyright (c) 2013 Greg Franko; Licensed MIT */

// Immediately-Invoked Function Expression (IIFE) [Ben Alman Blog Post](http://benalman.com/news/2010/11/immediately-invoked-function-expression/) that calls another IIFE that contains all of the plugin logic.  I used this pattern so that anyone viewing this code would not have to scroll to the bottom of the page to view the local parameters that were passed to the main IIFE.
(function(tocify) {

    // ECMAScript 5 Strict Mode: [John Resig Blog Post](http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/)
    "use strict";

    // Calls the second IIFE and locally passes in the global jQuery, window, and document objects
    tocify(window.jQuery, window, document);

}

// Locally passes in `jQuery`, the `window` object, the `document` object, and an `undefined` variable.  The `jQuery`, `window` and `document` objects are passed in locally, to improve performance, since javascript first searches for a variable match within the local variables set before searching the global variables set.  All of the global variables are also passed in locally to be minifier friendly. `undefined` can be passed in locally, because it is not a reserved word in JavaScript.
(function($, window, document, undefined) {

    // ECMAScript 5 Strict Mode: [John Resig Blog Post](http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/)
    "use strict";

    var tocClassName = "tocify",
        tocClass = "." + tocClassName,
        tocFocusClassName = "tocify-focus",
        tocHoverClassName = "tocify-hover",
        hideTocClassName = "tocify-hide",
        hideTocClass = "." + hideTocClassName,
        headerClassName = "tocify-header",
        headerClass = "." + headerClassName,
        subheaderClassName = "tocify-subheader",
        subheaderClass = "." + subheaderClassName,
        itemClassName = "tocify-item",
        itemClass = "." + itemClassName,
        extendPageClassName = "tocify-extend-page",
        extendPageClass = "." + extendPageClassName;

    // Calling the jQueryUI Widget Factory Method
    $.widget("toc.tocify", {

        //Plugin version
        version: "1.9.0",

        // These options will be used as defaults
        options: {

            // **context**: Accepts String: Any jQuery selector
            // The container element that holds all of the elements used to generate the table of contents
            context: "body",

            // **ignoreSelector**: Accepts String: Any jQuery selector
            // A selector to any element that would be matched by selectors that you wish to be ignored
            ignoreSelector: null,

            // **selectors**: Accepts an Array of Strings: Any jQuery selectors
            // The element's used to generate the table of contents.  The order is very important since it will determine the table of content's nesting structure
            selectors: "h1, h2, h3",

            // **showAndHide**: Accepts a boolean: true or false
            // Used to determine if elements should be shown and hidden
            showAndHide: true,

            // **showEffect**: Accepts String: "none", "fadeIn", "show", or "slideDown"
            // Used to display any of the table of contents nested items
            showEffect: "slideDown",

            // **showEffectSpeed**: Accepts Number (milliseconds) or String: "slow", "medium", or "fast"
            // The time duration of the show animation
            showEffectSpeed: "medium",

            // **hideEffect**: Accepts String: "none", "fadeOut", "hide", or "slideUp"
            // Used to hide any of the table of contents nested items
            hideEffect: "slideUp",

            // **hideEffectSpeed**: Accepts Number (milliseconds) or String: "slow", "medium", or "fast"
            // The time duration of the hide animation
            hideEffectSpeed: "medium",

            // **smoothScroll**: Accepts a boolean: true or false
            // Determines if a jQuery animation should be used to scroll to specific table of contents items on the page
            smoothScroll: true,

            // **smoothScrollSpeed**: Accepts Number (milliseconds) or String: "slow", "medium", or "fast"
            // The time duration of the smoothScroll animation
            smoothScrollSpeed: "medium",

            // **scrollTo**: Accepts Number (pixels)
            // The amount of space between the top of page and the selected table of contents item after the page has been scrolled
            scrollTo: 0,

            // **showAndHideOnScroll**: Accepts a boolean: true or false
            // Determines if table of contents nested items should be shown and hidden while scrolling
            showAndHideOnScroll: true,

            // **highlightOnScroll**: Accepts a boolean: true or false
            // Determines if table of contents nested items should be highlighted (set to a different color) while scrolling
            highlightOnScroll: true,

            // **highlightOffset**: Accepts a number
            // The offset distance in pixels to trigger the next active table of contents item
            highlightOffset: 40,

            // **theme**: Accepts a string: "bootstrap", "jqueryui", or "none"
            // Determines if Twitter Bootstrap, jQueryUI, or Tocify classes should be added to the table of contents
            theme: "bootstrap",

            // **extendPage**: Accepts a boolean: true or false
            // If a user scrolls to the bottom of the page and the page is not tall enough to scroll to the last table of contents item, then the page height is increased
            extendPage: true,

            // **extendPageOffset**: Accepts a number: pixels
            // How close to the bottom of the page a user must scroll before the page is extended
            extendPageOffset: 100,

            // **history**: Accepts a boolean: true or false
            // Adds a hash to the page url to maintain history
            history: true,

            // **scrollHistory**: Accepts a boolean: true or false
            // Adds a hash to the page url, to maintain history, when scrolling to a TOC item
            scrollHistory: false,

            // **hashGenerator**: How the hash value (the anchor segment of the URL, following the
            // # character) will be generated.
            //
            // "compact" (default) - #CompressesEverythingTogether
            // "pretty" - #looks-like-a-nice-url-and-is-easily-readable
            // function(text, element){} - Your own hash generation function that accepts the text as an
            // argument, and returns the hash value.
            hashGenerator: "compact",

            // **highlightDefault**: Accepts a boolean: true or false
            // Set's the first TOC item as active if no other TOC item is active.
            highlightDefault: true

        },

        // _Create
        // -------
        //      Constructs the plugin.  Only called once.
        _create: function() {

            var self = this;

            self.extendPageScroll = true;

            // Internal array that keeps track of all TOC items (Helps to recognize if there are duplicate TOC item strings)
            self.items = [];

            // Generates the HTML for the dynamic table of contents
            self._generateToc();

            // Adds CSS classes to the newly generated table of contents HTML
            self._addCSSClasses();

            self.webkit = (function() {

                for(var prop in window) {

                    if(prop) {

                        if(prop.toLowerCase().indexOf("webkit") !== -1) {

                            return true;

                        }

                    }

                }

                return false;

            }());

            // Adds jQuery event handlers to the newly generated table of contents
            self._setEventHandlers();

            // Binding to the Window load event to make sure the correct scrollTop is calculated
            $(window).load(function() {

                // Sets the active TOC item
                self._setActiveElement(true);

                // Once all animations on the page are complete, this callback function will be called
                $("html, body").promise().done(function() {

                    setTimeout(function() {

                        self.extendPageScroll = false;

                    },0);

                });

            });

        },

        // _generateToc
        // ------------
        //      Generates the HTML for the dynamic table of contents
        _generateToc: function() {

            // _Local variables_

            // Stores the plugin context in the self variable
            var self = this,

                // All of the HTML tags found within the context provided (i.e. body) that match the top level jQuery selector above
                firstElem,

                // Instantiated variable that will store the top level newly created unordered list DOM element
                ul,
                ignoreSelector = self.options.ignoreSelector;

            // If the selectors option has a comma within the string
            if(this.options.selectors.indexOf(",") !== -1) {

                // Grabs the first selector from the string
                firstElem = $(this.options.context).find(this.options.selectors.replace(/ /g,"").substr(0, this.options.selectors.indexOf(",")));

            }

            // If the selectors option does not have a comman within the string
            else {

                // Grabs the first selector from the string and makes sure there are no spaces
                firstElem = $(this.options.context).find(this.options.selectors.replace(/ /g,""));

            }

            if(!firstElem.length) {

                self.element.addClass(hideTocClassName);

                return;

            }

            self.element.addClass(tocClassName);

            // Loops through each top level selector
            firstElem.each(function(index) {

                //If the element matches the ignoreSelector then we skip it
                if($(this).is(ignoreSelector)) {
                    return;
                }

                // Creates an unordered list HTML element and adds a dynamic ID and standard class name
                ul = $("<ul/>", {
                    "id": headerClassName + index,
                    "class": headerClassName
                }).

                // Appends a top level list item HTML element to the previously created HTML header
                append(self._nestElements($(this), index));

                // Add the created unordered list element to the HTML element calling the plugin
                self.element.append(ul);

                // Finds all of the HTML tags between the header and subheader elements
                $(this).nextUntil(this.nodeName.toLowerCase()).each(function() {

                    // If there are no nested subheader elemements
                    if($(this).find(self.options.selectors).length === 0) {

                        // Loops through all of the subheader elements
                        $(this).filter(self.options.selectors).each(function() {

                            //If the element matches the ignoreSelector then we skip it
                            if($(this).is(ignoreSelector)) {
                                return;
                            }

                            self._appendSubheaders.call(this, self, ul);

                        });

                    }

                    // If there are nested subheader elements
                    else {

                        // Loops through all of the subheader elements
                        $(this).find(self.options.selectors).each(function() {

                            //If the element matches the ignoreSelector then we skip it
                            if($(this).is(ignoreSelector)) {
                                return;
                            }

                            self._appendSubheaders.call(this, self, ul);

                        });

                    }

                });

            });

        },

        _setActiveElement: function(pageload) {

            var self = this,

                hash = window.location.hash.substring(1),

                elem = self.element.find('li[data-unique="' + hash + '"]');

            if(hash.length) {

                // Removes highlighting from all of the list item's
                self.element.find("." + self.focusClass).removeClass(self.focusClass);

                // Highlights the current list item that was clicked
                elem.addClass(self.focusClass);

                // If the showAndHide option is true
                if(self.options.showAndHide) {

                    // Triggers the click event on the currently focused TOC item
                    elem.click();

                }

            }

            else {

                // Removes highlighting from all of the list item's
                self.element.find("." + self.focusClass).removeClass(self.focusClass);

                if(!hash.length && pageload && self.options.highlightDefault) {

                    // Highlights the first TOC item if no other items are highlighted
                    self.element.find(itemClass).first().addClass(self.focusClass);

                }

            }

            return self;

        },

        // _nestElements
        // -------------
        //      Helps create the table of contents list by appending nested list items
        _nestElements: function(self, index) {

            var arr, item, hashValue;

            arr = $.grep(this.items, function (item) {

                return item === self.text();

            });

            // If there is already a duplicate TOC item
            if(arr.length) {

                // Adds the current TOC item text and index (for slight randomization) to the internal array
                this.items.push(self.text() + index);

            }

            // If there not a duplicate TOC item
            else {

                // Adds the current TOC item text to the internal array
                this.items.push(self.text());

            }

            hashValue = this._generateHashValue(arr, self, index);

            // Appends a list item HTML element to the last unordered list HTML element found within the HTML element calling the plugin
            item = $("<li/>", {

                // Sets a common class name to the list item
                "class": itemClassName,

                "data-unique": hashValue

            }).append($("<a/>", {

                "text": self.text()

            }));

            // Adds an HTML anchor tag before the currently traversed HTML element
            self.before($("<div/>", {

                // Sets a name attribute on the anchor tag to the text of the currently traversed HTML element (also making sure that all whitespace is replaced with an underscore)
                "name": hashValue,

                "data-unique": hashValue

            }));

            return item;

        },

        // _generateHashValue
        // ------------------
        //      Generates the hash value that will be used to refer to each item.
        _generateHashValue: function(arr, self, index) {

            var hashValue = "",
                hashGeneratorOption = this.options.hashGenerator;

            if (hashGeneratorOption === "pretty") {

                // prettify the text
                hashValue = self.text().toLowerCase().replace(/\s/g, "-");

                // fix double hyphens
                while (hashValue.indexOf("--") > -1) {
                    hashValue = hashValue.replace(/--/g, "-");
                }

                // fix colon-space instances
                while (hashValue.indexOf(":-") > -1) {
                    hashValue = hashValue.replace(/:-/g, "-");
                }

            } else if (typeof hashGeneratorOption === "function") {

                // call the function
                hashValue = hashGeneratorOption(self.text(), self);

            } else {

                // compact - the default
                hashValue = self.text().replace(/\s/g, "");

            }

            // add the index if we need to
            if (arr.length) { hashValue += ""+index; }

            // return the value
            return hashValue;

        },

        // _appendElements
        // ---------------
        //      Helps create the table of contents list by appending subheader elements

        _appendSubheaders: function(self, ul) {

            // The current element index
            var index = $(this).index(self.options.selectors),

                // Finds the previous header DOM element
                previousHeader = $(self.options.selectors).eq(index - 1),

                currentTagName = +$(this).prop("tagName").charAt(1),

                previousTagName = +previousHeader.prop("tagName").charAt(1),

                lastSubheader;

            // If the current header DOM element is smaller than the previous header DOM element or the first subheader
            if(currentTagName < previousTagName) {

                // Selects the last unordered list HTML found within the HTML element calling the plugin
                self.element.find(subheaderClass + "[data-tag=" + currentTagName + "]").last().append(self._nestElements($(this), index));

            }

            // If the current header DOM element is the same type of header(eg. h4) as the previous header DOM element
            else if(currentTagName === previousTagName) {

                ul.find(itemClass).last().after(self._nestElements($(this), index));

            }

            else {

                // Selects the last unordered list HTML found within the HTML element calling the plugin
                ul.find(itemClass).last().

                // Appends an unorderedList HTML element to the dynamic `unorderedList` variable and sets a common class name
                after($("<ul/>", {

                    "class": subheaderClassName,

                    "data-tag": currentTagName

                })).next(subheaderClass).

                // Appends a list item HTML element to the last unordered list HTML element found within the HTML element calling the plugin
                append(self._nestElements($(this), index));
            }

        },

        // _setEventHandlers
        // ----------------
        //      Adds jQuery event handlers to the newly generated table of contents
        _setEventHandlers: function() {

            // _Local variables_

            // Stores the plugin context in the self variable
            var self = this,

                // Instantiates a new variable that will be used to hold a specific element's context
                $self,

                // Instantiates a new variable that will be used to determine the smoothScroll animation time duration
                duration;

            // Event delegation that looks for any clicks on list item elements inside of the HTML element calling the plugin
            this.element.on("click.tocify", "li", function(event) {

                if(self.options.history) {

                    window.location.hash = $(this).attr("data-unique");

                }

                // Removes highlighting from all of the list item's
                self.element.find("." + self.focusClass).removeClass(self.focusClass);

                // Highlights the current list item that was clicked
                $(this).addClass(self.focusClass);

                // If the showAndHide option is true
                if(self.options.showAndHide) {

                    var elem = $('li[data-unique="' + $(this).attr("data-unique") + '"]');

                    self._triggerShow(elem);

                }

                self._scrollTo($(this));

            });

            // Mouseenter and Mouseleave event handlers for the list item's within the HTML element calling the plugin
            this.element.find("li").on({

                // Mouseenter event handler
                "mouseenter.tocify": function() {

                    // Adds a hover CSS class to the current list item
                    $(this).addClass(self.hoverClass);

                    // Makes sure the cursor is set to the pointer icon
                    $(this).css("cursor", "pointer");

                },

                // Mouseleave event handler
                "mouseleave.tocify": function() {

                    if(self.options.theme !== "bootstrap") {

                        // Removes the hover CSS class from the current list item
                        $(this).removeClass(self.hoverClass);

                    }

                }
            });

            // only attach handler if needed (expensive in IE)
            if (self.options.extendPage || self.options.highlightOnScroll || self.options.scrollHistory || self.options.showAndHideOnScroll)
            {
                // Window scroll event handler
                $(window).on("scroll.tocify", function() {

                    // Once all animations on the page are complete, this callback function will be called
                    $("html, body").promise().done(function() {

                        // Local variables

                        // Stores how far the user has scrolled
                        var winScrollTop = $(window).scrollTop(),

                            // Stores the height of the window
                            winHeight = $(window).height(),

                            // Stores the height of the document
                            docHeight = $(document).height(),

                            scrollHeight = $("body")[0].scrollHeight,

                            // Instantiates a variable that will be used to hold a selected HTML element
                            elem,

                            lastElem,

                            lastElemOffset,

                            currentElem;

                        if(self.options.extendPage) {

                            // If the user has scrolled to the bottom of the page and the last toc item is not focused
                            if((self.webkit && winScrollTop >= scrollHeight - winHeight - self.options.extendPageOffset) || (!self.webkit && winHeight + winScrollTop > docHeight - self.options.extendPageOffset)) {

                                if(!$(extendPageClass).length) {

                                    lastElem = $('div[data-unique="' + $(itemClass).last().attr("data-unique") + '"]');

                                    if(!lastElem.length) return;

                                    // Gets the top offset of the page header that is linked to the last toc item
                                    lastElemOffset = lastElem.offset().top;

                                    // Appends a div to the bottom of the page and sets the height to the difference of the window scrollTop and the last element's position top offset
                                    $(self.options.context).append($("<div />", {

                                        "class": extendPageClassName,

                                        "height": Math.abs(lastElemOffset - winScrollTop) + "px",

                                        "data-unique": extendPageClassName

                                    }));

                                    if(self.extendPageScroll) {

                                        currentElem = self.element.find('li.active');

                                        self._scrollTo($('div[data-unique="' + currentElem.attr("data-unique") + '"]'));

                                    }

                                }

                            }

                        }

                        // The zero timeout ensures the following code is run after the scroll events
                        setTimeout(function() {

                            // _Local variables_

                            // Stores the distance to the closest anchor
                            var closestAnchorDistance = null,

                                // Stores the index of the closest anchor
                                closestAnchorIdx = null,

                                // Keeps a reference to all anchors
                                anchors = $(self.options.context).find("div[data-unique]"),

                                anchorText;

                            // Determines the index of the closest anchor
                            anchors.each(function(idx) {
                                var distance = Math.abs(($(this).next().length ? $(this).next() : $(this)).offset().top - winScrollTop - self.options.highlightOffset);
                                if (closestAnchorDistance == null || distance < closestAnchorDistance) {
                                    closestAnchorDistance = distance;
                                    closestAnchorIdx = idx;
                                } else {
                                    return false;
                                }
                            });

                            anchorText = $(anchors[closestAnchorIdx]).attr("data-unique");

                            // Stores the list item HTML element that corresponds to the currently traversed anchor tag
                            elem = $('li[data-unique="' + anchorText + '"]');

                            // If the `highlightOnScroll` option is true and a next element is found
                            if(self.options.highlightOnScroll && elem.length) {

                                // Removes highlighting from all of the list item's
                                self.element.find("." + self.focusClass).removeClass(self.focusClass);

                                // Highlights the corresponding list item
                                elem.addClass(self.focusClass);

                            }

                            if(self.options.scrollHistory) {

                                if(window.location.hash !== "#" + anchorText) {

                                    window.location.replace("#" + anchorText);

                                }
                            }

                            // If the `showAndHideOnScroll` option is true
                            if(self.options.showAndHideOnScroll && self.options.showAndHide) {

                                self._triggerShow(elem, true);

                            }

                        }, 0);

                    });

                });
            }

        },

        // Show
        // ----
        //      Opens the current sub-header
        show: function(elem, scroll) {

            // Stores the plugin context in the `self` variable
            var self = this,
                element = elem;

            // If the sub-header is not already visible
            if (!elem.is(":visible")) {

                // If the current element does not have any nested subheaders, is not a header, and its parent is not visible
                if(!elem.find(subheaderClass).length && !elem.parent().is(headerClass) && !elem.parent().is(":visible")) {

                    // Sets the current element to all of the subheaders within the current header
                    elem = elem.parents(subheaderClass).add(elem);

                }

                // If the current element does not have any nested subheaders and is not a header
                else if(!elem.children(subheaderClass).length && !elem.parent().is(headerClass)) {

                    // Sets the current element to the closest subheader
                    elem = elem.closest(subheaderClass);

                }

                //Determines what jQuery effect to use
                switch (self.options.showEffect) {

                    //Uses `no effect`
                    case "none":

                        elem.show();

                        break;

                    //Uses the jQuery `show` special effect
                    case "show":

                        elem.show(self.options.showEffectSpeed);

                        break;

                    //Uses the jQuery `slideDown` special effect
                    case "slideDown":

                        elem.slideDown(self.options.showEffectSpeed);

                        break;

                    //Uses the jQuery `fadeIn` special effect
                    case "fadeIn":

                        elem.fadeIn(self.options.showEffectSpeed);

                        break;

                    //If none of the above options were passed, then a `jQueryUI show effect` is expected
                    default:

                        elem.show();

                        break;

                }

            }

            // If the current subheader parent element is a header
            if(elem.parent().is(headerClass)) {

                // Hides all non-active sub-headers
                self.hide($(subheaderClass).not(elem));

            }

            // If the current subheader parent element is not a header
            else {

                // Hides all non-active sub-headers
                self.hide($(subheaderClass).not(elem.closest(headerClass).find(subheaderClass).not(elem.siblings())));

            }

            // Maintains chainablity
            return self;

        },

        // Hide
        // ----
        //      Closes the current sub-header
        hide: function(elem) {

            // Stores the plugin context in the `self` variable
            var self = this;

            //Determines what jQuery effect to use
            switch (self.options.hideEffect) {

                // Uses `no effect`
                case "none":

                    elem.hide();

                    break;

                // Uses the jQuery `hide` special effect
                case "hide":

                    elem.hide(self.options.hideEffectSpeed);

                    break;

                // Uses the jQuery `slideUp` special effect
                case "slideUp":

                    elem.slideUp(self.options.hideEffectSpeed);

                    break;

                // Uses the jQuery `fadeOut` special effect
                case "fadeOut":

                    elem.fadeOut(self.options.hideEffectSpeed);

                    break;

                // If none of the above options were passed, then a `jqueryUI hide effect` is expected
                default:

                    elem.hide();

                    break;

            }

            // Maintains chainablity
            return self;
        },

        // _triggerShow
        // ------------
        //      Determines what elements get shown on scroll and click
        _triggerShow: function(elem, scroll) {

            var self = this;

            // If the current element's parent is a header element or the next element is a nested subheader element
            if(elem.parent().is(headerClass) || elem.next().is(subheaderClass)) {

                // Shows the next sub-header element
                self.show(elem.next(subheaderClass), scroll);

            }

            // If the current element's parent is a subheader element
            else if(elem.parent().is(subheaderClass)) {

                // Shows the parent sub-header element
                self.show(elem.parent(), scroll);

            }

            // Maintains chainability
            return self;

        },

        // _addCSSClasses
        // --------------
        //      Adds CSS classes to the newly generated table of contents HTML
        _addCSSClasses: function() {

            // If the user wants a jqueryUI theme
            if(this.options.theme === "jqueryui") {

                this.focusClass = "ui-state-default";

                this.hoverClass = "ui-state-hover";

                //Adds the default styling to the dropdown list
                this.element.addClass("ui-widget").find(".toc-title").addClass("ui-widget-header").end().find("li").addClass("ui-widget-content");

            }

            // If the user wants a twitterBootstrap theme
            else if(this.options.theme === "bootstrap") {

                this.element.find(headerClass + "," + subheaderClass).addClass("nav nav-list");

                this.focusClass = "active";

            }

            // If a user does not want a prebuilt theme
            else {

                // Adds more neutral classes (instead of jqueryui)

                this.focusClass = tocFocusClassName;

                this.hoverClass = tocHoverClassName;

            }

            //Maintains chainability
            return this;

        },

        // setOption
        // ---------
        //      Sets a single Tocify option after the plugin is invoked
        setOption: function() {

            // Calls the jQueryUI Widget Factory setOption method
            $.Widget.prototype._setOption.apply(this, arguments);

        },

        // setOptions
        // ----------
        //      Sets a single or multiple Tocify options after the plugin is invoked
        setOptions: function() {

            // Calls the jQueryUI Widget Factory setOptions method
            $.Widget.prototype._setOptions.apply(this, arguments);

        },

        // _scrollTo
        // ---------
        //      Scrolls to a specific element
        _scrollTo: function(elem) {

            var self = this,
                duration = self.options.smoothScroll || 0,
                scrollTo = self.options.scrollTo,
                currentDiv = $('div[data-unique="' + elem.attr("data-unique") + '"]');

            if(!currentDiv.length) {

                return self;

            }

            // Once all animations on the page are complete, this callback function will be called
            $("html, body").promise().done(function() {

                // Animates the html and body element scrolltops
                $("html, body").animate({

                    // Sets the jQuery `scrollTop` to the top offset of the HTML div tag that matches the current list item's `data-unique` tag
                    "scrollTop": currentDiv.offset().top - ($.isFunction(scrollTo) ? scrollTo.call() : scrollTo) + "px"

                }, {

                    // Sets the smoothScroll animation time duration to the smoothScrollSpeed option
                    "duration": duration

                });

            });

            // Maintains chainability
            return self;

        }

    });

})); //end of plugin

/*!
 * sweetalert2 v6.4.2
 * Released under the MIT License.
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
            (global.Sweetalert2 = factory());
}(this, (function () { 'use strict';

    var defaultParams = {
        title: '',
        titleText: '',
        text: '',
        html: '',
        type: null,
        customClass: '',
        target: 'body',
        animation: true,
        allowOutsideClick: true,
        allowEscapeKey: true,
        allowEnterKey: true,
        showConfirmButton: true,
        showCancelButton: false,
        preConfirm: null,
        confirmButtonText: 'OK',
        confirmButtonColor: '#8CD4F5',
        confirmButtonClass: null,
        cancelButtonText: 'Cancel',
        cancelButtonColor: '#C1C1C1',
        cancelButtonClass: null,
        buttonsStyling: true,
        reverseButtons: false,
        focusCancel: false,
        showCloseButton: false,
        showLoaderOnConfirm: false,
        imageUrl: null,
        imageWidth: null,
        imageHeight: null,
        imageClass: null,
        timer: null,
        width: 500,
        padding: 20,
        background: '#fff',
        input: null,
        inputPlaceholder: '',
        inputValue: '',
        inputOptions: {},
        inputAutoTrim: true,
        inputClass: null,
        inputAttributes: {},
        inputValidator: null,
        progressSteps: [],
        currentProgressStep: null,
        progressStepsDistance: '40px',
        onOpen: null,
        onClose: null
    };

    var swalPrefix = 'swal2-';

    var prefix = function prefix(items) {
        var result = {};
        for (var i in items) {
            result[items[i]] = swalPrefix + items[i];
        }
        return result;
    };

    var swalClasses = prefix(['container', 'shown', 'iosfix', 'modal', 'overlay', 'fade', 'show', 'hide', 'noanimation', 'close', 'title', 'content', 'spacer', 'confirm', 'cancel', 'icon', 'image', 'input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea', 'inputerror', 'validationerror', 'progresssteps', 'activeprogressstep', 'progresscircle', 'progressline', 'loading', 'styled']);

    var iconTypes = prefix(['success', 'warning', 'info', 'question', 'error']);

    /*
 * Set hover, active and focus-states for buttons (source: http://www.sitepoint.com/javascript-generate-lighter-darker-color)
 */
    var colorLuminance = function colorLuminance(hex, lum) {
        // Validate hex string
        hex = String(hex).replace(/[^0-9a-f]/gi, '');
        if (hex.length < 6) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        lum = lum || 0;

        // Convert to decimal and change luminosity
        var rgb = '#';
        for (var i = 0; i < 3; i++) {
            var c = parseInt(hex.substr(i * 2, 2), 16);
            c = Math.round(Math.min(Math.max(0, c + c * lum), 255)).toString(16);
            rgb += ('00' + c).substr(c.length);
        }

        return rgb;
    };

    /* global MouseEvent */

// Remember state in cases where opening and handling a modal will fiddle with it.
    var states = {
        previousWindowKeyDown: null,
        previousActiveElement: null,
        previousBodyPadding: null
    };

    /*
 * Add modal + overlay to DOM
 */
    var init = function init(params) {
        if (typeof document === 'undefined') {
            console.error('SweetAlert2 requires document to initialize');
            return;
        }

        var container = document.createElement('div');
        container.className = swalClasses.container;
        container.innerHTML = sweetHTML;

        var targetElement = document.querySelector(params.target);
        if (!targetElement) {
            console.warn('SweetAlert2: Can\'t find the target "' + params.target + '"');
            targetElement = document.body;
        }
        targetElement.appendChild(container);

        var modal = getModal();
        var input = getChildByClass(modal, swalClasses.input);
        var file = getChildByClass(modal, swalClasses.file);
        var range = modal.querySelector('.' + swalClasses.range + ' input');
        var rangeOutput = modal.querySelector('.' + swalClasses.range + ' output');
        var select = getChildByClass(modal, swalClasses.select);
        var checkbox = modal.querySelector('.' + swalClasses.checkbox + ' input');
        var textarea = getChildByClass(modal, swalClasses.textarea);

        input.oninput = function () {
            sweetAlert.resetValidationError();
        };

        input.onkeydown = function (event) {
            setTimeout(function () {
                if (event.keyCode === 13 && params.allowEnterKey) {
                    event.stopPropagation();
                    sweetAlert.clickConfirm();
                }
            }, 0);
        };

        file.onchange = function () {
            sweetAlert.resetValidationError();
        };

        range.oninput = function () {
            sweetAlert.resetValidationError();
            rangeOutput.value = range.value;
        };

        range.onchange = function () {
            sweetAlert.resetValidationError();
            range.previousSibling.value = range.value;
        };

        select.onchange = function () {
            sweetAlert.resetValidationError();
        };

        checkbox.onchange = function () {
            sweetAlert.resetValidationError();
        };

        textarea.oninput = function () {
            sweetAlert.resetValidationError();
        };

        return modal;
    };

    /*
 * Manipulate DOM
 */

    var sweetHTML = ('\n <div  role="dialog" aria-labelledby="modalTitleId" aria-describedby="modalContentId" class="' + swalClasses.modal + '" tabIndex="-1" >\n   <ul class="' + swalClasses.progresssteps + '"></ul>\n   <div class="' + swalClasses.icon + ' ' + iconTypes.error + '">\n     <span class="x-mark"><span class="line left"></span><span class="line right"></span></span>\n   </div>\n   <div class="' + swalClasses.icon + ' ' + iconTypes.question + '">?</div>\n   <div class="' + swalClasses.icon + ' ' + iconTypes.warning + '">!</div>\n   <div class="' + swalClasses.icon + ' ' + iconTypes.info + '">i</div>\n   <div class="' + swalClasses.icon + ' ' + iconTypes.success + '">\n     <span class="line tip"></span> <span class="line long"></span>\n     <div class="placeholder"></div> <div class="fix"></div>\n   </div>\n   <img class="' + swalClasses.image + '">\n   <h2 class="' + swalClasses.title + '" id="modalTitleId"></h2>\n   <div id="modalContentId" class="' + swalClasses.content + '"></div>\n   <input class="' + swalClasses.input + '">\n   <input type="file" class="' + swalClasses.file + '">\n   <div class="' + swalClasses.range + '">\n     <output></output>\n     <input type="range">\n   </div>\n   <select class="' + swalClasses.select + '"></select>\n   <div class="' + swalClasses.radio + '"></div>\n   <label for="' + swalClasses.checkbox + '" class="' + swalClasses.checkbox + '">\n     <input type="checkbox">\n   </label>\n   <textarea class="' + swalClasses.textarea + '"></textarea>\n   <div class="' + swalClasses.validationerror + '"></div>\n   <hr class="' + swalClasses.spacer + '">\n   <button type="button" role="button" tabIndex="0" class="' + swalClasses.confirm + '">OK</button>\n   <button type="button" role="button" tabIndex="0" class="' + swalClasses.cancel + '">Cancel</button>\n   <span class="' + swalClasses.close + '">&times;</span>\n </div>\n').replace(/(^|\n)\s*/g, '');

    var getContainer = function getContainer() {
        return document.body.querySelector('.' + swalClasses.container);
    };

    var getModal = function getModal() {
        return getContainer() ? getContainer().querySelector('.' + swalClasses.modal) : null;
    };

    var getIcons = function getIcons() {
        var modal = getModal();
        return modal.querySelectorAll('.' + swalClasses.icon);
    };

    var elementByClass = function elementByClass(className) {
        return getContainer() ? getContainer().querySelector('.' + className) : null;
    };

    var getTitle = function getTitle() {
        return elementByClass(swalClasses.title);
    };

    var getContent = function getContent() {
        return elementByClass(swalClasses.content);
    };

    var getImage = function getImage() {
        return elementByClass(swalClasses.image);
    };

    var getSpacer = function getSpacer() {
        return elementByClass(swalClasses.spacer);
    };

    var getProgressSteps = function getProgressSteps() {
        return elementByClass(swalClasses.progresssteps);
    };

    var getValidationError = function getValidationError() {
        return elementByClass(swalClasses.validationerror);
    };

    var getConfirmButton = function getConfirmButton() {
        return elementByClass(swalClasses.confirm);
    };

    var getCancelButton = function getCancelButton() {
        return elementByClass(swalClasses.cancel);
    };

    var getCloseButton = function getCloseButton() {
        return elementByClass(swalClasses.close);
    };

    var getFocusableElements = function getFocusableElements(focusCancel) {
        var buttons = [getConfirmButton(), getCancelButton()];
        if (focusCancel) {
            buttons.reverse();
        }
        return buttons.concat(Array.prototype.slice.call(getModal().querySelectorAll('button:not([class^=' + swalPrefix + ']), input:not([type=hidden]), textarea, select')));
    };

    var hasClass = function hasClass(elem, className) {
        if (elem.classList) {
            return elem.classList.contains(className);
        }
        return false;
    };

    var focusInput = function focusInput(input) {
        input.focus();

        // place cursor at end of text in text input
        if (input.type !== 'file') {
            // http://stackoverflow.com/a/2345915/1331425
            var val = input.value;
            input.value = '';
            input.value = val;
        }
    };

    var addClass = function addClass(elem, className) {
        if (!elem || !className) {
            return;
        }
        var classes = className.split(/\s+/).filter(Boolean);
        classes.forEach(function (className) {
            elem.classList.add(className);
        });
    };

    var removeClass = function removeClass(elem, className) {
        if (!elem || !className) {
            return;
        }
        var classes = className.split(/\s+/).filter(Boolean);
        classes.forEach(function (className) {
            elem.classList.remove(className);
        });
    };

    var getChildByClass = function getChildByClass(elem, className) {
        for (var i = 0; i < elem.childNodes.length; i++) {
            if (hasClass(elem.childNodes[i], className)) {
                return elem.childNodes[i];
            }
        }
    };

    var show = function show(elem, display) {
        if (!display) {
            display = 'block';
        }
        elem.style.opacity = '';
        elem.style.display = display;
    };

    var hide = function hide(elem) {
        elem.style.opacity = '';
        elem.style.display = 'none';
    };

    var empty = function empty(elem) {
        while (elem.firstChild) {
            elem.removeChild(elem.firstChild);
        }
    };

// borrowed from jqeury $(elem).is(':visible') implementation
    var isVisible = function isVisible(elem) {
        return elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length;
    };

    var removeStyleProperty = function removeStyleProperty(elem, property) {
        if (elem.style.removeProperty) {
            elem.style.removeProperty(property);
        } else {
            elem.style.removeAttribute(property);
        }
    };

    var fireClick = function fireClick(node) {
        if (!isVisible(node)) {
            return false;
        }

        // Taken from http://www.nonobtrusive.com/2011/11/29/programatically-fire-crossbrowser-click-event-with-javascript/
        // Then fixed for today's Chrome browser.
        if (typeof MouseEvent === 'function') {
            // Up-to-date approach
            var mevt = new MouseEvent('click', {
                view: window,
                bubbles: false,
                cancelable: true
            });
            node.dispatchEvent(mevt);
        } else if (document.createEvent) {
            // Fallback
            var evt = document.createEvent('MouseEvents');
            evt.initEvent('click', false, false);
            node.dispatchEvent(evt);
        } else if (document.createEventObject) {
            node.fireEvent('onclick');
        } else if (typeof node.onclick === 'function') {
            node.onclick();
        }
    };

    var animationEndEvent = function () {
        var testEl = document.createElement('div');
        var transEndEventNames = {
            'WebkitAnimation': 'webkitAnimationEnd',
            'OAnimation': 'oAnimationEnd oanimationend',
            'msAnimation': 'MSAnimationEnd',
            'animation': 'animationend'
        };
        for (var i in transEndEventNames) {
            if (transEndEventNames.hasOwnProperty(i) && testEl.style[i] !== undefined) {
                return transEndEventNames[i];
            }
        }

        return false;
    }();

// Reset previous window keydown handler and focued element
    var resetPrevState = function resetPrevState() {
        window.onkeydown = states.previousWindowKeyDown;
        if (states.previousActiveElement && states.previousActiveElement.focus) {
            var x = window.scrollX;
            var y = window.scrollY;
            states.previousActiveElement.focus();
            if (x && y) {
                // IE has no scrollX/scrollY support
                window.scrollTo(x, y);
            }
        }
    };

// Measure width of scrollbar
// https://github.com/twbs/bootstrap/blob/master/js/modal.js#L279-L286
    var measureScrollbar = function measureScrollbar() {
        var supportsTouch = 'ontouchstart' in window || navigator.msMaxTouchPoints;
        if (supportsTouch) {
            return 0;
        }
        var scrollDiv = document.createElement('div');
        scrollDiv.style.width = '50px';
        scrollDiv.style.height = '50px';
        scrollDiv.style.overflow = 'scroll';
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
    };

// JavaScript Debounce Function
// Simplivied version of https://davidwalsh.name/javascript-debounce-function
    var debounce = function debounce(func, wait) {
        var timeout = void 0;
        return function () {
            var later = function later() {
                timeout = null;
                func();
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    };

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };





















    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    var modalParams = _extends({}, defaultParams);
    var queue = [];
    var swal2Observer = void 0;

    /*
 * Set type, text and actions on modal
 */
    var setParameters = function setParameters(params) {
        var modal = getModal() || init(params);

        for (var param in params) {
            if (!defaultParams.hasOwnProperty(param) && param !== 'extraParams') {
                console.warn('SweetAlert2: Unknown parameter "' + param + '"');
            }
        }

        // set modal width and margin-left
        modal.style.width = typeof params.width === 'number' ? params.width + 'px' : params.width;

        modal.style.padding = params.padding + 'px';
        modal.style.background = params.background;

        var title = getTitle();
        var content = getContent();
        var confirmButton = getConfirmButton();
        var cancelButton = getCancelButton();
        var closeButton = getCloseButton();

        // Title
        if (params.titleText) {
            title.innerText = params.titleText;
        } else {
            title.innerHTML = params.title.split('\n').join('<br>');
        }

        // Content
        if (params.text || params.html) {
            if (_typeof(params.html) === 'object') {
                content.innerHTML = '';
                if (0 in params.html) {
                    for (var i = 0; i in params.html; i++) {
                        content.appendChild(params.html[i].cloneNode(true));
                    }
                } else {
                    content.appendChild(params.html.cloneNode(true));
                }
            } else if (params.html) {
                content.innerHTML = params.html;
            } else if (params.text) {
                content.textContent = params.text;
            }
            show(content);
        } else {
            hide(content);
        }

        // Close button
        if (params.showCloseButton) {
            show(closeButton);
        } else {
            hide(closeButton);
        }

        // Custom Class
        modal.className = swalClasses.modal;
        if (params.customClass) {
            addClass(modal, params.customClass);
        }

        // Progress steps
        var progressStepsContainer = getProgressSteps();
        var currentProgressStep = parseInt(params.currentProgressStep === null ? sweetAlert.getQueueStep() : params.currentProgressStep, 10);
        if (params.progressSteps.length) {
            show(progressStepsContainer);
            empty(progressStepsContainer);
            if (currentProgressStep >= params.progressSteps.length) {
                console.warn('SweetAlert2: Invalid currentProgressStep parameter, it should be less than progressSteps.length ' + '(currentProgressStep like JS arrays starts from 0)');
            }
            params.progressSteps.forEach(function (step, index) {
                var circle = document.createElement('li');
                addClass(circle, swalClasses.progresscircle);
                circle.innerHTML = step;
                if (index === currentProgressStep) {
                    addClass(circle, swalClasses.activeprogressstep);
                }
                progressStepsContainer.appendChild(circle);
                if (index !== params.progressSteps.length - 1) {
                    var line = document.createElement('li');
                    addClass(line, swalClasses.progressline);
                    line.style.width = params.progressStepsDistance;
                    progressStepsContainer.appendChild(line);
                }
            });
        } else {
            hide(progressStepsContainer);
        }

        // Icon
        var icons = getIcons();
        for (var _i = 0; _i < icons.length; _i++) {
            hide(icons[_i]);
        }
        if (params.type) {
            var validType = false;
            for (var iconType in iconTypes) {
                if (params.type === iconType) {
                    validType = true;
                    break;
                }
            }
            if (!validType) {
                console.error('SweetAlert2: Unknown alert type: ' + params.type);
                return false;
            }
            var icon = modal.querySelector('.' + swalClasses.icon + '.' + iconTypes[params.type]);
            show(icon);

            // Animate icon
            switch (params.type) {
                case 'success':
                    addClass(icon, 'animate');
                    addClass(icon.querySelector('.tip'), 'animate-success-tip');
                    addClass(icon.querySelector('.long'), 'animate-success-long');
                    break;
                case 'error':
                    addClass(icon, 'animate-error-icon');
                    addClass(icon.querySelector('.x-mark'), 'animate-x-mark');
                    break;
                case 'warning':
                    addClass(icon, 'pulse-warning');
                    break;
                default:
                    break;
            }
        }

        // Custom image
        var image = getImage();
        if (params.imageUrl) {
            image.setAttribute('src', params.imageUrl);
            show(image);

            if (params.imageWidth) {
                image.setAttribute('width', params.imageWidth);
            } else {
                image.removeAttribute('width');
            }

            if (params.imageHeight) {
                image.setAttribute('height', params.imageHeight);
            } else {
                image.removeAttribute('height');
            }

            image.className = swalClasses.image;
            if (params.imageClass) {
                addClass(image, params.imageClass);
            }
        } else {
            hide(image);
        }

        // Cancel button
        if (params.showCancelButton) {
            cancelButton.style.display = 'inline-block';
        } else {
            hide(cancelButton);
        }

        // Confirm button
        if (params.showConfirmButton) {
            removeStyleProperty(confirmButton, 'display');
        } else {
            hide(confirmButton);
        }

        // Buttons spacer
        var spacer = getSpacer();
        if (!params.showConfirmButton && !params.showCancelButton) {
            hide(spacer);
        } else {
            show(spacer);
        }

        // Edit text on cancel and confirm buttons
        confirmButton.innerHTML = params.confirmButtonText;
        cancelButton.innerHTML = params.cancelButtonText;

        // Set buttons to selected background colors
        if (params.buttonsStyling) {
            confirmButton.style.backgroundColor = params.confirmButtonColor;
            cancelButton.style.backgroundColor = params.cancelButtonColor;
        }

        // Add buttons custom classes
        confirmButton.className = swalClasses.confirm;
        addClass(confirmButton, params.confirmButtonClass);
        cancelButton.className = swalClasses.cancel;
        addClass(cancelButton, params.cancelButtonClass);

        // Buttons styling
        if (params.buttonsStyling) {
            addClass(confirmButton, swalClasses.styled);
            addClass(cancelButton, swalClasses.styled);
        } else {
            removeClass(confirmButton, swalClasses.styled);
            removeClass(cancelButton, swalClasses.styled);

            confirmButton.style.backgroundColor = confirmButton.style.borderLeftColor = confirmButton.style.borderRightColor = '';
            cancelButton.style.backgroundColor = cancelButton.style.borderLeftColor = cancelButton.style.borderRightColor = '';
        }

        // CSS animation
        if (params.animation === true) {
            removeClass(modal, swalClasses.noanimation);
        } else {
            addClass(modal, swalClasses.noanimation);
        }
    };

    /*
 * Animations
 */
    var openModal = function openModal(animation, onComplete) {
        var container = getContainer();
        var modal = getModal();

        if (animation) {
            addClass(modal, swalClasses.show);
            addClass(container, swalClasses.fade);
            removeClass(modal, swalClasses.hide);
        } else {
            removeClass(modal, swalClasses.fade);
        }
        show(modal);

        // scrolling is 'hidden' until animation is done, after that 'auto'
        container.style.overflowY = 'hidden';
        if (animationEndEvent && !hasClass(modal, swalClasses.noanimation)) {
            modal.addEventListener(animationEndEvent, function swalCloseEventFinished() {
                modal.removeEventListener(animationEndEvent, swalCloseEventFinished);
                container.style.overflowY = 'auto';
            });
        } else {
            container.style.overflowY = 'auto';
        }

        addClass(document.documentElement, swalClasses.shown);
        addClass(document.body, swalClasses.shown);
        addClass(container, swalClasses.shown);
        fixScrollbar();
        iOSfix();
        states.previousActiveElement = document.activeElement;
        if (onComplete !== null && typeof onComplete === 'function') {
            setTimeout(function () {
                onComplete(modal);
            });
        }
    };

    var fixScrollbar = function fixScrollbar() {
        // for queues, do not do this more than once
        if (states.previousBodyPadding !== null) {
            return;
        }
        // if the body has overflow
        if (document.body.scrollHeight > window.innerHeight) {
            // add padding so the content doesn't shift after removal of scrollbar
            states.previousBodyPadding = document.body.style.paddingRight;
            document.body.style.paddingRight = measureScrollbar() + 'px';
        }
    };

    var undoScrollbar = function undoScrollbar() {
        if (states.previousBodyPadding !== null) {
            document.body.style.paddingRight = states.previousBodyPadding;
            states.previousBodyPadding = null;
        }
    };

// Fix iOS scrolling http://stackoverflow.com/q/39626302/1331425
    var iOSfix = function iOSfix() {
        var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        if (iOS && !hasClass(document.body, swalClasses.iosfix)) {
            var offset = document.body.scrollTop;
            document.body.style.top = offset * -1 + 'px';
            addClass(document.body, swalClasses.iosfix);
        }
    };

    var undoIOSfix = function undoIOSfix() {
        if (hasClass(document.body, swalClasses.iosfix)) {
            var offset = parseInt(document.body.style.top, 10);
            removeClass(document.body, swalClasses.iosfix);
            document.body.style.top = '';
            document.body.scrollTop = offset * -1;
        }
    };

// SweetAlert entry point
    var sweetAlert = function sweetAlert() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        if (args[0] === undefined) {
            console.error('SweetAlert2 expects at least 1 attribute!');
            return false;
        }

        var params = _extends({}, modalParams);

        switch (_typeof(args[0])) {
            case 'string':
                params.title = args[0];
                params.html = args[1];
                params.type = args[2];

                break;

            case 'object':
                _extends(params, args[0]);
                params.extraParams = args[0].extraParams;

                if (params.input === 'email' && params.inputValidator === null) {
                    params.inputValidator = function (email) {
                        return new Promise(function (resolve, reject) {
                            var emailRegex = /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
                            if (emailRegex.test(email)) {
                                resolve();
                            } else {
                                reject('Invalid email address');
                            }
                        });
                    };
                }
                break;

            default:
                console.error('SweetAlert2: Unexpected type of argument! Expected "string" or "object", got ' + _typeof(args[0]));
                return false;
        }

        setParameters(params);

        var container = getContainer();
        var modal = getModal();

        return new Promise(function (resolve, reject) {
            // Close on timer
            if (params.timer) {
                modal.timeout = setTimeout(function () {
                    sweetAlert.closeModal(params.onClose);
                    reject('timer');
                }, params.timer);
            }

            // Get input element by specified type or, if type isn't specified, by params.input
            var getInput = function getInput(inputType) {
                inputType = inputType || params.input;
                if (!inputType) {
                    return null;
                }
                switch (inputType) {
                    case 'select':
                    case 'textarea':
                    case 'file':
                        return getChildByClass(modal, swalClasses[inputType]);
                    case 'checkbox':
                        return modal.querySelector('.' + swalClasses.checkbox + ' input');
                    case 'radio':
                        return modal.querySelector('.' + swalClasses.radio + ' input:checked') || modal.querySelector('.' + swalClasses.radio + ' input:first-child');
                    case 'range':
                        return modal.querySelector('.' + swalClasses.range + ' input');
                    default:
                        return getChildByClass(modal, swalClasses.input);
                }
            };

            // Get the value of the modal input
            var getInputValue = function getInputValue() {
                var input = getInput();
                if (!input) {
                    return null;
                }
                switch (params.input) {
                    case 'checkbox':
                        return input.checked ? 1 : 0;
                    case 'radio':
                        return input.checked ? input.value : null;
                    case 'file':
                        return input.files.length ? input.files[0] : null;
                    default:
                        return params.inputAutoTrim ? input.value.trim() : input.value;
                }
            };

            // input autofocus
            if (params.input) {
                setTimeout(function () {
                    var input = getInput();
                    if (input) {
                        focusInput(input);
                    }
                }, 0);
            }

            var confirm = function confirm(value) {
                if (params.showLoaderOnConfirm) {
                    sweetAlert.showLoading();
                }

                if (params.preConfirm) {
                    params.preConfirm(value, params.extraParams).then(function (preConfirmValue) {
                        sweetAlert.closeModal(params.onClose);
                        resolve(preConfirmValue || value);
                    }, function (error) {
                        sweetAlert.hideLoading();
                        if (error) {
                            sweetAlert.showValidationError(error);
                        }
                    });
                } else {
                    sweetAlert.closeModal(params.onClose);
                    resolve(value);
                }
            };

            // Mouse interactions
            var onButtonEvent = function onButtonEvent(event) {
                var e = event || window.event;
                var target = e.target || e.srcElement;
                var confirmButton = getConfirmButton();
                var cancelButton = getCancelButton();
                var targetedConfirm = confirmButton === target || confirmButton.contains(target);
                var targetedCancel = cancelButton === target || cancelButton.contains(target);

                switch (e.type) {
                    case 'mouseover':
                    case 'mouseup':
                        if (params.buttonsStyling) {
                            if (targetedConfirm) {
                                confirmButton.style.backgroundColor = colorLuminance(params.confirmButtonColor, -0.1);
                            } else if (targetedCancel) {
                                cancelButton.style.backgroundColor = colorLuminance(params.cancelButtonColor, -0.1);
                            }
                        }
                        break;
                    case 'mouseout':
                        if (params.buttonsStyling) {
                            if (targetedConfirm) {
                                confirmButton.style.backgroundColor = params.confirmButtonColor;
                            } else if (targetedCancel) {
                                cancelButton.style.backgroundColor = params.cancelButtonColor;
                            }
                        }
                        break;
                    case 'mousedown':
                        if (params.buttonsStyling) {
                            if (targetedConfirm) {
                                confirmButton.style.backgroundColor = colorLuminance(params.confirmButtonColor, -0.2);
                            } else if (targetedCancel) {
                                cancelButton.style.backgroundColor = colorLuminance(params.cancelButtonColor, -0.2);
                            }
                        }
                        break;
                    case 'click':
                        // Clicked 'confirm'
                        if (targetedConfirm && sweetAlert.isVisible()) {
                            sweetAlert.disableButtons();
                            if (params.input) {
                                (function () {
                                    var inputValue = getInputValue();

                                    if (params.inputValidator) {
                                        sweetAlert.disableInput();
                                        params.inputValidator(inputValue, params.extraParams).then(function () {
                                            sweetAlert.enableButtons();
                                            sweetAlert.enableInput();
                                            confirm(inputValue);
                                        }, function (error) {
                                            sweetAlert.enableButtons();
                                            sweetAlert.enableInput();
                                            if (error) {
                                                sweetAlert.showValidationError(error);
                                            }
                                        });
                                    } else {
                                        confirm(inputValue);
                                    }
                                })();
                            } else {
                                confirm(true);
                            }

                            // Clicked 'cancel'
                        } else if (targetedCancel && sweetAlert.isVisible()) {
                            sweetAlert.disableButtons();
                            sweetAlert.closeModal(params.onClose);
                            reject('cancel');
                        }
                        break;
                    default:
                }
            };

            var buttons = modal.querySelectorAll('button');
            for (var i = 0; i < buttons.length; i++) {
                buttons[i].onclick = onButtonEvent;
                buttons[i].onmouseover = onButtonEvent;
                buttons[i].onmouseout = onButtonEvent;
                buttons[i].onmousedown = onButtonEvent;
            }

            // Closing modal by close button
            getCloseButton().onclick = function () {
                sweetAlert.closeModal(params.onClose);
                reject('close');
            };

            // Closing modal by overlay click
            container.onclick = function (e) {
                if (e.target !== container) {
                    return;
                }
                if (params.allowOutsideClick) {
                    sweetAlert.closeModal(params.onClose);
                    reject('overlay');
                }
            };

            var confirmButton = getConfirmButton();
            var cancelButton = getCancelButton();

            // Reverse buttons (Confirm on the right side)
            if (params.reverseButtons) {
                confirmButton.parentNode.insertBefore(cancelButton, confirmButton);
            } else {
                confirmButton.parentNode.insertBefore(confirmButton, cancelButton);
            }

            // Focus handling
            var setFocus = function setFocus(index, increment) {
                var focusableElements = getFocusableElements(params.focusCancel);
                // search for visible elements and select the next possible match
                for (var _i2 = 0; _i2 < focusableElements.length; _i2++) {
                    index = index + increment;

                    // rollover to first item
                    if (index === focusableElements.length) {
                        index = 0;

                        // go to last item
                    } else if (index === -1) {
                        index = focusableElements.length - 1;
                    }

                    // determine if element is visible
                    var el = focusableElements[index];
                    if (isVisible(el)) {
                        return el.focus();
                    }
                }
            };

            var handleKeyDown = function handleKeyDown(event) {
                var e = event || window.event;
                var keyCode = e.keyCode || e.which;

                if ([9, 13, 32, 27].indexOf(keyCode) === -1) {
                    // Don't do work on keys we don't care about.
                    return;
                }

                var targetElement = e.target || e.srcElement;

                var focusableElements = getFocusableElements(params.focusCancel);
                var btnIndex = -1; // Find the button - note, this is a nodelist, not an array.
                for (var _i3 = 0; _i3 < focusableElements.length; _i3++) {
                    if (targetElement === focusableElements[_i3]) {
                        btnIndex = _i3;
                        break;
                    }
                }

                // TAB
                if (keyCode === 9) {
                    if (!e.shiftKey) {
                        // Cycle to the next button
                        setFocus(btnIndex, 1);
                    } else {
                        // Cycle to the prev button
                        setFocus(btnIndex, -1);
                    }
                    e.stopPropagation();
                    e.preventDefault();

                    // ENTER/SPACE
                } else if (keyCode === 13 || keyCode === 32) {
                    if (btnIndex === -1 && params.allowEnterKey) {
                        // ENTER/SPACE clicked outside of a button.
                        if (params.focusCancel) {
                            fireClick(cancelButton, e);
                        } else {
                            fireClick(confirmButton, e);
                        }
                    }
                    // ESC
                } else if (keyCode === 27 && params.allowEscapeKey === true) {
                    sweetAlert.closeModal(params.onClose);
                    reject('esc');
                }
            };

            states.previousWindowKeyDown = window.onkeydown;
            window.onkeydown = handleKeyDown;

            // Loading state
            if (params.buttonsStyling) {
                confirmButton.style.borderLeftColor = params.confirmButtonColor;
                confirmButton.style.borderRightColor = params.confirmButtonColor;
            }

            /**
             * Show spinner instead of Confirm button and disable Cancel button
             */
            sweetAlert.showLoading = sweetAlert.enableLoading = function () {
                show(getSpacer());
                show(confirmButton, 'inline-block');
                addClass(confirmButton, swalClasses.loading);
                addClass(modal, swalClasses.loading);
                confirmButton.disabled = true;
                cancelButton.disabled = true;
            };

            /**
             * Show spinner instead of Confirm button and disable Cancel button
             */
            sweetAlert.hideLoading = sweetAlert.disableLoading = function () {
                if (!params.showConfirmButton) {
                    hide(confirmButton);
                    if (!params.showCancelButton) {
                        hide(getSpacer());
                    }
                }
                removeClass(confirmButton, swalClasses.loading);
                removeClass(modal, swalClasses.loading);
                confirmButton.disabled = false;
                cancelButton.disabled = false;
            };

            sweetAlert.getTitle = function () {
                return getTitle();
            };
            sweetAlert.getContent = function () {
                return getContent();
            };
            sweetAlert.getInput = function () {
                return getInput();
            };
            sweetAlert.getImage = function () {
                return getImage();
            };
            sweetAlert.getConfirmButton = function () {
                return getConfirmButton();
            };
            sweetAlert.getCancelButton = function () {
                return getCancelButton();
            };

            sweetAlert.enableButtons = function () {
                confirmButton.disabled = false;
                cancelButton.disabled = false;
            };

            sweetAlert.disableButtons = function () {
                confirmButton.disabled = true;
                cancelButton.disabled = true;
            };

            sweetAlert.enableConfirmButton = function () {
                confirmButton.disabled = false;
            };

            sweetAlert.disableConfirmButton = function () {
                confirmButton.disabled = true;
            };

            sweetAlert.enableInput = function () {
                var input = getInput();
                if (!input) {
                    return false;
                }
                if (input.type === 'radio') {
                    var radiosContainer = input.parentNode.parentNode;
                    var radios = radiosContainer.querySelectorAll('input');
                    for (var _i4 = 0; _i4 < radios.length; _i4++) {
                        radios[_i4].disabled = false;
                    }
                } else {
                    input.disabled = false;
                }
            };

            sweetAlert.disableInput = function () {
                var input = getInput();
                if (!input) {
                    return false;
                }
                if (input && input.type === 'radio') {
                    var radiosContainer = input.parentNode.parentNode;
                    var radios = radiosContainer.querySelectorAll('input');
                    for (var _i5 = 0; _i5 < radios.length; _i5++) {
                        radios[_i5].disabled = true;
                    }
                } else {
                    input.disabled = true;
                }
            };

            // Set modal min-height to disable scrolling inside the modal
            sweetAlert.recalculateHeight = debounce(function () {
                var modal = getModal();
                if (!modal) {
                    return;
                }
                var prevState = modal.style.display;
                modal.style.minHeight = '';
                show(modal);
                modal.style.minHeight = modal.scrollHeight + 1 + 'px';
                modal.style.display = prevState;
            }, 50);

            // Show block with validation error
            sweetAlert.showValidationError = function (error) {
                var validationError = getValidationError();
                validationError.innerHTML = error;
                show(validationError);

                var input = getInput();
                if (input) {
                    focusInput(input);
                    addClass(input, swalClasses.inputerror);
                }
            };

            // Hide block with validation error
            sweetAlert.resetValidationError = function () {
                var validationError = getValidationError();
                hide(validationError);
                sweetAlert.recalculateHeight();

                var input = getInput();
                if (input) {
                    removeClass(input, swalClasses.inputerror);
                }
            };

            sweetAlert.getProgressSteps = function () {
                return params.progressSteps;
            };

            sweetAlert.setProgressSteps = function (progressSteps) {
                params.progressSteps = progressSteps;
                setParameters(params);
            };

            sweetAlert.showProgressSteps = function () {
                show(getProgressSteps());
            };

            sweetAlert.hideProgressSteps = function () {
                hide(getProgressSteps());
            };

            sweetAlert.enableButtons();
            sweetAlert.hideLoading();
            sweetAlert.resetValidationError();

            // inputs
            var inputTypes = ['input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea'];
            var input = void 0;
            for (var _i6 = 0; _i6 < inputTypes.length; _i6++) {
                var inputClass = swalClasses[inputTypes[_i6]];
                var inputContainer = getChildByClass(modal, inputClass);
                input = getInput(inputTypes[_i6]);

                // set attributes
                if (input) {
                    for (var j in input.attributes) {
                        if (input.attributes.hasOwnProperty(j)) {
                            var attrName = input.attributes[j].name;
                            if (attrName !== 'type' && attrName !== 'value') {
                                input.removeAttribute(attrName);
                            }
                        }
                    }
                    for (var attr in params.inputAttributes) {
                        input.setAttribute(attr, params.inputAttributes[attr]);
                    }
                }

                // set class
                inputContainer.className = inputClass;
                if (params.inputClass) {
                    addClass(inputContainer, params.inputClass);
                }

                hide(inputContainer);
            }

            var populateInputOptions = void 0;

            (function () {
                switch (params.input) {
                    case 'text':
                    case 'email':
                    case 'password':
                    case 'number':
                    case 'tel':
                        input = getChildByClass(modal, swalClasses.input);
                        input.value = params.inputValue;
                        input.placeholder = params.inputPlaceholder;
                        input.type = params.input;
                        show(input);
                        break;
                    case 'file':
                        input = getChildByClass(modal, swalClasses.file);
                        input.placeholder = params.inputPlaceholder;
                        input.type = params.input;
                        show(input);
                        break;
                    case 'range':
                        var range = getChildByClass(modal, swalClasses.range);
                        var rangeInput = range.querySelector('input');
                        var rangeOutput = range.querySelector('output');
                        rangeInput.value = params.inputValue;
                        rangeInput.type = params.input;
                        rangeOutput.value = params.inputValue;
                        show(range);
                        break;
                    case 'select':
                        var select = getChildByClass(modal, swalClasses.select);
                        select.innerHTML = '';
                        if (params.inputPlaceholder) {
                            var placeholder = document.createElement('option');
                            placeholder.innerHTML = params.inputPlaceholder;
                            placeholder.value = '';
                            placeholder.disabled = true;
                            placeholder.selected = true;
                            select.appendChild(placeholder);
                        }
                        populateInputOptions = function populateInputOptions(inputOptions) {
                            for (var optionValue in inputOptions) {
                                var option = document.createElement('option');
                                option.value = optionValue;
                                option.innerHTML = inputOptions[optionValue];
                                if (params.inputValue === optionValue) {
                                    option.selected = true;
                                }
                                select.appendChild(option);
                            }
                            show(select);
                            select.focus();
                        };
                        break;
                    case 'radio':
                        var radio = getChildByClass(modal, swalClasses.radio);
                        radio.innerHTML = '';
                        populateInputOptions = function populateInputOptions(inputOptions) {
                            for (var radioValue in inputOptions) {
                                var radioInput = document.createElement('input');
                                var radioLabel = document.createElement('label');
                                var radioLabelSpan = document.createElement('span');
                                radioInput.type = 'radio';
                                radioInput.name = swalClasses.radio;
                                radioInput.value = radioValue;
                                if (params.inputValue === radioValue) {
                                    radioInput.checked = true;
                                }
                                radioLabelSpan.innerHTML = inputOptions[radioValue];
                                radioLabel.appendChild(radioInput);
                                radioLabel.appendChild(radioLabelSpan);
                                radioLabel.for = radioInput.id;
                                radio.appendChild(radioLabel);
                            }
                            show(radio);
                            var radios = radio.querySelectorAll('input');
                            if (radios.length) {
                                radios[0].focus();
                            }
                        };
                        break;
                    case 'checkbox':
                        var checkbox = getChildByClass(modal, swalClasses.checkbox);
                        var checkboxInput = getInput('checkbox');
                        checkboxInput.type = 'checkbox';
                        checkboxInput.value = 1;
                        checkboxInput.id = swalClasses.checkbox;
                        checkboxInput.checked = Boolean(params.inputValue);
                        var label = checkbox.getElementsByTagName('span');
                        if (label.length) {
                            checkbox.removeChild(label[0]);
                        }
                        label = document.createElement('span');
                        label.innerHTML = params.inputPlaceholder;
                        checkbox.appendChild(label);
                        show(checkbox);
                        break;
                    case 'textarea':
                        var textarea = getChildByClass(modal, swalClasses.textarea);
                        textarea.value = params.inputValue;
                        textarea.placeholder = params.inputPlaceholder;
                        show(textarea);
                        break;
                    case null:
                        break;
                    default:
                        console.error('SweetAlert2: Unexpected type of input! Expected "text", "email", "password", "select", "checkbox", "textarea" or "file", got "' + params.input + '"');
                        break;
                }
            })();

            if (params.input === 'select' || params.input === 'radio') {
                if (params.inputOptions instanceof Promise) {
                    sweetAlert.showLoading();
                    params.inputOptions.then(function (inputOptions) {
                        sweetAlert.hideLoading();
                        populateInputOptions(inputOptions);
                    });
                } else if (_typeof(params.inputOptions) === 'object') {
                    populateInputOptions(params.inputOptions);
                } else {
                    console.error('SweetAlert2: Unexpected type of inputOptions! Expected object or Promise, got ' + _typeof(params.inputOptions));
                }
            }

            openModal(params.animation, params.onOpen);

            // Focus the first element (input or button)
            if (params.allowEnterKey) {
                setFocus(-1, 1);
            } else {
                if (document.activeElement) {
                    document.activeElement.blur();
                }
            }

            // fix scroll
            getContainer().scrollTop = 0;

            // Observe changes inside the modal and adjust height
            if (typeof MutationObserver !== 'undefined' && !swal2Observer) {
                swal2Observer = new MutationObserver(sweetAlert.recalculateHeight);
                swal2Observer.observe(modal, { childList: true, characterData: true, subtree: true });
            }
        });
    };

    /*
 * Global function to determine if swal2 modal is shown
 */
    sweetAlert.isVisible = function () {
        return !!getModal();
    };

    /*
 * Global function for chaining sweetAlert modals
 */
    sweetAlert.queue = function (steps) {
        queue = steps;
        var resetQueue = function resetQueue() {
            queue = [];
            document.body.removeAttribute('data-swal2-queue-step');
        };
        var queueResult = [];
        return new Promise(function (resolve, reject) {
            (function step(i, callback) {
                if (i < queue.length) {
                    document.body.setAttribute('data-swal2-queue-step', i);

                    sweetAlert(queue[i]).then(function (result) {
                        queueResult.push(result);
                        step(i + 1, callback);
                    }, function (dismiss) {
                        resetQueue();
                        reject(dismiss);
                    });
                } else {
                    resetQueue();
                    resolve(queueResult);
                }
            })(0);
        });
    };

    /*
 * Global function for getting the index of current modal in queue
 */
    sweetAlert.getQueueStep = function () {
        return document.body.getAttribute('data-swal2-queue-step');
    };

    /*
 * Global function for inserting a modal to the queue
 */
    sweetAlert.insertQueueStep = function (step, index) {
        if (index && index < queue.length) {
            return queue.splice(index, 0, step);
        }
        return queue.push(step);
    };

    /*
 * Global function for deleting a modal from the queue
 */
    sweetAlert.deleteQueueStep = function (index) {
        if (typeof queue[index] !== 'undefined') {
            queue.splice(index, 1);
        }
    };

    /*
 * Global function to close sweetAlert
 */
    sweetAlert.close = sweetAlert.closeModal = function (onComplete) {
        var container = getContainer();
        var modal = getModal();
        if (!modal) {
            return;
        }
        removeClass(modal, swalClasses.show);
        addClass(modal, swalClasses.hide);
        clearTimeout(modal.timeout);

        resetPrevState();

        var removeModalAndResetState = function removeModalAndResetState() {
            container.parentNode.removeChild(container);
            removeClass(document.documentElement, swalClasses.shown);
            removeClass(document.body, swalClasses.shown);
            undoScrollbar();
            undoIOSfix();
        };

        // If animation is supported, animate
        if (animationEndEvent && !hasClass(modal, swalClasses.noanimation)) {
            modal.addEventListener(animationEndEvent, function swalCloseEventFinished() {
                modal.removeEventListener(animationEndEvent, swalCloseEventFinished);
                if (hasClass(modal, swalClasses.hide)) {
                    removeModalAndResetState();
                }
            });
        } else {
            // Otherwise, remove immediately
            removeModalAndResetState();
        }
        if (onComplete !== null && typeof onComplete === 'function') {
            setTimeout(function () {
                onComplete(modal);
            });
        }
    };

    /*
 * Global function to click 'Confirm' button
 */
    sweetAlert.clickConfirm = function () {
        return getConfirmButton().click();
    };

    /*
 * Global function to click 'Cancel' button
 */
    sweetAlert.clickCancel = function () {
        return getCancelButton().click();
    };

    /**
     * Set default params for each popup
     * @param {Object} userParams
     */
    sweetAlert.setDefaults = function (userParams) {
        if (!userParams || (typeof userParams === 'undefined' ? 'undefined' : _typeof(userParams)) !== 'object') {
            return console.error('SweetAlert2: the argument for setDefaults() is required and has to be a object');
        }

        for (var param in userParams) {
            if (!defaultParams.hasOwnProperty(param) && param !== 'extraParams') {
                console.warn('SweetAlert2: Unknown parameter "' + param + '"');
                delete userParams[param];
            }
        }

        _extends(modalParams, userParams);
    };

    /**
     * Reset default params for each popup
     */
    sweetAlert.resetDefaults = function () {
        modalParams = _extends({}, defaultParams);
    };

    sweetAlert.noop = function () {};

    sweetAlert.version = '6.4.2';

    sweetAlert.default = sweetAlert;

    return sweetAlert;

})));
if (window.Sweetalert2) window.sweetAlert = window.swal = window.Sweetalert2;
/**
 * simplemde v1.11.2
 * Copyright Next Step Webs, Inc.
 * @link https://github.com/NextStepWebs/simplemde-markdown-editor
 * @license MIT
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.SimpleMDE = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
        'use strict'

        exports.toByteArray = toByteArray
        exports.fromByteArray = fromByteArray

        var lookup = []
        var revLookup = []
        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

        function init () {
            var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
            for (var i = 0, len = code.length; i < len; ++i) {
                lookup[i] = code[i]
                revLookup[code.charCodeAt(i)] = i
            }

            revLookup['-'.charCodeAt(0)] = 62
            revLookup['_'.charCodeAt(0)] = 63
        }

        init()

        function toByteArray (b64) {
            var i, j, l, tmp, placeHolders, arr
            var len = b64.length

            if (len % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4')
            }

            // the number of equal signs (place holders)
            // if there are two placeholders, than the two characters before it
            // represent one byte
            // if there is only one, then the three characters before it represent 2 bytes
            // this is just a cheap hack to not do indexOf twice
            placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

            // base64 is 4/3 + up to two characters of the original data
            arr = new Arr(len * 3 / 4 - placeHolders)

            // if there are placeholders, only get up to the last complete 4 chars
            l = placeHolders > 0 ? len - 4 : len

            var L = 0

            for (i = 0, j = 0; i < l; i += 4, j += 3) {
                tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
                arr[L++] = (tmp >> 16) & 0xFF
                arr[L++] = (tmp >> 8) & 0xFF
                arr[L++] = tmp & 0xFF
            }

            if (placeHolders === 2) {
                tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
                arr[L++] = tmp & 0xFF
            } else if (placeHolders === 1) {
                tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
                arr[L++] = (tmp >> 8) & 0xFF
                arr[L++] = tmp & 0xFF
            }

            return arr
        }

        function tripletToBase64 (num) {
            return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
        }

        function encodeChunk (uint8, start, end) {
            var tmp
            var output = []
            for (var i = start; i < end; i += 3) {
                tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
                output.push(tripletToBase64(tmp))
            }
            return output.join('')
        }

        function fromByteArray (uint8) {
            var tmp
            var len = uint8.length
            var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
            var output = ''
            var parts = []
            var maxChunkLength = 16383 // must be multiple of 3

            // go through the array every three bytes, we'll deal with trailing stuff later
            for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
            }

            // pad the end with zeros, but make sure to not forget the extra bytes
            if (extraBytes === 1) {
                tmp = uint8[len - 1]
                output += lookup[tmp >> 2]
                output += lookup[(tmp << 4) & 0x3F]
                output += '=='
            } else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
                output += lookup[tmp >> 10]
                output += lookup[(tmp >> 4) & 0x3F]
                output += lookup[(tmp << 2) & 0x3F]
                output += '='
            }

            parts.push(output)

            return parts.join('')
        }

    },{}],2:[function(require,module,exports){

    },{}],3:[function(require,module,exports){
        (function (global){
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
            /* eslint-disable no-proto */

            'use strict'

            var base64 = require('base64-js')
            var ieee754 = require('ieee754')
            var isArray = require('isarray')

            exports.Buffer = Buffer
            exports.SlowBuffer = SlowBuffer
            exports.INSPECT_MAX_BYTES = 50

            /**
             * If `Buffer.TYPED_ARRAY_SUPPORT`:
             *   === true    Use Uint8Array implementation (fastest)
             *   === false   Use Object implementation (most compatible, even IE6)
             *
             * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
             * Opera 11.6+, iOS 4.2+.
             *
             * Due to various browser bugs, sometimes the Object implementation will be used even
             * when the browser supports typed arrays.
             *
             * Note:
             *
             *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
             *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
             *
             *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
             *
             *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
             *     incorrect length in some situations.

             * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
             * get the Object implementation, which is slower but behaves correctly.
             */
            Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
                ? global.TYPED_ARRAY_SUPPORT
                : typedArraySupport()

            /*
 * Export kMaxLength after typed array support is determined.
 */
            exports.kMaxLength = kMaxLength()

            function typedArraySupport () {
                try {
                    var arr = new Uint8Array(1)
                    arr.foo = function () { return 42 }
                    return arr.foo() === 42 && // typed array instances can be augmented
                        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
                        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
                } catch (e) {
                    return false
                }
            }

            function kMaxLength () {
                return Buffer.TYPED_ARRAY_SUPPORT
                    ? 0x7fffffff
                    : 0x3fffffff
            }

            function createBuffer (that, length) {
                if (kMaxLength() < length) {
                    throw new RangeError('Invalid typed array length')
                }
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    // Return an augmented `Uint8Array` instance, for best performance
                    that = new Uint8Array(length)
                    that.__proto__ = Buffer.prototype
                } else {
                    // Fallback: Return an object instance of the Buffer class
                    if (that === null) {
                        that = new Buffer(length)
                    }
                    that.length = length
                }

                return that
            }

            /**
             * The Buffer constructor returns instances of `Uint8Array` that have their
             * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
             * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
             * and the `Uint8Array` methods. Square bracket notation works as expected -- it
             * returns a single octet.
             *
             * The `Uint8Array` prototype remains unmodified.
             */

            function Buffer (arg, encodingOrOffset, length) {
                if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
                    return new Buffer(arg, encodingOrOffset, length)
                }

                // Common case.
                if (typeof arg === 'number') {
                    if (typeof encodingOrOffset === 'string') {
                        throw new Error(
                            'If encoding is specified then the first argument must be a string'
                        )
                    }
                    return allocUnsafe(this, arg)
                }
                return from(this, arg, encodingOrOffset, length)
            }

            Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
            Buffer._augment = function (arr) {
                arr.__proto__ = Buffer.prototype
                return arr
            }

            function from (that, value, encodingOrOffset, length) {
                if (typeof value === 'number') {
                    throw new TypeError('"value" argument must not be a number')
                }

                if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
                    return fromArrayBuffer(that, value, encodingOrOffset, length)
                }

                if (typeof value === 'string') {
                    return fromString(that, value, encodingOrOffset)
                }

                return fromObject(that, value)
            }

            /**
             * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
             * if value is a number.
             * Buffer.from(str[, encoding])
             * Buffer.from(array)
             * Buffer.from(buffer)
             * Buffer.from(arrayBuffer[, byteOffset[, length]])
             **/
            Buffer.from = function (value, encodingOrOffset, length) {
                return from(null, value, encodingOrOffset, length)
            }

            if (Buffer.TYPED_ARRAY_SUPPORT) {
                Buffer.prototype.__proto__ = Uint8Array.prototype
                Buffer.__proto__ = Uint8Array
                if (typeof Symbol !== 'undefined' && Symbol.species &&
                    Buffer[Symbol.species] === Buffer) {
                    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
                    Object.defineProperty(Buffer, Symbol.species, {
                        value: null,
                        configurable: true
                    })
                }
            }

            function assertSize (size) {
                if (typeof size !== 'number') {
                    throw new TypeError('"size" argument must be a number')
                }
            }

            function alloc (that, size, fill, encoding) {
                assertSize(size)
                if (size <= 0) {
                    return createBuffer(that, size)
                }
                if (fill !== undefined) {
                    // Only pay attention to encoding if it's a string. This
                    // prevents accidentally sending in a number that would
                    // be interpretted as a start offset.
                    return typeof encoding === 'string'
                        ? createBuffer(that, size).fill(fill, encoding)
                        : createBuffer(that, size).fill(fill)
                }
                return createBuffer(that, size)
            }

            /**
             * Creates a new filled Buffer instance.
             * alloc(size[, fill[, encoding]])
             **/
            Buffer.alloc = function (size, fill, encoding) {
                return alloc(null, size, fill, encoding)
            }

            function allocUnsafe (that, size) {
                assertSize(size)
                that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
                if (!Buffer.TYPED_ARRAY_SUPPORT) {
                    for (var i = 0; i < size; i++) {
                        that[i] = 0
                    }
                }
                return that
            }

            /**
             * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
             * */
            Buffer.allocUnsafe = function (size) {
                return allocUnsafe(null, size)
            }
            /**
             * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
             */
            Buffer.allocUnsafeSlow = function (size) {
                return allocUnsafe(null, size)
            }

            function fromString (that, string, encoding) {
                if (typeof encoding !== 'string' || encoding === '') {
                    encoding = 'utf8'
                }

                if (!Buffer.isEncoding(encoding)) {
                    throw new TypeError('"encoding" must be a valid string encoding')
                }

                var length = byteLength(string, encoding) | 0
                that = createBuffer(that, length)

                that.write(string, encoding)
                return that
            }

            function fromArrayLike (that, array) {
                var length = checked(array.length) | 0
                that = createBuffer(that, length)
                for (var i = 0; i < length; i += 1) {
                    that[i] = array[i] & 255
                }
                return that
            }

            function fromArrayBuffer (that, array, byteOffset, length) {
                array.byteLength // this throws if `array` is not a valid ArrayBuffer

                if (byteOffset < 0 || array.byteLength < byteOffset) {
                    throw new RangeError('\'offset\' is out of bounds')
                }

                if (array.byteLength < byteOffset + (length || 0)) {
                    throw new RangeError('\'length\' is out of bounds')
                }

                if (length === undefined) {
                    array = new Uint8Array(array, byteOffset)
                } else {
                    array = new Uint8Array(array, byteOffset, length)
                }

                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    // Return an augmented `Uint8Array` instance, for best performance
                    that = array
                    that.__proto__ = Buffer.prototype
                } else {
                    // Fallback: Return an object instance of the Buffer class
                    that = fromArrayLike(that, array)
                }
                return that
            }

            function fromObject (that, obj) {
                if (Buffer.isBuffer(obj)) {
                    var len = checked(obj.length) | 0
                    that = createBuffer(that, len)

                    if (that.length === 0) {
                        return that
                    }

                    obj.copy(that, 0, 0, len)
                    return that
                }

                if (obj) {
                    if ((typeof ArrayBuffer !== 'undefined' &&
                            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
                        if (typeof obj.length !== 'number' || isnan(obj.length)) {
                            return createBuffer(that, 0)
                        }
                        return fromArrayLike(that, obj)
                    }

                    if (obj.type === 'Buffer' && isArray(obj.data)) {
                        return fromArrayLike(that, obj.data)
                    }
                }

                throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
            }

            function checked (length) {
                // Note: cannot use `length < kMaxLength` here because that fails when
                // length is NaN (which is otherwise coerced to zero.)
                if (length >= kMaxLength()) {
                    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                        'size: 0x' + kMaxLength().toString(16) + ' bytes')
                }
                return length | 0
            }

            function SlowBuffer (length) {
                if (+length != length) { // eslint-disable-line eqeqeq
                    length = 0
                }
                return Buffer.alloc(+length)
            }

            Buffer.isBuffer = function isBuffer (b) {
                return !!(b != null && b._isBuffer)
            }

            Buffer.compare = function compare (a, b) {
                if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                    throw new TypeError('Arguments must be Buffers')
                }

                if (a === b) return 0

                var x = a.length
                var y = b.length

                for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                    if (a[i] !== b[i]) {
                        x = a[i]
                        y = b[i]
                        break
                    }
                }

                if (x < y) return -1
                if (y < x) return 1
                return 0
            }

            Buffer.isEncoding = function isEncoding (encoding) {
                switch (String(encoding).toLowerCase()) {
                    case 'hex':
                    case 'utf8':
                    case 'utf-8':
                    case 'ascii':
                    case 'binary':
                    case 'base64':
                    case 'raw':
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return true
                    default:
                        return false
                }
            }

            Buffer.concat = function concat (list, length) {
                if (!isArray(list)) {
                    throw new TypeError('"list" argument must be an Array of Buffers')
                }

                if (list.length === 0) {
                    return Buffer.alloc(0)
                }

                var i
                if (length === undefined) {
                    length = 0
                    for (i = 0; i < list.length; i++) {
                        length += list[i].length
                    }
                }

                var buffer = Buffer.allocUnsafe(length)
                var pos = 0
                for (i = 0; i < list.length; i++) {
                    var buf = list[i]
                    if (!Buffer.isBuffer(buf)) {
                        throw new TypeError('"list" argument must be an Array of Buffers')
                    }
                    buf.copy(buffer, pos)
                    pos += buf.length
                }
                return buffer
            }

            function byteLength (string, encoding) {
                if (Buffer.isBuffer(string)) {
                    return string.length
                }
                if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
                    (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                    return string.byteLength
                }
                if (typeof string !== 'string') {
                    string = '' + string
                }

                var len = string.length
                if (len === 0) return 0

                // Use a for loop to avoid recursion
                var loweredCase = false
                for (;;) {
                    switch (encoding) {
                        case 'ascii':
                        case 'binary':
                        // Deprecated
                        case 'raw':
                        case 'raws':
                            return len
                        case 'utf8':
                        case 'utf-8':
                        case undefined:
                            return utf8ToBytes(string).length
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return len * 2
                        case 'hex':
                            return len >>> 1
                        case 'base64':
                            return base64ToBytes(string).length
                        default:
                            if (loweredCase) return utf8ToBytes(string).length // assume utf8
                            encoding = ('' + encoding).toLowerCase()
                            loweredCase = true
                    }
                }
            }
            Buffer.byteLength = byteLength

            function slowToString (encoding, start, end) {
                var loweredCase = false

                // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
                // property of a typed array.

                // This behaves neither like String nor Uint8Array in that we set start/end
                // to their upper/lower bounds if the value passed is out of range.
                // undefined is handled specially as per ECMA-262 6th Edition,
                // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
                if (start === undefined || start < 0) {
                    start = 0
                }
                // Return early if start > this.length. Done here to prevent potential uint32
                // coercion fail below.
                if (start > this.length) {
                    return ''
                }

                if (end === undefined || end > this.length) {
                    end = this.length
                }

                if (end <= 0) {
                    return ''
                }

                // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
                end >>>= 0
                start >>>= 0

                if (end <= start) {
                    return ''
                }

                if (!encoding) encoding = 'utf8'

                while (true) {
                    switch (encoding) {
                        case 'hex':
                            return hexSlice(this, start, end)

                        case 'utf8':
                        case 'utf-8':
                            return utf8Slice(this, start, end)

                        case 'ascii':
                            return asciiSlice(this, start, end)

                        case 'binary':
                            return binarySlice(this, start, end)

                        case 'base64':
                            return base64Slice(this, start, end)

                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return utf16leSlice(this, start, end)

                        default:
                            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                            encoding = (encoding + '').toLowerCase()
                            loweredCase = true
                    }
                }
            }

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
            Buffer.prototype._isBuffer = true

            function swap (b, n, m) {
                var i = b[n]
                b[n] = b[m]
                b[m] = i
            }

            Buffer.prototype.swap16 = function swap16 () {
                var len = this.length
                if (len % 2 !== 0) {
                    throw new RangeError('Buffer size must be a multiple of 16-bits')
                }
                for (var i = 0; i < len; i += 2) {
                    swap(this, i, i + 1)
                }
                return this
            }

            Buffer.prototype.swap32 = function swap32 () {
                var len = this.length
                if (len % 4 !== 0) {
                    throw new RangeError('Buffer size must be a multiple of 32-bits')
                }
                for (var i = 0; i < len; i += 4) {
                    swap(this, i, i + 3)
                    swap(this, i + 1, i + 2)
                }
                return this
            }

            Buffer.prototype.toString = function toString () {
                var length = this.length | 0
                if (length === 0) return ''
                if (arguments.length === 0) return utf8Slice(this, 0, length)
                return slowToString.apply(this, arguments)
            }

            Buffer.prototype.equals = function equals (b) {
                if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
                if (this === b) return true
                return Buffer.compare(this, b) === 0
            }

            Buffer.prototype.inspect = function inspect () {
                var str = ''
                var max = exports.INSPECT_MAX_BYTES
                if (this.length > 0) {
                    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
                    if (this.length > max) str += ' ... '
                }
                return '<Buffer ' + str + '>'
            }

            Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
                if (!Buffer.isBuffer(target)) {
                    throw new TypeError('Argument must be a Buffer')
                }

                if (start === undefined) {
                    start = 0
                }
                if (end === undefined) {
                    end = target ? target.length : 0
                }
                if (thisStart === undefined) {
                    thisStart = 0
                }
                if (thisEnd === undefined) {
                    thisEnd = this.length
                }

                if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                    throw new RangeError('out of range index')
                }

                if (thisStart >= thisEnd && start >= end) {
                    return 0
                }
                if (thisStart >= thisEnd) {
                    return -1
                }
                if (start >= end) {
                    return 1
                }

                start >>>= 0
                end >>>= 0
                thisStart >>>= 0
                thisEnd >>>= 0

                if (this === target) return 0

                var x = thisEnd - thisStart
                var y = end - start
                var len = Math.min(x, y)

                var thisCopy = this.slice(thisStart, thisEnd)
                var targetCopy = target.slice(start, end)

                for (var i = 0; i < len; ++i) {
                    if (thisCopy[i] !== targetCopy[i]) {
                        x = thisCopy[i]
                        y = targetCopy[i]
                        break
                    }
                }

                if (x < y) return -1
                if (y < x) return 1
                return 0
            }

            function arrayIndexOf (arr, val, byteOffset, encoding) {
                var indexSize = 1
                var arrLength = arr.length
                var valLength = val.length

                if (encoding !== undefined) {
                    encoding = String(encoding).toLowerCase()
                    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
                        encoding === 'utf16le' || encoding === 'utf-16le') {
                        if (arr.length < 2 || val.length < 2) {
                            return -1
                        }
                        indexSize = 2
                        arrLength /= 2
                        valLength /= 2
                        byteOffset /= 2
                    }
                }

                function read (buf, i) {
                    if (indexSize === 1) {
                        return buf[i]
                    } else {
                        return buf.readUInt16BE(i * indexSize)
                    }
                }

                var foundIndex = -1
                for (var i = 0; byteOffset + i < arrLength; i++) {
                    if (read(arr, byteOffset + i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                        if (foundIndex === -1) foundIndex = i
                        if (i - foundIndex + 1 === valLength) return (byteOffset + foundIndex) * indexSize
                    } else {
                        if (foundIndex !== -1) i -= i - foundIndex
                        foundIndex = -1
                    }
                }
                return -1
            }

            Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
                if (typeof byteOffset === 'string') {
                    encoding = byteOffset
                    byteOffset = 0
                } else if (byteOffset > 0x7fffffff) {
                    byteOffset = 0x7fffffff
                } else if (byteOffset < -0x80000000) {
                    byteOffset = -0x80000000
                }
                byteOffset >>= 0

                if (this.length === 0) return -1
                if (byteOffset >= this.length) return -1

                // Negative offsets start from the end of the buffer
                if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

                if (typeof val === 'string') {
                    val = Buffer.from(val, encoding)
                }

                if (Buffer.isBuffer(val)) {
                    // special case: looking for empty string/buffer always fails
                    if (val.length === 0) {
                        return -1
                    }
                    return arrayIndexOf(this, val, byteOffset, encoding)
                }
                if (typeof val === 'number') {
                    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
                        return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
                    }
                    return arrayIndexOf(this, [ val ], byteOffset, encoding)
                }

                throw new TypeError('val must be string, number or Buffer')
            }

            Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
                return this.indexOf(val, byteOffset, encoding) !== -1
            }

            function hexWrite (buf, string, offset, length) {
                offset = Number(offset) || 0
                var remaining = buf.length - offset
                if (!length) {
                    length = remaining
                } else {
                    length = Number(length)
                    if (length > remaining) {
                        length = remaining
                    }
                }

                // must be an even number of digits
                var strLen = string.length
                if (strLen % 2 !== 0) throw new Error('Invalid hex string')

                if (length > strLen / 2) {
                    length = strLen / 2
                }
                for (var i = 0; i < length; i++) {
                    var parsed = parseInt(string.substr(i * 2, 2), 16)
                    if (isNaN(parsed)) return i
                    buf[offset + i] = parsed
                }
                return i
            }

            function utf8Write (buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
            }

            function asciiWrite (buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length)
            }

            function binaryWrite (buf, string, offset, length) {
                return asciiWrite(buf, string, offset, length)
            }

            function base64Write (buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length)
            }

            function ucs2Write (buf, string, offset, length) {
                return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
            }

            Buffer.prototype.write = function write (string, offset, length, encoding) {
                // Buffer#write(string)
                if (offset === undefined) {
                    encoding = 'utf8'
                    length = this.length
                    offset = 0
                    // Buffer#write(string, encoding)
                } else if (length === undefined && typeof offset === 'string') {
                    encoding = offset
                    length = this.length
                    offset = 0
                    // Buffer#write(string, offset[, length][, encoding])
                } else if (isFinite(offset)) {
                    offset = offset | 0
                    if (isFinite(length)) {
                        length = length | 0
                        if (encoding === undefined) encoding = 'utf8'
                    } else {
                        encoding = length
                        length = undefined
                    }
                    // legacy write(string, encoding, offset, length) - remove in v0.13
                } else {
                    throw new Error(
                        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
                    )
                }

                var remaining = this.length - offset
                if (length === undefined || length > remaining) length = remaining

                if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                    throw new RangeError('Attempt to write outside buffer bounds')
                }

                if (!encoding) encoding = 'utf8'

                var loweredCase = false
                for (;;) {
                    switch (encoding) {
                        case 'hex':
                            return hexWrite(this, string, offset, length)

                        case 'utf8':
                        case 'utf-8':
                            return utf8Write(this, string, offset, length)

                        case 'ascii':
                            return asciiWrite(this, string, offset, length)

                        case 'binary':
                            return binaryWrite(this, string, offset, length)

                        case 'base64':
                            // Warning: maxLength not taken into account in base64Write
                            return base64Write(this, string, offset, length)

                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return ucs2Write(this, string, offset, length)

                        default:
                            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                            encoding = ('' + encoding).toLowerCase()
                            loweredCase = true
                    }
                }
            }

            Buffer.prototype.toJSON = function toJSON () {
                return {
                    type: 'Buffer',
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }

            function base64Slice (buf, start, end) {
                if (start === 0 && end === buf.length) {
                    return base64.fromByteArray(buf)
                } else {
                    return base64.fromByteArray(buf.slice(start, end))
                }
            }

            function utf8Slice (buf, start, end) {
                end = Math.min(buf.length, end)
                var res = []

                var i = start
                while (i < end) {
                    var firstByte = buf[i]
                    var codePoint = null
                    var bytesPerSequence = (firstByte > 0xEF) ? 4
                        : (firstByte > 0xDF) ? 3
                            : (firstByte > 0xBF) ? 2
                                : 1

                    if (i + bytesPerSequence <= end) {
                        var secondByte, thirdByte, fourthByte, tempCodePoint

                        switch (bytesPerSequence) {
                            case 1:
                                if (firstByte < 0x80) {
                                    codePoint = firstByte
                                }
                                break
                            case 2:
                                secondByte = buf[i + 1]
                                if ((secondByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                                    if (tempCodePoint > 0x7F) {
                                        codePoint = tempCodePoint
                                    }
                                }
                                break
                            case 3:
                                secondByte = buf[i + 1]
                                thirdByte = buf[i + 2]
                                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                                        codePoint = tempCodePoint
                                    }
                                }
                                break
                            case 4:
                                secondByte = buf[i + 1]
                                thirdByte = buf[i + 2]
                                fourthByte = buf[i + 3]
                                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                                        codePoint = tempCodePoint
                                    }
                                }
                        }
                    }

                    if (codePoint === null) {
                        // we did not generate a valid codePoint so insert a
                        // replacement char (U+FFFD) and advance only 1 byte
                        codePoint = 0xFFFD
                        bytesPerSequence = 1
                    } else if (codePoint > 0xFFFF) {
                        // encode to utf16 (surrogate pair dance)
                        codePoint -= 0x10000
                        res.push(codePoint >>> 10 & 0x3FF | 0xD800)
                        codePoint = 0xDC00 | codePoint & 0x3FF
                    }

                    res.push(codePoint)
                    i += bytesPerSequence
                }

                return decodeCodePointsArray(res)
            }

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
            var MAX_ARGUMENTS_LENGTH = 0x1000

            function decodeCodePointsArray (codePoints) {
                var len = codePoints.length
                if (len <= MAX_ARGUMENTS_LENGTH) {
                    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
                }

                // Decode in chunks to avoid "call stack size exceeded".
                var res = ''
                var i = 0
                while (i < len) {
                    res += String.fromCharCode.apply(
                        String,
                        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                    )
                }
                return res
            }

            function asciiSlice (buf, start, end) {
                var ret = ''
                end = Math.min(buf.length, end)

                for (var i = start; i < end; i++) {
                    ret += String.fromCharCode(buf[i] & 0x7F)
                }
                return ret
            }

            function binarySlice (buf, start, end) {
                var ret = ''
                end = Math.min(buf.length, end)

                for (var i = start; i < end; i++) {
                    ret += String.fromCharCode(buf[i])
                }
                return ret
            }

            function hexSlice (buf, start, end) {
                var len = buf.length

                if (!start || start < 0) start = 0
                if (!end || end < 0 || end > len) end = len

                var out = ''
                for (var i = start; i < end; i++) {
                    out += toHex(buf[i])
                }
                return out
            }

            function utf16leSlice (buf, start, end) {
                var bytes = buf.slice(start, end)
                var res = ''
                for (var i = 0; i < bytes.length; i += 2) {
                    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
                }
                return res
            }

            Buffer.prototype.slice = function slice (start, end) {
                var len = this.length
                start = ~~start
                end = end === undefined ? len : ~~end

                if (start < 0) {
                    start += len
                    if (start < 0) start = 0
                } else if (start > len) {
                    start = len
                }

                if (end < 0) {
                    end += len
                    if (end < 0) end = 0
                } else if (end > len) {
                    end = len
                }

                if (end < start) end = start

                var newBuf
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    newBuf = this.subarray(start, end)
                    newBuf.__proto__ = Buffer.prototype
                } else {
                    var sliceLen = end - start
                    newBuf = new Buffer(sliceLen, undefined)
                    for (var i = 0; i < sliceLen; i++) {
                        newBuf[i] = this[i + start]
                    }
                }

                return newBuf
            }

            /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
            function checkOffset (offset, ext, length) {
                if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
                if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
            }

            Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)

                var val = this[offset]
                var mul = 1
                var i = 0
                while (++i < byteLength && (mul *= 0x100)) {
                    val += this[offset + i] * mul
                }

                return val
            }

            Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) {
                    checkOffset(offset, byteLength, this.length)
                }

                var val = this[offset + --byteLength]
                var mul = 1
                while (byteLength > 0 && (mul *= 0x100)) {
                    val += this[offset + --byteLength] * mul
                }

                return val
            }

            Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
                if (!noAssert) checkOffset(offset, 1, this.length)
                return this[offset]
            }

            Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                return this[offset] | (this[offset + 1] << 8)
            }

            Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                return (this[offset] << 8) | this[offset + 1]
            }

            Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)

                return ((this[offset]) |
                    (this[offset + 1] << 8) |
                    (this[offset + 2] << 16)) +
                    (this[offset + 3] * 0x1000000)
            }

            Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)

                return (this[offset] * 0x1000000) +
                    ((this[offset + 1] << 16) |
                        (this[offset + 2] << 8) |
                        this[offset + 3])
            }

            Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)

                var val = this[offset]
                var mul = 1
                var i = 0
                while (++i < byteLength && (mul *= 0x100)) {
                    val += this[offset + i] * mul
                }
                mul *= 0x80

                if (val >= mul) val -= Math.pow(2, 8 * byteLength)

                return val
            }

            Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)

                var i = byteLength
                var mul = 1
                var val = this[offset + --i]
                while (i > 0 && (mul *= 0x100)) {
                    val += this[offset + --i] * mul
                }
                mul *= 0x80

                if (val >= mul) val -= Math.pow(2, 8 * byteLength)

                return val
            }

            Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
                if (!noAssert) checkOffset(offset, 1, this.length)
                if (!(this[offset] & 0x80)) return (this[offset])
                return ((0xff - this[offset] + 1) * -1)
            }

            Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                var val = this[offset] | (this[offset + 1] << 8)
                return (val & 0x8000) ? val | 0xFFFF0000 : val
            }

            Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                var val = this[offset + 1] | (this[offset] << 8)
                return (val & 0x8000) ? val | 0xFFFF0000 : val
            }

            Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)

                return (this[offset]) |
                    (this[offset + 1] << 8) |
                    (this[offset + 2] << 16) |
                    (this[offset + 3] << 24)
            }

            Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)

                return (this[offset] << 24) |
                    (this[offset + 1] << 16) |
                    (this[offset + 2] << 8) |
                    (this[offset + 3])
            }

            Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, true, 23, 4)
            }

            Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, false, 23, 4)
            }

            Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
                if (!noAssert) checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, true, 52, 8)
            }

            Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
                if (!noAssert) checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, false, 52, 8)
            }

            function checkInt (buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
                if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
                if (offset + ext > buf.length) throw new RangeError('Index out of range')
            }

            Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength) - 1
                    checkInt(this, value, offset, byteLength, maxBytes, 0)
                }

                var mul = 1
                var i = 0
                this[offset] = value & 0xFF
                while (++i < byteLength && (mul *= 0x100)) {
                    this[offset + i] = (value / mul) & 0xFF
                }

                return offset + byteLength
            }

            Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength) - 1
                    checkInt(this, value, offset, byteLength, maxBytes, 0)
                }

                var i = byteLength - 1
                var mul = 1
                this[offset + i] = value & 0xFF
                while (--i >= 0 && (mul *= 0x100)) {
                    this[offset + i] = (value / mul) & 0xFF
                }

                return offset + byteLength
            }

            Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
                if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
                this[offset] = (value & 0xff)
                return offset + 1
            }

            function objectWriteUInt16 (buf, value, offset, littleEndian) {
                if (value < 0) value = 0xffff + value + 1
                for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
                    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                        (littleEndian ? i : 1 - i) * 8
                }
            }

            Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value & 0xff)
                    this[offset + 1] = (value >>> 8)
                } else {
                    objectWriteUInt16(this, value, offset, true)
                }
                return offset + 2
            }

            Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 8)
                    this[offset + 1] = (value & 0xff)
                } else {
                    objectWriteUInt16(this, value, offset, false)
                }
                return offset + 2
            }

            function objectWriteUInt32 (buf, value, offset, littleEndian) {
                if (value < 0) value = 0xffffffff + value + 1
                for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
                    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
                }
            }

            Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset + 3] = (value >>> 24)
                    this[offset + 2] = (value >>> 16)
                    this[offset + 1] = (value >>> 8)
                    this[offset] = (value & 0xff)
                } else {
                    objectWriteUInt32(this, value, offset, true)
                }
                return offset + 4
            }

            Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 24)
                    this[offset + 1] = (value >>> 16)
                    this[offset + 2] = (value >>> 8)
                    this[offset + 3] = (value & 0xff)
                } else {
                    objectWriteUInt32(this, value, offset, false)
                }
                return offset + 4
            }

            Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1)

                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }

                var i = 0
                var mul = 1
                var sub = 0
                this[offset] = value & 0xFF
                while (++i < byteLength && (mul *= 0x100)) {
                    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                        sub = 1
                    }
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                }

                return offset + byteLength
            }

            Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1)

                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }

                var i = byteLength - 1
                var mul = 1
                var sub = 0
                this[offset + i] = value & 0xFF
                while (--i >= 0 && (mul *= 0x100)) {
                    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                        sub = 1
                    }
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                }

                return offset + byteLength
            }

            Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
                if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
                if (value < 0) value = 0xff + value + 1
                this[offset] = (value & 0xff)
                return offset + 1
            }

            Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value & 0xff)
                    this[offset + 1] = (value >>> 8)
                } else {
                    objectWriteUInt16(this, value, offset, true)
                }
                return offset + 2
            }

            Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 8)
                    this[offset + 1] = (value & 0xff)
                } else {
                    objectWriteUInt16(this, value, offset, false)
                }
                return offset + 2
            }

            Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value & 0xff)
                    this[offset + 1] = (value >>> 8)
                    this[offset + 2] = (value >>> 16)
                    this[offset + 3] = (value >>> 24)
                } else {
                    objectWriteUInt32(this, value, offset, true)
                }
                return offset + 4
            }

            Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                if (value < 0) value = 0xffffffff + value + 1
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 24)
                    this[offset + 1] = (value >>> 16)
                    this[offset + 2] = (value >>> 8)
                    this[offset + 3] = (value & 0xff)
                } else {
                    objectWriteUInt32(this, value, offset, false)
                }
                return offset + 4
            }

            function checkIEEE754 (buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length) throw new RangeError('Index out of range')
                if (offset < 0) throw new RangeError('Index out of range')
            }

            function writeFloat (buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
                }
                ieee754.write(buf, value, offset, littleEndian, 23, 4)
                return offset + 4
            }

            Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
                return writeFloat(this, value, offset, true, noAssert)
            }

            Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
                return writeFloat(this, value, offset, false, noAssert)
            }

            function writeDouble (buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
                }
                ieee754.write(buf, value, offset, littleEndian, 52, 8)
                return offset + 8
            }

            Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
                return writeDouble(this, value, offset, true, noAssert)
            }

            Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
                return writeDouble(this, value, offset, false, noAssert)
            }

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
            Buffer.prototype.copy = function copy (target, targetStart, start, end) {
                if (!start) start = 0
                if (!end && end !== 0) end = this.length
                if (targetStart >= target.length) targetStart = target.length
                if (!targetStart) targetStart = 0
                if (end > 0 && end < start) end = start

                // Copy 0 bytes; we're done
                if (end === start) return 0
                if (target.length === 0 || this.length === 0) return 0

                // Fatal error conditions
                if (targetStart < 0) {
                    throw new RangeError('targetStart out of bounds')
                }
                if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
                if (end < 0) throw new RangeError('sourceEnd out of bounds')

                // Are we oob?
                if (end > this.length) end = this.length
                if (target.length - targetStart < end - start) {
                    end = target.length - targetStart + start
                }

                var len = end - start
                var i

                if (this === target && start < targetStart && targetStart < end) {
                    // descending copy from end
                    for (i = len - 1; i >= 0; i--) {
                        target[i + targetStart] = this[i + start]
                    }
                } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                    // ascending copy from start
                    for (i = 0; i < len; i++) {
                        target[i + targetStart] = this[i + start]
                    }
                } else {
                    Uint8Array.prototype.set.call(
                        target,
                        this.subarray(start, start + len),
                        targetStart
                    )
                }

                return len
            }

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
            Buffer.prototype.fill = function fill (val, start, end, encoding) {
                // Handle string cases:
                if (typeof val === 'string') {
                    if (typeof start === 'string') {
                        encoding = start
                        start = 0
                        end = this.length
                    } else if (typeof end === 'string') {
                        encoding = end
                        end = this.length
                    }
                    if (val.length === 1) {
                        var code = val.charCodeAt(0)
                        if (code < 256) {
                            val = code
                        }
                    }
                    if (encoding !== undefined && typeof encoding !== 'string') {
                        throw new TypeError('encoding must be a string')
                    }
                    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                        throw new TypeError('Unknown encoding: ' + encoding)
                    }
                } else if (typeof val === 'number') {
                    val = val & 255
                }

                // Invalid ranges are not set to a default, so can range check early.
                if (start < 0 || this.length < start || this.length < end) {
                    throw new RangeError('Out of range index')
                }

                if (end <= start) {
                    return this
                }

                start = start >>> 0
                end = end === undefined ? this.length : end >>> 0

                if (!val) val = 0

                var i
                if (typeof val === 'number') {
                    for (i = start; i < end; i++) {
                        this[i] = val
                    }
                } else {
                    var bytes = Buffer.isBuffer(val)
                        ? val
                        : utf8ToBytes(new Buffer(val, encoding).toString())
                    var len = bytes.length
                    for (i = 0; i < end - start; i++) {
                        this[i + start] = bytes[i % len]
                    }
                }

                return this
            }

// HELPER FUNCTIONS
// ================

            var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

            function base64clean (str) {
                // Node strips out invalid characters like \n and \t from the string, base64-js does not
                str = stringtrim(str).replace(INVALID_BASE64_RE, '')
                // Node converts strings with length < 2 to ''
                if (str.length < 2) return ''
                // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                while (str.length % 4 !== 0) {
                    str = str + '='
                }
                return str
            }

            function stringtrim (str) {
                if (str.trim) return str.trim()
                return str.replace(/^\s+|\s+$/g, '')
            }

            function toHex (n) {
                if (n < 16) return '0' + n.toString(16)
                return n.toString(16)
            }

            function utf8ToBytes (string, units) {
                units = units || Infinity
                var codePoint
                var length = string.length
                var leadSurrogate = null
                var bytes = []

                for (var i = 0; i < length; i++) {
                    codePoint = string.charCodeAt(i)

                    // is surrogate component
                    if (codePoint > 0xD7FF && codePoint < 0xE000) {
                        // last char was a lead
                        if (!leadSurrogate) {
                            // no lead yet
                            if (codePoint > 0xDBFF) {
                                // unexpected trail
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                                continue
                            } else if (i + 1 === length) {
                                // unpaired lead
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                                continue
                            }

                            // valid lead
                            leadSurrogate = codePoint

                            continue
                        }

                        // 2 leads in a row
                        if (codePoint < 0xDC00) {
                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                            leadSurrogate = codePoint
                            continue
                        }

                        // valid surrogate pair
                        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
                    } else if (leadSurrogate) {
                        // valid bmp char, but last char was a lead
                        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                    }

                    leadSurrogate = null

                    // encode utf8
                    if (codePoint < 0x80) {
                        if ((units -= 1) < 0) break
                        bytes.push(codePoint)
                    } else if (codePoint < 0x800) {
                        if ((units -= 2) < 0) break
                        bytes.push(
                            codePoint >> 0x6 | 0xC0,
                            codePoint & 0x3F | 0x80
                        )
                    } else if (codePoint < 0x10000) {
                        if ((units -= 3) < 0) break
                        bytes.push(
                            codePoint >> 0xC | 0xE0,
                            codePoint >> 0x6 & 0x3F | 0x80,
                            codePoint & 0x3F | 0x80
                        )
                    } else if (codePoint < 0x110000) {
                        if ((units -= 4) < 0) break
                        bytes.push(
                            codePoint >> 0x12 | 0xF0,
                            codePoint >> 0xC & 0x3F | 0x80,
                            codePoint >> 0x6 & 0x3F | 0x80,
                            codePoint & 0x3F | 0x80
                        )
                    } else {
                        throw new Error('Invalid code point')
                    }
                }

                return bytes
            }

            function asciiToBytes (str) {
                var byteArray = []
                for (var i = 0; i < str.length; i++) {
                    // Node's code seems to be doing this and not & 0x7F..
                    byteArray.push(str.charCodeAt(i) & 0xFF)
                }
                return byteArray
            }

            function utf16leToBytes (str, units) {
                var c, hi, lo
                var byteArray = []
                for (var i = 0; i < str.length; i++) {
                    if ((units -= 2) < 0) break

                    c = str.charCodeAt(i)
                    hi = c >> 8
                    lo = c % 256
                    byteArray.push(lo)
                    byteArray.push(hi)
                }

                return byteArray
            }

            function base64ToBytes (str) {
                return base64.toByteArray(base64clean(str))
            }

            function blitBuffer (src, dst, offset, length) {
                for (var i = 0; i < length; i++) {
                    if ((i + offset >= dst.length) || (i >= src.length)) break
                    dst[i + offset] = src[i]
                }
                return i
            }

            function isnan (val) {
                return val !== val // eslint-disable-line no-self-compare
            }

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"base64-js":1,"ieee754":15,"isarray":16}],4:[function(require,module,exports){
// Use strict mode (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)
        "use strict";


// Requires
        var Typo = require("typo-js");


// Create function
        function CodeMirrorSpellChecker(options) {
            // Initialize
            options = options || {};


            // Verify
            if(typeof options.codeMirrorInstance !== "function" || typeof options.codeMirrorInstance.defineMode !== "function") {
                console.log("CodeMirror Spell Checker: You must provide an instance of CodeMirror via the option `codeMirrorInstance`");
                return;
            }


            // Because some browsers don't support this functionality yet
            if(!String.prototype.includes) {
                String.prototype.includes = function() {
                    "use strict";
                    return String.prototype.indexOf.apply(this, arguments) !== -1;
                };
            }


            // Define the new mode
            options.codeMirrorInstance.defineMode("spell-checker", function(config) {
                // Load AFF/DIC data
                if(!CodeMirrorSpellChecker.aff_loading) {
                    CodeMirrorSpellChecker.aff_loading = true;
                    var xhr_aff = new XMLHttpRequest();
                    xhr_aff.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.aff", true);
                    xhr_aff.onload = function() {
                        if(xhr_aff.readyState === 4 && xhr_aff.status === 200) {
                            CodeMirrorSpellChecker.aff_data = xhr_aff.responseText;
                            CodeMirrorSpellChecker.num_loaded++;

                            if(CodeMirrorSpellChecker.num_loaded == 2) {
                                CodeMirrorSpellChecker.typo = new Typo("en_US", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {
                                    platform: "any"
                                });
                            }
                        }
                    };
                    xhr_aff.send(null);
                }

                if(!CodeMirrorSpellChecker.dic_loading) {
                    CodeMirrorSpellChecker.dic_loading = true;
                    var xhr_dic = new XMLHttpRequest();
                    xhr_dic.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.dic", true);
                    xhr_dic.onload = function() {
                        if(xhr_dic.readyState === 4 && xhr_dic.status === 200) {
                            CodeMirrorSpellChecker.dic_data = xhr_dic.responseText;
                            CodeMirrorSpellChecker.num_loaded++;

                            if(CodeMirrorSpellChecker.num_loaded == 2) {
                                CodeMirrorSpellChecker.typo = new Typo("en_US", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {
                                    platform: "any"
                                });
                            }
                        }
                    };
                    xhr_dic.send(null);
                }


                // Define what separates a word
                var rx_word = "!\"#$%&()*+,-./:;<=>?@[\\]^_`{|}~ ";


                // Create the overlay and such
                var overlay = {
                    token: function(stream) {
                        var ch = stream.peek();
                        var word = "";

                        if(rx_word.includes(ch)) {
                            stream.next();
                            return null;
                        }

                        while((ch = stream.peek()) != null && !rx_word.includes(ch)) {
                            word += ch;
                            stream.next();
                        }

                        if(CodeMirrorSpellChecker.typo && !CodeMirrorSpellChecker.typo.check(word))
                            return "spell-error"; // CSS class: cm-spell-error

                        return null;
                    }
                };

                var mode = options.codeMirrorInstance.getMode(
                    config, config.backdrop || "text/plain"
                );

                return options.codeMirrorInstance.overlayMode(mode, overlay, true);
            });
        }


// Initialize data globally to reduce memory consumption
        CodeMirrorSpellChecker.num_loaded = 0;
        CodeMirrorSpellChecker.aff_loading = false;
        CodeMirrorSpellChecker.dic_loading = false;
        CodeMirrorSpellChecker.aff_data = "";
        CodeMirrorSpellChecker.dic_data = "";
        CodeMirrorSpellChecker.typo;


// Export
        module.exports = CodeMirrorSpellChecker;
    },{"typo-js":18}],5:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

        (function(mod) {
            if (typeof exports == "object" && typeof module == "object") // CommonJS
                mod(require("../../lib/codemirror"));
            else if (typeof define == "function" && define.amd) // AMD
                define(["../../lib/codemirror"], mod);
            else // Plain browser env
                mod(CodeMirror);
        })(function(CodeMirror) {
            "use strict";

            CodeMirror.defineOption("fullScreen", false, function(cm, val, old) {
                if (old == CodeMirror.Init) old = false;
                if (!old == !val) return;
                if (val) setFullscreen(cm);
                else setNormal(cm);
            });

            function setFullscreen(cm) {
                var wrap = cm.getWrapperElement();
                cm.state.fullScreenRestore = {scrollTop: window.pageYOffset, scrollLeft: window.pageXOffset,
                    width: wrap.style.width, height: wrap.style.height};
                wrap.style.width = "";
                wrap.style.height = "auto";
                wrap.className += " CodeMirror-fullscreen";
                document.documentElement.style.overflow = "hidden";
                cm.refresh();
            }

            function setNormal(cm) {
                var wrap = cm.getWrapperElement();
                wrap.className = wrap.className.replace(/\s*CodeMirror-fullscreen\b/, "");
                document.documentElement.style.overflow = "";
                var info = cm.state.fullScreenRestore;
                wrap.style.width = info.width; wrap.style.height = info.height;
                window.scrollTo(info.scrollLeft, info.scrollTop);
                cm.refresh();
            }
        });

    },{"../../lib/codemirror":10}],6:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

        (function(mod) {
            if (typeof exports == "object" && typeof module == "object") // CommonJS
                mod(require("../../lib/codemirror"));
            else if (typeof define == "function" && define.amd) // AMD
                define(["../../lib/codemirror"], mod);
            else // Plain browser env
                mod(CodeMirror);
        })(function(CodeMirror) {
            CodeMirror.defineOption("placeholder", "", function(cm, val, old) {
                var prev = old && old != CodeMirror.Init;
                if (val && !prev) {
                    cm.on("blur", onBlur);
                    cm.on("change", onChange);
                    cm.on("swapDoc", onChange);
                    onChange(cm);
                } else if (!val && prev) {
                    cm.off("blur", onBlur);
                    cm.off("change", onChange);
                    cm.off("swapDoc", onChange);
                    clearPlaceholder(cm);
                    var wrapper = cm.getWrapperElement();
                    wrapper.className = wrapper.className.replace(" CodeMirror-empty", "");
                }

                if (val && !cm.hasFocus()) onBlur(cm);
            });

            function clearPlaceholder(cm) {
                if (cm.state.placeholder) {
                    cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);
                    cm.state.placeholder = null;
                }
            }
            function setPlaceholder(cm) {
                clearPlaceholder(cm);
                var elt = cm.state.placeholder = document.createElement("pre");
                elt.style.cssText = "height: 0; overflow: visible";
                elt.className = "CodeMirror-placeholder";
                var placeHolder = cm.getOption("placeholder")
                if (typeof placeHolder == "string") placeHolder = document.createTextNode(placeHolder)
                elt.appendChild(placeHolder)
                cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);
            }

            function onBlur(cm) {
                if (isEmpty(cm)) setPlaceholder(cm);
            }
            function onChange(cm) {
                var wrapper = cm.getWrapperElement(), empty = isEmpty(cm);
                wrapper.className = wrapper.className.replace(" CodeMirror-empty", "") + (empty ? " CodeMirror-empty" : "");

                if (empty) setPlaceholder(cm);
                else clearPlaceholder(cm);
            }

            function isEmpty(cm) {
                return (cm.lineCount() === 1) && (cm.getLine(0) === "");
            }
        });

    },{"../../lib/codemirror":10}],7:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

        (function(mod) {
            if (typeof exports == "object" && typeof module == "object") // CommonJS
                mod(require("../../lib/codemirror"));
            else if (typeof define == "function" && define.amd) // AMD
                define(["../../lib/codemirror"], mod);
            else // Plain browser env
                mod(CodeMirror);
        })(function(CodeMirror) {
            "use strict";

            var listRE = /^(\s*)(>[> ]*|[*+-]\s|(\d+)([.)]))(\s*)/,
                emptyListRE = /^(\s*)(>[> ]*|[*+-]|(\d+)[.)])(\s*)$/,
                unorderedListRE = /[*+-]\s/;

            CodeMirror.commands.newlineAndIndentContinueMarkdownList = function(cm) {
                if (cm.getOption("disableInput")) return CodeMirror.Pass;
                var ranges = cm.listSelections(), replacements = [];
                for (var i = 0; i < ranges.length; i++) {
                    var pos = ranges[i].head;
                    var eolState = cm.getStateAfter(pos.line);
                    var inList = eolState.list !== false;
                    var inQuote = eolState.quote !== 0;

                    var line = cm.getLine(pos.line), match = listRE.exec(line);
                    if (!ranges[i].empty() || (!inList && !inQuote) || !match) {
                        cm.execCommand("newlineAndIndent");
                        return;
                    }
                    if (emptyListRE.test(line)) {
                        cm.replaceRange("", {
                            line: pos.line, ch: 0
                        }, {
                            line: pos.line, ch: pos.ch + 1
                        });
                        replacements[i] = "\n";
                    } else {
                        var indent = match[1], after = match[5];
                        var bullet = unorderedListRE.test(match[2]) || match[2].indexOf(">") >= 0
                            ? match[2]
                            : (parseInt(match[3], 10) + 1) + match[4];

                        replacements[i] = "\n" + indent + bullet + after;
                    }
                }

                cm.replaceSelections(replacements);
            };
        });

    },{"../../lib/codemirror":10}],8:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// Utility function that allows modes to be combined. The mode given
// as the base argument takes care of most of the normal mode
// functionality, but a second (typically simple) mode is used, which
// can override the style of text. Both modes get to parse all of the
// text, but when both assign a non-null style to a piece of code, the
// overlay wins, unless the combine argument was true and not overridden,
// or state.overlay.combineTokens was true, in which case the styles are
// combined.

        (function(mod) {
            if (typeof exports == "object" && typeof module == "object") // CommonJS
                mod(require("../../lib/codemirror"));
            else if (typeof define == "function" && define.amd) // AMD
                define(["../../lib/codemirror"], mod);
            else // Plain browser env
                mod(CodeMirror);
        })(function(CodeMirror) {
            "use strict";

            CodeMirror.overlayMode = function(base, overlay, combine) {
                return {
                    startState: function() {
                        return {
                            base: CodeMirror.startState(base),
                            overlay: CodeMirror.startState(overlay),
                            basePos: 0, baseCur: null,
                            overlayPos: 0, overlayCur: null,
                            streamSeen: null
                        };
                    },
                    copyState: function(state) {
                        return {
                            base: CodeMirror.copyState(base, state.base),
                            overlay: CodeMirror.copyState(overlay, state.overlay),
                            basePos: state.basePos, baseCur: null,
                            overlayPos: state.overlayPos, overlayCur: null
                        };
                    },

                    token: function(stream, state) {
                        if (stream != state.streamSeen ||
                            Math.min(state.basePos, state.overlayPos) < stream.start) {
                            state.streamSeen = stream;
                            state.basePos = state.overlayPos = stream.start;
                        }

                        if (stream.start == state.basePos) {
                            state.baseCur = base.token(stream, state.base);
                            state.basePos = stream.pos;
                        }
                        if (stream.start == state.overlayPos) {
                            stream.pos = stream.start;
                            state.overlayCur = overlay.token(stream, state.overlay);
                            state.overlayPos = stream.pos;
                        }
                        stream.pos = Math.min(state.basePos, state.overlayPos);

                        // state.overlay.combineTokens always takes precedence over combine,
                        // unless set to null
                        if (state.overlayCur == null) return state.baseCur;
                        else if (state.baseCur != null &&
                            state.overlay.combineTokens ||
                            combine && state.overlay.combineTokens == null)
                            return state.baseCur + " " + state.overlayCur;
                        else return state.overlayCur;
                    },

                    indent: base.indent && function(state, textAfter) {
                        return base.indent(state.base, textAfter);
                    },
                    electricChars: base.electricChars,

                    innerMode: function(state) { return {state: state.base, mode: base}; },

                    blankLine: function(state) {
                        if (base.blankLine) base.blankLine(state.base);
                        if (overlay.blankLine) overlay.blankLine(state.overlay);
                    }
                };
            };

        });

    },{"../../lib/codemirror":10}],9:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// Because sometimes you need to mark the selected *text*.
//
// Adds an option 'styleSelectedText' which, when enabled, gives
// selected text the CSS class given as option value, or
// "CodeMirror-selectedtext" when the value is not a string.

        (function(mod) {
            if (typeof exports == "object" && typeof module == "object") // CommonJS
                mod(require("../../lib/codemirror"));
            else if (typeof define == "function" && define.amd) // AMD
                define(["../../lib/codemirror"], mod);
            else // Plain browser env
                mod(CodeMirror);
        })(function(CodeMirror) {
            "use strict";

            CodeMirror.defineOption("styleSelectedText", false, function(cm, val, old) {
                var prev = old && old != CodeMirror.Init;
                if (val && !prev) {
                    cm.state.markedSelection = [];
                    cm.state.markedSelectionStyle = typeof val == "string" ? val : "CodeMirror-selectedtext";
                    reset(cm);
                    cm.on("cursorActivity", onCursorActivity);
                    cm.on("change", onChange);
                } else if (!val && prev) {
                    cm.off("cursorActivity", onCursorActivity);
                    cm.off("change", onChange);
                    clear(cm);
                    cm.state.markedSelection = cm.state.markedSelectionStyle = null;
                }
            });

            function onCursorActivity(cm) {
                cm.operation(function() { update(cm); });
            }

            function onChange(cm) {
                if (cm.state.markedSelection.length)
                    cm.operation(function() { clear(cm); });
            }

            var CHUNK_SIZE = 8;
            var Pos = CodeMirror.Pos;
            var cmp = CodeMirror.cmpPos;

            function coverRange(cm, from, to, addAt) {
                if (cmp(from, to) == 0) return;
                var array = cm.state.markedSelection;
                var cls = cm.state.markedSelectionStyle;
                for (var line = from.line;;) {
                    var start = line == from.line ? from : Pos(line, 0);
                    var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;
                    var end = atEnd ? to : Pos(endLine, 0);
                    var mark = cm.markText(start, end, {className: cls});
                    if (addAt == null) array.push(mark);
                    else array.splice(addAt++, 0, mark);
                    if (atEnd) break;
                    line = endLine;
                }
            }

            function clear(cm) {
                var array = cm.state.markedSelection;
                for (var i = 0; i < array.length; ++i) array[i].clear();
                array.length = 0;
            }

            function reset(cm) {
                clear(cm);
                var ranges = cm.listSelections();
                for (var i = 0; i < ranges.length; i++)
                    coverRange(cm, ranges[i].from(), ranges[i].to());
            }

            function update(cm) {
                if (!cm.somethingSelected()) return clear(cm);
                if (cm.listSelections().length > 1) return reset(cm);

                var from = cm.getCursor("start"), to = cm.getCursor("end");

                var array = cm.state.markedSelection;
                if (!array.length) return coverRange(cm, from, to);

                var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();
                if (!coverStart || !coverEnd || to.line - from.line < CHUNK_SIZE ||
                    cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)
                    return reset(cm);

                while (cmp(from, coverStart.from) > 0) {
                    array.shift().clear();
                    coverStart = array[0].find();
                }
                if (cmp(from, coverStart.from) < 0) {
                    if (coverStart.to.line - from.line < CHUNK_SIZE) {
                        array.shift().clear();
                        coverRange(cm, from, coverStart.to, 0);
                    } else {
                        coverRange(cm, from, coverStart.from, 0);
                    }
                }

                while (cmp(to, coverEnd.to) < 0) {
                    array.pop().clear();
                    coverEnd = array[array.length - 1].find();
                }
                if (cmp(to, coverEnd.to) > 0) {
                    if (to.line - coverEnd.from.line < CHUNK_SIZE) {
                        array.pop().clear();
                        coverRange(cm, coverEnd.from, to);
                    } else {
                        coverRange(cm, coverEnd.to, to);
                    }
                }
            }
        });

    },{"../../lib/codemirror":10}],10:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

        (function(mod) {
            if (typeof exports == "object" && typeof module == "object") // CommonJS
                module.exports = mod();
            else if (typeof define == "function" && define.amd) // AMD
                return define([], mod);
            else // Plain browser env
                (this || window).CodeMirror = mod();
        })(function() {
            "use strict";

            // BROWSER SNIFFING

            // Kludges for bugs and behavior differences that can't be feature
            // detected are enabled based on userAgent etc sniffing.
            var userAgent = navigator.userAgent;
            var platform = navigator.platform;

            var gecko = /gecko\/\d/i.test(userAgent);
            var ie_upto10 = /MSIE \d/.test(userAgent);
            var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
            var ie = ie_upto10 || ie_11up;
            var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
            var webkit = /WebKit\//.test(userAgent);
            var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
            var chrome = /Chrome\//.test(userAgent);
            var presto = /Opera\//.test(userAgent);
            var safari = /Apple Computer/.test(navigator.vendor);
            var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
            var phantom = /PhantomJS/.test(userAgent);

            var ios = /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
            // This is woefully incomplete. Suggestions for alternative methods welcome.
            var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
            var mac = ios || /Mac/.test(platform);
            var chromeOS = /\bCrOS\b/.test(userAgent);
            var windows = /win/i.test(platform);

            var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
            if (presto_version) presto_version = Number(presto_version[1]);
            if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
            // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
            var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
            var captureRightClick = gecko || (ie && ie_version >= 9);

            // Optimize some code when these features are not used.
            var sawReadOnlySpans = false, sawCollapsedSpans = false;

            // EDITOR CONSTRUCTOR

            // A CodeMirror instance represents an editor. This is the object
            // that user code is usually dealing with.

            function CodeMirror(place, options) {
                if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

                this.options = options = options ? copyObj(options) : {};
                // Determine effective options based on given values and defaults.
                copyObj(defaults, options, false);
                setGuttersForLineNumbers(options);

                var doc = options.value;
                if (typeof doc == "string") doc = new Doc(doc, options.mode, null, options.lineSeparator);
                this.doc = doc;

                var input = new CodeMirror.inputStyles[options.inputStyle](this);
                var display = this.display = new Display(place, doc, input);
                display.wrapper.CodeMirror = this;
                updateGutters(this);
                themeChanged(this);
                if (options.lineWrapping)
                    this.display.wrapper.className += " CodeMirror-wrap";
                if (options.autofocus && !mobile) display.input.focus();
                initScrollbars(this);

                this.state = {
                    keyMaps: [],  // stores maps added by addKeyMap
                    overlays: [], // highlighting overlays, as added by addOverlay
                    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
                    overwrite: false,
                    delayingBlurEvent: false,
                    focused: false,
                    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
                    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
                    selectingText: false,
                    draggingText: false,
                    highlight: new Delayed(), // stores highlight worker timeout
                    keySeq: null,  // Unfinished key sequence
                    specialChars: null
                };

                var cm = this;

                // Override magic textarea content restore that IE sometimes does
                // on our hidden textarea on reload
                if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);

                registerEventHandlers(this);
                ensureGlobalHandlers();

                startOperation(this);
                this.curOp.forceUpdate = true;
                attachDoc(this, doc);

                if ((options.autofocus && !mobile) || cm.hasFocus())
                    setTimeout(bind(onFocus, this), 20);
                else
                    onBlur(this);

                for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
                    optionHandlers[opt](this, options[opt], Init);
                maybeUpdateLineNumberWidth(this);
                if (options.finishInit) options.finishInit(this);
                for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
                endOperation(this);
                // Suppress optimizelegibility in Webkit, since it breaks text
                // measuring on line wrapping boundaries.
                if (webkit && options.lineWrapping &&
                    getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
                    display.lineDiv.style.textRendering = "auto";
            }

            // DISPLAY CONSTRUCTOR

            // The display handles the DOM integration, both for input reading
            // and content drawing. It holds references to DOM nodes and
            // display-related state.

            function Display(place, doc, input) {
                var d = this;
                this.input = input;

                // Covers bottom-right square when both scrollbars are present.
                d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
                d.scrollbarFiller.setAttribute("cm-not-content", "true");
                // Covers bottom of gutter when coverGutterNextToScrollbar is on
                // and h scrollbar is present.
                d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
                d.gutterFiller.setAttribute("cm-not-content", "true");
                // Will contain the actual code, positioned to cover the viewport.
                d.lineDiv = elt("div", null, "CodeMirror-code");
                // Elements are added to these to represent selection and cursors.
                d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
                d.cursorDiv = elt("div", null, "CodeMirror-cursors");
                // A visibility: hidden element used to find the size of things.
                d.measure = elt("div", null, "CodeMirror-measure");
                // When lines outside of the viewport are measured, they are drawn in this.
                d.lineMeasure = elt("div", null, "CodeMirror-measure");
                // Wraps everything that needs to exist inside the vertically-padded coordinate system
                d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                    null, "position: relative; outline: none");
                // Moved around its parent to cover visible view.
                d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
                // Set to the height of the document, allowing scrolling.
                d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
                d.sizerWidth = null;
                // Behavior of elts with overflow: auto and padding is
                // inconsistent across browsers. This is used to ensure the
                // scrollable area is big enough.
                d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
                // Will contain the gutters, if any.
                d.gutters = elt("div", null, "CodeMirror-gutters");
                d.lineGutter = null;
                // Actual scrollable element.
                d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
                d.scroller.setAttribute("tabIndex", "-1");
                // The element in which the editor lives.
                d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

                // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
                if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
                if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;

                if (place) {
                    if (place.appendChild) place.appendChild(d.wrapper);
                    else place(d.wrapper);
                }

                // Current rendered range (may be bigger than the view window).
                d.viewFrom = d.viewTo = doc.first;
                d.reportedViewFrom = d.reportedViewTo = doc.first;
                // Information about the rendered lines.
                d.view = [];
                d.renderedView = null;
                // Holds info about a single rendered line when it was rendered
                // for measurement, while not in view.
                d.externalMeasured = null;
                // Empty space (in pixels) above the view
                d.viewOffset = 0;
                d.lastWrapHeight = d.lastWrapWidth = 0;
                d.updateLineNumbers = null;

                d.nativeBarWidth = d.barHeight = d.barWidth = 0;
                d.scrollbarsClipped = false;

                // Used to only resize the line number gutter when necessary (when
                // the amount of lines crosses a boundary that makes its width change)
                d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
                // Set to true when a non-horizontal-scrolling line widget is
                // added. As an optimization, line widget aligning is skipped when
                // this is false.
                d.alignWidgets = false;

                d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

                // Tracks the maximum line length so that the horizontal scrollbar
                // can be kept static when scrolling.
                d.maxLine = null;
                d.maxLineLength = 0;
                d.maxLineChanged = false;

                // Used for measuring wheel scrolling granularity
                d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

                // True when shift is held down.
                d.shift = false;

                // Used to track whether anything happened since the context menu
                // was opened.
                d.selForContextMenu = null;

                d.activeTouch = null;

                input.init(d);
            }

            // STATE UPDATES

            // Used to get the editor into a consistent state again when options change.

            function loadMode(cm) {
                cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
                resetModeState(cm);
            }

            function resetModeState(cm) {
                cm.doc.iter(function(line) {
                    if (line.stateAfter) line.stateAfter = null;
                    if (line.styles) line.styles = null;
                });
                cm.doc.frontier = cm.doc.first;
                startWorker(cm, 100);
                cm.state.modeGen++;
                if (cm.curOp) regChange(cm);
            }

            function wrappingChanged(cm) {
                if (cm.options.lineWrapping) {
                    addClass(cm.display.wrapper, "CodeMirror-wrap");
                    cm.display.sizer.style.minWidth = "";
                    cm.display.sizerWidth = null;
                } else {
                    rmClass(cm.display.wrapper, "CodeMirror-wrap");
                    findMaxLine(cm);
                }
                estimateLineHeights(cm);
                regChange(cm);
                clearCaches(cm);
                setTimeout(function(){updateScrollbars(cm);}, 100);
            }

            // Returns a function that estimates the height of a line, to use as
            // first approximation until the line becomes visible (and is thus
            // properly measurable).
            function estimateHeight(cm) {
                var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
                var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
                return function(line) {
                    if (lineIsHidden(cm.doc, line)) return 0;

                    var widgetsHeight = 0;
                    if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
                        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
                    }

                    if (wrapping)
                        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
                    else
                        return widgetsHeight + th;
                };
            }

            function estimateLineHeights(cm) {
                var doc = cm.doc, est = estimateHeight(cm);
                doc.iter(function(line) {
                    var estHeight = est(line);
                    if (estHeight != line.height) updateLineHeight(line, estHeight);
                });
            }

            function themeChanged(cm) {
                cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
                    cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
                clearCaches(cm);
            }

            function guttersChanged(cm) {
                updateGutters(cm);
                regChange(cm);
                setTimeout(function(){alignHorizontally(cm);}, 20);
            }

            // Rebuild the gutter elements, ensure the margin to the left of the
            // code matches their width.
            function updateGutters(cm) {
                var gutters = cm.display.gutters, specs = cm.options.gutters;
                removeChildren(gutters);
                for (var i = 0; i < specs.length; ++i) {
                    var gutterClass = specs[i];
                    var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
                    if (gutterClass == "CodeMirror-linenumbers") {
                        cm.display.lineGutter = gElt;
                        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
                    }
                }
                gutters.style.display = i ? "" : "none";
                updateGutterSpace(cm);
            }

            function updateGutterSpace(cm) {
                var width = cm.display.gutters.offsetWidth;
                cm.display.sizer.style.marginLeft = width + "px";
            }

            // Compute the character length of a line, taking into account
            // collapsed ranges (see markText) that might hide parts, and join
            // other lines onto it.
            function lineLength(line) {
                if (line.height == 0) return 0;
                var len = line.text.length, merged, cur = line;
                while (merged = collapsedSpanAtStart(cur)) {
                    var found = merged.find(0, true);
                    cur = found.from.line;
                    len += found.from.ch - found.to.ch;
                }
                cur = line;
                while (merged = collapsedSpanAtEnd(cur)) {
                    var found = merged.find(0, true);
                    len -= cur.text.length - found.from.ch;
                    cur = found.to.line;
                    len += cur.text.length - found.to.ch;
                }
                return len;
            }

            // Find the longest line in the document.
            function findMaxLine(cm) {
                var d = cm.display, doc = cm.doc;
                d.maxLine = getLine(doc, doc.first);
                d.maxLineLength = lineLength(d.maxLine);
                d.maxLineChanged = true;
                doc.iter(function(line) {
                    var len = lineLength(line);
                    if (len > d.maxLineLength) {
                        d.maxLineLength = len;
                        d.maxLine = line;
                    }
                });
            }

            // Make sure the gutters options contains the element
            // "CodeMirror-linenumbers" when the lineNumbers option is true.
            function setGuttersForLineNumbers(options) {
                var found = indexOf(options.gutters, "CodeMirror-linenumbers");
                if (found == -1 && options.lineNumbers) {
                    options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
                } else if (found > -1 && !options.lineNumbers) {
                    options.gutters = options.gutters.slice(0);
                    options.gutters.splice(found, 1);
                }
            }

            // SCROLLBARS

            // Prepare DOM reads needed to update the scrollbars. Done in one
            // shot to minimize update/measure roundtrips.
            function measureForScrollbars(cm) {
                var d = cm.display, gutterW = d.gutters.offsetWidth;
                var docH = Math.round(cm.doc.height + paddingVert(cm.display));
                return {
                    clientHeight: d.scroller.clientHeight,
                    viewHeight: d.wrapper.clientHeight,
                    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
                    viewWidth: d.wrapper.clientWidth,
                    barLeft: cm.options.fixedGutter ? gutterW : 0,
                    docHeight: docH,
                    scrollHeight: docH + scrollGap(cm) + d.barHeight,
                    nativeBarWidth: d.nativeBarWidth,
                    gutterWidth: gutterW
                };
            }

            function NativeScrollbars(place, scroll, cm) {
                this.cm = cm;
                var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
                var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
                place(vert); place(horiz);

                on(vert, "scroll", function() {
                    if (vert.clientHeight) scroll(vert.scrollTop, "vertical");
                });
                on(horiz, "scroll", function() {
                    if (horiz.clientWidth) scroll(horiz.scrollLeft, "horizontal");
                });

                this.checkedZeroWidth = false;
                // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
                if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
            }

            NativeScrollbars.prototype = copyObj({
                update: function(measure) {
                    var needsH = measure.scrollWidth > measure.clientWidth + 1;
                    var needsV = measure.scrollHeight > measure.clientHeight + 1;
                    var sWidth = measure.nativeBarWidth;

                    if (needsV) {
                        this.vert.style.display = "block";
                        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
                        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
                        // A bug in IE8 can cause this value to be negative, so guard it.
                        this.vert.firstChild.style.height =
                            Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
                    } else {
                        this.vert.style.display = "";
                        this.vert.firstChild.style.height = "0";
                    }

                    if (needsH) {
                        this.horiz.style.display = "block";
                        this.horiz.style.right = needsV ? sWidth + "px" : "0";
                        this.horiz.style.left = measure.barLeft + "px";
                        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
                        this.horiz.firstChild.style.width =
                            (measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
                    } else {
                        this.horiz.style.display = "";
                        this.horiz.firstChild.style.width = "0";
                    }

                    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
                        if (sWidth == 0) this.zeroWidthHack();
                        this.checkedZeroWidth = true;
                    }

                    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};
                },
                setScrollLeft: function(pos) {
                    if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;
                    if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);
                },
                setScrollTop: function(pos) {
                    if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;
                    if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);
                },
                zeroWidthHack: function() {
                    var w = mac && !mac_geMountainLion ? "12px" : "18px";
                    this.horiz.style.height = this.vert.style.width = w;
                    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
                    this.disableHoriz = new Delayed;
                    this.disableVert = new Delayed;
                },
                enableZeroWidthBar: function(bar, delay) {
                    bar.style.pointerEvents = "auto";
                    function maybeDisable() {
                        // To find out whether the scrollbar is still visible, we
                        // check whether the element under the pixel in the bottom
                        // left corner of the scrollbar box is the scrollbar box
                        // itself (when the bar is still visible) or its filler child
                        // (when the bar is hidden). If it is still visible, we keep
                        // it enabled, if it's hidden, we disable pointer events.
                        var box = bar.getBoundingClientRect();
                        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);
                        if (elt != bar) bar.style.pointerEvents = "none";
                        else delay.set(1000, maybeDisable);
                    }
                    delay.set(1000, maybeDisable);
                },
                clear: function() {
                    var parent = this.horiz.parentNode;
                    parent.removeChild(this.horiz);
                    parent.removeChild(this.vert);
                }
            }, NativeScrollbars.prototype);

            function NullScrollbars() {}

            NullScrollbars.prototype = copyObj({
                update: function() { return {bottom: 0, right: 0}; },
                setScrollLeft: function() {},
                setScrollTop: function() {},
                clear: function() {}
            }, NullScrollbars.prototype);

            CodeMirror.scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

            function initScrollbars(cm) {
                if (cm.display.scrollbars) {
                    cm.display.scrollbars.clear();
                    if (cm.display.scrollbars.addClass)
                        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
                }

                cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {
                    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
                    // Prevent clicks in the scrollbars from killing focus
                    on(node, "mousedown", function() {
                        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);
                    });
                    node.setAttribute("cm-not-content", "true");
                }, function(pos, axis) {
                    if (axis == "horizontal") setScrollLeft(cm, pos);
                    else setScrollTop(cm, pos);
                }, cm);
                if (cm.display.scrollbars.addClass)
                    addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
            }

            function updateScrollbars(cm, measure) {
                if (!measure) measure = measureForScrollbars(cm);
                var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
                updateScrollbarsInner(cm, measure);
                for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
                    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
                        updateHeightsInViewport(cm);
                    updateScrollbarsInner(cm, measureForScrollbars(cm));
                    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
                }
            }

            // Re-synchronize the fake scrollbars with the actual size of the
            // content.
            function updateScrollbarsInner(cm, measure) {
                var d = cm.display;
                var sizes = d.scrollbars.update(measure);

                d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
                d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
                d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent"

                if (sizes.right && sizes.bottom) {
                    d.scrollbarFiller.style.display = "block";
                    d.scrollbarFiller.style.height = sizes.bottom + "px";
                    d.scrollbarFiller.style.width = sizes.right + "px";
                } else d.scrollbarFiller.style.display = "";
                if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
                    d.gutterFiller.style.display = "block";
                    d.gutterFiller.style.height = sizes.bottom + "px";
                    d.gutterFiller.style.width = measure.gutterWidth + "px";
                } else d.gutterFiller.style.display = "";
            }

            // Compute the lines that are visible in a given viewport (defaults
            // the the current scroll position). viewport may contain top,
            // height, and ensure (see op.scrollToPos) properties.
            function visibleLines(display, doc, viewport) {
                var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
                top = Math.floor(top - paddingTop(display));
                var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

                var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
                // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
                // forces those lines into the viewport (if possible).
                if (viewport && viewport.ensure) {
                    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
                    if (ensureFrom < from) {
                        from = ensureFrom;
                        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
                    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
                        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
                        to = ensureTo;
                    }
                }
                return {from: from, to: Math.max(to, from + 1)};
            }

            // LINE NUMBERS

            // Re-align line numbers and gutter marks to compensate for
            // horizontal scrolling.
            function alignHorizontally(cm) {
                var display = cm.display, view = display.view;
                if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
                var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
                var gutterW = display.gutters.offsetWidth, left = comp + "px";
                for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
                    if (cm.options.fixedGutter && view[i].gutter)
                        view[i].gutter.style.left = left;
                    var align = view[i].alignable;
                    if (align) for (var j = 0; j < align.length; j++)
                        align[j].style.left = left;
                }
                if (cm.options.fixedGutter)
                    display.gutters.style.left = (comp + gutterW) + "px";
            }

            // Used to ensure that the line number gutter is still the right
            // size for the current document size. Returns true when an update
            // is needed.
            function maybeUpdateLineNumberWidth(cm) {
                if (!cm.options.lineNumbers) return false;
                var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
                if (last.length != display.lineNumChars) {
                    var test = display.measure.appendChild(elt("div", [elt("div", last)],
                        "CodeMirror-linenumber CodeMirror-gutter-elt"));
                    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
                    display.lineGutter.style.width = "";
                    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
                    display.lineNumWidth = display.lineNumInnerWidth + padding;
                    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
                    display.lineGutter.style.width = display.lineNumWidth + "px";
                    updateGutterSpace(cm);
                    return true;
                }
                return false;
            }

            function lineNumberFor(options, i) {
                return String(options.lineNumberFormatter(i + options.firstLineNumber));
            }

            // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
            // but using getBoundingClientRect to get a sub-pixel-accurate
            // result.
            function compensateForHScroll(display) {
                return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
            }

            // DISPLAY DRAWING

            function DisplayUpdate(cm, viewport, force) {
                var display = cm.display;

                this.viewport = viewport;
                // Store some values that we'll need later (but don't want to force a relayout for)
                this.visible = visibleLines(display, cm.doc, viewport);
                this.editorIsHidden = !display.wrapper.offsetWidth;
                this.wrapperHeight = display.wrapper.clientHeight;
                this.wrapperWidth = display.wrapper.clientWidth;
                this.oldDisplayWidth = displayWidth(cm);
                this.force = force;
                this.dims = getDimensions(cm);
                this.events = [];
            }

            DisplayUpdate.prototype.signal = function(emitter, type) {
                if (hasHandler(emitter, type))
                    this.events.push(arguments);
            };
            DisplayUpdate.prototype.finish = function() {
                for (var i = 0; i < this.events.length; i++)
                    signal.apply(null, this.events[i]);
            };

            function maybeClipScrollbars(cm) {
                var display = cm.display;
                if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
                    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
                    display.heightForcer.style.height = scrollGap(cm) + "px";
                    display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
                    display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
                    display.scrollbarsClipped = true;
                }
            }

            // Does the actual updating of the line display. Bails out
            // (returning false) when there is nothing to be done and forced is
            // false.
            function updateDisplayIfNeeded(cm, update) {
                var display = cm.display, doc = cm.doc;

                if (update.editorIsHidden) {
                    resetView(cm);
                    return false;
                }

                // Bail out if the visible area is already rendered and nothing changed.
                if (!update.force &&
                    update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
                    (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
                    display.renderedView == display.view && countDirtyView(cm) == 0)
                    return false;

                if (maybeUpdateLineNumberWidth(cm)) {
                    resetView(cm);
                    update.dims = getDimensions(cm);
                }

                // Compute a suitable new viewport (from & to)
                var end = doc.first + doc.size;
                var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
                var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
                if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
                if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
                if (sawCollapsedSpans) {
                    from = visualLineNo(cm.doc, from);
                    to = visualLineEndNo(cm.doc, to);
                }

                var different = from != display.viewFrom || to != display.viewTo ||
                    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
                adjustView(cm, from, to);

                display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
                // Position the mover div to align with the current scroll position
                cm.display.mover.style.top = display.viewOffset + "px";

                var toUpdate = countDirtyView(cm);
                if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
                    (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
                    return false;

                // For big changes, we hide the enclosing element during the
                // update, since that speeds up the operations on most browsers.
                var focused = activeElt();
                if (toUpdate > 4) display.lineDiv.style.display = "none";
                patchDisplay(cm, display.updateLineNumbers, update.dims);
                if (toUpdate > 4) display.lineDiv.style.display = "";
                display.renderedView = display.view;
                // There might have been a widget with a focused element that got
                // hidden or updated, if so re-focus it.
                if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();

                // Prevent selection and cursors from interfering with the scroll
                // width and height.
                removeChildren(display.cursorDiv);
                removeChildren(display.selectionDiv);
                display.gutters.style.height = display.sizer.style.minHeight = 0;

                if (different) {
                    display.lastWrapHeight = update.wrapperHeight;
                    display.lastWrapWidth = update.wrapperWidth;
                    startWorker(cm, 400);
                }

                display.updateLineNumbers = null;

                return true;
            }

            function postUpdateDisplay(cm, update) {
                var viewport = update.viewport;

                for (var first = true;; first = false) {
                    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
                        // Clip forced viewport to actual scrollable area.
                        if (viewport && viewport.top != null)
                            viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};
                        // Updated line heights might result in the drawn area not
                        // actually covering the viewport. Keep looping until it does.
                        update.visible = visibleLines(cm.display, cm.doc, viewport);
                        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
                            break;
                    }
                    if (!updateDisplayIfNeeded(cm, update)) break;
                    updateHeightsInViewport(cm);
                    var barMeasure = measureForScrollbars(cm);
                    updateSelection(cm);
                    updateScrollbars(cm, barMeasure);
                    setDocumentHeight(cm, barMeasure);
                }

                update.signal(cm, "update", cm);
                if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
                    update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
                    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
                }
            }

            function updateDisplaySimple(cm, viewport) {
                var update = new DisplayUpdate(cm, viewport);
                if (updateDisplayIfNeeded(cm, update)) {
                    updateHeightsInViewport(cm);
                    postUpdateDisplay(cm, update);
                    var barMeasure = measureForScrollbars(cm);
                    updateSelection(cm);
                    updateScrollbars(cm, barMeasure);
                    setDocumentHeight(cm, barMeasure);
                    update.finish();
                }
            }

            function setDocumentHeight(cm, measure) {
                cm.display.sizer.style.minHeight = measure.docHeight + "px";
                cm.display.heightForcer.style.top = measure.docHeight + "px";
                cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
            }

            // Read the actual heights of the rendered lines, and update their
            // stored heights to match.
            function updateHeightsInViewport(cm) {
                var display = cm.display;
                var prevBottom = display.lineDiv.offsetTop;
                for (var i = 0; i < display.view.length; i++) {
                    var cur = display.view[i], height;
                    if (cur.hidden) continue;
                    if (ie && ie_version < 8) {
                        var bot = cur.node.offsetTop + cur.node.offsetHeight;
                        height = bot - prevBottom;
                        prevBottom = bot;
                    } else {
                        var box = cur.node.getBoundingClientRect();
                        height = box.bottom - box.top;
                    }
                    var diff = cur.line.height - height;
                    if (height < 2) height = textHeight(display);
                    if (diff > .001 || diff < -.001) {
                        updateLineHeight(cur.line, height);
                        updateWidgetHeight(cur.line);
                        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
                            updateWidgetHeight(cur.rest[j]);
                    }
                }
            }

            // Read and store the height of line widgets associated with the
            // given line.
            function updateWidgetHeight(line) {
                if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
                    line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;
            }

            // Do a bulk-read of the DOM positions and sizes needed to draw the
            // view, so that we don't interleave reading and writing to the DOM.
            function getDimensions(cm) {
                var d = cm.display, left = {}, width = {};
                var gutterLeft = d.gutters.clientLeft;
                for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
                    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
                    width[cm.options.gutters[i]] = n.clientWidth;
                }
                return {fixedPos: compensateForHScroll(d),
                    gutterTotalWidth: d.gutters.offsetWidth,
                    gutterLeft: left,
                    gutterWidth: width,
                    wrapperWidth: d.wrapper.clientWidth};
            }

            // Sync the actual display DOM structure with display.view, removing
            // nodes for lines that are no longer in view, and creating the ones
            // that are not there yet, and updating the ones that are out of
            // date.
            function patchDisplay(cm, updateNumbersFrom, dims) {
                var display = cm.display, lineNumbers = cm.options.lineNumbers;
                var container = display.lineDiv, cur = container.firstChild;

                function rm(node) {
                    var next = node.nextSibling;
                    // Works around a throw-scroll bug in OS X Webkit
                    if (webkit && mac && cm.display.currentWheelTarget == node)
                        node.style.display = "none";
                    else
                        node.parentNode.removeChild(node);
                    return next;
                }

                var view = display.view, lineN = display.viewFrom;
                // Loop over the elements in the view, syncing cur (the DOM nodes
                // in display.lineDiv) with the view as we go.
                for (var i = 0; i < view.length; i++) {
                    var lineView = view[i];
                    if (lineView.hidden) {
                    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
                        var node = buildLineElement(cm, lineView, lineN, dims);
                        container.insertBefore(node, cur);
                    } else { // Already drawn
                        while (cur != lineView.node) cur = rm(cur);
                        var updateNumber = lineNumbers && updateNumbersFrom != null &&
                            updateNumbersFrom <= lineN && lineView.lineNumber;
                        if (lineView.changes) {
                            if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
                            updateLineForChanges(cm, lineView, lineN, dims);
                        }
                        if (updateNumber) {
                            removeChildren(lineView.lineNumber);
                            lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
                        }
                        cur = lineView.node.nextSibling;
                    }
                    lineN += lineView.size;
                }
                while (cur) cur = rm(cur);
            }

            // When an aspect of a line changes, a string is added to
            // lineView.changes. This updates the relevant part of the line's
            // DOM structure.
            function updateLineForChanges(cm, lineView, lineN, dims) {
                for (var j = 0; j < lineView.changes.length; j++) {
                    var type = lineView.changes[j];
                    if (type == "text") updateLineText(cm, lineView);
                    else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
                    else if (type == "class") updateLineClasses(lineView);
                    else if (type == "widget") updateLineWidgets(cm, lineView, dims);
                }
                lineView.changes = null;
            }

            // Lines with gutter elements, widgets or a background class need to
            // be wrapped, and have the extra elements added to the wrapper div
            function ensureLineWrapped(lineView) {
                if (lineView.node == lineView.text) {
                    lineView.node = elt("div", null, null, "position: relative");
                    if (lineView.text.parentNode)
                        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
                    lineView.node.appendChild(lineView.text);
                    if (ie && ie_version < 8) lineView.node.style.zIndex = 2;
                }
                return lineView.node;
            }

            function updateLineBackground(lineView) {
                var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
                if (cls) cls += " CodeMirror-linebackground";
                if (lineView.background) {
                    if (cls) lineView.background.className = cls;
                    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
                } else if (cls) {
                    var wrap = ensureLineWrapped(lineView);
                    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
                }
            }

            // Wrapper around buildLineContent which will reuse the structure
            // in display.externalMeasured when possible.
            function getLineContent(cm, lineView) {
                var ext = cm.display.externalMeasured;
                if (ext && ext.line == lineView.line) {
                    cm.display.externalMeasured = null;
                    lineView.measure = ext.measure;
                    return ext.built;
                }
                return buildLineContent(cm, lineView);
            }

            // Redraw the line's text. Interacts with the background and text
            // classes because the mode may output tokens that influence these
            // classes.
            function updateLineText(cm, lineView) {
                var cls = lineView.text.className;
                var built = getLineContent(cm, lineView);
                if (lineView.text == lineView.node) lineView.node = built.pre;
                lineView.text.parentNode.replaceChild(built.pre, lineView.text);
                lineView.text = built.pre;
                if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
                    lineView.bgClass = built.bgClass;
                    lineView.textClass = built.textClass;
                    updateLineClasses(lineView);
                } else if (cls) {
                    lineView.text.className = cls;
                }
            }

            function updateLineClasses(lineView) {
                updateLineBackground(lineView);
                if (lineView.line.wrapClass)
                    ensureLineWrapped(lineView).className = lineView.line.wrapClass;
                else if (lineView.node != lineView.text)
                    lineView.node.className = "";
                var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
                lineView.text.className = textClass || "";
            }

            function updateLineGutter(cm, lineView, lineN, dims) {
                if (lineView.gutter) {
                    lineView.node.removeChild(lineView.gutter);
                    lineView.gutter = null;
                }
                if (lineView.gutterBackground) {
                    lineView.node.removeChild(lineView.gutterBackground);
                    lineView.gutterBackground = null;
                }
                if (lineView.line.gutterClass) {
                    var wrap = ensureLineWrapped(lineView);
                    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                        "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +
                        "px; width: " + dims.gutterTotalWidth + "px");
                    wrap.insertBefore(lineView.gutterBackground, lineView.text);
                }
                var markers = lineView.line.gutterMarkers;
                if (cm.options.lineNumbers || markers) {
                    var wrap = ensureLineWrapped(lineView);
                    var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " +
                        (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
                    cm.display.input.setUneditable(gutterWrap);
                    wrap.insertBefore(gutterWrap, lineView.text);
                    if (lineView.line.gutterClass)
                        gutterWrap.className += " " + lineView.line.gutterClass;
                    if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
                        lineView.lineNumber = gutterWrap.appendChild(
                            elt("div", lineNumberFor(cm.options, lineN),
                                "CodeMirror-linenumber CodeMirror-gutter-elt",
                                "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
                                + cm.display.lineNumInnerWidth + "px"));
                    if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
                        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
                        if (found)
                            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
                    }
                }
            }

            function updateLineWidgets(cm, lineView, dims) {
                if (lineView.alignable) lineView.alignable = null;
                for (var node = lineView.node.firstChild, next; node; node = next) {
                    var next = node.nextSibling;
                    if (node.className == "CodeMirror-linewidget")
                        lineView.node.removeChild(node);
                }
                insertLineWidgets(cm, lineView, dims);
            }

            // Build a line's DOM representation from scratch
            function buildLineElement(cm, lineView, lineN, dims) {
                var built = getLineContent(cm, lineView);
                lineView.text = lineView.node = built.pre;
                if (built.bgClass) lineView.bgClass = built.bgClass;
                if (built.textClass) lineView.textClass = built.textClass;

                updateLineClasses(lineView);
                updateLineGutter(cm, lineView, lineN, dims);
                insertLineWidgets(cm, lineView, dims);
                return lineView.node;
            }

            // A lineView may contain multiple logical lines (when merged by
            // collapsed spans). The widgets for all of them need to be drawn.
            function insertLineWidgets(cm, lineView, dims) {
                insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
                if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
                    insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
            }

            function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
                if (!line.widgets) return;
                var wrap = ensureLineWrapped(lineView);
                for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
                    var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
                    if (!widget.handleMouseEvents) node.setAttribute("cm-ignore-events", "true");
                    positionLineWidget(widget, node, lineView, dims);
                    cm.display.input.setUneditable(node);
                    if (allowAbove && widget.above)
                        wrap.insertBefore(node, lineView.gutter || lineView.text);
                    else
                        wrap.appendChild(node);
                    signalLater(widget, "redraw");
                }
            }

            function positionLineWidget(widget, node, lineView, dims) {
                if (widget.noHScroll) {
                    (lineView.alignable || (lineView.alignable = [])).push(node);
                    var width = dims.wrapperWidth;
                    node.style.left = dims.fixedPos + "px";
                    if (!widget.coverGutter) {
                        width -= dims.gutterTotalWidth;
                        node.style.paddingLeft = dims.gutterTotalWidth + "px";
                    }
                    node.style.width = width + "px";
                }
                if (widget.coverGutter) {
                    node.style.zIndex = 5;
                    node.style.position = "relative";
                    if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
                }
            }

            // POSITION OBJECT

            // A Pos instance represents a position within the text.
            var Pos = CodeMirror.Pos = function(line, ch) {
                if (!(this instanceof Pos)) return new Pos(line, ch);
                this.line = line; this.ch = ch;
            };

            // Compare two positions, return 0 if they are the same, a negative
            // number when a is less, and a positive number otherwise.
            var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };

            function copyPos(x) {return Pos(x.line, x.ch);}
            function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
            function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }

            // INPUT HANDLING

            function ensureFocus(cm) {
                if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
            }

            // This will be set to a {lineWise: bool, text: [string]} object, so
            // that, when pasting, we know what kind of selections the copied
            // text was made out of.
            var lastCopied = null;

            function applyTextInput(cm, inserted, deleted, sel, origin) {
                var doc = cm.doc;
                cm.display.shift = false;
                if (!sel) sel = doc.sel;

                var paste = cm.state.pasteIncoming || origin == "paste";
                var textLines = doc.splitLines(inserted), multiPaste = null
                // When pasing N lines into N selections, insert one line per selection
                if (paste && sel.ranges.length > 1) {
                    if (lastCopied && lastCopied.text.join("\n") == inserted) {
                        if (sel.ranges.length % lastCopied.text.length == 0) {
                            multiPaste = [];
                            for (var i = 0; i < lastCopied.text.length; i++)
                                multiPaste.push(doc.splitLines(lastCopied.text[i]));
                        }
                    } else if (textLines.length == sel.ranges.length) {
                        multiPaste = map(textLines, function(l) { return [l]; });
                    }
                }

                // Normal behavior is to insert the new text into every selection
                for (var i = sel.ranges.length - 1; i >= 0; i--) {
                    var range = sel.ranges[i];
                    var from = range.from(), to = range.to();
                    if (range.empty()) {
                        if (deleted && deleted > 0) // Handle deletion
                            from = Pos(from.line, from.ch - deleted);
                        else if (cm.state.overwrite && !paste) // Handle overwrite
                            to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
                        else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
                            from = to = Pos(from.line, 0)
                    }
                    var updateInput = cm.curOp.updateInput;
                    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
                        origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};
                    makeChange(cm.doc, changeEvent);
                    signalLater(cm, "inputRead", cm, changeEvent);
                }
                if (inserted && !paste)
                    triggerElectric(cm, inserted);

                ensureCursorVisible(cm);
                cm.curOp.updateInput = updateInput;
                cm.curOp.typing = true;
                cm.state.pasteIncoming = cm.state.cutIncoming = false;
            }

            function handlePaste(e, cm) {
                var pasted = e.clipboardData && e.clipboardData.getData("text/plain");
                if (pasted) {
                    e.preventDefault();
                    if (!cm.isReadOnly() && !cm.options.disableInput)
                        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, "paste"); });
                    return true;
                }
            }

            function triggerElectric(cm, inserted) {
                // When an 'electric' character is inserted, immediately trigger a reindent
                if (!cm.options.electricChars || !cm.options.smartIndent) return;
                var sel = cm.doc.sel;

                for (var i = sel.ranges.length - 1; i >= 0; i--) {
                    var range = sel.ranges[i];
                    if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;
                    var mode = cm.getModeAt(range.head);
                    var indented = false;
                    if (mode.electricChars) {
                        for (var j = 0; j < mode.electricChars.length; j++)
                            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                                indented = indentLine(cm, range.head.line, "smart");
                                break;
                            }
                    } else if (mode.electricInput) {
                        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
                            indented = indentLine(cm, range.head.line, "smart");
                    }
                    if (indented) signalLater(cm, "electricInput", cm, range.head.line);
                }
            }

            function copyableRanges(cm) {
                var text = [], ranges = [];
                for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
                    var line = cm.doc.sel.ranges[i].head.line;
                    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
                    ranges.push(lineRange);
                    text.push(cm.getRange(lineRange.anchor, lineRange.head));
                }
                return {text: text, ranges: ranges};
            }

            function disableBrowserMagic(field) {
                field.setAttribute("autocorrect", "off");
                field.setAttribute("autocapitalize", "off");
                field.setAttribute("spellcheck", "false");
            }

            // TEXTAREA INPUT STYLE

            function TextareaInput(cm) {
                this.cm = cm;
                // See input.poll and input.reset
                this.prevInput = "";

                // Flag that indicates whether we expect input to appear real soon
                // now (after some event like 'keypress' or 'input') and are
                // polling intensively.
                this.pollingFast = false;
                // Self-resetting timeout for the poller
                this.polling = new Delayed();
                // Tracks when input.reset has punted to just putting a short
                // string into the textarea instead of the full selection.
                this.inaccurateSelection = false;
                // Used to work around IE issue with selection being forgotten when focus moves away from textarea
                this.hasSelection = false;
                this.composing = null;
            };

            function hiddenTextarea() {
                var te = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
                var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
                // The textarea is kept positioned near the cursor to prevent the
                // fact that it'll be scrolled into view on input from scrolling
                // our fake cursor out of view. On webkit, when wrap=off, paste is
                // very slow. So make the area wide instead.
                if (webkit) te.style.width = "1000px";
                else te.setAttribute("wrap", "off");
                // If border: 0; -- iOS fails to open keyboard (issue #1287)
                if (ios) te.style.border = "1px solid black";
                disableBrowserMagic(te);
                return div;
            }

            TextareaInput.prototype = copyObj({
                init: function(display) {
                    var input = this, cm = this.cm;

                    // Wraps and hides input textarea
                    var div = this.wrapper = hiddenTextarea();
                    // The semihidden textarea that is focused when the editor is
                    // focused, and receives input.
                    var te = this.textarea = div.firstChild;
                    display.wrapper.insertBefore(div, display.wrapper.firstChild);

                    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
                    if (ios) te.style.width = "0px";

                    on(te, "input", function() {
                        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;
                        input.poll();
                    });

                    on(te, "paste", function(e) {
                        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return

                        cm.state.pasteIncoming = true;
                        input.fastPoll();
                    });

                    function prepareCopyCut(e) {
                        if (signalDOMEvent(cm, e)) return
                        if (cm.somethingSelected()) {
                            lastCopied = {lineWise: false, text: cm.getSelections()};
                            if (input.inaccurateSelection) {
                                input.prevInput = "";
                                input.inaccurateSelection = false;
                                te.value = lastCopied.text.join("\n");
                                selectInput(te);
                            }
                        } else if (!cm.options.lineWiseCopyCut) {
                            return;
                        } else {
                            var ranges = copyableRanges(cm);
                            lastCopied = {lineWise: true, text: ranges.text};
                            if (e.type == "cut") {
                                cm.setSelections(ranges.ranges, null, sel_dontScroll);
                            } else {
                                input.prevInput = "";
                                te.value = ranges.text.join("\n");
                                selectInput(te);
                            }
                        }
                        if (e.type == "cut") cm.state.cutIncoming = true;
                    }
                    on(te, "cut", prepareCopyCut);
                    on(te, "copy", prepareCopyCut);

                    on(display.scroller, "paste", function(e) {
                        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;
                        cm.state.pasteIncoming = true;
                        input.focus();
                    });

                    // Prevent normal selection in the editor (we handle our own)
                    on(display.lineSpace, "selectstart", function(e) {
                        if (!eventInWidget(display, e)) e_preventDefault(e);
                    });

                    on(te, "compositionstart", function() {
                        var start = cm.getCursor("from");
                        if (input.composing) input.composing.range.clear()
                        input.composing = {
                            start: start,
                            range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
                        };
                    });
                    on(te, "compositionend", function() {
                        if (input.composing) {
                            input.poll();
                            input.composing.range.clear();
                            input.composing = null;
                        }
                    });
                },

                prepareSelection: function() {
                    // Redraw the selection and/or cursor
                    var cm = this.cm, display = cm.display, doc = cm.doc;
                    var result = prepareSelection(cm);

                    // Move the hidden textarea near the cursor to prevent scrolling artifacts
                    if (cm.options.moveInputWithCursor) {
                        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
                        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
                        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                            headPos.top + lineOff.top - wrapOff.top));
                        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                            headPos.left + lineOff.left - wrapOff.left));
                    }

                    return result;
                },

                showSelection: function(drawn) {
                    var cm = this.cm, display = cm.display;
                    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
                    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
                    if (drawn.teTop != null) {
                        this.wrapper.style.top = drawn.teTop + "px";
                        this.wrapper.style.left = drawn.teLeft + "px";
                    }
                },

                // Reset the input to correspond to the selection (or to be empty,
                // when not typing and nothing is selected)
                reset: function(typing) {
                    if (this.contextMenuPending) return;
                    var minimal, selected, cm = this.cm, doc = cm.doc;
                    if (cm.somethingSelected()) {
                        this.prevInput = "";
                        var range = doc.sel.primary();
                        minimal = hasCopyEvent &&
                            (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
                        var content = minimal ? "-" : selected || cm.getSelection();
                        this.textarea.value = content;
                        if (cm.state.focused) selectInput(this.textarea);
                        if (ie && ie_version >= 9) this.hasSelection = content;
                    } else if (!typing) {
                        this.prevInput = this.textarea.value = "";
                        if (ie && ie_version >= 9) this.hasSelection = null;
                    }
                    this.inaccurateSelection = minimal;
                },

                getField: function() { return this.textarea; },

                supportsTouch: function() { return false; },

                focus: function() {
                    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
                        try { this.textarea.focus(); }
                        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
                    }
                },

                blur: function() { this.textarea.blur(); },

                resetPosition: function() {
                    this.wrapper.style.top = this.wrapper.style.left = 0;
                },

                receivedFocus: function() { this.slowPoll(); },

                // Poll for input changes, using the normal rate of polling. This
                // runs as long as the editor is focused.
                slowPoll: function() {
                    var input = this;
                    if (input.pollingFast) return;
                    input.polling.set(this.cm.options.pollInterval, function() {
                        input.poll();
                        if (input.cm.state.focused) input.slowPoll();
                    });
                },

                // When an event has just come in that is likely to add or change
                // something in the input textarea, we poll faster, to ensure that
                // the change appears on the screen quickly.
                fastPoll: function() {
                    var missed = false, input = this;
                    input.pollingFast = true;
                    function p() {
                        var changed = input.poll();
                        if (!changed && !missed) {missed = true; input.polling.set(60, p);}
                        else {input.pollingFast = false; input.slowPoll();}
                    }
                    input.polling.set(20, p);
                },

                // Read input from the textarea, and update the document to match.
                // When something is selected, it is present in the textarea, and
                // selected (unless it is huge, in which case a placeholder is
                // used). When nothing is selected, the cursor sits after previously
                // seen text (can be empty), which is stored in prevInput (we must
                // not reset the textarea when typing, because that breaks IME).
                poll: function() {
                    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
                    // Since this is called a *lot*, try to bail out as cheaply as
                    // possible when it is clear that nothing happened. hasSelection
                    // will be the case when there is a lot of text in the textarea,
                    // in which case reading its value would be expensive.
                    if (this.contextMenuPending || !cm.state.focused ||
                        (hasSelection(input) && !prevInput && !this.composing) ||
                        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
                        return false;

                    var text = input.value;
                    // If nothing changed, bail.
                    if (text == prevInput && !cm.somethingSelected()) return false;
                    // Work around nonsensical selection resetting in IE9/10, and
                    // inexplicable appearance of private area unicode characters on
                    // some key combos in Mac (#2689).
                    if (ie && ie_version >= 9 && this.hasSelection === text ||
                        mac && /[\uf700-\uf7ff]/.test(text)) {
                        cm.display.input.reset();
                        return false;
                    }

                    if (cm.doc.sel == cm.display.selForContextMenu) {
                        var first = text.charCodeAt(0);
                        if (first == 0x200b && !prevInput) prevInput = "\u200b";
                        if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo"); }
                    }
                    // Find the part of the input that is actually new
                    var same = 0, l = Math.min(prevInput.length, text.length);
                    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;

                    var self = this;
                    runInOp(cm, function() {
                        applyTextInput(cm, text.slice(same), prevInput.length - same,
                            null, self.composing ? "*compose" : null);

                        // Don't leave long text in the textarea, since it makes further polling slow
                        if (text.length > 1000 || text.indexOf("\n") > -1) input.value = self.prevInput = "";
                        else self.prevInput = text;

                        if (self.composing) {
                            self.composing.range.clear();
                            self.composing.range = cm.markText(self.composing.start, cm.getCursor("to"),
                                {className: "CodeMirror-composing"});
                        }
                    });
                    return true;
                },

                ensurePolled: function() {
                    if (this.pollingFast && this.poll()) this.pollingFast = false;
                },

                onKeyPress: function() {
                    if (ie && ie_version >= 9) this.hasSelection = null;
                    this.fastPoll();
                },

                onContextMenu: function(e) {
                    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
                    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
                    if (!pos || presto) return; // Opera is difficult.

                    // Reset the current text selection only if the click is done outside of the selection
                    // and 'resetSelectionOnContextMenu' option is true.
                    var reset = cm.options.resetSelectionOnContextMenu;
                    if (reset && cm.doc.sel.contains(pos) == -1)
                        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

                    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
                    input.wrapper.style.cssText = "position: absolute"
                    var wrapperBox = input.wrapper.getBoundingClientRect()
                    te.style.cssText = "position: absolute; width: 30px; height: 30px; top: " + (e.clientY - wrapperBox.top - 5) +
                        "px; left: " + (e.clientX - wrapperBox.left - 5) + "px; z-index: 1000; background: " +
                        (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
                        "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
                    if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)
                    display.input.focus();
                    if (webkit) window.scrollTo(null, oldScrollY);
                    display.input.reset();
                    // Adds "Select all" to context menu in FF
                    if (!cm.somethingSelected()) te.value = input.prevInput = " ";
                    input.contextMenuPending = true;
                    display.selForContextMenu = cm.doc.sel;
                    clearTimeout(display.detectingSelectAll);

                    // Select-all will be greyed out if there's nothing to select, so
                    // this adds a zero-width space so that we can later check whether
                    // it got selected.
                    function prepareSelectAllHack() {
                        if (te.selectionStart != null) {
                            var selected = cm.somethingSelected();
                            var extval = "\u200b" + (selected ? te.value : "");
                            te.value = "\u21da"; // Used to catch context-menu undo
                            te.value = extval;
                            input.prevInput = selected ? "" : "\u200b";
                            te.selectionStart = 1; te.selectionEnd = extval.length;
                            // Re-set this, in case some other handler touched the
                            // selection in the meantime.
                            display.selForContextMenu = cm.doc.sel;
                        }
                    }
                    function rehide() {
                        input.contextMenuPending = false;
                        input.wrapper.style.cssText = oldWrapperCSS
                        te.style.cssText = oldCSS;
                        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);

                        // Try to detect the user choosing select-all
                        if (te.selectionStart != null) {
                            if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();
                            var i = 0, poll = function() {
                                if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
                                    te.selectionEnd > 0 && input.prevInput == "\u200b")
                                    operation(cm, commands.selectAll)(cm);
                                else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);
                                else display.input.reset();
                            };
                            display.detectingSelectAll = setTimeout(poll, 200);
                        }
                    }

                    if (ie && ie_version >= 9) prepareSelectAllHack();
                    if (captureRightClick) {
                        e_stop(e);
                        var mouseup = function() {
                            off(window, "mouseup", mouseup);
                            setTimeout(rehide, 20);
                        };
                        on(window, "mouseup", mouseup);
                    } else {
                        setTimeout(rehide, 50);
                    }
                },

                readOnlyChanged: function(val) {
                    if (!val) this.reset();
                },

                setUneditable: nothing,

                needsContentAttribute: false
            }, TextareaInput.prototype);

            // CONTENTEDITABLE INPUT STYLE

            function ContentEditableInput(cm) {
                this.cm = cm;
                this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
                this.polling = new Delayed();
                this.gracePeriod = false;
            }

            ContentEditableInput.prototype = copyObj({
                init: function(display) {
                    var input = this, cm = input.cm;
                    var div = input.div = display.lineDiv;
                    disableBrowserMagic(div);

                    on(div, "paste", function(e) {
                        if (!signalDOMEvent(cm, e)) handlePaste(e, cm);
                    })

                    on(div, "compositionstart", function(e) {
                        var data = e.data;
                        input.composing = {sel: cm.doc.sel, data: data, startData: data};
                        if (!data) return;
                        var prim = cm.doc.sel.primary();
                        var line = cm.getLine(prim.head.line);
                        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));
                        if (found > -1 && found <= prim.head.ch)
                            input.composing.sel = simpleSelection(Pos(prim.head.line, found),
                                Pos(prim.head.line, found + data.length));
                    });
                    on(div, "compositionupdate", function(e) {
                        input.composing.data = e.data;
                    });
                    on(div, "compositionend", function(e) {
                        var ours = input.composing;
                        if (!ours) return;
                        if (e.data != ours.startData && !/\u200b/.test(e.data))
                            ours.data = e.data;
                        // Need a small delay to prevent other code (input event,
                        // selection polling) from doing damage when fired right after
                        // compositionend.
                        setTimeout(function() {
                            if (!ours.handled)
                                input.applyComposition(ours);
                            if (input.composing == ours)
                                input.composing = null;
                        }, 50);
                    });

                    on(div, "touchstart", function() {
                        input.forceCompositionEnd();
                    });

                    on(div, "input", function() {
                        if (input.composing) return;
                        if (cm.isReadOnly() || !input.pollContent())
                            runInOp(input.cm, function() {regChange(cm);});
                    });

                    function onCopyCut(e) {
                        if (signalDOMEvent(cm, e)) return
                        if (cm.somethingSelected()) {
                            lastCopied = {lineWise: false, text: cm.getSelections()};
                            if (e.type == "cut") cm.replaceSelection("", null, "cut");
                        } else if (!cm.options.lineWiseCopyCut) {
                            return;
                        } else {
                            var ranges = copyableRanges(cm);
                            lastCopied = {lineWise: true, text: ranges.text};
                            if (e.type == "cut") {
                                cm.operation(function() {
                                    cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                                    cm.replaceSelection("", null, "cut");
                                });
                            }
                        }
                        // iOS exposes the clipboard API, but seems to discard content inserted into it
                        if (e.clipboardData && !ios) {
                            e.preventDefault();
                            e.clipboardData.clearData();
                            e.clipboardData.setData("text/plain", lastCopied.text.join("\n"));
                        } else {
                            // Old-fashioned briefly-focus-a-textarea hack
                            var kludge = hiddenTextarea(), te = kludge.firstChild;
                            cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
                            te.value = lastCopied.text.join("\n");
                            var hadFocus = document.activeElement;
                            selectInput(te);
                            setTimeout(function() {
                                cm.display.lineSpace.removeChild(kludge);
                                hadFocus.focus();
                            }, 50);
                        }
                    }
                    on(div, "copy", onCopyCut);
                    on(div, "cut", onCopyCut);
                },

                prepareSelection: function() {
                    var result = prepareSelection(this.cm, false);
                    result.focus = this.cm.state.focused;
                    return result;
                },

                showSelection: function(info, takeFocus) {
                    if (!info || !this.cm.display.view.length) return;
                    if (info.focus || takeFocus) this.showPrimarySelection();
                    this.showMultipleSelections(info);
                },

                showPrimarySelection: function() {
                    var sel = window.getSelection(), prim = this.cm.doc.sel.primary();
                    var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
                    var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
                    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
                        cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&
                        cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
                        return;

                    var start = posToDOM(this.cm, prim.from());
                    var end = posToDOM(this.cm, prim.to());
                    if (!start && !end) return;

                    var view = this.cm.display.view;
                    var old = sel.rangeCount && sel.getRangeAt(0);
                    if (!start) {
                        start = {node: view[0].measure.map[2], offset: 0};
                    } else if (!end) { // FIXME dangerously hacky
                        var measure = view[view.length - 1].measure;
                        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
                        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
                    }

                    try { var rng = range(start.node, start.offset, end.offset, end.node); }
                    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
                    if (rng) {
                        if (!gecko && this.cm.state.focused) {
                            sel.collapse(start.node, start.offset);
                            if (!rng.collapsed) sel.addRange(rng);
                        } else {
                            sel.removeAllRanges();
                            sel.addRange(rng);
                        }
                        if (old && sel.anchorNode == null) sel.addRange(old);
                        else if (gecko) this.startGracePeriod();
                    }
                    this.rememberSelection();
                },

                startGracePeriod: function() {
                    var input = this;
                    clearTimeout(this.gracePeriod);
                    this.gracePeriod = setTimeout(function() {
                        input.gracePeriod = false;
                        if (input.selectionChanged())
                            input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });
                    }, 20);
                },

                showMultipleSelections: function(info) {
                    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
                    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
                },

                rememberSelection: function() {
                    var sel = window.getSelection();
                    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
                    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
                },

                selectionInEditor: function() {
                    var sel = window.getSelection();
                    if (!sel.rangeCount) return false;
                    var node = sel.getRangeAt(0).commonAncestorContainer;
                    return contains(this.div, node);
                },

                focus: function() {
                    if (this.cm.options.readOnly != "nocursor") this.div.focus();
                },
                blur: function() { this.div.blur(); },
                getField: function() { return this.div; },

                supportsTouch: function() { return true; },

                receivedFocus: function() {
                    var input = this;
                    if (this.selectionInEditor())
                        this.pollSelection();
                    else
                        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });

                    function poll() {
                        if (input.cm.state.focused) {
                            input.pollSelection();
                            input.polling.set(input.cm.options.pollInterval, poll);
                        }
                    }
                    this.polling.set(this.cm.options.pollInterval, poll);
                },

                selectionChanged: function() {
                    var sel = window.getSelection();
                    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
                        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
                },

                pollSelection: function() {
                    if (!this.composing && !this.gracePeriod && this.selectionChanged()) {
                        var sel = window.getSelection(), cm = this.cm;
                        this.rememberSelection();
                        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
                        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
                        if (anchor && head) runInOp(cm, function() {
                            setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
                            if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;
                        });
                    }
                },

                pollContent: function() {
                    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
                    var from = sel.from(), to = sel.to();
                    if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;

                    var fromIndex;
                    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
                        var fromLine = lineNo(display.view[0].line);
                        var fromNode = display.view[0].node;
                    } else {
                        var fromLine = lineNo(display.view[fromIndex].line);
                        var fromNode = display.view[fromIndex - 1].node.nextSibling;
                    }
                    var toIndex = findViewIndex(cm, to.line);
                    if (toIndex == display.view.length - 1) {
                        var toLine = display.viewTo - 1;
                        var toNode = display.lineDiv.lastChild;
                    } else {
                        var toLine = lineNo(display.view[toIndex + 1].line) - 1;
                        var toNode = display.view[toIndex + 1].node.previousSibling;
                    }

                    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
                    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
                    while (newText.length > 1 && oldText.length > 1) {
                        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
                        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
                        else break;
                    }

                    var cutFront = 0, cutEnd = 0;
                    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
                    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
                        ++cutFront;
                    var newBot = lst(newText), oldBot = lst(oldText);
                    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                        oldBot.length - (oldText.length == 1 ? cutFront : 0));
                    while (cutEnd < maxCutEnd &&
                    newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
                        ++cutEnd;

                    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);
                    newText[0] = newText[0].slice(cutFront);

                    var chFrom = Pos(fromLine, cutFront);
                    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
                    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
                        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
                        return true;
                    }
                },

                ensurePolled: function() {
                    this.forceCompositionEnd();
                },
                reset: function() {
                    this.forceCompositionEnd();
                },
                forceCompositionEnd: function() {
                    if (!this.composing || this.composing.handled) return;
                    this.applyComposition(this.composing);
                    this.composing.handled = true;
                    this.div.blur();
                    this.div.focus();
                },
                applyComposition: function(composing) {
                    if (this.cm.isReadOnly())
                        operation(this.cm, regChange)(this.cm)
                    else if (composing.data && composing.data != composing.startData)
                        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);
                },

                setUneditable: function(node) {
                    node.contentEditable = "false"
                },

                onKeyPress: function(e) {
                    e.preventDefault();
                    if (!this.cm.isReadOnly())
                        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
                },

                readOnlyChanged: function(val) {
                    this.div.contentEditable = String(val != "nocursor")
                },

                onContextMenu: nothing,
                resetPosition: nothing,

                needsContentAttribute: true
            }, ContentEditableInput.prototype);

            function posToDOM(cm, pos) {
                var view = findViewForLine(cm, pos.line);
                if (!view || view.hidden) return null;
                var line = getLine(cm.doc, pos.line);
                var info = mapFromLineView(view, line, pos.line);

                var order = getOrder(line), side = "left";
                if (order) {
                    var partPos = getBidiPartAt(order, pos.ch);
                    side = partPos % 2 ? "right" : "left";
                }
                var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
                result.offset = result.collapse == "right" ? result.end : result.start;
                return result;
            }

            function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }

            function domToPos(cm, node, offset) {
                var lineNode;
                if (node == cm.display.lineDiv) {
                    lineNode = cm.display.lineDiv.childNodes[offset];
                    if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
                    node = null; offset = 0;
                } else {
                    for (lineNode = node;; lineNode = lineNode.parentNode) {
                        if (!lineNode || lineNode == cm.display.lineDiv) return null;
                        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
                    }
                }
                for (var i = 0; i < cm.display.view.length; i++) {
                    var lineView = cm.display.view[i];
                    if (lineView.node == lineNode)
                        return locateNodeInLineView(lineView, node, offset);
                }
            }

            function locateNodeInLineView(lineView, node, offset) {
                var wrapper = lineView.text.firstChild, bad = false;
                if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);
                if (node == wrapper) {
                    bad = true;
                    node = wrapper.childNodes[offset];
                    offset = 0;
                    if (!node) {
                        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
                        return badPos(Pos(lineNo(line), line.text.length), bad);
                    }
                }

                var textNode = node.nodeType == 3 ? node : null, topNode = node;
                if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
                    textNode = node.firstChild;
                    if (offset) offset = textNode.nodeValue.length;
                }
                while (topNode.parentNode != wrapper) topNode = topNode.parentNode;
                var measure = lineView.measure, maps = measure.maps;

                function find(textNode, topNode, offset) {
                    for (var i = -1; i < (maps ? maps.length : 0); i++) {
                        var map = i < 0 ? measure.map : maps[i];
                        for (var j = 0; j < map.length; j += 3) {
                            var curNode = map[j + 2];
                            if (curNode == textNode || curNode == topNode) {
                                var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
                                var ch = map[j] + offset;
                                if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];
                                return Pos(line, ch);
                            }
                        }
                    }
                }
                var found = find(textNode, topNode, offset);
                if (found) return badPos(found, bad);

                // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
                for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
                    found = find(after, after.firstChild, 0);
                    if (found)
                        return badPos(Pos(found.line, found.ch - dist), bad);
                    else
                        dist += after.textContent.length;
                }
                for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {
                    found = find(before, before.firstChild, -1);
                    if (found)
                        return badPos(Pos(found.line, found.ch + dist), bad);
                    else
                        dist += after.textContent.length;
                }
            }

            function domTextBetween(cm, from, to, fromLine, toLine) {
                var text = "", closing = false, lineSep = cm.doc.lineSeparator();
                function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }
                function walk(node) {
                    if (node.nodeType == 1) {
                        var cmText = node.getAttribute("cm-text");
                        if (cmText != null) {
                            if (cmText == "") cmText = node.textContent.replace(/\u200b/g, "");
                            text += cmText;
                            return;
                        }
                        var markerID = node.getAttribute("cm-marker"), range;
                        if (markerID) {
                            var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
                            if (found.length && (range = found[0].find()))
                                text += getBetween(cm.doc, range.from, range.to).join(lineSep);
                            return;
                        }
                        if (node.getAttribute("contenteditable") == "false") return;
                        for (var i = 0; i < node.childNodes.length; i++)
                            walk(node.childNodes[i]);
                        if (/^(pre|div|p)$/i.test(node.nodeName))
                            closing = true;
                    } else if (node.nodeType == 3) {
                        var val = node.nodeValue;
                        if (!val) return;
                        if (closing) {
                            text += lineSep;
                            closing = false;
                        }
                        text += val;
                    }
                }
                for (;;) {
                    walk(from);
                    if (from == to) break;
                    from = from.nextSibling;
                }
                return text;
            }

            CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

            // SELECTION / CURSOR

            // Selection objects are immutable. A new one is created every time
            // the selection changes. A selection is one or more non-overlapping
            // (and non-touching) ranges, sorted, and an integer that indicates
            // which one is the primary selection (the one that's scrolled into
            // view, that getCursor returns, etc).
            function Selection(ranges, primIndex) {
                this.ranges = ranges;
                this.primIndex = primIndex;
            }

            Selection.prototype = {
                primary: function() { return this.ranges[this.primIndex]; },
                equals: function(other) {
                    if (other == this) return true;
                    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
                    for (var i = 0; i < this.ranges.length; i++) {
                        var here = this.ranges[i], there = other.ranges[i];
                        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
                    }
                    return true;
                },
                deepCopy: function() {
                    for (var out = [], i = 0; i < this.ranges.length; i++)
                        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
                    return new Selection(out, this.primIndex);
                },
                somethingSelected: function() {
                    for (var i = 0; i < this.ranges.length; i++)
                        if (!this.ranges[i].empty()) return true;
                    return false;
                },
                contains: function(pos, end) {
                    if (!end) end = pos;
                    for (var i = 0; i < this.ranges.length; i++) {
                        var range = this.ranges[i];
                        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
                            return i;
                    }
                    return -1;
                }
            };

            function Range(anchor, head) {
                this.anchor = anchor; this.head = head;
            }

            Range.prototype = {
                from: function() { return minPos(this.anchor, this.head); },
                to: function() { return maxPos(this.anchor, this.head); },
                empty: function() {
                    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
                }
            };

            // Take an unsorted, potentially overlapping set of ranges, and
            // build a selection out of it. 'Consumes' ranges array (modifying
            // it).
            function normalizeSelection(ranges, primIndex) {
                var prim = ranges[primIndex];
                ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
                primIndex = indexOf(ranges, prim);
                for (var i = 1; i < ranges.length; i++) {
                    var cur = ranges[i], prev = ranges[i - 1];
                    if (cmp(prev.to(), cur.from()) >= 0) {
                        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
                        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
                        if (i <= primIndex) --primIndex;
                        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
                    }
                }
                return new Selection(ranges, primIndex);
            }

            function simpleSelection(anchor, head) {
                return new Selection([new Range(anchor, head || anchor)], 0);
            }

            // Most of the external API clips given positions to make sure they
            // actually exist within the document.
            function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
            function clipPos(doc, pos) {
                if (pos.line < doc.first) return Pos(doc.first, 0);
                var last = doc.first + doc.size - 1;
                if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
                return clipToLen(pos, getLine(doc, pos.line).text.length);
            }
            function clipToLen(pos, linelen) {
                var ch = pos.ch;
                if (ch == null || ch > linelen) return Pos(pos.line, linelen);
                else if (ch < 0) return Pos(pos.line, 0);
                else return pos;
            }
            function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
            function clipPosArray(doc, array) {
                for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
                return out;
            }

            // SELECTION UPDATES

            // The 'scroll' parameter given to many of these indicated whether
            // the new cursor position should be scrolled into view after
            // modifying the selection.

            // If shift is held or the extend flag is set, extends a range to
            // include a given position (and optionally a second position).
            // Otherwise, simply returns the range between the given positions.
            // Used for cursor motion and such.
            function extendRange(doc, range, head, other) {
                if (doc.cm && doc.cm.display.shift || doc.extend) {
                    var anchor = range.anchor;
                    if (other) {
                        var posBefore = cmp(head, anchor) < 0;
                        if (posBefore != (cmp(other, anchor) < 0)) {
                            anchor = head;
                            head = other;
                        } else if (posBefore != (cmp(head, other) < 0)) {
                            head = other;
                        }
                    }
                    return new Range(anchor, head);
                } else {
                    return new Range(other || head, head);
                }
            }

            // Extend the primary selection range, discard the rest.
            function extendSelection(doc, head, other, options) {
                setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
            }

            // Extend all selections (pos is an array of selections with length
            // equal the number of selections)
            function extendSelections(doc, heads, options) {
                for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
                    out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
                var newSel = normalizeSelection(out, doc.sel.primIndex);
                setSelection(doc, newSel, options);
            }

            // Updates a single range in the selection.
            function replaceOneSelection(doc, i, range, options) {
                var ranges = doc.sel.ranges.slice(0);
                ranges[i] = range;
                setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
            }

            // Reset the selection to a single range.
            function setSimpleSelection(doc, anchor, head, options) {
                setSelection(doc, simpleSelection(anchor, head), options);
            }

            // Give beforeSelectionChange handlers a change to influence a
            // selection update.
            function filterSelectionChange(doc, sel, options) {
                var obj = {
                    ranges: sel.ranges,
                    update: function(ranges) {
                        this.ranges = [];
                        for (var i = 0; i < ranges.length; i++)
                            this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                clipPos(doc, ranges[i].head));
                    },
                    origin: options && options.origin
                };
                signal(doc, "beforeSelectionChange", doc, obj);
                if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
                if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
                else return sel;
            }

            function setSelectionReplaceHistory(doc, sel, options) {
                var done = doc.history.done, last = lst(done);
                if (last && last.ranges) {
                    done[done.length - 1] = sel;
                    setSelectionNoUndo(doc, sel, options);
                } else {
                    setSelection(doc, sel, options);
                }
            }

            // Set a new selection.
            function setSelection(doc, sel, options) {
                setSelectionNoUndo(doc, sel, options);
                addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
            }

            function setSelectionNoUndo(doc, sel, options) {
                if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
                    sel = filterSelectionChange(doc, sel, options);

                var bias = options && options.bias ||
                    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
                setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

                if (!(options && options.scroll === false) && doc.cm)
                    ensureCursorVisible(doc.cm);
            }

            function setSelectionInner(doc, sel) {
                if (sel.equals(doc.sel)) return;

                doc.sel = sel;

                if (doc.cm) {
                    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
                    signalCursorActivity(doc.cm);
                }
                signalLater(doc, "cursorActivity", doc);
            }

            // Verify that the selection does not partially select any atomic
            // marked ranges.
            function reCheckSelection(doc) {
                setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
            }

            // Return a selection that does not partially select any atomic
            // ranges.
            function skipAtomicInSelection(doc, sel, bias, mayClear) {
                var out;
                for (var i = 0; i < sel.ranges.length; i++) {
                    var range = sel.ranges[i];
                    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
                    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
                    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
                    if (out || newAnchor != range.anchor || newHead != range.head) {
                        if (!out) out = sel.ranges.slice(0, i);
                        out[i] = new Range(newAnchor, newHead);
                    }
                }
                return out ? normalizeSelection(out, sel.primIndex) : sel;
            }

            function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
                var line = getLine(doc, pos.line);
                if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
                    var sp = line.markedSpans[i], m = sp.marker;
                    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
                        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
                        if (mayClear) {
                            signal(m, "beforeCursorEnter");
                            if (m.explicitlyCleared) {
                                if (!line.markedSpans) break;
                                else {--i; continue;}
                            }
                        }
                        if (!m.atomic) continue;

                        if (oldPos) {
                            var near = m.find(dir < 0 ? 1 : -1), diff;
                            if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
                                near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
                            if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
                                return skipAtomicInner(doc, near, pos, dir, mayClear);
                        }

                        var far = m.find(dir < 0 ? -1 : 1);
                        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
                            far = movePos(doc, far, dir, far.line == pos.line ? line : null);
                        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
                    }
                }
                return pos;
            }

            // Ensure a given position is not inside an atomic range.
            function skipAtomic(doc, pos, oldPos, bias, mayClear) {
                var dir = bias || 1;
                var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
                    (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
                    skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
                    (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
                if (!found) {
                    doc.cantEdit = true;
                    return Pos(doc.first, 0);
                }
                return found;
            }

            function movePos(doc, pos, dir, line) {
                if (dir < 0 && pos.ch == 0) {
                    if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));
                    else return null;
                } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
                    if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);
                    else return null;
                } else {
                    return new Pos(pos.line, pos.ch + dir);
                }
            }

            // SELECTION DRAWING

            function updateSelection(cm) {
                cm.display.input.showSelection(cm.display.input.prepareSelection());
            }

            function prepareSelection(cm, primary) {
                var doc = cm.doc, result = {};
                var curFragment = result.cursors = document.createDocumentFragment();
                var selFragment = result.selection = document.createDocumentFragment();

                for (var i = 0; i < doc.sel.ranges.length; i++) {
                    if (primary === false && i == doc.sel.primIndex) continue;
                    var range = doc.sel.ranges[i];
                    if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) continue;
                    var collapsed = range.empty();
                    if (collapsed || cm.options.showCursorWhenSelecting)
                        drawSelectionCursor(cm, range.head, curFragment);
                    if (!collapsed)
                        drawSelectionRange(cm, range, selFragment);
                }
                return result;
            }

            // Draws a cursor for the given range
            function drawSelectionCursor(cm, head, output) {
                var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

                var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
                cursor.style.left = pos.left + "px";
                cursor.style.top = pos.top + "px";
                cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

                if (pos.other) {
                    // Secondary cursor, shown when on a 'jump' in bi-directional text
                    var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
                    otherCursor.style.display = "";
                    otherCursor.style.left = pos.other.left + "px";
                    otherCursor.style.top = pos.other.top + "px";
                    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
                }
            }

            // Draws the given range as a highlighted selection
            function drawSelectionRange(cm, range, output) {
                var display = cm.display, doc = cm.doc;
                var fragment = document.createDocumentFragment();
                var padding = paddingH(cm.display), leftSide = padding.left;
                var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;

                function add(left, top, width, bottom) {
                    if (top < 0) top = 0;
                    top = Math.round(top);
                    bottom = Math.round(bottom);
                    fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                        "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
                        "px; height: " + (bottom - top) + "px"));
                }

                function drawForLine(line, fromArg, toArg) {
                    var lineObj = getLine(doc, line);
                    var lineLen = lineObj.text.length;
                    var start, end;
                    function coords(ch, bias) {
                        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
                    }

                    iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
                        var leftPos = coords(from, "left"), rightPos, left, right;
                        if (from == to) {
                            rightPos = leftPos;
                            left = right = leftPos.left;
                        } else {
                            rightPos = coords(to - 1, "right");
                            if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
                            left = leftPos.left;
                            right = rightPos.right;
                        }
                        if (fromArg == null && from == 0) left = leftSide;
                        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
                            add(left, leftPos.top, null, leftPos.bottom);
                            left = leftSide;
                            if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
                        }
                        if (toArg == null && to == lineLen) right = rightSide;
                        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
                            start = leftPos;
                        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
                            end = rightPos;
                        if (left < leftSide + 1) left = leftSide;
                        add(left, rightPos.top, right - left, rightPos.bottom);
                    });
                    return {start: start, end: end};
                }

                var sFrom = range.from(), sTo = range.to();
                if (sFrom.line == sTo.line) {
                    drawForLine(sFrom.line, sFrom.ch, sTo.ch);
                } else {
                    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
                    var singleVLine = visualLine(fromLine) == visualLine(toLine);
                    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
                    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
                    if (singleVLine) {
                        if (leftEnd.top < rightStart.top - 2) {
                            add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
                            add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
                        } else {
                            add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
                        }
                    }
                    if (leftEnd.bottom < rightStart.top)
                        add(leftSide, leftEnd.bottom, null, rightStart.top);
                }

                output.appendChild(fragment);
            }

            // Cursor-blinking
            function restartBlink(cm) {
                if (!cm.state.focused) return;
                var display = cm.display;
                clearInterval(display.blinker);
                var on = true;
                display.cursorDiv.style.visibility = "";
                if (cm.options.cursorBlinkRate > 0)
                    display.blinker = setInterval(function() {
                        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
                    }, cm.options.cursorBlinkRate);
                else if (cm.options.cursorBlinkRate < 0)
                    display.cursorDiv.style.visibility = "hidden";
            }

            // HIGHLIGHT WORKER

            function startWorker(cm, time) {
                if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
                    cm.state.highlight.set(time, bind(highlightWorker, cm));
            }

            function highlightWorker(cm) {
                var doc = cm.doc;
                if (doc.frontier < doc.first) doc.frontier = doc.first;
                if (doc.frontier >= cm.display.viewTo) return;
                var end = +new Date + cm.options.workTime;
                var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
                var changedLines = [];

                doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
                    if (doc.frontier >= cm.display.viewFrom) { // Visible
                        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;
                        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);
                        line.styles = highlighted.styles;
                        var oldCls = line.styleClasses, newCls = highlighted.classes;
                        if (newCls) line.styleClasses = newCls;
                        else if (oldCls) line.styleClasses = null;
                        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
                            oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
                        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
                        if (ischange) changedLines.push(doc.frontier);
                        line.stateAfter = tooLong ? state : copyState(doc.mode, state);
                    } else {
                        if (line.text.length <= cm.options.maxHighlightLength)
                            processLine(cm, line.text, state);
                        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
                    }
                    ++doc.frontier;
                    if (+new Date > end) {
                        startWorker(cm, cm.options.workDelay);
                        return true;
                    }
                });
                if (changedLines.length) runInOp(cm, function() {
                    for (var i = 0; i < changedLines.length; i++)
                        regLineChange(cm, changedLines[i], "text");
                });
            }

            // Finds the line to start with when starting a parse. Tries to
            // find a line with a stateAfter, so that it can start with a
            // valid state. If that fails, it returns the line with the
            // smallest indentation, which tends to need the least context to
            // parse correctly.
            function findStartLine(cm, n, precise) {
                var minindent, minline, doc = cm.doc;
                var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
                for (var search = n; search > lim; --search) {
                    if (search <= doc.first) return doc.first;
                    var line = getLine(doc, search - 1);
                    if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
                    var indented = countColumn(line.text, null, cm.options.tabSize);
                    if (minline == null || minindent > indented) {
                        minline = search - 1;
                        minindent = indented;
                    }
                }
                return minline;
            }

            function getStateBefore(cm, n, precise) {
                var doc = cm.doc, display = cm.display;
                if (!doc.mode.startState) return true;
                var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
                if (!state) state = startState(doc.mode);
                else state = copyState(doc.mode, state);
                doc.iter(pos, n, function(line) {
                    processLine(cm, line.text, state);
                    var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
                    line.stateAfter = save ? copyState(doc.mode, state) : null;
                    ++pos;
                });
                if (precise) doc.frontier = pos;
                return state;
            }

            // POSITION MEASUREMENT

            function paddingTop(display) {return display.lineSpace.offsetTop;}
            function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
            function paddingH(display) {
                if (display.cachedPaddingH) return display.cachedPaddingH;
                var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
                var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
                var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
                if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
                return data;
            }

            function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }
            function displayWidth(cm) {
                return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
            }
            function displayHeight(cm) {
                return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
            }

            // Ensure the lineView.wrapping.heights array is populated. This is
            // an array of bottom offsets for the lines that make up a drawn
            // line. When lineWrapping is on, there might be more than one
            // height.
            function ensureLineHeights(cm, lineView, rect) {
                var wrapping = cm.options.lineWrapping;
                var curWidth = wrapping && displayWidth(cm);
                if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
                    var heights = lineView.measure.heights = [];
                    if (wrapping) {
                        lineView.measure.width = curWidth;
                        var rects = lineView.text.firstChild.getClientRects();
                        for (var i = 0; i < rects.length - 1; i++) {
                            var cur = rects[i], next = rects[i + 1];
                            if (Math.abs(cur.bottom - next.bottom) > 2)
                                heights.push((cur.bottom + next.top) / 2 - rect.top);
                        }
                    }
                    heights.push(rect.bottom - rect.top);
                }
            }

            // Find a line map (mapping character offsets to text nodes) and a
            // measurement cache for the given line number. (A line view might
            // contain multiple lines when collapsed ranges are present.)
            function mapFromLineView(lineView, line, lineN) {
                if (lineView.line == line)
                    return {map: lineView.measure.map, cache: lineView.measure.cache};
                for (var i = 0; i < lineView.rest.length; i++)
                    if (lineView.rest[i] == line)
                        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
                for (var i = 0; i < lineView.rest.length; i++)
                    if (lineNo(lineView.rest[i]) > lineN)
                        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
            }

            // Render a line into the hidden node display.externalMeasured. Used
            // when measurement is needed for a line that's not in the viewport.
            function updateExternalMeasurement(cm, line) {
                line = visualLine(line);
                var lineN = lineNo(line);
                var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
                view.lineN = lineN;
                var built = view.built = buildLineContent(cm, view);
                view.text = built.pre;
                removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
                return view;
            }

            // Get a {top, bottom, left, right} box (in line-local coordinates)
            // for a given character.
            function measureChar(cm, line, ch, bias) {
                return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
            }

            // Find a line view that corresponds to the given line number.
            function findViewForLine(cm, lineN) {
                if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
                    return cm.display.view[findViewIndex(cm, lineN)];
                var ext = cm.display.externalMeasured;
                if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
                    return ext;
            }

            // Measurement can be split in two steps, the set-up work that
            // applies to the whole line, and the measurement of the actual
            // character. Functions like coordsChar, that need to do a lot of
            // measurements in a row, can thus ensure that the set-up work is
            // only done once.
            function prepareMeasureForLine(cm, line) {
                var lineN = lineNo(line);
                var view = findViewForLine(cm, lineN);
                if (view && !view.text) {
                    view = null;
                } else if (view && view.changes) {
                    updateLineForChanges(cm, view, lineN, getDimensions(cm));
                    cm.curOp.forceUpdate = true;
                }
                if (!view)
                    view = updateExternalMeasurement(cm, line);

                var info = mapFromLineView(view, line, lineN);
                return {
                    line: line, view: view, rect: null,
                    map: info.map, cache: info.cache, before: info.before,
                    hasHeights: false
                };
            }

            // Given a prepared measurement object, measures the position of an
            // actual character (or fetches it from the cache).
            function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
                if (prepared.before) ch = -1;
                var key = ch + (bias || ""), found;
                if (prepared.cache.hasOwnProperty(key)) {
                    found = prepared.cache[key];
                } else {
                    if (!prepared.rect)
                        prepared.rect = prepared.view.text.getBoundingClientRect();
                    if (!prepared.hasHeights) {
                        ensureLineHeights(cm, prepared.view, prepared.rect);
                        prepared.hasHeights = true;
                    }
                    found = measureCharInner(cm, prepared, ch, bias);
                    if (!found.bogus) prepared.cache[key] = found;
                }
                return {left: found.left, right: found.right,
                    top: varHeight ? found.rtop : found.top,
                    bottom: varHeight ? found.rbottom : found.bottom};
            }

            var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

            function nodeAndOffsetInLineMap(map, ch, bias) {
                var node, start, end, collapse;
                // First, search the line map for the text node corresponding to,
                // or closest to, the target character.
                for (var i = 0; i < map.length; i += 3) {
                    var mStart = map[i], mEnd = map[i + 1];
                    if (ch < mStart) {
                        start = 0; end = 1;
                        collapse = "left";
                    } else if (ch < mEnd) {
                        start = ch - mStart;
                        end = start + 1;
                    } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
                        end = mEnd - mStart;
                        start = end - 1;
                        if (ch >= mEnd) collapse = "right";
                    }
                    if (start != null) {
                        node = map[i + 2];
                        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
                            collapse = bias;
                        if (bias == "left" && start == 0)
                            while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
                                node = map[(i -= 3) + 2];
                                collapse = "left";
                            }
                        if (bias == "right" && start == mEnd - mStart)
                            while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
                                node = map[(i += 3) + 2];
                                collapse = "right";
                            }
                        break;
                    }
                }
                return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};
            }

            function measureCharInner(cm, prepared, ch, bias) {
                var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
                var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

                var rect;
                if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
                    for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned
                        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;
                        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;
                        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
                            rect = node.parentNode.getBoundingClientRect();
                        } else if (ie && cm.options.lineWrapping) {
                            var rects = range(node, start, end).getClientRects();
                            if (rects.length)
                                rect = rects[bias == "right" ? rects.length - 1 : 0];
                            else
                                rect = nullRect;
                        } else {
                            rect = range(node, start, end).getBoundingClientRect() || nullRect;
                        }
                        if (rect.left || rect.right || start == 0) break;
                        end = start;
                        start = start - 1;
                        collapse = "right";
                    }
                    if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);
                } else { // If it is a widget, simply get the box for the whole widget.
                    if (start > 0) collapse = bias = "right";
                    var rects;
                    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
                        rect = rects[bias == "right" ? rects.length - 1 : 0];
                    else
                        rect = node.getBoundingClientRect();
                }
                if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
                    var rSpan = node.parentNode.getClientRects()[0];
                    if (rSpan)
                        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
                    else
                        rect = nullRect;
                }

                var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
                var mid = (rtop + rbot) / 2;
                var heights = prepared.view.measure.heights;
                for (var i = 0; i < heights.length - 1; i++)
                    if (mid < heights[i]) break;
                var top = i ? heights[i - 1] : 0, bot = heights[i];
                var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                    right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                    top: top, bottom: bot};
                if (!rect.left && !rect.right) result.bogus = true;
                if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

                return result;
            }

            // Work around problem with bounding client rects on ranges being
            // returned incorrectly when zoomed on IE10 and below.
            function maybeUpdateRectForZooming(measure, rect) {
                if (!window.screen || screen.logicalXDPI == null ||
                    screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
                    return rect;
                var scaleX = screen.logicalXDPI / screen.deviceXDPI;
                var scaleY = screen.logicalYDPI / screen.deviceYDPI;
                return {left: rect.left * scaleX, right: rect.right * scaleX,
                    top: rect.top * scaleY, bottom: rect.bottom * scaleY};
            }

            function clearLineMeasurementCacheFor(lineView) {
                if (lineView.measure) {
                    lineView.measure.cache = {};
                    lineView.measure.heights = null;
                    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
                        lineView.measure.caches[i] = {};
                }
            }

            function clearLineMeasurementCache(cm) {
                cm.display.externalMeasure = null;
                removeChildren(cm.display.lineMeasure);
                for (var i = 0; i < cm.display.view.length; i++)
                    clearLineMeasurementCacheFor(cm.display.view[i]);
            }

            function clearCaches(cm) {
                clearLineMeasurementCache(cm);
                cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
                if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
                cm.display.lineNumChars = null;
            }

            function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
            function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

            // Converts a {top, bottom, left, right} box from line-local
            // coordinates into another coordinate system. Context may be one of
            // "line", "div" (display.lineDiv), "local"/null (editor), "window",
            // or "page".
            function intoCoordSystem(cm, lineObj, rect, context) {
                if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
                    var size = widgetHeight(lineObj.widgets[i]);
                    rect.top += size; rect.bottom += size;
                }
                if (context == "line") return rect;
                if (!context) context = "local";
                var yOff = heightAtLine(lineObj);
                if (context == "local") yOff += paddingTop(cm.display);
                else yOff -= cm.display.viewOffset;
                if (context == "page" || context == "window") {
                    var lOff = cm.display.lineSpace.getBoundingClientRect();
                    yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
                    var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
                    rect.left += xOff; rect.right += xOff;
                }
                rect.top += yOff; rect.bottom += yOff;
                return rect;
            }

            // Coverts a box from "div" coords to another coordinate system.
            // Context may be "window", "page", "div", or "local"/null.
            function fromCoordSystem(cm, coords, context) {
                if (context == "div") return coords;
                var left = coords.left, top = coords.top;
                // First move into "page" coordinate system
                if (context == "page") {
                    left -= pageScrollX();
                    top -= pageScrollY();
                } else if (context == "local" || !context) {
                    var localBox = cm.display.sizer.getBoundingClientRect();
                    left += localBox.left;
                    top += localBox.top;
                }

                var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
                return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
            }

            function charCoords(cm, pos, context, lineObj, bias) {
                if (!lineObj) lineObj = getLine(cm.doc, pos.line);
                return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
            }

            // Returns a box for a given cursor position, which may have an
            // 'other' property containing the position of the secondary cursor
            // on a bidi boundary.
            function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
                lineObj = lineObj || getLine(cm.doc, pos.line);
                if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
                function get(ch, right) {
                    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
                    if (right) m.left = m.right; else m.right = m.left;
                    return intoCoordSystem(cm, lineObj, m, context);
                }
                function getBidi(ch, partPos) {
                    var part = order[partPos], right = part.level % 2;
                    if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
                        part = order[--partPos];
                        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
                        right = true;
                    } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
                        part = order[++partPos];
                        ch = bidiLeft(part) - part.level % 2;
                        right = false;
                    }
                    if (right && ch == part.to && ch > part.from) return get(ch - 1);
                    return get(ch, right);
                }
                var order = getOrder(lineObj), ch = pos.ch;
                if (!order) return get(ch);
                var partPos = getBidiPartAt(order, ch);
                var val = getBidi(ch, partPos);
                if (bidiOther != null) val.other = getBidi(ch, bidiOther);
                return val;
            }

            // Used to cheaply estimate the coordinates for a position. Used for
            // intermediate scroll updates.
            function estimateCoords(cm, pos) {
                var left = 0, pos = clipPos(cm.doc, pos);
                if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
                var lineObj = getLine(cm.doc, pos.line);
                var top = heightAtLine(lineObj) + paddingTop(cm.display);
                return {left: left, right: left, top: top, bottom: top + lineObj.height};
            }

            // Positions returned by coordsChar contain some extra information.
            // xRel is the relative x position of the input coordinates compared
            // to the found position (so xRel > 0 means the coordinates are to
            // the right of the character position, for example). When outside
            // is true, that means the coordinates lie outside the line's
            // vertical range.
            function PosWithInfo(line, ch, outside, xRel) {
                var pos = Pos(line, ch);
                pos.xRel = xRel;
                if (outside) pos.outside = true;
                return pos;
            }

            // Compute the character position closest to the given coordinates.
            // Input must be lineSpace-local ("div" coordinate system).
            function coordsChar(cm, x, y) {
                var doc = cm.doc;
                y += cm.display.viewOffset;
                if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
                var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
                if (lineN > last)
                    return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
                if (x < 0) x = 0;

                var lineObj = getLine(doc, lineN);
                for (;;) {
                    var found = coordsCharInner(cm, lineObj, lineN, x, y);
                    var merged = collapsedSpanAtEnd(lineObj);
                    var mergedPos = merged && merged.find(0, true);
                    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
                        lineN = lineNo(lineObj = mergedPos.to.line);
                    else
                        return found;
                }
            }

            function coordsCharInner(cm, lineObj, lineNo, x, y) {
                var innerOff = y - heightAtLine(lineObj);
                var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
                var preparedMeasure = prepareMeasureForLine(cm, lineObj);

                function getX(ch) {
                    var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
                    wrongLine = true;
                    if (innerOff > sp.bottom) return sp.left - adjust;
                    else if (innerOff < sp.top) return sp.left + adjust;
                    else wrongLine = false;
                    return sp.left;
                }

                var bidi = getOrder(lineObj), dist = lineObj.text.length;
                var from = lineLeft(lineObj), to = lineRight(lineObj);
                var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

                if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
                // Do a binary search between these bounds.
                for (;;) {
                    if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
                        var ch = x < fromX || x - fromX <= toX - x ? from : to;
                        var xDiff = x - (ch == from ? fromX : toX);
                        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
                        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                            xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
                        return pos;
                    }
                    var step = Math.ceil(dist / 2), middle = from + step;
                    if (bidi) {
                        middle = from;
                        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
                    }
                    var middleX = getX(middle);
                    if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
                    else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
                }
            }

            var measureText;
            // Compute the default text height.
            function textHeight(display) {
                if (display.cachedTextHeight != null) return display.cachedTextHeight;
                if (measureText == null) {
                    measureText = elt("pre");
                    // Measure a bunch of lines, for browsers that compute
                    // fractional heights.
                    for (var i = 0; i < 49; ++i) {
                        measureText.appendChild(document.createTextNode("x"));
                        measureText.appendChild(elt("br"));
                    }
                    measureText.appendChild(document.createTextNode("x"));
                }
                removeChildrenAndAdd(display.measure, measureText);
                var height = measureText.offsetHeight / 50;
                if (height > 3) display.cachedTextHeight = height;
                removeChildren(display.measure);
                return height || 1;
            }

            // Compute the default character width.
            function charWidth(display) {
                if (display.cachedCharWidth != null) return display.cachedCharWidth;
                var anchor = elt("span", "xxxxxxxxxx");
                var pre = elt("pre", [anchor]);
                removeChildrenAndAdd(display.measure, pre);
                var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
                if (width > 2) display.cachedCharWidth = width;
                return width || 10;
            }

            // OPERATIONS

            // Operations are used to wrap a series of changes to the editor
            // state in such a way that each change won't have to update the
            // cursor and display (which would be awkward, slow, and
            // error-prone). Instead, display updates are batched and then all
            // combined and executed at once.

            var operationGroup = null;

            var nextOpId = 0;
            // Start a new operation.
            function startOperation(cm) {
                cm.curOp = {
                    cm: cm,
                    viewChanged: false,      // Flag that indicates that lines might need to be redrawn
                    startHeight: cm.doc.height, // Used to detect need to update scrollbar
                    forceUpdate: false,      // Used to force a redraw
                    updateInput: null,       // Whether to reset the input textarea
                    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
                    changeObjs: null,        // Accumulated changes, for firing change events
                    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
                    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
                    selectionChanged: false, // Whether the selection needs to be redrawn
                    updateMaxLine: false,    // Set when the widest line needs to be determined anew
                    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
                    scrollToPos: null,       // Used to scroll to a specific position
                    focus: false,
                    id: ++nextOpId           // Unique ID
                };
                if (operationGroup) {
                    operationGroup.ops.push(cm.curOp);
                } else {
                    cm.curOp.ownsGroup = operationGroup = {
                        ops: [cm.curOp],
                        delayedCallbacks: []
                    };
                }
            }

            function fireCallbacksForOps(group) {
                // Calls delayed callbacks and cursorActivity handlers until no
                // new ones appear
                var callbacks = group.delayedCallbacks, i = 0;
                do {
                    for (; i < callbacks.length; i++)
                        callbacks[i].call(null);
                    for (var j = 0; j < group.ops.length; j++) {
                        var op = group.ops[j];
                        if (op.cursorActivityHandlers)
                            while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
                                op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
                    }
                } while (i < callbacks.length);
            }

            // Finish an operation, updating the display and signalling delayed events
            function endOperation(cm) {
                var op = cm.curOp, group = op.ownsGroup;
                if (!group) return;

                try { fireCallbacksForOps(group); }
                finally {
                    operationGroup = null;
                    for (var i = 0; i < group.ops.length; i++)
                        group.ops[i].cm.curOp = null;
                    endOperations(group);
                }
            }

            // The DOM updates done when an operation finishes are batched so
            // that the minimum number of relayouts are required.
            function endOperations(group) {
                var ops = group.ops;
                for (var i = 0; i < ops.length; i++) // Read DOM
                    endOperation_R1(ops[i]);
                for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
                    endOperation_W1(ops[i]);
                for (var i = 0; i < ops.length; i++) // Read DOM
                    endOperation_R2(ops[i]);
                for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
                    endOperation_W2(ops[i]);
                for (var i = 0; i < ops.length; i++) // Read DOM
                    endOperation_finish(ops[i]);
            }

            function endOperation_R1(op) {
                var cm = op.cm, display = cm.display;
                maybeClipScrollbars(cm);
                if (op.updateMaxLine) findMaxLine(cm);

                op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
                    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                        op.scrollToPos.to.line >= display.viewTo) ||
                    display.maxLineChanged && cm.options.lineWrapping;
                op.update = op.mustUpdate &&
                    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
            }

            function endOperation_W1(op) {
                op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
            }

            function endOperation_R2(op) {
                var cm = op.cm, display = cm.display;
                if (op.updatedDisplay) updateHeightsInViewport(cm);

                op.barMeasure = measureForScrollbars(cm);

                // If the max line changed since it was last measured, measure it,
                // and ensure the document's width matches it.
                // updateDisplay_W2 will use these properties to do the actual resizing
                if (display.maxLineChanged && !cm.options.lineWrapping) {
                    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
                    cm.display.sizerWidth = op.adjustWidthTo;
                    op.barMeasure.scrollWidth =
                        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
                    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
                }

                if (op.updatedDisplay || op.selectionChanged)
                    op.preparedSelection = display.input.prepareSelection(op.focus);
            }

            function endOperation_W2(op) {
                var cm = op.cm;

                if (op.adjustWidthTo != null) {
                    cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
                    if (op.maxScrollLeft < cm.doc.scrollLeft)
                        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
                    cm.display.maxLineChanged = false;
                }

                var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())
                if (op.preparedSelection)
                    cm.display.input.showSelection(op.preparedSelection, takeFocus);
                if (op.updatedDisplay || op.startHeight != cm.doc.height)
                    updateScrollbars(cm, op.barMeasure);
                if (op.updatedDisplay)
                    setDocumentHeight(cm, op.barMeasure);

                if (op.selectionChanged) restartBlink(cm);

                if (cm.state.focused && op.updateInput)
                    cm.display.input.reset(op.typing);
                if (takeFocus) ensureFocus(op.cm);
            }

            function endOperation_finish(op) {
                var cm = op.cm, display = cm.display, doc = cm.doc;

                if (op.updatedDisplay) postUpdateDisplay(cm, op.update);

                // Abort mouse wheel delta measurement, when scrolling explicitly
                if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
                    display.wheelStartX = display.wheelStartY = null;

                // Propagate the scroll position to the actual DOM scroller
                if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
                    doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
                    display.scrollbars.setScrollTop(doc.scrollTop);
                    display.scroller.scrollTop = doc.scrollTop;
                }
                if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
                    doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
                    display.scrollbars.setScrollLeft(doc.scrollLeft);
                    display.scroller.scrollLeft = doc.scrollLeft;
                    alignHorizontally(cm);
                }
                // If we need to scroll a specific position into view, do so.
                if (op.scrollToPos) {
                    var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                        clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
                    if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
                }

                // Fire events for markers that are hidden/unidden by editing or
                // undoing
                var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
                if (hidden) for (var i = 0; i < hidden.length; ++i)
                    if (!hidden[i].lines.length) signal(hidden[i], "hide");
                if (unhidden) for (var i = 0; i < unhidden.length; ++i)
                    if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

                if (display.wrapper.offsetHeight)
                    doc.scrollTop = cm.display.scroller.scrollTop;

                // Fire change events, and delayed event handlers
                if (op.changeObjs)
                    signal(cm, "changes", cm, op.changeObjs);
                if (op.update)
                    op.update.finish();
            }

            // Run the given function in an operation
            function runInOp(cm, f) {
                if (cm.curOp) return f();
                startOperation(cm);
                try { return f(); }
                finally { endOperation(cm); }
            }
            // Wraps a function in an operation. Returns the wrapped function.
            function operation(cm, f) {
                return function() {
                    if (cm.curOp) return f.apply(cm, arguments);
                    startOperation(cm);
                    try { return f.apply(cm, arguments); }
                    finally { endOperation(cm); }
                };
            }
            // Used to add methods to editor and doc instances, wrapping them in
            // operations.
            function methodOp(f) {
                return function() {
                    if (this.curOp) return f.apply(this, arguments);
                    startOperation(this);
                    try { return f.apply(this, arguments); }
                    finally { endOperation(this); }
                };
            }
            function docMethodOp(f) {
                return function() {
                    var cm = this.cm;
                    if (!cm || cm.curOp) return f.apply(this, arguments);
                    startOperation(cm);
                    try { return f.apply(this, arguments); }
                    finally { endOperation(cm); }
                };
            }

            // VIEW TRACKING

            // These objects are used to represent the visible (currently drawn)
            // part of the document. A LineView may correspond to multiple
            // logical lines, if those are connected by collapsed ranges.
            function LineView(doc, line, lineN) {
                // The starting line
                this.line = line;
                // Continuing lines, if any
                this.rest = visualLineContinued(line);
                // Number of logical lines in this visual line
                this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
                this.node = this.text = null;
                this.hidden = lineIsHidden(doc, line);
            }

            // Create a range of LineView objects for the given lines.
            function buildViewArray(cm, from, to) {
                var array = [], nextPos;
                for (var pos = from; pos < to; pos = nextPos) {
                    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
                    nextPos = pos + view.size;
                    array.push(view);
                }
                return array;
            }

            // Updates the display.view data structure for a given change to the
            // document. From and to are in pre-change coordinates. Lendiff is
            // the amount of lines added or subtracted by the change. This is
            // used for changes that span multiple lines, or change the way
            // lines are divided into visual lines. regLineChange (below)
            // registers single-line changes.
            function regChange(cm, from, to, lendiff) {
                if (from == null) from = cm.doc.first;
                if (to == null) to = cm.doc.first + cm.doc.size;
                if (!lendiff) lendiff = 0;

                var display = cm.display;
                if (lendiff && to < display.viewTo &&
                    (display.updateLineNumbers == null || display.updateLineNumbers > from))
                    display.updateLineNumbers = from;

                cm.curOp.viewChanged = true;

                if (from >= display.viewTo) { // Change after
                    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
                        resetView(cm);
                } else if (to <= display.viewFrom) { // Change before
                    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
                        resetView(cm);
                    } else {
                        display.viewFrom += lendiff;
                        display.viewTo += lendiff;
                    }
                } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
                    resetView(cm);
                } else if (from <= display.viewFrom) { // Top overlap
                    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
                    if (cut) {
                        display.view = display.view.slice(cut.index);
                        display.viewFrom = cut.lineN;
                        display.viewTo += lendiff;
                    } else {
                        resetView(cm);
                    }
                } else if (to >= display.viewTo) { // Bottom overlap
                    var cut = viewCuttingPoint(cm, from, from, -1);
                    if (cut) {
                        display.view = display.view.slice(0, cut.index);
                        display.viewTo = cut.lineN;
                    } else {
                        resetView(cm);
                    }
                } else { // Gap in the middle
                    var cutTop = viewCuttingPoint(cm, from, from, -1);
                    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
                    if (cutTop && cutBot) {
                        display.view = display.view.slice(0, cutTop.index)
                            .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
                            .concat(display.view.slice(cutBot.index));
                        display.viewTo += lendiff;
                    } else {
                        resetView(cm);
                    }
                }

                var ext = display.externalMeasured;
                if (ext) {
                    if (to < ext.lineN)
                        ext.lineN += lendiff;
                    else if (from < ext.lineN + ext.size)
                        display.externalMeasured = null;
                }
            }

            // Register a change to a single line. Type must be one of "text",
            // "gutter", "class", "widget"
            function regLineChange(cm, line, type) {
                cm.curOp.viewChanged = true;
                var display = cm.display, ext = cm.display.externalMeasured;
                if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
                    display.externalMeasured = null;

                if (line < display.viewFrom || line >= display.viewTo) return;
                var lineView = display.view[findViewIndex(cm, line)];
                if (lineView.node == null) return;
                var arr = lineView.changes || (lineView.changes = []);
                if (indexOf(arr, type) == -1) arr.push(type);
            }

            // Clear the view.
            function resetView(cm) {
                cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
                cm.display.view = [];
                cm.display.viewOffset = 0;
            }

            // Find the view element corresponding to a given line. Return null
            // when the line isn't visible.
            function findViewIndex(cm, n) {
                if (n >= cm.display.viewTo) return null;
                n -= cm.display.viewFrom;
                if (n < 0) return null;
                var view = cm.display.view;
                for (var i = 0; i < view.length; i++) {
                    n -= view[i].size;
                    if (n < 0) return i;
                }
            }

            function viewCuttingPoint(cm, oldN, newN, dir) {
                var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
                if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
                    return {index: index, lineN: newN};
                for (var i = 0, n = cm.display.viewFrom; i < index; i++)
                    n += view[i].size;
                if (n != oldN) {
                    if (dir > 0) {
                        if (index == view.length - 1) return null;
                        diff = (n + view[index].size) - oldN;
                        index++;
                    } else {
                        diff = n - oldN;
                    }
                    oldN += diff; newN += diff;
                }
                while (visualLineNo(cm.doc, newN) != newN) {
                    if (index == (dir < 0 ? 0 : view.length - 1)) return null;
                    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
                    index += dir;
                }
                return {index: index, lineN: newN};
            }

            // Force the view to cover a given range, adding empty view element
            // or clipping off existing ones as needed.
            function adjustView(cm, from, to) {
                var display = cm.display, view = display.view;
                if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
                    display.view = buildViewArray(cm, from, to);
                    display.viewFrom = from;
                } else {
                    if (display.viewFrom > from)
                        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
                    else if (display.viewFrom < from)
                        display.view = display.view.slice(findViewIndex(cm, from));
                    display.viewFrom = from;
                    if (display.viewTo < to)
                        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
                    else if (display.viewTo > to)
                        display.view = display.view.slice(0, findViewIndex(cm, to));
                }
                display.viewTo = to;
            }

            // Count the number of lines in the view whose DOM representation is
            // out of date (or nonexistent).
            function countDirtyView(cm) {
                var view = cm.display.view, dirty = 0;
                for (var i = 0; i < view.length; i++) {
                    var lineView = view[i];
                    if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
                }
                return dirty;
            }

            // EVENT HANDLERS

            // Attach the necessary event handlers when initializing the editor
            function registerEventHandlers(cm) {
                var d = cm.display;
                on(d.scroller, "mousedown", operation(cm, onMouseDown));
                // Older IE's will not fire a second mousedown for a double click
                if (ie && ie_version < 11)
                    on(d.scroller, "dblclick", operation(cm, function(e) {
                        if (signalDOMEvent(cm, e)) return;
                        var pos = posFromMouse(cm, e);
                        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
                        e_preventDefault(e);
                        var word = cm.findWordAt(pos);
                        extendSelection(cm.doc, word.anchor, word.head);
                    }));
                else
                    on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
                // Some browsers fire contextmenu *after* opening the menu, at
                // which point we can't mess with it anymore. Context menu is
                // handled in onMouseDown for these browsers.
                if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

                // Used to suppress mouse event handling when a touch happens
                var touchFinished, prevTouch = {end: 0};
                function finishTouch() {
                    if (d.activeTouch) {
                        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);
                        prevTouch = d.activeTouch;
                        prevTouch.end = +new Date;
                    }
                };
                function isMouseLikeTouchEvent(e) {
                    if (e.touches.length != 1) return false;
                    var touch = e.touches[0];
                    return touch.radiusX <= 1 && touch.radiusY <= 1;
                }
                function farAway(touch, other) {
                    if (other.left == null) return true;
                    var dx = other.left - touch.left, dy = other.top - touch.top;
                    return dx * dx + dy * dy > 20 * 20;
                }
                on(d.scroller, "touchstart", function(e) {
                    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
                        clearTimeout(touchFinished);
                        var now = +new Date;
                        d.activeTouch = {start: now, moved: false,
                            prev: now - prevTouch.end <= 300 ? prevTouch : null};
                        if (e.touches.length == 1) {
                            d.activeTouch.left = e.touches[0].pageX;
                            d.activeTouch.top = e.touches[0].pageY;
                        }
                    }
                });
                on(d.scroller, "touchmove", function() {
                    if (d.activeTouch) d.activeTouch.moved = true;
                });
                on(d.scroller, "touchend", function(e) {
                    var touch = d.activeTouch;
                    if (touch && !eventInWidget(d, e) && touch.left != null &&
                        !touch.moved && new Date - touch.start < 300) {
                        var pos = cm.coordsChar(d.activeTouch, "page"), range;
                        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
                            range = new Range(pos, pos);
                        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
                            range = cm.findWordAt(pos);
                        else // Triple tap
                            range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
                        cm.setSelection(range.anchor, range.head);
                        cm.focus();
                        e_preventDefault(e);
                    }
                    finishTouch();
                });
                on(d.scroller, "touchcancel", finishTouch);

                // Sync scrolling between fake scrollbars and real scrollable
                // area, ensure viewport is updated when scrolling.
                on(d.scroller, "scroll", function() {
                    if (d.scroller.clientHeight) {
                        setScrollTop(cm, d.scroller.scrollTop);
                        setScrollLeft(cm, d.scroller.scrollLeft, true);
                        signal(cm, "scroll", cm);
                    }
                });

                // Listen to wheel events in order to try and update the viewport on time.
                on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
                on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

                // Prevent wrapper from ever scrolling
                on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

                d.dragFunctions = {
                    enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},
                    over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
                    start: function(e){onDragStart(cm, e);},
                    drop: operation(cm, onDrop),
                    leave: function(e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
                };

                var inp = d.input.getField();
                on(inp, "keyup", function(e) { onKeyUp.call(cm, e); });
                on(inp, "keydown", operation(cm, onKeyDown));
                on(inp, "keypress", operation(cm, onKeyPress));
                on(inp, "focus", bind(onFocus, cm));
                on(inp, "blur", bind(onBlur, cm));
            }

            function dragDropChanged(cm, value, old) {
                var wasOn = old && old != CodeMirror.Init;
                if (!value != !wasOn) {
                    var funcs = cm.display.dragFunctions;
                    var toggle = value ? on : off;
                    toggle(cm.display.scroller, "dragstart", funcs.start);
                    toggle(cm.display.scroller, "dragenter", funcs.enter);
                    toggle(cm.display.scroller, "dragover", funcs.over);
                    toggle(cm.display.scroller, "dragleave", funcs.leave);
                    toggle(cm.display.scroller, "drop", funcs.drop);
                }
            }

            // Called when the window resizes
            function onResize(cm) {
                var d = cm.display;
                if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
                    return;
                // Might be a text scaling operation, clear size caches.
                d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
                d.scrollbarsClipped = false;
                cm.setSize();
            }

            // MOUSE EVENTS

            // Return true when the given mouse event happened in a widget
            function eventInWidget(display, e) {
                for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
                    if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
                        (n.parentNode == display.sizer && n != display.mover))
                        return true;
                }
            }

            // Given a mouse event, find the corresponding position. If liberal
            // is false, it checks whether a gutter or scrollbar was clicked,
            // and returns null if it was. forRect is used by rectangular
            // selections, and tries to estimate a character position even for
            // coordinates beyond the right of the text.
            function posFromMouse(cm, e, liberal, forRect) {
                var display = cm.display;
                if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") return null;

                var x, y, space = display.lineSpace.getBoundingClientRect();
                // Fails unpredictably on IE[67] when mouse is dragged around quickly.
                try { x = e.clientX - space.left; y = e.clientY - space.top; }
                catch (e) { return null; }
                var coords = coordsChar(cm, x, y), line;
                if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
                    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
                    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
                }
                return coords;
            }

            // A mouse down can be a single click, double click, triple click,
            // start of selection drag, start of text drag, new cursor
            // (ctrl-click), rectangle drag (alt-drag), or xwin
            // middle-click-paste. Or it might be a click on something we should
            // not interfere with, such as a scrollbar or widget.
            function onMouseDown(e) {
                var cm = this, display = cm.display;
                if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;
                display.shift = e.shiftKey;

                if (eventInWidget(display, e)) {
                    if (!webkit) {
                        // Briefly turn off draggability, to allow widgets to do
                        // normal dragging things.
                        display.scroller.draggable = false;
                        setTimeout(function(){display.scroller.draggable = true;}, 100);
                    }
                    return;
                }
                if (clickInGutter(cm, e)) return;
                var start = posFromMouse(cm, e);
                window.focus();

                switch (e_button(e)) {
                    case 1:
                        // #3261: make sure, that we're not starting a second selection
                        if (cm.state.selectingText)
                            cm.state.selectingText(e);
                        else if (start)
                            leftButtonDown(cm, e, start);
                        else if (e_target(e) == display.scroller)
                            e_preventDefault(e);
                        break;
                    case 2:
                        if (webkit) cm.state.lastMiddleDown = +new Date;
                        if (start) extendSelection(cm.doc, start);
                        setTimeout(function() {display.input.focus();}, 20);
                        e_preventDefault(e);
                        break;
                    case 3:
                        if (captureRightClick) onContextMenu(cm, e);
                        else delayBlurEvent(cm);
                        break;
                }
            }

            var lastClick, lastDoubleClick;
            function leftButtonDown(cm, e, start) {
                if (ie) setTimeout(bind(ensureFocus, cm), 0);
                else cm.curOp.focus = activeElt();

                var now = +new Date, type;
                if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
                    type = "triple";
                } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
                    type = "double";
                    lastDoubleClick = {time: now, pos: start};
                } else {
                    type = "single";
                    lastClick = {time: now, pos: start};
                }

                var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
                if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
                    type == "single" && (contained = sel.contains(start)) > -1 &&
                    (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&
                    (cmp(contained.to(), start) > 0 || start.xRel < 0))
                    leftButtonStartDrag(cm, e, start, modifier);
                else
                    leftButtonSelect(cm, e, start, type, modifier);
            }

            // Start a text drag. When it ends, see if any dragging actually
            // happen, and treat as a click if it didn't.
            function leftButtonStartDrag(cm, e, start, modifier) {
                var display = cm.display, startTime = +new Date;
                var dragEnd = operation(cm, function(e2) {
                    if (webkit) display.scroller.draggable = false;
                    cm.state.draggingText = false;
                    off(document, "mouseup", dragEnd);
                    off(display.scroller, "drop", dragEnd);
                    if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
                        e_preventDefault(e2);
                        if (!modifier && +new Date - 200 < startTime)
                            extendSelection(cm.doc, start);
                        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
                        if (webkit || ie && ie_version == 9)
                            setTimeout(function() {document.body.focus(); display.input.focus();}, 20);
                        else
                            display.input.focus();
                    }
                });
                // Let the drag handler handle this.
                if (webkit) display.scroller.draggable = true;
                cm.state.draggingText = dragEnd;
                // IE's approach to draggable
                if (display.scroller.dragDrop) display.scroller.dragDrop();
                on(document, "mouseup", dragEnd);
                on(display.scroller, "drop", dragEnd);
            }

            // Normal selection, as opposed to text dragging.
            function leftButtonSelect(cm, e, start, type, addNew) {
                var display = cm.display, doc = cm.doc;
                e_preventDefault(e);

                var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
                if (addNew && !e.shiftKey) {
                    ourIndex = doc.sel.contains(start);
                    if (ourIndex > -1)
                        ourRange = ranges[ourIndex];
                    else
                        ourRange = new Range(start, start);
                } else {
                    ourRange = doc.sel.primary();
                    ourIndex = doc.sel.primIndex;
                }

                if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {
                    type = "rect";
                    if (!addNew) ourRange = new Range(start, start);
                    start = posFromMouse(cm, e, true, true);
                    ourIndex = -1;
                } else if (type == "double") {
                    var word = cm.findWordAt(start);
                    if (cm.display.shift || doc.extend)
                        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
                    else
                        ourRange = word;
                } else if (type == "triple") {
                    var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
                    if (cm.display.shift || doc.extend)
                        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
                    else
                        ourRange = line;
                } else {
                    ourRange = extendRange(doc, ourRange, start);
                }

                if (!addNew) {
                    ourIndex = 0;
                    setSelection(doc, new Selection([ourRange], 0), sel_mouse);
                    startSel = doc.sel;
                } else if (ourIndex == -1) {
                    ourIndex = ranges.length;
                    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
                        {scroll: false, origin: "*mouse"});
                } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
                    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                        {scroll: false, origin: "*mouse"});
                    startSel = doc.sel;
                } else {
                    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
                }

                var lastPos = start;
                function extendTo(pos) {
                    if (cmp(lastPos, pos) == 0) return;
                    lastPos = pos;

                    if (type == "rect") {
                        var ranges = [], tabSize = cm.options.tabSize;
                        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
                        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
                        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
                        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
                             line <= end; line++) {
                            var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
                            if (left == right)
                                ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
                            else if (text.length > leftPos)
                                ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
                        }
                        if (!ranges.length) ranges.push(new Range(start, start));
                        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                            {origin: "*mouse", scroll: false});
                        cm.scrollIntoView(pos);
                    } else {
                        var oldRange = ourRange;
                        var anchor = oldRange.anchor, head = pos;
                        if (type != "single") {
                            if (type == "double")
                                var range = cm.findWordAt(pos);
                            else
                                var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
                            if (cmp(range.anchor, anchor) > 0) {
                                head = range.head;
                                anchor = minPos(oldRange.from(), range.anchor);
                            } else {
                                head = range.anchor;
                                anchor = maxPos(oldRange.to(), range.head);
                            }
                        }
                        var ranges = startSel.ranges.slice(0);
                        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
                        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
                    }
                }

                var editorSize = display.wrapper.getBoundingClientRect();
                // Used to ensure timeout re-tries don't fire when another extend
                // happened in the meantime (clearTimeout isn't reliable -- at
                // least on Chrome, the timeouts still happen even when cleared,
                // if the clear happens after their scheduled firing time).
                var counter = 0;

                function extend(e) {
                    var curCount = ++counter;
                    var cur = posFromMouse(cm, e, true, type == "rect");
                    if (!cur) return;
                    if (cmp(cur, lastPos) != 0) {
                        cm.curOp.focus = activeElt();
                        extendTo(cur);
                        var visible = visibleLines(display, doc);
                        if (cur.line >= visible.to || cur.line < visible.from)
                            setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
                    } else {
                        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
                        if (outside) setTimeout(operation(cm, function() {
                            if (counter != curCount) return;
                            display.scroller.scrollTop += outside;
                            extend(e);
                        }), 50);
                    }
                }

                function done(e) {
                    cm.state.selectingText = false;
                    counter = Infinity;
                    e_preventDefault(e);
                    display.input.focus();
                    off(document, "mousemove", move);
                    off(document, "mouseup", up);
                    doc.history.lastSelOrigin = null;
                }

                var move = operation(cm, function(e) {
                    if (!e_button(e)) done(e);
                    else extend(e);
                });
                var up = operation(cm, done);
                cm.state.selectingText = up;
                on(document, "mousemove", move);
                on(document, "mouseup", up);
            }

            // Determines whether an event happened in the gutter, and fires the
            // handlers for the corresponding event.
            function gutterEvent(cm, e, type, prevent) {
                try { var mX = e.clientX, mY = e.clientY; }
                catch(e) { return false; }
                if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
                if (prevent) e_preventDefault(e);

                var display = cm.display;
                var lineBox = display.lineDiv.getBoundingClientRect();

                if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
                mY -= lineBox.top - display.viewOffset;

                for (var i = 0; i < cm.options.gutters.length; ++i) {
                    var g = display.gutters.childNodes[i];
                    if (g && g.getBoundingClientRect().right >= mX) {
                        var line = lineAtHeight(cm.doc, mY);
                        var gutter = cm.options.gutters[i];
                        signal(cm, type, cm, line, gutter, e);
                        return e_defaultPrevented(e);
                    }
                }
            }

            function clickInGutter(cm, e) {
                return gutterEvent(cm, e, "gutterClick", true);
            }

            // Kludge to work around strange IE behavior where it'll sometimes
            // re-fire a series of drag-related events right after the drop (#1551)
            var lastDrop = 0;

            function onDrop(e) {
                var cm = this;
                clearDragCursor(cm);
                if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
                    return;
                e_preventDefault(e);
                if (ie) lastDrop = +new Date;
                var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
                if (!pos || cm.isReadOnly()) return;
                // Might be a file drop, in which case we simply extract the text
                // and insert it.
                if (files && files.length && window.FileReader && window.File) {
                    var n = files.length, text = Array(n), read = 0;
                    var loadFile = function(file, i) {
                        if (cm.options.allowDropFileTypes &&
                            indexOf(cm.options.allowDropFileTypes, file.type) == -1)
                            return;

                        var reader = new FileReader;
                        reader.onload = operation(cm, function() {
                            var content = reader.result;
                            if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) content = "";
                            text[i] = content;
                            if (++read == n) {
                                pos = clipPos(cm.doc, pos);
                                var change = {from: pos, to: pos,
                                    text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                                    origin: "paste"};
                                makeChange(cm.doc, change);
                                setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
                            }
                        });
                        reader.readAsText(file);
                    };
                    for (var i = 0; i < n; ++i) loadFile(files[i], i);
                } else { // Normal drop
                    // Don't do a replace if the drop happened inside of the selected text.
                    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
                        cm.state.draggingText(e);
                        // Ensure the editor is re-focused
                        setTimeout(function() {cm.display.input.focus();}, 20);
                        return;
                    }
                    try {
                        var text = e.dataTransfer.getData("Text");
                        if (text) {
                            if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))
                                var selected = cm.listSelections();
                            setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
                            if (selected) for (var i = 0; i < selected.length; ++i)
                                replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
                            cm.replaceSelection(text, "around", "paste");
                            cm.display.input.focus();
                        }
                    }
                    catch(e){}
                }
            }

            function onDragStart(cm, e) {
                if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
                if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

                e.dataTransfer.setData("Text", cm.getSelection());
                e.dataTransfer.effectAllowed = "copyMove"

                // Use dummy image instead of default browsers image.
                // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
                if (e.dataTransfer.setDragImage && !safari) {
                    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
                    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
                    if (presto) {
                        img.width = img.height = 1;
                        cm.display.wrapper.appendChild(img);
                        // Force a relayout, or Opera won't use our image for some obscure reason
                        img._top = img.offsetTop;
                    }
                    e.dataTransfer.setDragImage(img, 0, 0);
                    if (presto) img.parentNode.removeChild(img);
                }
            }

            function onDragOver(cm, e) {
                var pos = posFromMouse(cm, e);
                if (!pos) return;
                var frag = document.createDocumentFragment();
                drawSelectionCursor(cm, pos, frag);
                if (!cm.display.dragCursor) {
                    cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
                    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
                }
                removeChildrenAndAdd(cm.display.dragCursor, frag);
            }

            function clearDragCursor(cm) {
                if (cm.display.dragCursor) {
                    cm.display.lineSpace.removeChild(cm.display.dragCursor);
                    cm.display.dragCursor = null;
                }
            }

            // SCROLL EVENTS

            // Sync the scrollable area and scrollbars, ensure the viewport
            // covers the visible area.
            function setScrollTop(cm, val) {
                if (Math.abs(cm.doc.scrollTop - val) < 2) return;
                cm.doc.scrollTop = val;
                if (!gecko) updateDisplaySimple(cm, {top: val});
                if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
                cm.display.scrollbars.setScrollTop(val);
                if (gecko) updateDisplaySimple(cm);
                startWorker(cm, 100);
            }
            // Sync scroller and scrollbar, ensure the gutter elements are
            // aligned.
            function setScrollLeft(cm, val, isScroller) {
                if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
                val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
                cm.doc.scrollLeft = val;
                alignHorizontally(cm);
                if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
                cm.display.scrollbars.setScrollLeft(val);
            }

            // Since the delta values reported on mouse wheel events are
            // unstandardized between browsers and even browser versions, and
            // generally horribly unpredictable, this code starts by measuring
            // the scroll effect that the first few mouse wheel events have,
            // and, from that, detects the way it can convert deltas to pixel
            // offsets afterwards.
            //
            // The reason we want to know the amount a wheel event will scroll
            // is that it gives us a chance to update the display before the
            // actual scrolling happens, reducing flickering.

            var wheelSamples = 0, wheelPixelsPerUnit = null;
            // Fill in a browser-detected starting value on browsers where we
            // know one. These don't have to be accurate -- the result of them
            // being wrong would just be a slight flicker on the first wheel
            // scroll (if it is large enough).
            if (ie) wheelPixelsPerUnit = -.53;
            else if (gecko) wheelPixelsPerUnit = 15;
            else if (chrome) wheelPixelsPerUnit = -.7;
            else if (safari) wheelPixelsPerUnit = -1/3;

            var wheelEventDelta = function(e) {
                var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
                if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
                if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
                else if (dy == null) dy = e.wheelDelta;
                return {x: dx, y: dy};
            };
            CodeMirror.wheelEventPixels = function(e) {
                var delta = wheelEventDelta(e);
                delta.x *= wheelPixelsPerUnit;
                delta.y *= wheelPixelsPerUnit;
                return delta;
            };

            function onScrollWheel(cm, e) {
                var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

                var display = cm.display, scroll = display.scroller;
                // Quit if there's nothing to scroll here
                var canScrollX = scroll.scrollWidth > scroll.clientWidth;
                var canScrollY = scroll.scrollHeight > scroll.clientHeight;
                if (!(dx && canScrollX || dy && canScrollY)) return;

                // Webkit browsers on OS X abort momentum scrolls when the target
                // of the scroll event is removed from the scrollable element.
                // This hack (see related code in patchDisplay) makes sure the
                // element is kept around.
                if (dy && mac && webkit) {
                    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
                        for (var i = 0; i < view.length; i++) {
                            if (view[i].node == cur) {
                                cm.display.currentWheelTarget = cur;
                                break outer;
                            }
                        }
                    }
                }

                // On some browsers, horizontal scrolling will cause redraws to
                // happen before the gutter has been realigned, causing it to
                // wriggle around in a most unseemly way. When we have an
                // estimated pixels/delta value, we just handle horizontal
                // scrolling entirely here. It'll be slightly off from native, but
                // better than glitching out.
                if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
                    if (dy && canScrollY)
                        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
                    setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
                    // Only prevent default scrolling if vertical scrolling is
                    // actually possible. Otherwise, it causes vertical scroll
                    // jitter on OSX trackpads when deltaX is small and deltaY
                    // is large (issue #3579)
                    if (!dy || (dy && canScrollY))
                        e_preventDefault(e);
                    display.wheelStartX = null; // Abort measurement, if in progress
                    return;
                }

                // 'Project' the visible viewport to cover the area that is being
                // scrolled into view (if we know enough to estimate it).
                if (dy && wheelPixelsPerUnit != null) {
                    var pixels = dy * wheelPixelsPerUnit;
                    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
                    if (pixels < 0) top = Math.max(0, top + pixels - 50);
                    else bot = Math.min(cm.doc.height, bot + pixels + 50);
                    updateDisplaySimple(cm, {top: top, bottom: bot});
                }

                if (wheelSamples < 20) {
                    if (display.wheelStartX == null) {
                        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
                        display.wheelDX = dx; display.wheelDY = dy;
                        setTimeout(function() {
                            if (display.wheelStartX == null) return;
                            var movedX = scroll.scrollLeft - display.wheelStartX;
                            var movedY = scroll.scrollTop - display.wheelStartY;
                            var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
                                (movedX && display.wheelDX && movedX / display.wheelDX);
                            display.wheelStartX = display.wheelStartY = null;
                            if (!sample) return;
                            wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
                            ++wheelSamples;
                        }, 200);
                    } else {
                        display.wheelDX += dx; display.wheelDY += dy;
                    }
                }
            }

            // KEY EVENTS

            // Run a handler that was bound to a key.
            function doHandleBinding(cm, bound, dropShift) {
                if (typeof bound == "string") {
                    bound = commands[bound];
                    if (!bound) return false;
                }
                // Ensure previous input has been read, so that the handler sees a
                // consistent view of the document
                cm.display.input.ensurePolled();
                var prevShift = cm.display.shift, done = false;
                try {
                    if (cm.isReadOnly()) cm.state.suppressEdits = true;
                    if (dropShift) cm.display.shift = false;
                    done = bound(cm) != Pass;
                } finally {
                    cm.display.shift = prevShift;
                    cm.state.suppressEdits = false;
                }
                return done;
            }

            function lookupKeyForEditor(cm, name, handle) {
                for (var i = 0; i < cm.state.keyMaps.length; i++) {
                    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
                    if (result) return result;
                }
                return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
                    || lookupKey(name, cm.options.keyMap, handle, cm);
            }

            var stopSeq = new Delayed;
            function dispatchKey(cm, name, e, handle) {
                var seq = cm.state.keySeq;
                if (seq) {
                    if (isModifierKey(name)) return "handled";
                    stopSeq.set(50, function() {
                        if (cm.state.keySeq == seq) {
                            cm.state.keySeq = null;
                            cm.display.input.reset();
                        }
                    });
                    name = seq + " " + name;
                }
                var result = lookupKeyForEditor(cm, name, handle);

                if (result == "multi")
                    cm.state.keySeq = name;
                if (result == "handled")
                    signalLater(cm, "keyHandled", cm, name, e);

                if (result == "handled" || result == "multi") {
                    e_preventDefault(e);
                    restartBlink(cm);
                }

                if (seq && !result && /\'$/.test(name)) {
                    e_preventDefault(e);
                    return true;
                }
                return !!result;
            }

            // Handle a key from the keydown event.
            function handleKeyBinding(cm, e) {
                var name = keyName(e, true);
                if (!name) return false;

                if (e.shiftKey && !cm.state.keySeq) {
                    // First try to resolve full name (including 'Shift-'). Failing
                    // that, see if there is a cursor-motion command (starting with
                    // 'go') bound to the keyname without 'Shift-'.
                    return dispatchKey(cm, "Shift-" + name, e, function(b) {return doHandleBinding(cm, b, true);})
                        || dispatchKey(cm, name, e, function(b) {
                            if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                                return doHandleBinding(cm, b);
                        });
                } else {
                    return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });
                }
            }

            // Handle a key from the keypress event
            function handleCharBinding(cm, e, ch) {
                return dispatchKey(cm, "'" + ch + "'", e,
                    function(b) { return doHandleBinding(cm, b, true); });
            }

            var lastStoppedKey = null;
            function onKeyDown(e) {
                var cm = this;
                cm.curOp.focus = activeElt();
                if (signalDOMEvent(cm, e)) return;
                // IE does strange things with escape.
                if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;
                var code = e.keyCode;
                cm.display.shift = code == 16 || e.shiftKey;
                var handled = handleKeyBinding(cm, e);
                if (presto) {
                    lastStoppedKey = handled ? code : null;
                    // Opera has no cut event... we try to at least catch the key combo
                    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
                        cm.replaceSelection("", null, "cut");
                }

                // Turn mouse into crosshair when Alt is held on Mac.
                if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
                    showCrossHair(cm);
            }

            function showCrossHair(cm) {
                var lineDiv = cm.display.lineDiv;
                addClass(lineDiv, "CodeMirror-crosshair");

                function up(e) {
                    if (e.keyCode == 18 || !e.altKey) {
                        rmClass(lineDiv, "CodeMirror-crosshair");
                        off(document, "keyup", up);
                        off(document, "mouseover", up);
                    }
                }
                on(document, "keyup", up);
                on(document, "mouseover", up);
            }

            function onKeyUp(e) {
                if (e.keyCode == 16) this.doc.sel.shift = false;
                signalDOMEvent(this, e);
            }

            function onKeyPress(e) {
                var cm = this;
                if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;
                var keyCode = e.keyCode, charCode = e.charCode;
                if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
                if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;
                var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
                if (handleCharBinding(cm, e, ch)) return;
                cm.display.input.onKeyPress(e);
            }

            // FOCUS/BLUR EVENTS

            function delayBlurEvent(cm) {
                cm.state.delayingBlurEvent = true;
                setTimeout(function() {
                    if (cm.state.delayingBlurEvent) {
                        cm.state.delayingBlurEvent = false;
                        onBlur(cm);
                    }
                }, 100);
            }

            function onFocus(cm) {
                if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;

                if (cm.options.readOnly == "nocursor") return;
                if (!cm.state.focused) {
                    signal(cm, "focus", cm);
                    cm.state.focused = true;
                    addClass(cm.display.wrapper, "CodeMirror-focused");
                    // This test prevents this from firing when a context
                    // menu is closed (since the input reset would kill the
                    // select-all detection hack)
                    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
                        cm.display.input.reset();
                        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730
                    }
                    cm.display.input.receivedFocus();
                }
                restartBlink(cm);
            }
            function onBlur(cm) {
                if (cm.state.delayingBlurEvent) return;

                if (cm.state.focused) {
                    signal(cm, "blur", cm);
                    cm.state.focused = false;
                    rmClass(cm.display.wrapper, "CodeMirror-focused");
                }
                clearInterval(cm.display.blinker);
                setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
            }

            // CONTEXT MENU HANDLING

            // To make the context menu work, we need to briefly unhide the
            // textarea (making it as unobtrusive as possible) to let the
            // right-click take effect on it.
            function onContextMenu(cm, e) {
                if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;
                if (signalDOMEvent(cm, e, "contextmenu")) return;
                cm.display.input.onContextMenu(e);
            }

            function contextMenuInGutter(cm, e) {
                if (!hasHandler(cm, "gutterContextMenu")) return false;
                return gutterEvent(cm, e, "gutterContextMenu", false);
            }

            // UPDATING

            // Compute the position of the end of a change (its 'to' property
            // refers to the pre-change end).
            var changeEnd = CodeMirror.changeEnd = function(change) {
                if (!change.text) return change.to;
                return Pos(change.from.line + change.text.length - 1,
                    lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
            };

            // Adjust a position to refer to the post-change position of the
            // same text, or the end of the change if the change covers it.
            function adjustForChange(pos, change) {
                if (cmp(pos, change.from) < 0) return pos;
                if (cmp(pos, change.to) <= 0) return changeEnd(change);

                var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
                if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
                return Pos(line, ch);
            }

            function computeSelAfterChange(doc, change) {
                var out = [];
                for (var i = 0; i < doc.sel.ranges.length; i++) {
                    var range = doc.sel.ranges[i];
                    out.push(new Range(adjustForChange(range.anchor, change),
                        adjustForChange(range.head, change)));
                }
                return normalizeSelection(out, doc.sel.primIndex);
            }

            function offsetPos(pos, old, nw) {
                if (pos.line == old.line)
                    return Pos(nw.line, pos.ch - old.ch + nw.ch);
                else
                    return Pos(nw.line + (pos.line - old.line), pos.ch);
            }

            // Used by replaceSelections to allow moving the selection to the
            // start or around the replaced test. Hint may be "start" or "around".
            function computeReplacedSel(doc, changes, hint) {
                var out = [];
                var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
                for (var i = 0; i < changes.length; i++) {
                    var change = changes[i];
                    var from = offsetPos(change.from, oldPrev, newPrev);
                    var to = offsetPos(changeEnd(change), oldPrev, newPrev);
                    oldPrev = change.to;
                    newPrev = to;
                    if (hint == "around") {
                        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
                        out[i] = new Range(inv ? to : from, inv ? from : to);
                    } else {
                        out[i] = new Range(from, from);
                    }
                }
                return new Selection(out, doc.sel.primIndex);
            }

            // Allow "beforeChange" event handlers to influence a change
            function filterChange(doc, change, update) {
                var obj = {
                    canceled: false,
                    from: change.from,
                    to: change.to,
                    text: change.text,
                    origin: change.origin,
                    cancel: function() { this.canceled = true; }
                };
                if (update) obj.update = function(from, to, text, origin) {
                    if (from) this.from = clipPos(doc, from);
                    if (to) this.to = clipPos(doc, to);
                    if (text) this.text = text;
                    if (origin !== undefined) this.origin = origin;
                };
                signal(doc, "beforeChange", doc, obj);
                if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

                if (obj.canceled) return null;
                return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
            }

            // Apply a change to a document, and add it to the document's
            // history, and propagating it to all linked documents.
            function makeChange(doc, change, ignoreReadOnly) {
                if (doc.cm) {
                    if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
                    if (doc.cm.state.suppressEdits) return;
                }

                if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
                    change = filterChange(doc, change, true);
                    if (!change) return;
                }

                // Possibly split or suppress the update based on the presence
                // of read-only spans in its range.
                var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
                if (split) {
                    for (var i = split.length - 1; i >= 0; --i)
                        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
                } else {
                    makeChangeInner(doc, change);
                }
            }

            function makeChangeInner(doc, change) {
                if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
                var selAfter = computeSelAfterChange(doc, change);
                addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

                makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
                var rebased = [];

                linkedDocs(doc, function(doc, sharedHist) {
                    if (!sharedHist && indexOf(rebased, doc.history) == -1) {
                        rebaseHist(doc.history, change);
                        rebased.push(doc.history);
                    }
                    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
                });
            }

            // Revert a change stored in a document's history.
            function makeChangeFromHistory(doc, type, allowSelectionOnly) {
                if (doc.cm && doc.cm.state.suppressEdits) return;

                var hist = doc.history, event, selAfter = doc.sel;
                var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

                // Verify that there is a useable event (so that ctrl-z won't
                // needlessly clear selection events)
                for (var i = 0; i < source.length; i++) {
                    event = source[i];
                    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
                        break;
                }
                if (i == source.length) return;
                hist.lastOrigin = hist.lastSelOrigin = null;

                for (;;) {
                    event = source.pop();
                    if (event.ranges) {
                        pushSelectionToHistory(event, dest);
                        if (allowSelectionOnly && !event.equals(doc.sel)) {
                            setSelection(doc, event, {clearRedo: false});
                            return;
                        }
                        selAfter = event;
                    }
                    else break;
                }

                // Build up a reverse change object to add to the opposite history
                // stack (redo when undoing, and vice versa).
                var antiChanges = [];
                pushSelectionToHistory(selAfter, dest);
                dest.push({changes: antiChanges, generation: hist.generation});
                hist.generation = event.generation || ++hist.maxGeneration;

                var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

                for (var i = event.changes.length - 1; i >= 0; --i) {
                    var change = event.changes[i];
                    change.origin = type;
                    if (filter && !filterChange(doc, change, false)) {
                        source.length = 0;
                        return;
                    }

                    antiChanges.push(historyChangeFromChange(doc, change));

                    var after = i ? computeSelAfterChange(doc, change) : lst(source);
                    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
                    if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
                    var rebased = [];

                    // Propagate to the linked documents
                    linkedDocs(doc, function(doc, sharedHist) {
                        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
                            rebaseHist(doc.history, change);
                            rebased.push(doc.history);
                        }
                        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
                    });
                }
            }

            // Sub-views need their line numbers shifted when text is added
            // above or below them in the parent document.
            function shiftDoc(doc, distance) {
                if (distance == 0) return;
                doc.first += distance;
                doc.sel = new Selection(map(doc.sel.ranges, function(range) {
                    return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
                        Pos(range.head.line + distance, range.head.ch));
                }), doc.sel.primIndex);
                if (doc.cm) {
                    regChange(doc.cm, doc.first, doc.first - distance, distance);
                    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
                        regLineChange(doc.cm, l, "gutter");
                }
            }

            // More lower-level change function, handling only a single document
            // (not linked ones).
            function makeChangeSingleDoc(doc, change, selAfter, spans) {
                if (doc.cm && !doc.cm.curOp)
                    return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

                if (change.to.line < doc.first) {
                    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
                    return;
                }
                if (change.from.line > doc.lastLine()) return;

                // Clip the change to the size of this doc
                if (change.from.line < doc.first) {
                    var shift = change.text.length - 1 - (doc.first - change.from.line);
                    shiftDoc(doc, shift);
                    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                        text: [lst(change.text)], origin: change.origin};
                }
                var last = doc.lastLine();
                if (change.to.line > last) {
                    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                        text: [change.text[0]], origin: change.origin};
                }

                change.removed = getBetween(doc, change.from, change.to);

                if (!selAfter) selAfter = computeSelAfterChange(doc, change);
                if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
                else updateDoc(doc, change, spans);
                setSelectionNoUndo(doc, selAfter, sel_dontScroll);
            }

            // Handle the interaction of a change to a document with the editor
            // that this document is part of.
            function makeChangeSingleDocInEditor(cm, change, spans) {
                var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

                var recomputeMaxLength = false, checkWidthStart = from.line;
                if (!cm.options.lineWrapping) {
                    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
                    doc.iter(checkWidthStart, to.line + 1, function(line) {
                        if (line == display.maxLine) {
                            recomputeMaxLength = true;
                            return true;
                        }
                    });
                }

                if (doc.sel.contains(change.from, change.to) > -1)
                    signalCursorActivity(cm);

                updateDoc(doc, change, spans, estimateHeight(cm));

                if (!cm.options.lineWrapping) {
                    doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
                        var len = lineLength(line);
                        if (len > display.maxLineLength) {
                            display.maxLine = line;
                            display.maxLineLength = len;
                            display.maxLineChanged = true;
                            recomputeMaxLength = false;
                        }
                    });
                    if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
                }

                // Adjust frontier, schedule worker
                doc.frontier = Math.min(doc.frontier, from.line);
                startWorker(cm, 400);

                var lendiff = change.text.length - (to.line - from.line) - 1;
                // Remember that these lines changed, for updating the display
                if (change.full)
                    regChange(cm);
                else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
                    regLineChange(cm, from.line, "text");
                else
                    regChange(cm, from.line, to.line + 1, lendiff);

                var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
                if (changeHandler || changesHandler) {
                    var obj = {
                        from: from, to: to,
                        text: change.text,
                        removed: change.removed,
                        origin: change.origin
                    };
                    if (changeHandler) signalLater(cm, "change", cm, obj);
                    if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
                }
                cm.display.selForContextMenu = null;
            }

            function replaceRange(doc, code, from, to, origin) {
                if (!to) to = from;
                if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
                if (typeof code == "string") code = doc.splitLines(code);
                makeChange(doc, {from: from, to: to, text: code, origin: origin});
            }

            // SCROLLING THINGS INTO VIEW

            // If an editor sits on the top or bottom of the window, partially
            // scrolled out of view, this ensures that the cursor is visible.
            function maybeScrollWindow(cm, coords) {
                if (signalDOMEvent(cm, "scrollCursorIntoView")) return;

                var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
                if (coords.top + box.top < 0) doScroll = true;
                else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
                if (doScroll != null && !phantom) {
                    var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
                        (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
                        (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " +
                        coords.left + "px; width: 2px;");
                    cm.display.lineSpace.appendChild(scrollNode);
                    scrollNode.scrollIntoView(doScroll);
                    cm.display.lineSpace.removeChild(scrollNode);
                }
            }

            // Scroll a given position into view (immediately), verifying that
            // it actually became visible (as line heights are accurately
            // measured, the position of something may 'drift' during drawing).
            function scrollPosIntoView(cm, pos, end, margin) {
                if (margin == null) margin = 0;
                for (var limit = 0; limit < 5; limit++) {
                    var changed = false, coords = cursorCoords(cm, pos);
                    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
                    var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
                        Math.min(coords.top, endCoords.top) - margin,
                        Math.max(coords.left, endCoords.left),
                        Math.max(coords.bottom, endCoords.bottom) + margin);
                    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
                    if (scrollPos.scrollTop != null) {
                        setScrollTop(cm, scrollPos.scrollTop);
                        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
                    }
                    if (scrollPos.scrollLeft != null) {
                        setScrollLeft(cm, scrollPos.scrollLeft);
                        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
                    }
                    if (!changed) break;
                }
                return coords;
            }

            // Scroll a given set of coordinates into view (immediately).
            function scrollIntoView(cm, x1, y1, x2, y2) {
                var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
                if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
                if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
            }

            // Calculate a new scroll position needed to scroll the given
            // rectangle into view. Returns an object with scrollTop and
            // scrollLeft properties. When these are undefined, the
            // vertical/horizontal position does not need to be adjusted.
            function calculateScrollPos(cm, x1, y1, x2, y2) {
                var display = cm.display, snapMargin = textHeight(cm.display);
                if (y1 < 0) y1 = 0;
                var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
                var screen = displayHeight(cm), result = {};
                if (y2 - y1 > screen) y2 = y1 + screen;
                var docBottom = cm.doc.height + paddingVert(display);
                var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
                if (y1 < screentop) {
                    result.scrollTop = atTop ? 0 : y1;
                } else if (y2 > screentop + screen) {
                    var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
                    if (newTop != screentop) result.scrollTop = newTop;
                }

                var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
                var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
                var tooWide = x2 - x1 > screenw;
                if (tooWide) x2 = x1 + screenw;
                if (x1 < 10)
                    result.scrollLeft = 0;
                else if (x1 < screenleft)
                    result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
                else if (x2 > screenw + screenleft - 3)
                    result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
                return result;
            }

            // Store a relative adjustment to the scroll position in the current
            // operation (to be applied when the operation finishes).
            function addToScrollPos(cm, left, top) {
                if (left != null || top != null) resolveScrollToPos(cm);
                if (left != null)
                    cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
                if (top != null)
                    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
            }

            // Make sure that at the end of the operation the current cursor is
            // shown.
            function ensureCursorVisible(cm) {
                resolveScrollToPos(cm);
                var cur = cm.getCursor(), from = cur, to = cur;
                if (!cm.options.lineWrapping) {
                    from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
                    to = Pos(cur.line, cur.ch + 1);
                }
                cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
            }

            // When an operation has its scrollToPos property set, and another
            // scroll action is applied before the end of the operation, this
            // 'simulates' scrolling that position into view in a cheap way, so
            // that the effect of intermediate scroll commands is not ignored.
            function resolveScrollToPos(cm) {
                var range = cm.curOp.scrollToPos;
                if (range) {
                    cm.curOp.scrollToPos = null;
                    var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
                    var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
                        Math.min(from.top, to.top) - range.margin,
                        Math.max(from.right, to.right),
                        Math.max(from.bottom, to.bottom) + range.margin);
                    cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
                }
            }

            // API UTILITIES

            // Indent the given line. The how parameter can be "smart",
            // "add"/null, "subtract", or "prev". When aggressive is false
            // (typically set to true for forced single-line indents), empty
            // lines are not indented, and places where the mode returns Pass
            // are left alone.
            function indentLine(cm, n, how, aggressive) {
                var doc = cm.doc, state;
                if (how == null) how = "add";
                if (how == "smart") {
                    // Fall back to "prev" when the mode doesn't have an indentation
                    // method.
                    if (!doc.mode.indent) how = "prev";
                    else state = getStateBefore(cm, n);
                }

                var tabSize = cm.options.tabSize;
                var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
                if (line.stateAfter) line.stateAfter = null;
                var curSpaceString = line.text.match(/^\s*/)[0], indentation;
                if (!aggressive && !/\S/.test(line.text)) {
                    indentation = 0;
                    how = "not";
                } else if (how == "smart") {
                    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
                    if (indentation == Pass || indentation > 150) {
                        if (!aggressive) return;
                        how = "prev";
                    }
                }
                if (how == "prev") {
                    if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
                    else indentation = 0;
                } else if (how == "add") {
                    indentation = curSpace + cm.options.indentUnit;
                } else if (how == "subtract") {
                    indentation = curSpace - cm.options.indentUnit;
                } else if (typeof how == "number") {
                    indentation = curSpace + how;
                }
                indentation = Math.max(0, indentation);

                var indentString = "", pos = 0;
                if (cm.options.indentWithTabs)
                    for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
                if (pos < indentation) indentString += spaceStr(indentation - pos);

                if (indentString != curSpaceString) {
                    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
                    line.stateAfter = null;
                    return true;
                } else {
                    // Ensure that, if the cursor was in the whitespace at the start
                    // of the line, it is moved to the end of that space.
                    for (var i = 0; i < doc.sel.ranges.length; i++) {
                        var range = doc.sel.ranges[i];
                        if (range.head.line == n && range.head.ch < curSpaceString.length) {
                            var pos = Pos(n, curSpaceString.length);
                            replaceOneSelection(doc, i, new Range(pos, pos));
                            break;
                        }
                    }
                }
            }

            // Utility for applying a change to a line by handle or number,
            // returning the number and optionally registering the line as
            // changed.
            function changeLine(doc, handle, changeType, op) {
                var no = handle, line = handle;
                if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
                else no = lineNo(handle);
                if (no == null) return null;
                if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);
                return line;
            }

            // Helper for deleting text near the selection(s), used to implement
            // backspace, delete, and similar functionality.
            function deleteNearSelection(cm, compute) {
                var ranges = cm.doc.sel.ranges, kill = [];
                // Build up a set of ranges to kill first, merging overlapping
                // ranges.
                for (var i = 0; i < ranges.length; i++) {
                    var toKill = compute(ranges[i]);
                    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
                        var replaced = kill.pop();
                        if (cmp(replaced.from, toKill.from) < 0) {
                            toKill.from = replaced.from;
                            break;
                        }
                    }
                    kill.push(toKill);
                }
                // Next, remove those actual ranges.
                runInOp(cm, function() {
                    for (var i = kill.length - 1; i >= 0; i--)
                        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
                    ensureCursorVisible(cm);
                });
            }

            // Used for horizontal relative motion. Dir is -1 or 1 (left or
            // right), unit can be "char", "column" (like char, but doesn't
            // cross line boundaries), "word" (across next word), or "group" (to
            // the start of next group of word or non-word-non-whitespace
            // chars). The visually param controls whether, in right-to-left
            // text, direction 1 means to move towards the next index in the
            // string, or towards the character to the right of the current
            // position. The resulting position will have a hitSide=true
            // property if it reached the end of the document.
            function findPosH(doc, pos, dir, unit, visually) {
                var line = pos.line, ch = pos.ch, origDir = dir;
                var lineObj = getLine(doc, line);
                function findNextLine() {
                    var l = line + dir;
                    if (l < doc.first || l >= doc.first + doc.size) return false
                    line = l;
                    return lineObj = getLine(doc, l);
                }
                function moveOnce(boundToLine) {
                    var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
                    if (next == null) {
                        if (!boundToLine && findNextLine()) {
                            if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
                            else ch = dir < 0 ? lineObj.text.length : 0;
                        } else return false
                    } else ch = next;
                    return true;
                }

                if (unit == "char") {
                    moveOnce()
                } else if (unit == "column") {
                    moveOnce(true)
                } else if (unit == "word" || unit == "group") {
                    var sawType = null, group = unit == "group";
                    var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
                    for (var first = true;; first = false) {
                        if (dir < 0 && !moveOnce(!first)) break;
                        var cur = lineObj.text.charAt(ch) || "\n";
                        var type = isWordChar(cur, helper) ? "w"
                            : group && cur == "\n" ? "n"
                                : !group || /\s/.test(cur) ? null
                                    : "p";
                        if (group && !first && !type) type = "s";
                        if (sawType && sawType != type) {
                            if (dir < 0) {dir = 1; moveOnce();}
                            break;
                        }

                        if (type) sawType = type;
                        if (dir > 0 && !moveOnce(!first)) break;
                    }
                }
                var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);
                if (!cmp(pos, result)) result.hitSide = true;
                return result;
            }

            // For relative vertical movement. Dir may be -1 or 1. Unit can be
            // "page" or "line". The resulting position will have a hitSide=true
            // property if it reached the end of the document.
            function findPosV(cm, pos, dir, unit) {
                var doc = cm.doc, x = pos.left, y;
                if (unit == "page") {
                    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
                    y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
                } else if (unit == "line") {
                    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
                }
                for (;;) {
                    var target = coordsChar(cm, x, y);
                    if (!target.outside) break;
                    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
                    y += dir * 5;
                }
                return target;
            }

            // EDITOR METHODS

            // The publicly visible API. Note that methodOp(f) means
            // 'wrap f in an operation, performed on its `this` parameter'.

            // This is not the complete set of editor methods. Most of the
            // methods defined on the Doc type are also injected into
            // CodeMirror.prototype, for backwards compatibility and
            // convenience.

            CodeMirror.prototype = {
                constructor: CodeMirror,
                focus: function(){window.focus(); this.display.input.focus();},

                setOption: function(option, value) {
                    var options = this.options, old = options[option];
                    if (options[option] == value && option != "mode") return;
                    options[option] = value;
                    if (optionHandlers.hasOwnProperty(option))
                        operation(this, optionHandlers[option])(this, value, old);
                },

                getOption: function(option) {return this.options[option];},
                getDoc: function() {return this.doc;},

                addKeyMap: function(map, bottom) {
                    this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
                },
                removeKeyMap: function(map) {
                    var maps = this.state.keyMaps;
                    for (var i = 0; i < maps.length; ++i)
                        if (maps[i] == map || maps[i].name == map) {
                            maps.splice(i, 1);
                            return true;
                        }
                },

                addOverlay: methodOp(function(spec, options) {
                    var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
                    if (mode.startState) throw new Error("Overlays may not be stateful.");
                    this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
                    this.state.modeGen++;
                    regChange(this);
                }),
                removeOverlay: methodOp(function(spec) {
                    var overlays = this.state.overlays;
                    for (var i = 0; i < overlays.length; ++i) {
                        var cur = overlays[i].modeSpec;
                        if (cur == spec || typeof spec == "string" && cur.name == spec) {
                            overlays.splice(i, 1);
                            this.state.modeGen++;
                            regChange(this);
                            return;
                        }
                    }
                }),

                indentLine: methodOp(function(n, dir, aggressive) {
                    if (typeof dir != "string" && typeof dir != "number") {
                        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
                        else dir = dir ? "add" : "subtract";
                    }
                    if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
                }),
                indentSelection: methodOp(function(how) {
                    var ranges = this.doc.sel.ranges, end = -1;
                    for (var i = 0; i < ranges.length; i++) {
                        var range = ranges[i];
                        if (!range.empty()) {
                            var from = range.from(), to = range.to();
                            var start = Math.max(end, from.line);
                            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                            for (var j = start; j < end; ++j)
                                indentLine(this, j, how);
                            var newRanges = this.doc.sel.ranges;
                            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
                                replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
                        } else if (range.head.line > end) {
                            indentLine(this, range.head.line, how, true);
                            end = range.head.line;
                            if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
                        }
                    }
                }),

                // Fetch the parser token for a given character. Useful for hacks
                // that want to inspect the mode state (say, for completion).
                getTokenAt: function(pos, precise) {
                    return takeToken(this, pos, precise);
                },

                getLineTokens: function(line, precise) {
                    return takeToken(this, Pos(line), precise, true);
                },

                getTokenTypeAt: function(pos) {
                    pos = clipPos(this.doc, pos);
                    var styles = getLineStyles(this, getLine(this.doc, pos.line));
                    var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
                    var type;
                    if (ch == 0) type = styles[2];
                    else for (;;) {
                        var mid = (before + after) >> 1;
                        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
                        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
                        else { type = styles[mid * 2 + 2]; break; }
                    }
                    var cut = type ? type.indexOf("cm-overlay ") : -1;
                    return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
                },

                getModeAt: function(pos) {
                    var mode = this.doc.mode;
                    if (!mode.innerMode) return mode;
                    return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
                },

                getHelper: function(pos, type) {
                    return this.getHelpers(pos, type)[0];
                },

                getHelpers: function(pos, type) {
                    var found = [];
                    if (!helpers.hasOwnProperty(type)) return found;
                    var help = helpers[type], mode = this.getModeAt(pos);
                    if (typeof mode[type] == "string") {
                        if (help[mode[type]]) found.push(help[mode[type]]);
                    } else if (mode[type]) {
                        for (var i = 0; i < mode[type].length; i++) {
                            var val = help[mode[type][i]];
                            if (val) found.push(val);
                        }
                    } else if (mode.helperType && help[mode.helperType]) {
                        found.push(help[mode.helperType]);
                    } else if (help[mode.name]) {
                        found.push(help[mode.name]);
                    }
                    for (var i = 0; i < help._global.length; i++) {
                        var cur = help._global[i];
                        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
                            found.push(cur.val);
                    }
                    return found;
                },

                getStateAfter: function(line, precise) {
                    var doc = this.doc;
                    line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
                    return getStateBefore(this, line + 1, precise);
                },

                cursorCoords: function(start, mode) {
                    var pos, range = this.doc.sel.primary();
                    if (start == null) pos = range.head;
                    else if (typeof start == "object") pos = clipPos(this.doc, start);
                    else pos = start ? range.from() : range.to();
                    return cursorCoords(this, pos, mode || "page");
                },

                charCoords: function(pos, mode) {
                    return charCoords(this, clipPos(this.doc, pos), mode || "page");
                },

                coordsChar: function(coords, mode) {
                    coords = fromCoordSystem(this, coords, mode || "page");
                    return coordsChar(this, coords.left, coords.top);
                },

                lineAtHeight: function(height, mode) {
                    height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
                    return lineAtHeight(this.doc, height + this.display.viewOffset);
                },
                heightAtLine: function(line, mode) {
                    var end = false, lineObj;
                    if (typeof line == "number") {
                        var last = this.doc.first + this.doc.size - 1;
                        if (line < this.doc.first) line = this.doc.first;
                        else if (line > last) { line = last; end = true; }
                        lineObj = getLine(this.doc, line);
                    } else {
                        lineObj = line;
                    }
                    return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
                        (end ? this.doc.height - heightAtLine(lineObj) : 0);
                },

                defaultTextHeight: function() { return textHeight(this.display); },
                defaultCharWidth: function() { return charWidth(this.display); },

                setGutterMarker: methodOp(function(line, gutterID, value) {
                    return changeLine(this.doc, line, "gutter", function(line) {
                        var markers = line.gutterMarkers || (line.gutterMarkers = {});
                        markers[gutterID] = value;
                        if (!value && isEmpty(markers)) line.gutterMarkers = null;
                        return true;
                    });
                }),

                clearGutter: methodOp(function(gutterID) {
                    var cm = this, doc = cm.doc, i = doc.first;
                    doc.iter(function(line) {
                        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
                            line.gutterMarkers[gutterID] = null;
                            regLineChange(cm, i, "gutter");
                            if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
                        }
                        ++i;
                    });
                }),

                lineInfo: function(line) {
                    if (typeof line == "number") {
                        if (!isLine(this.doc, line)) return null;
                        var n = line;
                        line = getLine(this.doc, line);
                        if (!line) return null;
                    } else {
                        var n = lineNo(line);
                        if (n == null) return null;
                    }
                    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
                        textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
                        widgets: line.widgets};
                },

                getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

                addWidget: function(pos, node, scroll, vert, horiz) {
                    var display = this.display;
                    pos = cursorCoords(this, clipPos(this.doc, pos));
                    var top = pos.bottom, left = pos.left;
                    node.style.position = "absolute";
                    node.setAttribute("cm-ignore-events", "true");
                    this.display.input.setUneditable(node);
                    display.sizer.appendChild(node);
                    if (vert == "over") {
                        top = pos.top;
                    } else if (vert == "above" || vert == "near") {
                        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
                            hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                        // Default to positioning above (if specified and possible); otherwise default to positioning below
                        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
                            top = pos.top - node.offsetHeight;
                        else if (pos.bottom + node.offsetHeight <= vspace)
                            top = pos.bottom;
                        if (left + node.offsetWidth > hspace)
                            left = hspace - node.offsetWidth;
                    }
                    node.style.top = top + "px";
                    node.style.left = node.style.right = "";
                    if (horiz == "right") {
                        left = display.sizer.clientWidth - node.offsetWidth;
                        node.style.right = "0px";
                    } else {
                        if (horiz == "left") left = 0;
                        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
                        node.style.left = left + "px";
                    }
                    if (scroll)
                        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
                },

                triggerOnKeyDown: methodOp(onKeyDown),
                triggerOnKeyPress: methodOp(onKeyPress),
                triggerOnKeyUp: onKeyUp,

                execCommand: function(cmd) {
                    if (commands.hasOwnProperty(cmd))
                        return commands[cmd].call(null, this);
                },

                triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

                findPosH: function(from, amount, unit, visually) {
                    var dir = 1;
                    if (amount < 0) { dir = -1; amount = -amount; }
                    for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
                        cur = findPosH(this.doc, cur, dir, unit, visually);
                        if (cur.hitSide) break;
                    }
                    return cur;
                },

                moveH: methodOp(function(dir, unit) {
                    var cm = this;
                    cm.extendSelectionsBy(function(range) {
                        if (cm.display.shift || cm.doc.extend || range.empty())
                            return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
                        else
                            return dir < 0 ? range.from() : range.to();
                    }, sel_move);
                }),

                deleteH: methodOp(function(dir, unit) {
                    var sel = this.doc.sel, doc = this.doc;
                    if (sel.somethingSelected())
                        doc.replaceSelection("", null, "+delete");
                    else
                        deleteNearSelection(this, function(range) {
                            var other = findPosH(doc, range.head, dir, unit, false);
                            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
                        });
                }),

                findPosV: function(from, amount, unit, goalColumn) {
                    var dir = 1, x = goalColumn;
                    if (amount < 0) { dir = -1; amount = -amount; }
                    for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
                        var coords = cursorCoords(this, cur, "div");
                        if (x == null) x = coords.left;
                        else coords.left = x;
                        cur = findPosV(this, coords, dir, unit);
                        if (cur.hitSide) break;
                    }
                    return cur;
                },

                moveV: methodOp(function(dir, unit) {
                    var cm = this, doc = this.doc, goals = [];
                    var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
                    doc.extendSelectionsBy(function(range) {
                        if (collapse)
                            return dir < 0 ? range.from() : range.to();
                        var headPos = cursorCoords(cm, range.head, "div");
                        if (range.goalColumn != null) headPos.left = range.goalColumn;
                        goals.push(headPos.left);
                        var pos = findPosV(cm, headPos, dir, unit);
                        if (unit == "page" && range == doc.sel.primary())
                            addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
                        return pos;
                    }, sel_move);
                    if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
                        doc.sel.ranges[i].goalColumn = goals[i];
                }),

                // Find the word at the given position (as returned by coordsChar).
                findWordAt: function(pos) {
                    var doc = this.doc, line = getLine(doc, pos.line).text;
                    var start = pos.ch, end = pos.ch;
                    if (line) {
                        var helper = this.getHelper(pos, "wordChars");
                        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
                        var startChar = line.charAt(start);
                        var check = isWordChar(startChar, helper)
                            ? function(ch) { return isWordChar(ch, helper); }
                            : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
                                : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
                        while (start > 0 && check(line.charAt(start - 1))) --start;
                        while (end < line.length && check(line.charAt(end))) ++end;
                    }
                    return new Range(Pos(pos.line, start), Pos(pos.line, end));
                },

                toggleOverwrite: function(value) {
                    if (value != null && value == this.state.overwrite) return;
                    if (this.state.overwrite = !this.state.overwrite)
                        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
                    else
                        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

                    signal(this, "overwriteToggle", this, this.state.overwrite);
                },
                hasFocus: function() { return this.display.input.getField() == activeElt(); },
                isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },

                scrollTo: methodOp(function(x, y) {
                    if (x != null || y != null) resolveScrollToPos(this);
                    if (x != null) this.curOp.scrollLeft = x;
                    if (y != null) this.curOp.scrollTop = y;
                }),
                getScrollInfo: function() {
                    var scroller = this.display.scroller;
                    return {left: scroller.scrollLeft, top: scroller.scrollTop,
                        height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                        width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                        clientHeight: displayHeight(this), clientWidth: displayWidth(this)};
                },

                scrollIntoView: methodOp(function(range, margin) {
                    if (range == null) {
                        range = {from: this.doc.sel.primary().head, to: null};
                        if (margin == null) margin = this.options.cursorScrollMargin;
                    } else if (typeof range == "number") {
                        range = {from: Pos(range, 0), to: null};
                    } else if (range.from == null) {
                        range = {from: range, to: null};
                    }
                    if (!range.to) range.to = range.from;
                    range.margin = margin || 0;

                    if (range.from.line != null) {
                        resolveScrollToPos(this);
                        this.curOp.scrollToPos = range;
                    } else {
                        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
                            Math.min(range.from.top, range.to.top) - range.margin,
                            Math.max(range.from.right, range.to.right),
                            Math.max(range.from.bottom, range.to.bottom) + range.margin);
                        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
                    }
                }),

                setSize: methodOp(function(width, height) {
                    var cm = this;
                    function interpret(val) {
                        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
                    }
                    if (width != null) cm.display.wrapper.style.width = interpret(width);
                    if (height != null) cm.display.wrapper.style.height = interpret(height);
                    if (cm.options.lineWrapping) clearLineMeasurementCache(this);
                    var lineNo = cm.display.viewFrom;
                    cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
                        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)
                            if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }
                        ++lineNo;
                    });
                    cm.curOp.forceUpdate = true;
                    signal(cm, "refresh", this);
                }),

                operation: function(f){return runInOp(this, f);},

                refresh: methodOp(function() {
                    var oldHeight = this.display.cachedTextHeight;
                    regChange(this);
                    this.curOp.forceUpdate = true;
                    clearCaches(this);
                    this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
                    updateGutterSpace(this);
                    if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
                        estimateLineHeights(this);
                    signal(this, "refresh", this);
                }),

                swapDoc: methodOp(function(doc) {
                    var old = this.doc;
                    old.cm = null;
                    attachDoc(this, doc);
                    clearCaches(this);
                    this.display.input.reset();
                    this.scrollTo(doc.scrollLeft, doc.scrollTop);
                    this.curOp.forceScroll = true;
                    signalLater(this, "swapDoc", this, old);
                    return old;
                }),

                getInputField: function(){return this.display.input.getField();},
                getWrapperElement: function(){return this.display.wrapper;},
                getScrollerElement: function(){return this.display.scroller;},
                getGutterElement: function(){return this.display.gutters;}
            };
            eventMixin(CodeMirror);

            // OPTION DEFAULTS

            // The default configuration options.
            var defaults = CodeMirror.defaults = {};
            // Functions to run when options are changed.
            var optionHandlers = CodeMirror.optionHandlers = {};

            function option(name, deflt, handle, notOnInit) {
                CodeMirror.defaults[name] = deflt;
                if (handle) optionHandlers[name] =
                    notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
            }

            // Passed to option handlers when there is no old value.
            var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

            // These two are, on init, called from the constructor because they
            // have to be initialized before the editor can start at all.
            option("value", "", function(cm, val) {
                cm.setValue(val);
            }, true);
            option("mode", null, function(cm, val) {
                cm.doc.modeOption = val;
                loadMode(cm);
            }, true);

            option("indentUnit", 2, loadMode, true);
            option("indentWithTabs", false);
            option("smartIndent", true);
            option("tabSize", 4, function(cm) {
                resetModeState(cm);
                clearCaches(cm);
                regChange(cm);
            }, true);
            option("lineSeparator", null, function(cm, val) {
                cm.doc.lineSep = val;
                if (!val) return;
                var newBreaks = [], lineNo = cm.doc.first;
                cm.doc.iter(function(line) {
                    for (var pos = 0;;) {
                        var found = line.text.indexOf(val, pos);
                        if (found == -1) break;
                        pos = found + val.length;
                        newBreaks.push(Pos(lineNo, found));
                    }
                    lineNo++;
                });
                for (var i = newBreaks.length - 1; i >= 0; i--)
                    replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))
            });
            option("specialChars", /[\u0000-\u001f\u007f\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
                cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
                if (old != CodeMirror.Init) cm.refresh();
            });
            option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
            option("electricChars", true);
            option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
                throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
            }, true);
            option("rtlMoveVisually", !windows);
            option("wholeLineUpdateBefore", true);

            option("theme", "default", function(cm) {
                themeChanged(cm);
                guttersChanged(cm);
            }, true);
            option("keyMap", "default", function(cm, val, old) {
                var next = getKeyMap(val);
                var prev = old != CodeMirror.Init && getKeyMap(old);
                if (prev && prev.detach) prev.detach(cm, next);
                if (next.attach) next.attach(cm, prev || null);
            });
            option("extraKeys", null);

            option("lineWrapping", false, wrappingChanged, true);
            option("gutters", [], function(cm) {
                setGuttersForLineNumbers(cm.options);
                guttersChanged(cm);
            }, true);
            option("fixedGutter", true, function(cm, val) {
                cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
                cm.refresh();
            }, true);
            option("coverGutterNextToScrollbar", false, function(cm) {updateScrollbars(cm);}, true);
            option("scrollbarStyle", "native", function(cm) {
                initScrollbars(cm);
                updateScrollbars(cm);
                cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
                cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
            }, true);
            option("lineNumbers", false, function(cm) {
                setGuttersForLineNumbers(cm.options);
                guttersChanged(cm);
            }, true);
            option("firstLineNumber", 1, guttersChanged, true);
            option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
            option("showCursorWhenSelecting", false, updateSelection, true);

            option("resetSelectionOnContextMenu", true);
            option("lineWiseCopyCut", true);

            option("readOnly", false, function(cm, val) {
                if (val == "nocursor") {
                    onBlur(cm);
                    cm.display.input.blur();
                    cm.display.disabled = true;
                } else {
                    cm.display.disabled = false;
                }
                cm.display.input.readOnlyChanged(val)
            });
            option("disableInput", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);
            option("dragDrop", true, dragDropChanged);
            option("allowDropFileTypes", null);

            option("cursorBlinkRate", 530);
            option("cursorScrollMargin", 0);
            option("cursorHeight", 1, updateSelection, true);
            option("singleCursorHeightPerLine", true, updateSelection, true);
            option("workTime", 100);
            option("workDelay", 100);
            option("flattenSpans", true, resetModeState, true);
            option("addModeClass", false, resetModeState, true);
            option("pollInterval", 100);
            option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
            option("historyEventDelay", 1250);
            option("viewportMargin", 10, function(cm){cm.refresh();}, true);
            option("maxHighlightLength", 10000, resetModeState, true);
            option("moveInputWithCursor", true, function(cm, val) {
                if (!val) cm.display.input.resetPosition();
            });

            option("tabindex", null, function(cm, val) {
                cm.display.input.getField().tabIndex = val || "";
            });
            option("autofocus", null);

            // MODE DEFINITION AND QUERYING

            // Known modes, by name and by MIME
            var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

            // Extra arguments are stored as the mode's dependencies, which is
            // used by (legacy) mechanisms like loadmode.js to automatically
            // load a mode. (Preferred mechanism is the require/define calls.)
            CodeMirror.defineMode = function(name, mode) {
                if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
                if (arguments.length > 2)
                    mode.dependencies = Array.prototype.slice.call(arguments, 2);
                modes[name] = mode;
            };

            CodeMirror.defineMIME = function(mime, spec) {
                mimeModes[mime] = spec;
            };

            // Given a MIME type, a {name, ...options} config object, or a name
            // string, return a mode config object.
            CodeMirror.resolveMode = function(spec) {
                if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
                    spec = mimeModes[spec];
                } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
                    var found = mimeModes[spec.name];
                    if (typeof found == "string") found = {name: found};
                    spec = createObj(found, spec);
                    spec.name = found.name;
                } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
                    return CodeMirror.resolveMode("application/xml");
                }
                if (typeof spec == "string") return {name: spec};
                else return spec || {name: "null"};
            };

            // Given a mode spec (anything that resolveMode accepts), find and
            // initialize an actual mode object.
            CodeMirror.getMode = function(options, spec) {
                var spec = CodeMirror.resolveMode(spec);
                var mfactory = modes[spec.name];
                if (!mfactory) return CodeMirror.getMode(options, "text/plain");
                var modeObj = mfactory(options, spec);
                if (modeExtensions.hasOwnProperty(spec.name)) {
                    var exts = modeExtensions[spec.name];
                    for (var prop in exts) {
                        if (!exts.hasOwnProperty(prop)) continue;
                        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
                        modeObj[prop] = exts[prop];
                    }
                }
                modeObj.name = spec.name;
                if (spec.helperType) modeObj.helperType = spec.helperType;
                if (spec.modeProps) for (var prop in spec.modeProps)
                    modeObj[prop] = spec.modeProps[prop];

                return modeObj;
            };

            // Minimal default mode.
            CodeMirror.defineMode("null", function() {
                return {token: function(stream) {stream.skipToEnd();}};
            });
            CodeMirror.defineMIME("text/plain", "null");

            // This can be used to attach properties to mode objects from
            // outside the actual mode definition.
            var modeExtensions = CodeMirror.modeExtensions = {};
            CodeMirror.extendMode = function(mode, properties) {
                var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
                copyObj(properties, exts);
            };

            // EXTENSIONS

            CodeMirror.defineExtension = function(name, func) {
                CodeMirror.prototype[name] = func;
            };
            CodeMirror.defineDocExtension = function(name, func) {
                Doc.prototype[name] = func;
            };
            CodeMirror.defineOption = option;

            var initHooks = [];
            CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

            var helpers = CodeMirror.helpers = {};
            CodeMirror.registerHelper = function(type, name, value) {
                if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
                helpers[type][name] = value;
            };
            CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
                CodeMirror.registerHelper(type, name, value);
                helpers[type]._global.push({pred: predicate, val: value});
            };

            // MODE STATE HANDLING

            // Utility functions for working with state. Exported because nested
            // modes need to do this for their inner modes.

            var copyState = CodeMirror.copyState = function(mode, state) {
                if (state === true) return state;
                if (mode.copyState) return mode.copyState(state);
                var nstate = {};
                for (var n in state) {
                    var val = state[n];
                    if (val instanceof Array) val = val.concat([]);
                    nstate[n] = val;
                }
                return nstate;
            };

            var startState = CodeMirror.startState = function(mode, a1, a2) {
                return mode.startState ? mode.startState(a1, a2) : true;
            };

            // Given a mode and a state (for that mode), find the inner mode and
            // state at the position that the state refers to.
            CodeMirror.innerMode = function(mode, state) {
                while (mode.innerMode) {
                    var info = mode.innerMode(state);
                    if (!info || info.mode == mode) break;
                    state = info.state;
                    mode = info.mode;
                }
                return info || {mode: mode, state: state};
            };

            // STANDARD COMMANDS

            // Commands are parameter-less actions that can be performed on an
            // editor, mostly used for keybindings.
            var commands = CodeMirror.commands = {
                selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
                singleSelection: function(cm) {
                    cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
                },
                killLine: function(cm) {
                    deleteNearSelection(cm, function(range) {
                        if (range.empty()) {
                            var len = getLine(cm.doc, range.head.line).text.length;
                            if (range.head.ch == len && range.head.line < cm.lastLine())
                                return {from: range.head, to: Pos(range.head.line + 1, 0)};
                            else
                                return {from: range.head, to: Pos(range.head.line, len)};
                        } else {
                            return {from: range.from(), to: range.to()};
                        }
                    });
                },
                deleteLine: function(cm) {
                    deleteNearSelection(cm, function(range) {
                        return {from: Pos(range.from().line, 0),
                            to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
                    });
                },
                delLineLeft: function(cm) {
                    deleteNearSelection(cm, function(range) {
                        return {from: Pos(range.from().line, 0), to: range.from()};
                    });
                },
                delWrappedLineLeft: function(cm) {
                    deleteNearSelection(cm, function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5;
                        var leftPos = cm.coordsChar({left: 0, top: top}, "div");
                        return {from: leftPos, to: range.from()};
                    });
                },
                delWrappedLineRight: function(cm) {
                    deleteNearSelection(cm, function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5;
                        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
                        return {from: range.from(), to: rightPos };
                    });
                },
                undo: function(cm) {cm.undo();},
                redo: function(cm) {cm.redo();},
                undoSelection: function(cm) {cm.undoSelection();},
                redoSelection: function(cm) {cm.redoSelection();},
                goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
                goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
                goLineStart: function(cm) {
                    cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },
                        {origin: "+move", bias: 1});
                },
                goLineStartSmart: function(cm) {
                    cm.extendSelectionsBy(function(range) {
                        return lineStartSmart(cm, range.head);
                    }, {origin: "+move", bias: 1});
                },
                goLineEnd: function(cm) {
                    cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },
                        {origin: "+move", bias: -1});
                },
                goLineRight: function(cm) {
                    cm.extendSelectionsBy(function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5;
                        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
                    }, sel_move);
                },
                goLineLeft: function(cm) {
                    cm.extendSelectionsBy(function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5;
                        return cm.coordsChar({left: 0, top: top}, "div");
                    }, sel_move);
                },
                goLineLeftSmart: function(cm) {
                    cm.extendSelectionsBy(function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5;
                        var pos = cm.coordsChar({left: 0, top: top}, "div");
                        if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
                        return pos;
                    }, sel_move);
                },
                goLineUp: function(cm) {cm.moveV(-1, "line");},
                goLineDown: function(cm) {cm.moveV(1, "line");},
                goPageUp: function(cm) {cm.moveV(-1, "page");},
                goPageDown: function(cm) {cm.moveV(1, "page");},
                goCharLeft: function(cm) {cm.moveH(-1, "char");},
                goCharRight: function(cm) {cm.moveH(1, "char");},
                goColumnLeft: function(cm) {cm.moveH(-1, "column");},
                goColumnRight: function(cm) {cm.moveH(1, "column");},
                goWordLeft: function(cm) {cm.moveH(-1, "word");},
                goGroupRight: function(cm) {cm.moveH(1, "group");},
                goGroupLeft: function(cm) {cm.moveH(-1, "group");},
                goWordRight: function(cm) {cm.moveH(1, "word");},
                delCharBefore: function(cm) {cm.deleteH(-1, "char");},
                delCharAfter: function(cm) {cm.deleteH(1, "char");},
                delWordBefore: function(cm) {cm.deleteH(-1, "word");},
                delWordAfter: function(cm) {cm.deleteH(1, "word");},
                delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
                delGroupAfter: function(cm) {cm.deleteH(1, "group");},
                indentAuto: function(cm) {cm.indentSelection("smart");},
                indentMore: function(cm) {cm.indentSelection("add");},
                indentLess: function(cm) {cm.indentSelection("subtract");},
                insertTab: function(cm) {cm.replaceSelection("\t");},
                insertSoftTab: function(cm) {
                    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
                    for (var i = 0; i < ranges.length; i++) {
                        var pos = ranges[i].from();
                        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
                        spaces.push(spaceStr(tabSize - col % tabSize));
                    }
                    cm.replaceSelections(spaces);
                },
                defaultTab: function(cm) {
                    if (cm.somethingSelected()) cm.indentSelection("add");
                    else cm.execCommand("insertTab");
                },
                transposeChars: function(cm) {
                    runInOp(cm, function() {
                        var ranges = cm.listSelections(), newSel = [];
                        for (var i = 0; i < ranges.length; i++) {
                            var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
                            if (line) {
                                if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);
                                if (cur.ch > 0) {
                                    cur = new Pos(cur.line, cur.ch + 1);
                                    cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                                        Pos(cur.line, cur.ch - 2), cur, "+transpose");
                                } else if (cur.line > cm.doc.first) {
                                    var prev = getLine(cm.doc, cur.line - 1).text;
                                    if (prev)
                                        cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                                            prev.charAt(prev.length - 1),
                                            Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
                                }
                            }
                            newSel.push(new Range(cur, cur));
                        }
                        cm.setSelections(newSel);
                    });
                },
                newlineAndIndent: function(cm) {
                    runInOp(cm, function() {
                        var len = cm.listSelections().length;
                        for (var i = 0; i < len; i++) {
                            var range = cm.listSelections()[i];
                            cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, "+input");
                            cm.indentLine(range.from().line + 1, null, true);
                        }
                        ensureCursorVisible(cm);
                    });
                },
                openLine: function(cm) {cm.replaceSelection("\n", "start")},
                toggleOverwrite: function(cm) {cm.toggleOverwrite();}
            };


            // STANDARD KEYMAPS

            var keyMap = CodeMirror.keyMap = {};

            keyMap.basic = {
                "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
                "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
                "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
                "Tab": "defaultTab", "Shift-Tab": "indentAuto",
                "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
                "Esc": "singleSelection"
            };
            // Note that the save and find-related commands aren't defined by
            // default. User code or addons can define them. Unknown commands
            // are simply ignored.
            keyMap.pcDefault = {
                "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
                "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
                "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
                "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
                "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
                "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
                "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
                fallthrough: "basic"
            };
            // Very basic readline/emacs-style bindings, which are standard on Mac.
            keyMap.emacsy = {
                "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
                "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
                "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
                "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
                "Ctrl-O": "openLine"
            };
            keyMap.macDefault = {
                "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
                "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
                "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
                "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
                "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
                "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
                "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
                fallthrough: ["basic", "emacsy"]
            };
            keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

            // KEYMAP DISPATCH

            function normalizeKeyName(name) {
                var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];
                var alt, ctrl, shift, cmd;
                for (var i = 0; i < parts.length - 1; i++) {
                    var mod = parts[i];
                    if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;
                    else if (/^a(lt)?$/i.test(mod)) alt = true;
                    else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
                    else if (/^s(hift)$/i.test(mod)) shift = true;
                    else throw new Error("Unrecognized modifier name: " + mod);
                }
                if (alt) name = "Alt-" + name;
                if (ctrl) name = "Ctrl-" + name;
                if (cmd) name = "Cmd-" + name;
                if (shift) name = "Shift-" + name;
                return name;
            }

            // This is a kludge to keep keymaps mostly working as raw objects
            // (backwards compatibility) while at the same time support features
            // like normalization and multi-stroke key bindings. It compiles a
            // new normalized keymap, and then updates the old object to reflect
            // this.
            CodeMirror.normalizeKeyMap = function(keymap) {
                var copy = {};
                for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
                    var value = keymap[keyname];
                    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
                    if (value == "...") { delete keymap[keyname]; continue; }

                    var keys = map(keyname.split(" "), normalizeKeyName);
                    for (var i = 0; i < keys.length; i++) {
                        var val, name;
                        if (i == keys.length - 1) {
                            name = keys.join(" ");
                            val = value;
                        } else {
                            name = keys.slice(0, i + 1).join(" ");
                            val = "...";
                        }
                        var prev = copy[name];
                        if (!prev) copy[name] = val;
                        else if (prev != val) throw new Error("Inconsistent bindings for " + name);
                    }
                    delete keymap[keyname];
                }
                for (var prop in copy) keymap[prop] = copy[prop];
                return keymap;
            };

            var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {
                map = getKeyMap(map);
                var found = map.call ? map.call(key, context) : map[key];
                if (found === false) return "nothing";
                if (found === "...") return "multi";
                if (found != null && handle(found)) return "handled";

                if (map.fallthrough) {
                    if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
                        return lookupKey(key, map.fallthrough, handle, context);
                    for (var i = 0; i < map.fallthrough.length; i++) {
                        var result = lookupKey(key, map.fallthrough[i], handle, context);
                        if (result) return result;
                    }
                }
            };

            // Modifier key presses don't count as 'real' key presses for the
            // purpose of keymap fallthrough.
            var isModifierKey = CodeMirror.isModifierKey = function(value) {
                var name = typeof value == "string" ? value : keyNames[value.keyCode];
                return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
            };

            // Look up the name of a key as indicated by an event object.
            var keyName = CodeMirror.keyName = function(event, noShift) {
                if (presto && event.keyCode == 34 && event["char"]) return false;
                var base = keyNames[event.keyCode], name = base;
                if (name == null || event.altGraphKey) return false;
                if (event.altKey && base != "Alt") name = "Alt-" + name;
                if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") name = "Ctrl-" + name;
                if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") name = "Cmd-" + name;
                if (!noShift && event.shiftKey && base != "Shift") name = "Shift-" + name;
                return name;
            };

            function getKeyMap(val) {
                return typeof val == "string" ? keyMap[val] : val;
            }

            // FROMTEXTAREA

            CodeMirror.fromTextArea = function(textarea, options) {
                options = options ? copyObj(options) : {};
                options.value = textarea.value;
                if (!options.tabindex && textarea.tabIndex)
                    options.tabindex = textarea.tabIndex;
                if (!options.placeholder && textarea.placeholder)
                    options.placeholder = textarea.placeholder;
                // Set autofocus to true if this textarea is focused, or if it has
                // autofocus and no other element is focused.
                if (options.autofocus == null) {
                    var hasFocus = activeElt();
                    options.autofocus = hasFocus == textarea ||
                        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
                }

                function save() {textarea.value = cm.getValue();}
                if (textarea.form) {
                    on(textarea.form, "submit", save);
                    // Deplorable hack to make the submit method do the right thing.
                    if (!options.leaveSubmitMethodAlone) {
                        var form = textarea.form, realSubmit = form.submit;
                        try {
                            var wrappedSubmit = form.submit = function() {
                                save();
                                form.submit = realSubmit;
                                form.submit();
                                form.submit = wrappedSubmit;
                            };
                        } catch(e) {}
                    }
                }

                options.finishInit = function(cm) {
                    cm.save = save;
                    cm.getTextArea = function() { return textarea; };
                    cm.toTextArea = function() {
                        cm.toTextArea = isNaN; // Prevent this from being ran twice
                        save();
                        textarea.parentNode.removeChild(cm.getWrapperElement());
                        textarea.style.display = "";
                        if (textarea.form) {
                            off(textarea.form, "submit", save);
                            if (typeof textarea.form.submit == "function")
                                textarea.form.submit = realSubmit;
                        }
                    };
                };

                textarea.style.display = "none";
                var cm = CodeMirror(function(node) {
                    textarea.parentNode.insertBefore(node, textarea.nextSibling);
                }, options);
                return cm;
            };

            // STRING STREAM

            // Fed to the mode parsers, provides helper functions to make
            // parsers more succinct.

            var StringStream = CodeMirror.StringStream = function(string, tabSize) {
                this.pos = this.start = 0;
                this.string = string;
                this.tabSize = tabSize || 8;
                this.lastColumnPos = this.lastColumnValue = 0;
                this.lineStart = 0;
            };

            StringStream.prototype = {
                eol: function() {return this.pos >= this.string.length;},
                sol: function() {return this.pos == this.lineStart;},
                peek: function() {return this.string.charAt(this.pos) || undefined;},
                next: function() {
                    if (this.pos < this.string.length)
                        return this.string.charAt(this.pos++);
                },
                eat: function(match) {
                    var ch = this.string.charAt(this.pos);
                    if (typeof match == "string") var ok = ch == match;
                    else var ok = ch && (match.test ? match.test(ch) : match(ch));
                    if (ok) {++this.pos; return ch;}
                },
                eatWhile: function(match) {
                    var start = this.pos;
                    while (this.eat(match)){}
                    return this.pos > start;
                },
                eatSpace: function() {
                    var start = this.pos;
                    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
                    return this.pos > start;
                },
                skipToEnd: function() {this.pos = this.string.length;},
                skipTo: function(ch) {
                    var found = this.string.indexOf(ch, this.pos);
                    if (found > -1) {this.pos = found; return true;}
                },
                backUp: function(n) {this.pos -= n;},
                column: function() {
                    if (this.lastColumnPos < this.start) {
                        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
                        this.lastColumnPos = this.start;
                    }
                    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
                },
                indentation: function() {
                    return countColumn(this.string, null, this.tabSize) -
                        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
                },
                match: function(pattern, consume, caseInsensitive) {
                    if (typeof pattern == "string") {
                        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
                        var substr = this.string.substr(this.pos, pattern.length);
                        if (cased(substr) == cased(pattern)) {
                            if (consume !== false) this.pos += pattern.length;
                            return true;
                        }
                    } else {
                        var match = this.string.slice(this.pos).match(pattern);
                        if (match && match.index > 0) return null;
                        if (match && consume !== false) this.pos += match[0].length;
                        return match;
                    }
                },
                current: function(){return this.string.slice(this.start, this.pos);},
                hideFirstChars: function(n, inner) {
                    this.lineStart += n;
                    try { return inner(); }
                    finally { this.lineStart -= n; }
                }
            };

            // TEXTMARKERS

            // Created with markText and setBookmark methods. A TextMarker is a
            // handle that can be used to clear or find a marked position in the
            // document. Line objects hold arrays (markedSpans) containing
            // {from, to, marker} object pointing to such marker objects, and
            // indicating that such a marker is present on that line. Multiple
            // lines may point to the same marker when it spans across lines.
            // The spans will have null for their from/to properties when the
            // marker continues beyond the start/end of the line. Markers have
            // links back to the lines they currently touch.

            var nextMarkerId = 0;

            var TextMarker = CodeMirror.TextMarker = function(doc, type) {
                this.lines = [];
                this.type = type;
                this.doc = doc;
                this.id = ++nextMarkerId;
            };
            eventMixin(TextMarker);

            // Clear the marker.
            TextMarker.prototype.clear = function() {
                if (this.explicitlyCleared) return;
                var cm = this.doc.cm, withOp = cm && !cm.curOp;
                if (withOp) startOperation(cm);
                if (hasHandler(this, "clear")) {
                    var found = this.find();
                    if (found) signalLater(this, "clear", found.from, found.to);
                }
                var min = null, max = null;
                for (var i = 0; i < this.lines.length; ++i) {
                    var line = this.lines[i];
                    var span = getMarkedSpanFor(line.markedSpans, this);
                    if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
                    else if (cm) {
                        if (span.to != null) max = lineNo(line);
                        if (span.from != null) min = lineNo(line);
                    }
                    line.markedSpans = removeMarkedSpan(line.markedSpans, span);
                    if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
                        updateLineHeight(line, textHeight(cm.display));
                }
                if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
                    var visual = visualLine(this.lines[i]), len = lineLength(visual);
                    if (len > cm.display.maxLineLength) {
                        cm.display.maxLine = visual;
                        cm.display.maxLineLength = len;
                        cm.display.maxLineChanged = true;
                    }
                }

                if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
                this.lines.length = 0;
                this.explicitlyCleared = true;
                if (this.atomic && this.doc.cantEdit) {
                    this.doc.cantEdit = false;
                    if (cm) reCheckSelection(cm.doc);
                }
                if (cm) signalLater(cm, "markerCleared", cm, this);
                if (withOp) endOperation(cm);
                if (this.parent) this.parent.clear();
            };

            // Find the position of the marker in the document. Returns a {from,
            // to} object by default. Side can be passed to get a specific side
            // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
            // Pos objects returned contain a line object, rather than a line
            // number (used to prevent looking up the same line twice).
            TextMarker.prototype.find = function(side, lineObj) {
                if (side == null && this.type == "bookmark") side = 1;
                var from, to;
                for (var i = 0; i < this.lines.length; ++i) {
                    var line = this.lines[i];
                    var span = getMarkedSpanFor(line.markedSpans, this);
                    if (span.from != null) {
                        from = Pos(lineObj ? line : lineNo(line), span.from);
                        if (side == -1) return from;
                    }
                    if (span.to != null) {
                        to = Pos(lineObj ? line : lineNo(line), span.to);
                        if (side == 1) return to;
                    }
                }
                return from && {from: from, to: to};
            };

            // Signals that the marker's widget changed, and surrounding layout
            // should be recomputed.
            TextMarker.prototype.changed = function() {
                var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
                if (!pos || !cm) return;
                runInOp(cm, function() {
                    var line = pos.line, lineN = lineNo(pos.line);
                    var view = findViewForLine(cm, lineN);
                    if (view) {
                        clearLineMeasurementCacheFor(view);
                        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
                    }
                    cm.curOp.updateMaxLine = true;
                    if (!lineIsHidden(widget.doc, line) && widget.height != null) {
                        var oldHeight = widget.height;
                        widget.height = null;
                        var dHeight = widgetHeight(widget) - oldHeight;
                        if (dHeight)
                            updateLineHeight(line, line.height + dHeight);
                    }
                });
            };

            TextMarker.prototype.attachLine = function(line) {
                if (!this.lines.length && this.doc.cm) {
                    var op = this.doc.cm.curOp;
                    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
                        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
                }
                this.lines.push(line);
            };
            TextMarker.prototype.detachLine = function(line) {
                this.lines.splice(indexOf(this.lines, line), 1);
                if (!this.lines.length && this.doc.cm) {
                    var op = this.doc.cm.curOp;
                    (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
                }
            };

            // Collapsed markers have unique ids, in order to be able to order
            // them, which is needed for uniquely determining an outer marker
            // when they overlap (they may nest, but not partially overlap).
            var nextMarkerId = 0;

            // Create a marker, wire it up to the right lines, and
            function markText(doc, from, to, options, type) {
                // Shared markers (across linked documents) are handled separately
                // (markTextShared will call out to this again, once per
                // document).
                if (options && options.shared) return markTextShared(doc, from, to, options, type);
                // Ensure we are in an operation.
                if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

                var marker = new TextMarker(doc, type), diff = cmp(from, to);
                if (options) copyObj(options, marker, false);
                // Don't connect empty markers unless clearWhenEmpty is false
                if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
                    return marker;
                if (marker.replacedWith) {
                    // Showing up as a widget implies collapsed (widget replaces text)
                    marker.collapsed = true;
                    marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
                    if (!options.handleMouseEvents) marker.widgetNode.setAttribute("cm-ignore-events", "true");
                    if (options.insertLeft) marker.widgetNode.insertLeft = true;
                }
                if (marker.collapsed) {
                    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
                        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
                        throw new Error("Inserting collapsed marker partially overlapping an existing one");
                    sawCollapsedSpans = true;
                }

                if (marker.addToHistory)
                    addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

                var curLine = from.line, cm = doc.cm, updateMaxLine;
                doc.iter(curLine, to.line + 1, function(line) {
                    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
                        updateMaxLine = true;
                    if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
                    addMarkedSpan(line, new MarkedSpan(marker,
                        curLine == from.line ? from.ch : null,
                        curLine == to.line ? to.ch : null));
                    ++curLine;
                });
                // lineIsHidden depends on the presence of the spans, so needs a second pass
                if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
                    if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
                });

                if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

                if (marker.readOnly) {
                    sawReadOnlySpans = true;
                    if (doc.history.done.length || doc.history.undone.length)
                        doc.clearHistory();
                }
                if (marker.collapsed) {
                    marker.id = ++nextMarkerId;
                    marker.atomic = true;
                }
                if (cm) {
                    // Sync editor state
                    if (updateMaxLine) cm.curOp.updateMaxLine = true;
                    if (marker.collapsed)
                        regChange(cm, from.line, to.line + 1);
                    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
                        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
                    if (marker.atomic) reCheckSelection(cm.doc);
                    signalLater(cm, "markerAdded", cm, marker);
                }
                return marker;
            }

            // SHARED TEXTMARKERS

            // A shared marker spans multiple linked documents. It is
            // implemented as a meta-marker-object controlling multiple normal
            // markers.
            var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
                this.markers = markers;
                this.primary = primary;
                for (var i = 0; i < markers.length; ++i)
                    markers[i].parent = this;
            };
            eventMixin(SharedTextMarker);

            SharedTextMarker.prototype.clear = function() {
                if (this.explicitlyCleared) return;
                this.explicitlyCleared = true;
                for (var i = 0; i < this.markers.length; ++i)
                    this.markers[i].clear();
                signalLater(this, "clear");
            };
            SharedTextMarker.prototype.find = function(side, lineObj) {
                return this.primary.find(side, lineObj);
            };

            function markTextShared(doc, from, to, options, type) {
                options = copyObj(options);
                options.shared = false;
                var markers = [markText(doc, from, to, options, type)], primary = markers[0];
                var widget = options.widgetNode;
                linkedDocs(doc, function(doc) {
                    if (widget) options.widgetNode = widget.cloneNode(true);
                    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
                    for (var i = 0; i < doc.linked.length; ++i)
                        if (doc.linked[i].isParent) return;
                    primary = lst(markers);
                });
                return new SharedTextMarker(markers, primary);
            }

            function findSharedMarkers(doc) {
                return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
                    function(m) { return m.parent; });
            }

            function copySharedMarkers(doc, markers) {
                for (var i = 0; i < markers.length; i++) {
                    var marker = markers[i], pos = marker.find();
                    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
                    if (cmp(mFrom, mTo)) {
                        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
                        marker.markers.push(subMark);
                        subMark.parent = marker;
                    }
                }
            }

            function detachSharedMarkers(markers) {
                for (var i = 0; i < markers.length; i++) {
                    var marker = markers[i], linked = [marker.primary.doc];;
                    linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
                    for (var j = 0; j < marker.markers.length; j++) {
                        var subMarker = marker.markers[j];
                        if (indexOf(linked, subMarker.doc) == -1) {
                            subMarker.parent = null;
                            marker.markers.splice(j--, 1);
                        }
                    }
                }
            }

            // TEXTMARKER SPANS

            function MarkedSpan(marker, from, to) {
                this.marker = marker;
                this.from = from; this.to = to;
            }

            // Search an array of spans for a span matching the given marker.
            function getMarkedSpanFor(spans, marker) {
                if (spans) for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    if (span.marker == marker) return span;
                }
            }
            // Remove a span from an array, returning undefined if no spans are
            // left (we don't store arrays for lines without spans).
            function removeMarkedSpan(spans, span) {
                for (var r, i = 0; i < spans.length; ++i)
                    if (spans[i] != span) (r || (r = [])).push(spans[i]);
                return r;
            }
            // Add a span to a line.
            function addMarkedSpan(line, span) {
                line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
                span.marker.attachLine(line);
            }

            // Used for the algorithm that adjusts markers for a change in the
            // document. These functions cut an array of spans at a given
            // character position, returning an array of remaining chunks (or
            // undefined if nothing remains).
            function markedSpansBefore(old, startCh, isInsert) {
                if (old) for (var i = 0, nw; i < old.length; ++i) {
                    var span = old[i], marker = span.marker;
                    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
                    if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
                        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
                    }
                }
                return nw;
            }
            function markedSpansAfter(old, endCh, isInsert) {
                if (old) for (var i = 0, nw; i < old.length; ++i) {
                    var span = old[i], marker = span.marker;
                    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
                    if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
                        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                            span.to == null ? null : span.to - endCh));
                    }
                }
                return nw;
            }

            // Given a change object, compute the new set of marker spans that
            // cover the line in which the change took place. Removes spans
            // entirely within the change, reconnects spans belonging to the
            // same marker that appear on both sides of the change, and cuts off
            // spans partially within the change. Returns an array of span
            // arrays with one element for each line in (after) the change.
            function stretchSpansOverChange(doc, change) {
                if (change.full) return null;
                var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
                var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
                if (!oldFirst && !oldLast) return null;

                var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
                // Get the spans that 'stick out' on both sides
                var first = markedSpansBefore(oldFirst, startCh, isInsert);
                var last = markedSpansAfter(oldLast, endCh, isInsert);

                // Next, merge those two ends
                var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
                if (first) {
                    // Fix up .to properties of first
                    for (var i = 0; i < first.length; ++i) {
                        var span = first[i];
                        if (span.to == null) {
                            var found = getMarkedSpanFor(last, span.marker);
                            if (!found) span.to = startCh;
                            else if (sameLine) span.to = found.to == null ? null : found.to + offset;
                        }
                    }
                }
                if (last) {
                    // Fix up .from in last (or move them into first in case of sameLine)
                    for (var i = 0; i < last.length; ++i) {
                        var span = last[i];
                        if (span.to != null) span.to += offset;
                        if (span.from == null) {
                            var found = getMarkedSpanFor(first, span.marker);
                            if (!found) {
                                span.from = offset;
                                if (sameLine) (first || (first = [])).push(span);
                            }
                        } else {
                            span.from += offset;
                            if (sameLine) (first || (first = [])).push(span);
                        }
                    }
                }
                // Make sure we didn't create any zero-length spans
                if (first) first = clearEmptySpans(first);
                if (last && last != first) last = clearEmptySpans(last);

                var newMarkers = [first];
                if (!sameLine) {
                    // Fill gap with whole-line-spans
                    var gap = change.text.length - 2, gapMarkers;
                    if (gap > 0 && first)
                        for (var i = 0; i < first.length; ++i)
                            if (first[i].to == null)
                                (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
                    for (var i = 0; i < gap; ++i)
                        newMarkers.push(gapMarkers);
                    newMarkers.push(last);
                }
                return newMarkers;
            }

            // Remove spans that are empty and don't have a clearWhenEmpty
            // option of false.
            function clearEmptySpans(spans) {
                for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
                        spans.splice(i--, 1);
                }
                if (!spans.length) return null;
                return spans;
            }

            // Used for un/re-doing changes from the history. Combines the
            // result of computing the existing spans with the set of spans that
            // existed in the history (so that deleting around a span and then
            // undoing brings back the span).
            function mergeOldSpans(doc, change) {
                var old = getOldSpans(doc, change);
                var stretched = stretchSpansOverChange(doc, change);
                if (!old) return stretched;
                if (!stretched) return old;

                for (var i = 0; i < old.length; ++i) {
                    var oldCur = old[i], stretchCur = stretched[i];
                    if (oldCur && stretchCur) {
                        spans: for (var j = 0; j < stretchCur.length; ++j) {
                            var span = stretchCur[j];
                            for (var k = 0; k < oldCur.length; ++k)
                                if (oldCur[k].marker == span.marker) continue spans;
                            oldCur.push(span);
                        }
                    } else if (stretchCur) {
                        old[i] = stretchCur;
                    }
                }
                return old;
            }

            // Used to 'clip' out readOnly ranges when making a change.
            function removeReadOnlyRanges(doc, from, to) {
                var markers = null;
                doc.iter(from.line, to.line + 1, function(line) {
                    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
                        var mark = line.markedSpans[i].marker;
                        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
                            (markers || (markers = [])).push(mark);
                    }
                });
                if (!markers) return null;
                var parts = [{from: from, to: to}];
                for (var i = 0; i < markers.length; ++i) {
                    var mk = markers[i], m = mk.find(0);
                    for (var j = 0; j < parts.length; ++j) {
                        var p = parts[j];
                        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
                        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
                        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
                            newParts.push({from: p.from, to: m.from});
                        if (dto > 0 || !mk.inclusiveRight && !dto)
                            newParts.push({from: m.to, to: p.to});
                        parts.splice.apply(parts, newParts);
                        j += newParts.length - 1;
                    }
                }
                return parts;
            }

            // Connect or disconnect spans from a line.
            function detachMarkedSpans(line) {
                var spans = line.markedSpans;
                if (!spans) return;
                for (var i = 0; i < spans.length; ++i)
                    spans[i].marker.detachLine(line);
                line.markedSpans = null;
            }
            function attachMarkedSpans(line, spans) {
                if (!spans) return;
                for (var i = 0; i < spans.length; ++i)
                    spans[i].marker.attachLine(line);
                line.markedSpans = spans;
            }

            // Helpers used when computing which overlapping collapsed span
            // counts as the larger one.
            function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
            function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

            // Returns a number indicating which of two overlapping collapsed
            // spans is larger (and thus includes the other). Falls back to
            // comparing ids when the spans cover exactly the same range.
            function compareCollapsedMarkers(a, b) {
                var lenDiff = a.lines.length - b.lines.length;
                if (lenDiff != 0) return lenDiff;
                var aPos = a.find(), bPos = b.find();
                var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
                if (fromCmp) return -fromCmp;
                var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
                if (toCmp) return toCmp;
                return b.id - a.id;
            }

            // Find out whether a line ends or starts in a collapsed span. If
            // so, return the marker for that span.
            function collapsedSpanAtSide(line, start) {
                var sps = sawCollapsedSpans && line.markedSpans, found;
                if (sps) for (var sp, i = 0; i < sps.length; ++i) {
                    sp = sps[i];
                    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
                        (!found || compareCollapsedMarkers(found, sp.marker) < 0))
                        found = sp.marker;
                }
                return found;
            }
            function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
            function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

            // Test whether there exists a collapsed span that partially
            // overlaps (covers the start or end, but not both) of a new span.
            // Such overlap is not allowed.
            function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
                var line = getLine(doc, lineNo);
                var sps = sawCollapsedSpans && line.markedSpans;
                if (sps) for (var i = 0; i < sps.length; ++i) {
                    var sp = sps[i];
                    if (!sp.marker.collapsed) continue;
                    var found = sp.marker.find(0);
                    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
                    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
                    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
                    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
                        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
                        return true;
                }
            }

            // A visual line is a line as drawn on the screen. Folding, for
            // example, can cause multiple logical lines to appear on the same
            // visual line. This finds the start of the visual line that the
            // given line is part of (usually that is the line itself).
            function visualLine(line) {
                var merged;
                while (merged = collapsedSpanAtStart(line))
                    line = merged.find(-1, true).line;
                return line;
            }

            // Returns an array of logical lines that continue the visual line
            // started by the argument, or undefined if there are no such lines.
            function visualLineContinued(line) {
                var merged, lines;
                while (merged = collapsedSpanAtEnd(line)) {
                    line = merged.find(1, true).line;
                    (lines || (lines = [])).push(line);
                }
                return lines;
            }

            // Get the line number of the start of the visual line that the
            // given line number is part of.
            function visualLineNo(doc, lineN) {
                var line = getLine(doc, lineN), vis = visualLine(line);
                if (line == vis) return lineN;
                return lineNo(vis);
            }
            // Get the line number of the start of the next visual line after
            // the given line.
            function visualLineEndNo(doc, lineN) {
                if (lineN > doc.lastLine()) return lineN;
                var line = getLine(doc, lineN), merged;
                if (!lineIsHidden(doc, line)) return lineN;
                while (merged = collapsedSpanAtEnd(line))
                    line = merged.find(1, true).line;
                return lineNo(line) + 1;
            }

            // Compute whether a line is hidden. Lines count as hidden when they
            // are part of a visual line that starts with another line, or when
            // they are entirely covered by collapsed, non-widget span.
            function lineIsHidden(doc, line) {
                var sps = sawCollapsedSpans && line.markedSpans;
                if (sps) for (var sp, i = 0; i < sps.length; ++i) {
                    sp = sps[i];
                    if (!sp.marker.collapsed) continue;
                    if (sp.from == null) return true;
                    if (sp.marker.widgetNode) continue;
                    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
                        return true;
                }
            }
            function lineIsHiddenInner(doc, line, span) {
                if (span.to == null) {
                    var end = span.marker.find(1, true);
                    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
                }
                if (span.marker.inclusiveRight && span.to == line.text.length)
                    return true;
                for (var sp, i = 0; i < line.markedSpans.length; ++i) {
                    sp = line.markedSpans[i];
                    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
                        (sp.to == null || sp.to != span.from) &&
                        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
                        lineIsHiddenInner(doc, line, sp)) return true;
                }
            }

            // LINE WIDGETS

            // Line widgets are block elements displayed above or below a line.

            var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {
                if (options) for (var opt in options) if (options.hasOwnProperty(opt))
                    this[opt] = options[opt];
                this.doc = doc;
                this.node = node;
            };
            eventMixin(LineWidget);

            function adjustScrollWhenAboveVisible(cm, line, diff) {
                if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
                    addToScrollPos(cm, null, diff);
            }

            LineWidget.prototype.clear = function() {
                var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
                if (no == null || !ws) return;
                for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
                if (!ws.length) line.widgets = null;
                var height = widgetHeight(this);
                updateLineHeight(line, Math.max(0, line.height - height));
                if (cm) runInOp(cm, function() {
                    adjustScrollWhenAboveVisible(cm, line, -height);
                    regLineChange(cm, no, "widget");
                });
            };
            LineWidget.prototype.changed = function() {
                var oldH = this.height, cm = this.doc.cm, line = this.line;
                this.height = null;
                var diff = widgetHeight(this) - oldH;
                if (!diff) return;
                updateLineHeight(line, line.height + diff);
                if (cm) runInOp(cm, function() {
                    cm.curOp.forceUpdate = true;
                    adjustScrollWhenAboveVisible(cm, line, diff);
                });
            };

            function widgetHeight(widget) {
                if (widget.height != null) return widget.height;
                var cm = widget.doc.cm;
                if (!cm) return 0;
                if (!contains(document.body, widget.node)) {
                    var parentStyle = "position: relative;";
                    if (widget.coverGutter)
                        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
                    if (widget.noHScroll)
                        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
                    removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
                }
                return widget.height = widget.node.parentNode.offsetHeight;
            }

            function addLineWidget(doc, handle, node, options) {
                var widget = new LineWidget(doc, node, options);
                var cm = doc.cm;
                if (cm && widget.noHScroll) cm.display.alignWidgets = true;
                changeLine(doc, handle, "widget", function(line) {
                    var widgets = line.widgets || (line.widgets = []);
                    if (widget.insertAt == null) widgets.push(widget);
                    else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
                    widget.line = line;
                    if (cm && !lineIsHidden(doc, line)) {
                        var aboveVisible = heightAtLine(line) < doc.scrollTop;
                        updateLineHeight(line, line.height + widgetHeight(widget));
                        if (aboveVisible) addToScrollPos(cm, null, widget.height);
                        cm.curOp.forceUpdate = true;
                    }
                    return true;
                });
                return widget;
            }

            // LINE DATA STRUCTURE

            // Line objects. These hold state related to a line, including
            // highlighting info (the styles array).
            var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
                this.text = text;
                attachMarkedSpans(this, markedSpans);
                this.height = estimateHeight ? estimateHeight(this) : 1;
            };
            eventMixin(Line);
            Line.prototype.lineNo = function() { return lineNo(this); };

            // Change the content (text, markers) of a line. Automatically
            // invalidates cached information and tries to re-estimate the
            // line's height.
            function updateLine(line, text, markedSpans, estimateHeight) {
                line.text = text;
                if (line.stateAfter) line.stateAfter = null;
                if (line.styles) line.styles = null;
                if (line.order != null) line.order = null;
                detachMarkedSpans(line);
                attachMarkedSpans(line, markedSpans);
                var estHeight = estimateHeight ? estimateHeight(line) : 1;
                if (estHeight != line.height) updateLineHeight(line, estHeight);
            }

            // Detach a line from the document tree and its markers.
            function cleanUpLine(line) {
                line.parent = null;
                detachMarkedSpans(line);
            }

            function extractLineClasses(type, output) {
                if (type) for (;;) {
                    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
                    if (!lineClass) break;
                    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
                    var prop = lineClass[1] ? "bgClass" : "textClass";
                    if (output[prop] == null)
                        output[prop] = lineClass[2];
                    else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
                        output[prop] += " " + lineClass[2];
                }
                return type;
            }

            function callBlankLine(mode, state) {
                if (mode.blankLine) return mode.blankLine(state);
                if (!mode.innerMode) return;
                var inner = CodeMirror.innerMode(mode, state);
                if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
            }

            function readToken(mode, stream, state, inner) {
                for (var i = 0; i < 10; i++) {
                    if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;
                    var style = mode.token(stream, state);
                    if (stream.pos > stream.start) return style;
                }
                throw new Error("Mode " + mode.name + " failed to advance stream.");
            }

            // Utility for getTokenAt and getLineTokens
            function takeToken(cm, pos, precise, asArray) {
                function getObj(copy) {
                    return {start: stream.start, end: stream.pos,
                        string: stream.current(),
                        type: style || null,
                        state: copy ? copyState(doc.mode, state) : state};
                }

                var doc = cm.doc, mode = doc.mode, style;
                pos = clipPos(doc, pos);
                var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
                var stream = new StringStream(line.text, cm.options.tabSize), tokens;
                if (asArray) tokens = [];
                while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
                    stream.start = stream.pos;
                    style = readToken(mode, stream, state);
                    if (asArray) tokens.push(getObj(true));
                }
                return asArray ? tokens : getObj();
            }

            // Run the given mode's parser over a line, calling f for each token.
            function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
                var flattenSpans = mode.flattenSpans;
                if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
                var curStart = 0, curStyle = null;
                var stream = new StringStream(text, cm.options.tabSize), style;
                var inner = cm.options.addModeClass && [null];
                if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
                while (!stream.eol()) {
                    if (stream.pos > cm.options.maxHighlightLength) {
                        flattenSpans = false;
                        if (forceToEnd) processLine(cm, text, state, stream.pos);
                        stream.pos = text.length;
                        style = null;
                    } else {
                        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
                    }
                    if (inner) {
                        var mName = inner[0].name;
                        if (mName) style = "m-" + (style ? mName + " " + style : mName);
                    }
                    if (!flattenSpans || curStyle != style) {
                        while (curStart < stream.start) {
                            curStart = Math.min(stream.start, curStart + 50000);
                            f(curStart, curStyle);
                        }
                        curStyle = style;
                    }
                    stream.start = stream.pos;
                }
                while (curStart < stream.pos) {
                    // Webkit seems to refuse to render text nodes longer than 57444 characters
                    var pos = Math.min(stream.pos, curStart + 50000);
                    f(pos, curStyle);
                    curStart = pos;
                }
            }

            // Compute a style array (an array starting with a mode generation
            // -- for invalidation -- followed by pairs of end positions and
            // style strings), which is used to highlight the tokens on the
            // line.
            function highlightLine(cm, line, state, forceToEnd) {
                // A styles array always starts with a number identifying the
                // mode/overlays that it is based on (for easy invalidation).
                var st = [cm.state.modeGen], lineClasses = {};
                // Compute the base array of styles
                runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
                    st.push(end, style);
                }, lineClasses, forceToEnd);

                // Run overlays, adjust style array.
                for (var o = 0; o < cm.state.overlays.length; ++o) {
                    var overlay = cm.state.overlays[o], i = 1, at = 0;
                    runMode(cm, line.text, overlay.mode, true, function(end, style) {
                        var start = i;
                        // Ensure there's a token end at the current position, and that i points at it
                        while (at < end) {
                            var i_end = st[i];
                            if (i_end > end)
                                st.splice(i, 1, end, st[i+1], i_end);
                            i += 2;
                            at = Math.min(end, i_end);
                        }
                        if (!style) return;
                        if (overlay.opaque) {
                            st.splice(start, i - start, end, "cm-overlay " + style);
                            i = start + 2;
                        } else {
                            for (; start < i; start += 2) {
                                var cur = st[start+1];
                                st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
                            }
                        }
                    }, lineClasses);
                }

                return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
            }

            function getLineStyles(cm, line, updateFrontier) {
                if (!line.styles || line.styles[0] != cm.state.modeGen) {
                    var state = getStateBefore(cm, lineNo(line));
                    var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
                    line.stateAfter = state;
                    line.styles = result.styles;
                    if (result.classes) line.styleClasses = result.classes;
                    else if (line.styleClasses) line.styleClasses = null;
                    if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;
                }
                return line.styles;
            }

            // Lightweight form of highlight -- proceed over this line and
            // update state, but don't save a style array. Used for lines that
            // aren't currently visible.
            function processLine(cm, text, state, startAt) {
                var mode = cm.doc.mode;
                var stream = new StringStream(text, cm.options.tabSize);
                stream.start = stream.pos = startAt || 0;
                if (text == "") callBlankLine(mode, state);
                while (!stream.eol()) {
                    readToken(mode, stream, state);
                    stream.start = stream.pos;
                }
            }

            // Convert a style as returned by a mode (either null, or a string
            // containing one or more styles) to a CSS style. This is cached,
            // and also looks for line-wide styles.
            var styleToClassCache = {}, styleToClassCacheWithMode = {};
            function interpretTokenStyle(style, options) {
                if (!style || /^\s*$/.test(style)) return null;
                var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
                return cache[style] ||
                    (cache[style] = style.replace(/\S+/g, "cm-$&"));
            }

            // Render the DOM representation of the text of a line. Also builds
            // up a 'line map', which points at the DOM nodes that represent
            // specific stretches of text, and is used by the measuring code.
            // The returned object contains the DOM node, this map, and
            // information about line-wide styles that were set by the mode.
            function buildLineContent(cm, lineView) {
                // The padding-right forces the element to have a 'border', which
                // is needed on Webkit to be able to get line-level bounding
                // rectangles for it (in measureChar).
                var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
                var builder = {pre: elt("pre", [content], "CodeMirror-line"), content: content,
                    col: 0, pos: 0, cm: cm,
                    splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
                lineView.measure = {};

                // Iterate over the logical lines that make up this visual line.
                for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
                    var line = i ? lineView.rest[i - 1] : lineView.line, order;
                    builder.pos = 0;
                    builder.addToken = buildToken;
                    // Optionally wire in some hacks into the token-rendering
                    // algorithm, to deal with browser quirks.
                    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
                        builder.addToken = buildTokenBadBidi(builder.addToken, order);
                    builder.map = [];
                    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
                    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
                    if (line.styleClasses) {
                        if (line.styleClasses.bgClass)
                            builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
                        if (line.styleClasses.textClass)
                            builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
                    }

                    // Ensure at least a single node is present, for measuring.
                    if (builder.map.length == 0)
                        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

                    // Store the map and a cache object for the current logical line
                    if (i == 0) {
                        lineView.measure.map = builder.map;
                        lineView.measure.cache = {};
                    } else {
                        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
                        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
                    }
                }

                // See issue #2901
                if (webkit) {
                    var last = builder.content.lastChild
                    if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
                        builder.content.className = "cm-tab-wrap-hack";
                }

                signal(cm, "renderLine", cm, lineView.line, builder.pre);
                if (builder.pre.className)
                    builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");

                return builder;
            }

            function defaultSpecialCharPlaceholder(ch) {
                var token = elt("span", "\u2022", "cm-invalidchar");
                token.title = "\\u" + ch.charCodeAt(0).toString(16);
                token.setAttribute("aria-label", token.title);
                return token;
            }

            // Build up the DOM representation for a single token, and add it to
            // the line map. Takes care to render special characters separately.
            function buildToken(builder, text, style, startStyle, endStyle, title, css) {
                if (!text) return;
                var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;
                var special = builder.cm.state.specialChars, mustWrap = false;
                if (!special.test(text)) {
                    builder.col += text.length;
                    var content = document.createTextNode(displayText);
                    builder.map.push(builder.pos, builder.pos + text.length, content);
                    if (ie && ie_version < 9) mustWrap = true;
                    builder.pos += text.length;
                } else {
                    var content = document.createDocumentFragment(), pos = 0;
                    while (true) {
                        special.lastIndex = pos;
                        var m = special.exec(text);
                        var skipped = m ? m.index - pos : text.length - pos;
                        if (skipped) {
                            var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
                            if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
                            else content.appendChild(txt);
                            builder.map.push(builder.pos, builder.pos + skipped, txt);
                            builder.col += skipped;
                            builder.pos += skipped;
                        }
                        if (!m) break;
                        pos += skipped + 1;
                        if (m[0] == "\t") {
                            var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                            var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
                            txt.setAttribute("role", "presentation");
                            txt.setAttribute("cm-text", "\t");
                            builder.col += tabWidth;
                        } else if (m[0] == "\r" || m[0] == "\n") {
                            var txt = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
                            txt.setAttribute("cm-text", m[0]);
                            builder.col += 1;
                        } else {
                            var txt = builder.cm.options.specialCharPlaceholder(m[0]);
                            txt.setAttribute("cm-text", m[0]);
                            if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
                            else content.appendChild(txt);
                            builder.col += 1;
                        }
                        builder.map.push(builder.pos, builder.pos + 1, txt);
                        builder.pos++;
                    }
                }
                if (style || startStyle || endStyle || mustWrap || css) {
                    var fullStyle = style || "";
                    if (startStyle) fullStyle += startStyle;
                    if (endStyle) fullStyle += endStyle;
                    var token = elt("span", [content], fullStyle, css);
                    if (title) token.title = title;
                    return builder.content.appendChild(token);
                }
                builder.content.appendChild(content);
            }

            function splitSpaces(old) {
                var out = " ";
                for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
                out += " ";
                return out;
            }

            // Work around nonsense dimensions being reported for stretches of
            // right-to-left text.
            function buildTokenBadBidi(inner, order) {
                return function(builder, text, style, startStyle, endStyle, title, css) {
                    style = style ? style + " cm-force-border" : "cm-force-border";
                    var start = builder.pos, end = start + text.length;
                    for (;;) {
                        // Find the part that overlaps with the start of this text
                        for (var i = 0; i < order.length; i++) {
                            var part = order[i];
                            if (part.to > start && part.from <= start) break;
                        }
                        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
                        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
                        startStyle = null;
                        text = text.slice(part.to - start);
                        start = part.to;
                    }
                };
            }

            function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
                var widget = !ignoreWidget && marker.widgetNode;
                if (widget) builder.map.push(builder.pos, builder.pos + size, widget);
                if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
                    if (!widget)
                        widget = builder.content.appendChild(document.createElement("span"));
                    widget.setAttribute("cm-marker", marker.id);
                }
                if (widget) {
                    builder.cm.display.input.setUneditable(widget);
                    builder.content.appendChild(widget);
                }
                builder.pos += size;
            }

            // Outputs a number of spans to make up a line, taking highlighting
            // and marked text into account.
            function insertLineContent(line, builder, styles) {
                var spans = line.markedSpans, allText = line.text, at = 0;
                if (!spans) {
                    for (var i = 1; i < styles.length; i+=2)
                        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
                    return;
                }

                var len = allText.length, pos = 0, i = 1, text = "", style, css;
                var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
                for (;;) {
                    if (nextChange == pos) { // Update current marker set
                        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
                        collapsed = null; nextChange = Infinity;
                        var foundBookmarks = [], endStyles
                        for (var j = 0; j < spans.length; ++j) {
                            var sp = spans[j], m = sp.marker;
                            if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
                                foundBookmarks.push(m);
                            } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
                                if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                                    nextChange = sp.to;
                                    spanEndStyle = "";
                                }
                                if (m.className) spanStyle += " " + m.className;
                                if (m.css) css = (css ? css + ";" : "") + m.css;
                                if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
                                if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)
                                if (m.title && !title) title = m.title;
                                if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
                                    collapsed = sp;
                            } else if (sp.from > pos && nextChange > sp.from) {
                                nextChange = sp.from;
                            }
                        }
                        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)
                            if (endStyles[j + 1] == nextChange) spanEndStyle += " " + endStyles[j]

                        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)
                            buildCollapsedSpan(builder, 0, foundBookmarks[j]);
                        if (collapsed && (collapsed.from || 0) == pos) {
                            buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                                collapsed.marker, collapsed.from == null);
                            if (collapsed.to == null) return;
                            if (collapsed.to == pos) collapsed = false;
                        }
                    }
                    if (pos >= len) break;

                    var upto = Math.min(len, nextChange);
                    while (true) {
                        if (text) {
                            var end = pos + text.length;
                            if (!collapsed) {
                                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                                builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                                    spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
                            }
                            if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
                            pos = end;
                            spanStartStyle = "";
                        }
                        text = allText.slice(at, at = styles[i++]);
                        style = interpretTokenStyle(styles[i++], builder.cm.options);
                    }
                }
            }

            // DOCUMENT DATA STRUCTURE

            // By default, updates that start and end at the beginning of a line
            // are treated specially, in order to make the association of line
            // widgets and marker elements with the text behave more intuitive.
            function isWholeLineUpdate(doc, change) {
                return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
                    (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
            }

            // Perform a change on the document data structure.
            function updateDoc(doc, change, markedSpans, estimateHeight) {
                function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
                function update(line, text, spans) {
                    updateLine(line, text, spans, estimateHeight);
                    signalLater(line, "change", line, change);
                }
                function linesFor(start, end) {
                    for (var i = start, result = []; i < end; ++i)
                        result.push(new Line(text[i], spansFor(i), estimateHeight));
                    return result;
                }

                var from = change.from, to = change.to, text = change.text;
                var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
                var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

                // Adjust the line structure
                if (change.full) {
                    doc.insert(0, linesFor(0, text.length));
                    doc.remove(text.length, doc.size - text.length);
                } else if (isWholeLineUpdate(doc, change)) {
                    // This is a whole-line replace. Treated specially to make
                    // sure line objects move the way they are supposed to.
                    var added = linesFor(0, text.length - 1);
                    update(lastLine, lastLine.text, lastSpans);
                    if (nlines) doc.remove(from.line, nlines);
                    if (added.length) doc.insert(from.line, added);
                } else if (firstLine == lastLine) {
                    if (text.length == 1) {
                        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
                    } else {
                        var added = linesFor(1, text.length - 1);
                        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
                        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
                        doc.insert(from.line + 1, added);
                    }
                } else if (text.length == 1) {
                    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
                    doc.remove(from.line + 1, nlines);
                } else {
                    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
                    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
                    var added = linesFor(1, text.length - 1);
                    if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
                    doc.insert(from.line + 1, added);
                }

                signalLater(doc, "change", doc, change);
            }

            // The document is represented as a BTree consisting of leaves, with
            // chunk of lines in them, and branches, with up to ten leaves or
            // other branch nodes below them. The top node is always a branch
            // node, and is the document object itself (meaning it has
            // additional methods and properties).
            //
            // All nodes have parent links. The tree is used both to go from
            // line numbers to line objects, and to go from objects to numbers.
            // It also indexes by height, and is used to convert between height
            // and line object, and to find the total height of the document.
            //
            // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

            function LeafChunk(lines) {
                this.lines = lines;
                this.parent = null;
                for (var i = 0, height = 0; i < lines.length; ++i) {
                    lines[i].parent = this;
                    height += lines[i].height;
                }
                this.height = height;
            }

            LeafChunk.prototype = {
                chunkSize: function() { return this.lines.length; },
                // Remove the n lines at offset 'at'.
                removeInner: function(at, n) {
                    for (var i = at, e = at + n; i < e; ++i) {
                        var line = this.lines[i];
                        this.height -= line.height;
                        cleanUpLine(line);
                        signalLater(line, "delete");
                    }
                    this.lines.splice(at, n);
                },
                // Helper used to collapse a small branch into a single leaf.
                collapse: function(lines) {
                    lines.push.apply(lines, this.lines);
                },
                // Insert the given array of lines at offset 'at', count them as
                // having the given height.
                insertInner: function(at, lines, height) {
                    this.height += height;
                    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
                    for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
                },
                // Used to iterate over a part of the tree.
                iterN: function(at, n, op) {
                    for (var e = at + n; at < e; ++at)
                        if (op(this.lines[at])) return true;
                }
            };

            function BranchChunk(children) {
                this.children = children;
                var size = 0, height = 0;
                for (var i = 0; i < children.length; ++i) {
                    var ch = children[i];
                    size += ch.chunkSize(); height += ch.height;
                    ch.parent = this;
                }
                this.size = size;
                this.height = height;
                this.parent = null;
            }

            BranchChunk.prototype = {
                chunkSize: function() { return this.size; },
                removeInner: function(at, n) {
                    this.size -= n;
                    for (var i = 0; i < this.children.length; ++i) {
                        var child = this.children[i], sz = child.chunkSize();
                        if (at < sz) {
                            var rm = Math.min(n, sz - at), oldHeight = child.height;
                            child.removeInner(at, rm);
                            this.height -= oldHeight - child.height;
                            if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
                            if ((n -= rm) == 0) break;
                            at = 0;
                        } else at -= sz;
                    }
                    // If the result is smaller than 25 lines, ensure that it is a
                    // single leaf node.
                    if (this.size - n < 25 &&
                        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
                        var lines = [];
                        this.collapse(lines);
                        this.children = [new LeafChunk(lines)];
                        this.children[0].parent = this;
                    }
                },
                collapse: function(lines) {
                    for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
                },
                insertInner: function(at, lines, height) {
                    this.size += lines.length;
                    this.height += height;
                    for (var i = 0; i < this.children.length; ++i) {
                        var child = this.children[i], sz = child.chunkSize();
                        if (at <= sz) {
                            child.insertInner(at, lines, height);
                            if (child.lines && child.lines.length > 50) {
                                // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
                                // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
                                var remaining = child.lines.length % 25 + 25
                                for (var pos = remaining; pos < child.lines.length;) {
                                    var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                                    child.height -= leaf.height;
                                    this.children.splice(++i, 0, leaf);
                                    leaf.parent = this;
                                }
                                child.lines = child.lines.slice(0, remaining);
                                this.maybeSpill();
                            }
                            break;
                        }
                        at -= sz;
                    }
                },
                // When a node has grown, check whether it should be split.
                maybeSpill: function() {
                    if (this.children.length <= 10) return;
                    var me = this;
                    do {
                        var spilled = me.children.splice(me.children.length - 5, 5);
                        var sibling = new BranchChunk(spilled);
                        if (!me.parent) { // Become the parent node
                            var copy = new BranchChunk(me.children);
                            copy.parent = me;
                            me.children = [copy, sibling];
                            me = copy;
                        } else {
                            me.size -= sibling.size;
                            me.height -= sibling.height;
                            var myIndex = indexOf(me.parent.children, me);
                            me.parent.children.splice(myIndex + 1, 0, sibling);
                        }
                        sibling.parent = me.parent;
                    } while (me.children.length > 10);
                    me.parent.maybeSpill();
                },
                iterN: function(at, n, op) {
                    for (var i = 0; i < this.children.length; ++i) {
                        var child = this.children[i], sz = child.chunkSize();
                        if (at < sz) {
                            var used = Math.min(n, sz - at);
                            if (child.iterN(at, used, op)) return true;
                            if ((n -= used) == 0) break;
                            at = 0;
                        } else at -= sz;
                    }
                }
            };

            var nextDocId = 0;
            var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {
                if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);
                if (firstLine == null) firstLine = 0;

                BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
                this.first = firstLine;
                this.scrollTop = this.scrollLeft = 0;
                this.cantEdit = false;
                this.cleanGeneration = 1;
                this.frontier = firstLine;
                var start = Pos(firstLine, 0);
                this.sel = simpleSelection(start);
                this.history = new History(null);
                this.id = ++nextDocId;
                this.modeOption = mode;
                this.lineSep = lineSep;
                this.extend = false;

                if (typeof text == "string") text = this.splitLines(text);
                updateDoc(this, {from: start, to: start, text: text});
                setSelection(this, simpleSelection(start), sel_dontScroll);
            };

            Doc.prototype = createObj(BranchChunk.prototype, {
                constructor: Doc,
                // Iterate over the document. Supports two forms -- with only one
                // argument, it calls that for each line in the document. With
                // three, it iterates over the range given by the first two (with
                // the second being non-inclusive).
                iter: function(from, to, op) {
                    if (op) this.iterN(from - this.first, to - from, op);
                    else this.iterN(this.first, this.first + this.size, from);
                },

                // Non-public interface for adding and removing lines.
                insert: function(at, lines) {
                    var height = 0;
                    for (var i = 0; i < lines.length; ++i) height += lines[i].height;
                    this.insertInner(at - this.first, lines, height);
                },
                remove: function(at, n) { this.removeInner(at - this.first, n); },

                // From here, the methods are part of the public interface. Most
                // are also available from CodeMirror (editor) instances.

                getValue: function(lineSep) {
                    var lines = getLines(this, this.first, this.first + this.size);
                    if (lineSep === false) return lines;
                    return lines.join(lineSep || this.lineSeparator());
                },
                setValue: docMethodOp(function(code) {
                    var top = Pos(this.first, 0), last = this.first + this.size - 1;
                    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
                    setSelection(this, simpleSelection(top));
                }),
                replaceRange: function(code, from, to, origin) {
                    from = clipPos(this, from);
                    to = to ? clipPos(this, to) : from;
                    replaceRange(this, code, from, to, origin);
                },
                getRange: function(from, to, lineSep) {
                    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
                    if (lineSep === false) return lines;
                    return lines.join(lineSep || this.lineSeparator());
                },

                getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

                getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
                getLineNumber: function(line) {return lineNo(line);},

                getLineHandleVisualStart: function(line) {
                    if (typeof line == "number") line = getLine(this, line);
                    return visualLine(line);
                },

                lineCount: function() {return this.size;},
                firstLine: function() {return this.first;},
                lastLine: function() {return this.first + this.size - 1;},

                clipPos: function(pos) {return clipPos(this, pos);},

                getCursor: function(start) {
                    var range = this.sel.primary(), pos;
                    if (start == null || start == "head") pos = range.head;
                    else if (start == "anchor") pos = range.anchor;
                    else if (start == "end" || start == "to" || start === false) pos = range.to();
                    else pos = range.from();
                    return pos;
                },
                listSelections: function() { return this.sel.ranges; },
                somethingSelected: function() {return this.sel.somethingSelected();},

                setCursor: docMethodOp(function(line, ch, options) {
                    setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
                }),
                setSelection: docMethodOp(function(anchor, head, options) {
                    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
                }),
                extendSelection: docMethodOp(function(head, other, options) {
                    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
                }),
                extendSelections: docMethodOp(function(heads, options) {
                    extendSelections(this, clipPosArray(this, heads), options);
                }),
                extendSelectionsBy: docMethodOp(function(f, options) {
                    var heads = map(this.sel.ranges, f);
                    extendSelections(this, clipPosArray(this, heads), options);
                }),
                setSelections: docMethodOp(function(ranges, primary, options) {
                    if (!ranges.length) return;
                    for (var i = 0, out = []; i < ranges.length; i++)
                        out[i] = new Range(clipPos(this, ranges[i].anchor),
                            clipPos(this, ranges[i].head));
                    if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
                    setSelection(this, normalizeSelection(out, primary), options);
                }),
                addSelection: docMethodOp(function(anchor, head, options) {
                    var ranges = this.sel.ranges.slice(0);
                    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
                    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
                }),

                getSelection: function(lineSep) {
                    var ranges = this.sel.ranges, lines;
                    for (var i = 0; i < ranges.length; i++) {
                        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
                        lines = lines ? lines.concat(sel) : sel;
                    }
                    if (lineSep === false) return lines;
                    else return lines.join(lineSep || this.lineSeparator());
                },
                getSelections: function(lineSep) {
                    var parts = [], ranges = this.sel.ranges;
                    for (var i = 0; i < ranges.length; i++) {
                        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
                        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());
                        parts[i] = sel;
                    }
                    return parts;
                },
                replaceSelection: function(code, collapse, origin) {
                    var dup = [];
                    for (var i = 0; i < this.sel.ranges.length; i++)
                        dup[i] = code;
                    this.replaceSelections(dup, collapse, origin || "+input");
                },
                replaceSelections: docMethodOp(function(code, collapse, origin) {
                    var changes = [], sel = this.sel;
                    for (var i = 0; i < sel.ranges.length; i++) {
                        var range = sel.ranges[i];
                        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
                    }
                    var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
                    for (var i = changes.length - 1; i >= 0; i--)
                        makeChange(this, changes[i]);
                    if (newSel) setSelectionReplaceHistory(this, newSel);
                    else if (this.cm) ensureCursorVisible(this.cm);
                }),
                undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
                redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
                undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
                redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

                setExtending: function(val) {this.extend = val;},
                getExtending: function() {return this.extend;},

                historySize: function() {
                    var hist = this.history, done = 0, undone = 0;
                    for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
                    for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
                    return {undo: done, redo: undone};
                },
                clearHistory: function() {this.history = new History(this.history.maxGeneration);},

                markClean: function() {
                    this.cleanGeneration = this.changeGeneration(true);
                },
                changeGeneration: function(forceSplit) {
                    if (forceSplit)
                        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
                    return this.history.generation;
                },
                isClean: function (gen) {
                    return this.history.generation == (gen || this.cleanGeneration);
                },

                getHistory: function() {
                    return {done: copyHistoryArray(this.history.done),
                        undone: copyHistoryArray(this.history.undone)};
                },
                setHistory: function(histData) {
                    var hist = this.history = new History(this.history.maxGeneration);
                    hist.done = copyHistoryArray(histData.done.slice(0), null, true);
                    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
                },

                addLineClass: docMethodOp(function(handle, where, cls) {
                    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
                        var prop = where == "text" ? "textClass"
                            : where == "background" ? "bgClass"
                                : where == "gutter" ? "gutterClass" : "wrapClass";
                        if (!line[prop]) line[prop] = cls;
                        else if (classTest(cls).test(line[prop])) return false;
                        else line[prop] += " " + cls;
                        return true;
                    });
                }),
                removeLineClass: docMethodOp(function(handle, where, cls) {
                    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
                        var prop = where == "text" ? "textClass"
                            : where == "background" ? "bgClass"
                                : where == "gutter" ? "gutterClass" : "wrapClass";
                        var cur = line[prop];
                        if (!cur) return false;
                        else if (cls == null) line[prop] = null;
                        else {
                            var found = cur.match(classTest(cls));
                            if (!found) return false;
                            var end = found.index + found[0].length;
                            line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
                        }
                        return true;
                    });
                }),

                addLineWidget: docMethodOp(function(handle, node, options) {
                    return addLineWidget(this, handle, node, options);
                }),
                removeLineWidget: function(widget) { widget.clear(); },

                markText: function(from, to, options) {
                    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
                },
                setBookmark: function(pos, options) {
                    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                        insertLeft: options && options.insertLeft,
                        clearWhenEmpty: false, shared: options && options.shared,
                        handleMouseEvents: options && options.handleMouseEvents};
                    pos = clipPos(this, pos);
                    return markText(this, pos, pos, realOpts, "bookmark");
                },
                findMarksAt: function(pos) {
                    pos = clipPos(this, pos);
                    var markers = [], spans = getLine(this, pos.line).markedSpans;
                    if (spans) for (var i = 0; i < spans.length; ++i) {
                        var span = spans[i];
                        if ((span.from == null || span.from <= pos.ch) &&
                            (span.to == null || span.to >= pos.ch))
                            markers.push(span.marker.parent || span.marker);
                    }
                    return markers;
                },
                findMarks: function(from, to, filter) {
                    from = clipPos(this, from); to = clipPos(this, to);
                    var found = [], lineNo = from.line;
                    this.iter(from.line, to.line + 1, function(line) {
                        var spans = line.markedSpans;
                        if (spans) for (var i = 0; i < spans.length; i++) {
                            var span = spans[i];
                            if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
                                    span.from == null && lineNo != from.line ||
                                    span.from != null && lineNo == to.line && span.from >= to.ch) &&
                                (!filter || filter(span.marker)))
                                found.push(span.marker.parent || span.marker);
                        }
                        ++lineNo;
                    });
                    return found;
                },
                getAllMarks: function() {
                    var markers = [];
                    this.iter(function(line) {
                        var sps = line.markedSpans;
                        if (sps) for (var i = 0; i < sps.length; ++i)
                            if (sps[i].from != null) markers.push(sps[i].marker);
                    });
                    return markers;
                },

                posFromIndex: function(off) {
                    var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
                    this.iter(function(line) {
                        var sz = line.text.length + sepSize;
                        if (sz > off) { ch = off; return true; }
                        off -= sz;
                        ++lineNo;
                    });
                    return clipPos(this, Pos(lineNo, ch));
                },
                indexFromPos: function (coords) {
                    coords = clipPos(this, coords);
                    var index = coords.ch;
                    if (coords.line < this.first || coords.ch < 0) return 0;
                    var sepSize = this.lineSeparator().length;
                    this.iter(this.first, coords.line, function (line) {
                        index += line.text.length + sepSize;
                    });
                    return index;
                },

                copy: function(copyHistory) {
                    var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep);
                    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
                    doc.sel = this.sel;
                    doc.extend = false;
                    if (copyHistory) {
                        doc.history.undoDepth = this.history.undoDepth;
                        doc.setHistory(this.getHistory());
                    }
                    return doc;
                },

                linkedDoc: function(options) {
                    if (!options) options = {};
                    var from = this.first, to = this.first + this.size;
                    if (options.from != null && options.from > from) from = options.from;
                    if (options.to != null && options.to < to) to = options.to;
                    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);
                    if (options.sharedHist) copy.history = this.history;
                    (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
                    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
                    copySharedMarkers(copy, findSharedMarkers(this));
                    return copy;
                },
                unlinkDoc: function(other) {
                    if (other instanceof CodeMirror) other = other.doc;
                    if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
                        var link = this.linked[i];
                        if (link.doc != other) continue;
                        this.linked.splice(i, 1);
                        other.unlinkDoc(this);
                        detachSharedMarkers(findSharedMarkers(this));
                        break;
                    }
                    // If the histories were shared, split them again
                    if (other.history == this.history) {
                        var splitIds = [other.id];
                        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
                        other.history = new History(null);
                        other.history.done = copyHistoryArray(this.history.done, splitIds);
                        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
                    }
                },
                iterLinkedDocs: function(f) {linkedDocs(this, f);},

                getMode: function() {return this.mode;},
                getEditor: function() {return this.cm;},

                splitLines: function(str) {
                    if (this.lineSep) return str.split(this.lineSep);
                    return splitLinesAuto(str);
                },
                lineSeparator: function() { return this.lineSep || "\n"; }
            });

            // Public alias.
            Doc.prototype.eachLine = Doc.prototype.iter;

            // Set up methods on CodeMirror's prototype to redirect to the editor's document.
            var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
            for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
                CodeMirror.prototype[prop] = (function(method) {
                    return function() {return method.apply(this.doc, arguments);};
                })(Doc.prototype[prop]);

            eventMixin(Doc);

            // Call f for all linked documents.
            function linkedDocs(doc, f, sharedHistOnly) {
                function propagate(doc, skip, sharedHist) {
                    if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
                        var rel = doc.linked[i];
                        if (rel.doc == skip) continue;
                        var shared = sharedHist && rel.sharedHist;
                        if (sharedHistOnly && !shared) continue;
                        f(rel.doc, shared);
                        propagate(rel.doc, doc, shared);
                    }
                }
                propagate(doc, null, true);
            }

            // Attach a document to an editor.
            function attachDoc(cm, doc) {
                if (doc.cm) throw new Error("This document is already in use.");
                cm.doc = doc;
                doc.cm = cm;
                estimateLineHeights(cm);
                loadMode(cm);
                if (!cm.options.lineWrapping) findMaxLine(cm);
                cm.options.mode = doc.modeOption;
                regChange(cm);
            }

            // LINE UTILITIES

            // Find the line object corresponding to the given line number.
            function getLine(doc, n) {
                n -= doc.first;
                if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
                for (var chunk = doc; !chunk.lines;) {
                    for (var i = 0;; ++i) {
                        var child = chunk.children[i], sz = child.chunkSize();
                        if (n < sz) { chunk = child; break; }
                        n -= sz;
                    }
                }
                return chunk.lines[n];
            }

            // Get the part of a document between two positions, as an array of
            // strings.
            function getBetween(doc, start, end) {
                var out = [], n = start.line;
                doc.iter(start.line, end.line + 1, function(line) {
                    var text = line.text;
                    if (n == end.line) text = text.slice(0, end.ch);
                    if (n == start.line) text = text.slice(start.ch);
                    out.push(text);
                    ++n;
                });
                return out;
            }
            // Get the lines between from and to, as array of strings.
            function getLines(doc, from, to) {
                var out = [];
                doc.iter(from, to, function(line) { out.push(line.text); });
                return out;
            }

            // Update the height of a line, propagating the height change
            // upwards to parent nodes.
            function updateLineHeight(line, height) {
                var diff = height - line.height;
                if (diff) for (var n = line; n; n = n.parent) n.height += diff;
            }

            // Given a line object, find its line number by walking up through
            // its parent links.
            function lineNo(line) {
                if (line.parent == null) return null;
                var cur = line.parent, no = indexOf(cur.lines, line);
                for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
                    for (var i = 0;; ++i) {
                        if (chunk.children[i] == cur) break;
                        no += chunk.children[i].chunkSize();
                    }
                }
                return no + cur.first;
            }

            // Find the line at the given vertical position, using the height
            // information in the document tree.
            function lineAtHeight(chunk, h) {
                var n = chunk.first;
                outer: do {
                    for (var i = 0; i < chunk.children.length; ++i) {
                        var child = chunk.children[i], ch = child.height;
                        if (h < ch) { chunk = child; continue outer; }
                        h -= ch;
                        n += child.chunkSize();
                    }
                    return n;
                } while (!chunk.lines);
                for (var i = 0; i < chunk.lines.length; ++i) {
                    var line = chunk.lines[i], lh = line.height;
                    if (h < lh) break;
                    h -= lh;
                }
                return n + i;
            }


            // Find the height above the given line.
            function heightAtLine(lineObj) {
                lineObj = visualLine(lineObj);

                var h = 0, chunk = lineObj.parent;
                for (var i = 0; i < chunk.lines.length; ++i) {
                    var line = chunk.lines[i];
                    if (line == lineObj) break;
                    else h += line.height;
                }
                for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
                    for (var i = 0; i < p.children.length; ++i) {
                        var cur = p.children[i];
                        if (cur == chunk) break;
                        else h += cur.height;
                    }
                }
                return h;
            }

            // Get the bidi ordering for the given line (and cache it). Returns
            // false for lines that are fully left-to-right, and an array of
            // BidiSpan objects otherwise.
            function getOrder(line) {
                var order = line.order;
                if (order == null) order = line.order = bidiOrdering(line.text);
                return order;
            }

            // HISTORY

            function History(startGen) {
                // Arrays of change events and selections. Doing something adds an
                // event to done and clears undo. Undoing moves events from done
                // to undone, redoing moves them in the other direction.
                this.done = []; this.undone = [];
                this.undoDepth = Infinity;
                // Used to track when changes can be merged into a single undo
                // event
                this.lastModTime = this.lastSelTime = 0;
                this.lastOp = this.lastSelOp = null;
                this.lastOrigin = this.lastSelOrigin = null;
                // Used by the isClean() method
                this.generation = this.maxGeneration = startGen || 1;
            }

            // Create a history change event from an updateDoc-style change
            // object.
            function historyChangeFromChange(doc, change) {
                var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
                attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
                linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
                return histChange;
            }

            // Pop all selection events off the end of a history array. Stop at
            // a change event.
            function clearSelectionEvents(array) {
                while (array.length) {
                    var last = lst(array);
                    if (last.ranges) array.pop();
                    else break;
                }
            }

            // Find the top change event in the history. Pop off selection
            // events that are in the way.
            function lastChangeEvent(hist, force) {
                if (force) {
                    clearSelectionEvents(hist.done);
                    return lst(hist.done);
                } else if (hist.done.length && !lst(hist.done).ranges) {
                    return lst(hist.done);
                } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
                    hist.done.pop();
                    return lst(hist.done);
                }
            }

            // Register a change in the history. Merges changes that are within
            // a single operation, ore are close together with an origin that
            // allows merging (starting with "+") into a single event.
            function addChangeToHistory(doc, change, selAfter, opId) {
                var hist = doc.history;
                hist.undone.length = 0;
                var time = +new Date, cur;

                if ((hist.lastOp == opId ||
                        hist.lastOrigin == change.origin && change.origin &&
                        ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
                            change.origin.charAt(0) == "*")) &&
                    (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
                    // Merge this change into the last event
                    var last = lst(cur.changes);
                    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
                        // Optimized case for simple insertion -- don't want to add
                        // new changesets for every character typed
                        last.to = changeEnd(change);
                    } else {
                        // Add new sub-event
                        cur.changes.push(historyChangeFromChange(doc, change));
                    }
                } else {
                    // Can not be merged, start a new event.
                    var before = lst(hist.done);
                    if (!before || !before.ranges)
                        pushSelectionToHistory(doc.sel, hist.done);
                    cur = {changes: [historyChangeFromChange(doc, change)],
                        generation: hist.generation};
                    hist.done.push(cur);
                    while (hist.done.length > hist.undoDepth) {
                        hist.done.shift();
                        if (!hist.done[0].ranges) hist.done.shift();
                    }
                }
                hist.done.push(selAfter);
                hist.generation = ++hist.maxGeneration;
                hist.lastModTime = hist.lastSelTime = time;
                hist.lastOp = hist.lastSelOp = opId;
                hist.lastOrigin = hist.lastSelOrigin = change.origin;

                if (!last) signal(doc, "historyAdded");
            }

            function selectionEventCanBeMerged(doc, origin, prev, sel) {
                var ch = origin.charAt(0);
                return ch == "*" ||
                    ch == "+" &&
                    prev.ranges.length == sel.ranges.length &&
                    prev.somethingSelected() == sel.somethingSelected() &&
                    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
            }

            // Called whenever the selection changes, sets the new selection as
            // the pending selection in the history, and pushes the old pending
            // selection into the 'done' array when it was significantly
            // different (in number of selected ranges, emptiness, or time).
            function addSelectionToHistory(doc, sel, opId, options) {
                var hist = doc.history, origin = options && options.origin;

                // A new event is started when the previous origin does not match
                // the current, or the origins don't allow matching. Origins
                // starting with * are always merged, those starting with + are
                // merged when similar and close together in time.
                if (opId == hist.lastSelOp ||
                    (origin && hist.lastSelOrigin == origin &&
                        (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
                            selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
                    hist.done[hist.done.length - 1] = sel;
                else
                    pushSelectionToHistory(sel, hist.done);

                hist.lastSelTime = +new Date;
                hist.lastSelOrigin = origin;
                hist.lastSelOp = opId;
                if (options && options.clearRedo !== false)
                    clearSelectionEvents(hist.undone);
            }

            function pushSelectionToHistory(sel, dest) {
                var top = lst(dest);
                if (!(top && top.ranges && top.equals(sel)))
                    dest.push(sel);
            }

            // Used to store marked span information in the history.
            function attachLocalSpans(doc, change, from, to) {
                var existing = change["spans_" + doc.id], n = 0;
                doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
                    if (line.markedSpans)
                        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
                    ++n;
                });
            }

            // When un/re-doing restores text containing marked spans, those
            // that have been explicitly cleared should not be restored.
            function removeClearedSpans(spans) {
                if (!spans) return null;
                for (var i = 0, out; i < spans.length; ++i) {
                    if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
                    else if (out) out.push(spans[i]);
                }
                return !out ? spans : out.length ? out : null;
            }

            // Retrieve and filter the old marked spans stored in a change event.
            function getOldSpans(doc, change) {
                var found = change["spans_" + doc.id];
                if (!found) return null;
                for (var i = 0, nw = []; i < change.text.length; ++i)
                    nw.push(removeClearedSpans(found[i]));
                return nw;
            }

            // Used both to provide a JSON-safe object in .getHistory, and, when
            // detaching a document, to split the history in two
            function copyHistoryArray(events, newGroup, instantiateSel) {
                for (var i = 0, copy = []; i < events.length; ++i) {
                    var event = events[i];
                    if (event.ranges) {
                        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
                        continue;
                    }
                    var changes = event.changes, newChanges = [];
                    copy.push({changes: newChanges});
                    for (var j = 0; j < changes.length; ++j) {
                        var change = changes[j], m;
                        newChanges.push({from: change.from, to: change.to, text: change.text});
                        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
                            if (indexOf(newGroup, Number(m[1])) > -1) {
                                lst(newChanges)[prop] = change[prop];
                                delete change[prop];
                            }
                        }
                    }
                }
                return copy;
            }

            // Rebasing/resetting history to deal with externally-sourced changes

            function rebaseHistSelSingle(pos, from, to, diff) {
                if (to < pos.line) {
                    pos.line += diff;
                } else if (from < pos.line) {
                    pos.line = from;
                    pos.ch = 0;
                }
            }

            // Tries to rebase an array of history events given a change in the
            // document. If the change touches the same lines as the event, the
            // event, and everything 'behind' it, is discarded. If the change is
            // before the event, the event's positions are updated. Uses a
            // copy-on-write scheme for the positions, to avoid having to
            // reallocate them all on every rebase, but also avoid problems with
            // shared position objects being unsafely updated.
            function rebaseHistArray(array, from, to, diff) {
                for (var i = 0; i < array.length; ++i) {
                    var sub = array[i], ok = true;
                    if (sub.ranges) {
                        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
                        for (var j = 0; j < sub.ranges.length; j++) {
                            rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
                            rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
                        }
                        continue;
                    }
                    for (var j = 0; j < sub.changes.length; ++j) {
                        var cur = sub.changes[j];
                        if (to < cur.from.line) {
                            cur.from = Pos(cur.from.line + diff, cur.from.ch);
                            cur.to = Pos(cur.to.line + diff, cur.to.ch);
                        } else if (from <= cur.to.line) {
                            ok = false;
                            break;
                        }
                    }
                    if (!ok) {
                        array.splice(0, i + 1);
                        i = 0;
                    }
                }
            }

            function rebaseHist(hist, change) {
                var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
                rebaseHistArray(hist.done, from, to, diff);
                rebaseHistArray(hist.undone, from, to, diff);
            }

            // EVENT UTILITIES

            // Due to the fact that we still support jurassic IE versions, some
            // compatibility wrappers are needed.

            var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
                if (e.preventDefault) e.preventDefault();
                else e.returnValue = false;
            };
            var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
                if (e.stopPropagation) e.stopPropagation();
                else e.cancelBubble = true;
            };
            function e_defaultPrevented(e) {
                return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
            }
            var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};

            function e_target(e) {return e.target || e.srcElement;}
            function e_button(e) {
                var b = e.which;
                if (b == null) {
                    if (e.button & 1) b = 1;
                    else if (e.button & 2) b = 3;
                    else if (e.button & 4) b = 2;
                }
                if (mac && e.ctrlKey && b == 1) b = 3;
                return b;
            }

            // EVENT HANDLING

            // Lightweight event framework. on/off also work on DOM nodes,
            // registering native DOM handlers.

            var on = CodeMirror.on = function(emitter, type, f) {
                if (emitter.addEventListener)
                    emitter.addEventListener(type, f, false);
                else if (emitter.attachEvent)
                    emitter.attachEvent("on" + type, f);
                else {
                    var map = emitter._handlers || (emitter._handlers = {});
                    var arr = map[type] || (map[type] = []);
                    arr.push(f);
                }
            };

            var noHandlers = []
            function getHandlers(emitter, type, copy) {
                var arr = emitter._handlers && emitter._handlers[type]
                if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers
                else return arr || noHandlers
            }

            var off = CodeMirror.off = function(emitter, type, f) {
                if (emitter.removeEventListener)
                    emitter.removeEventListener(type, f, false);
                else if (emitter.detachEvent)
                    emitter.detachEvent("on" + type, f);
                else {
                    var handlers = getHandlers(emitter, type, false)
                    for (var i = 0; i < handlers.length; ++i)
                        if (handlers[i] == f) { handlers.splice(i, 1); break; }
                }
            };

            var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
                var handlers = getHandlers(emitter, type, true)
                if (!handlers.length) return;
                var args = Array.prototype.slice.call(arguments, 2);
                for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);
            };

            var orphanDelayedCallbacks = null;

            // Often, we want to signal events at a point where we are in the
            // middle of some work, but don't want the handler to start calling
            // other methods on the editor, which might be in an inconsistent
            // state or simply not expect any other events to happen.
            // signalLater looks whether there are any handlers, and schedules
            // them to be executed when the last operation ends, or, if no
            // operation is active, when a timeout fires.
            function signalLater(emitter, type /*, values...*/) {
                var arr = getHandlers(emitter, type, false)
                if (!arr.length) return;
                var args = Array.prototype.slice.call(arguments, 2), list;
                if (operationGroup) {
                    list = operationGroup.delayedCallbacks;
                } else if (orphanDelayedCallbacks) {
                    list = orphanDelayedCallbacks;
                } else {
                    list = orphanDelayedCallbacks = [];
                    setTimeout(fireOrphanDelayed, 0);
                }
                function bnd(f) {return function(){f.apply(null, args);};};
                for (var i = 0; i < arr.length; ++i)
                    list.push(bnd(arr[i]));
            }

            function fireOrphanDelayed() {
                var delayed = orphanDelayedCallbacks;
                orphanDelayedCallbacks = null;
                for (var i = 0; i < delayed.length; ++i) delayed[i]();
            }

            // The DOM events that CodeMirror handles can be overridden by
            // registering a (non-DOM) handler on the editor for the event name,
            // and preventDefault-ing the event in that handler.
            function signalDOMEvent(cm, e, override) {
                if (typeof e == "string")
                    e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};
                signal(cm, override || e.type, cm, e);
                return e_defaultPrevented(e) || e.codemirrorIgnore;
            }

            function signalCursorActivity(cm) {
                var arr = cm._handlers && cm._handlers.cursorActivity;
                if (!arr) return;
                var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
                for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
                    set.push(arr[i]);
            }

            function hasHandler(emitter, type) {
                return getHandlers(emitter, type).length > 0
            }

            // Add on and off methods to a constructor's prototype, to make
            // registering events on such objects more convenient.
            function eventMixin(ctor) {
                ctor.prototype.on = function(type, f) {on(this, type, f);};
                ctor.prototype.off = function(type, f) {off(this, type, f);};
            }

            // MISC UTILITIES

            // Number of pixels added to scroller and sizer to hide scrollbar
            var scrollerGap = 30;

            // Returned or thrown by various protocols to signal 'I'm not
            // handling this'.
            var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

            // Reused option objects for setSelection & friends
            var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

            function Delayed() {this.id = null;}
            Delayed.prototype.set = function(ms, f) {
                clearTimeout(this.id);
                this.id = setTimeout(f, ms);
            };

            // Counts the column offset in a string, taking tabs into account.
            // Used mostly to find indentation.
            var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
                if (end == null) {
                    end = string.search(/[^\s\u00a0]/);
                    if (end == -1) end = string.length;
                }
                for (var i = startIndex || 0, n = startValue || 0;;) {
                    var nextTab = string.indexOf("\t", i);
                    if (nextTab < 0 || nextTab >= end)
                        return n + (end - i);
                    n += nextTab - i;
                    n += tabSize - (n % tabSize);
                    i = nextTab + 1;
                }
            };

            // The inverse of countColumn -- find the offset that corresponds to
            // a particular column.
            var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {
                for (var pos = 0, col = 0;;) {
                    var nextTab = string.indexOf("\t", pos);
                    if (nextTab == -1) nextTab = string.length;
                    var skipped = nextTab - pos;
                    if (nextTab == string.length || col + skipped >= goal)
                        return pos + Math.min(skipped, goal - col);
                    col += nextTab - pos;
                    col += tabSize - (col % tabSize);
                    pos = nextTab + 1;
                    if (col >= goal) return pos;
                }
            }

            var spaceStrs = [""];
            function spaceStr(n) {
                while (spaceStrs.length <= n)
                    spaceStrs.push(lst(spaceStrs) + " ");
                return spaceStrs[n];
            }

            function lst(arr) { return arr[arr.length-1]; }

            var selectInput = function(node) { node.select(); };
            if (ios) // Mobile Safari apparently has a bug where select() is broken.
                selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
            else if (ie) // Suppress mysterious IE10 errors
                selectInput = function(node) { try { node.select(); } catch(_e) {} };

            function indexOf(array, elt) {
                for (var i = 0; i < array.length; ++i)
                    if (array[i] == elt) return i;
                return -1;
            }
            function map(array, f) {
                var out = [];
                for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
                return out;
            }

            function nothing() {}

            function createObj(base, props) {
                var inst;
                if (Object.create) {
                    inst = Object.create(base);
                } else {
                    nothing.prototype = base;
                    inst = new nothing();
                }
                if (props) copyObj(props, inst);
                return inst;
            };

            function copyObj(obj, target, overwrite) {
                if (!target) target = {};
                for (var prop in obj)
                    if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
                        target[prop] = obj[prop];
                return target;
            }

            function bind(f) {
                var args = Array.prototype.slice.call(arguments, 1);
                return function(){return f.apply(null, args);};
            }

            var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
            var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
                return /\w/.test(ch) || ch > "\x80" &&
                    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
            };
            function isWordChar(ch, helper) {
                if (!helper) return isWordCharBasic(ch);
                if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) return true;
                return helper.test(ch);
            }

            function isEmpty(obj) {
                for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
                return true;
            }

            // Extending unicode characters. A series of a non-extending char +
            // any number of extending chars is treated as a single unit as far
            // as editing and measuring is concerned. This is not fully correct,
            // since some scripts/fonts/browsers also treat other configurations
            // of code points as a group.
            var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
            function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }

            // DOM UTILITIES

            function elt(tag, content, className, style) {
                var e = document.createElement(tag);
                if (className) e.className = className;
                if (style) e.style.cssText = style;
                if (typeof content == "string") e.appendChild(document.createTextNode(content));
                else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
                return e;
            }

            var range;
            if (document.createRange) range = function(node, start, end, endNode) {
                var r = document.createRange();
                r.setEnd(endNode || node, end);
                r.setStart(node, start);
                return r;
            };
            else range = function(node, start, end) {
                var r = document.body.createTextRange();
                try { r.moveToElementText(node.parentNode); }
                catch(e) { return r; }
                r.collapse(true);
                r.moveEnd("character", end);
                r.moveStart("character", start);
                return r;
            };

            function removeChildren(e) {
                for (var count = e.childNodes.length; count > 0; --count)
                    e.removeChild(e.firstChild);
                return e;
            }

            function removeChildrenAndAdd(parent, e) {
                return removeChildren(parent).appendChild(e);
            }

            var contains = CodeMirror.contains = function(parent, child) {
                if (child.nodeType == 3) // Android browser always returns false when child is a textnode
                    child = child.parentNode;
                if (parent.contains)
                    return parent.contains(child);
                do {
                    if (child.nodeType == 11) child = child.host;
                    if (child == parent) return true;
                } while (child = child.parentNode);
            };

            function activeElt() {
                var activeElement = document.activeElement;
                while (activeElement && activeElement.root && activeElement.root.activeElement)
                    activeElement = activeElement.root.activeElement;
                return activeElement;
            }
            // Older versions of IE throws unspecified error when touching
            // document.activeElement in some cases (during loading, in iframe)
            if (ie && ie_version < 11) activeElt = function() {
                try { return document.activeElement; }
                catch(e) { return document.body; }
            };

            function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*"); }
            var rmClass = CodeMirror.rmClass = function(node, cls) {
                var current = node.className;
                var match = classTest(cls).exec(current);
                if (match) {
                    var after = current.slice(match.index + match[0].length);
                    node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
                }
            };
            var addClass = CodeMirror.addClass = function(node, cls) {
                var current = node.className;
                if (!classTest(cls).test(current)) node.className += (current ? " " : "") + cls;
            };
            function joinClasses(a, b) {
                var as = a.split(" ");
                for (var i = 0; i < as.length; i++)
                    if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
                return b;
            }

            // WINDOW-WIDE EVENTS

            // These must be handled carefully, because naively registering a
            // handler for each editor will cause the editors to never be
            // garbage collected.

            function forEachCodeMirror(f) {
                if (!document.body.getElementsByClassName) return;
                var byClass = document.body.getElementsByClassName("CodeMirror");
                for (var i = 0; i < byClass.length; i++) {
                    var cm = byClass[i].CodeMirror;
                    if (cm) f(cm);
                }
            }

            var globalsRegistered = false;
            function ensureGlobalHandlers() {
                if (globalsRegistered) return;
                registerGlobalHandlers();
                globalsRegistered = true;
            }
            function registerGlobalHandlers() {
                // When the window resizes, we need to refresh active editors.
                var resizeTimer;
                on(window, "resize", function() {
                    if (resizeTimer == null) resizeTimer = setTimeout(function() {
                        resizeTimer = null;
                        forEachCodeMirror(onResize);
                    }, 100);
                });
                // When the window loses focus, we want to show the editor as blurred
                on(window, "blur", function() {
                    forEachCodeMirror(onBlur);
                });
            }

            // FEATURE DETECTION

            // Detect drag-and-drop
            var dragAndDrop = function() {
                // There is *some* kind of drag-and-drop support in IE6-8, but I
                // couldn't get it to work yet.
                if (ie && ie_version < 9) return false;
                var div = elt('div');
                return "draggable" in div || "dragDrop" in div;
            }();

            var zwspSupported;
            function zeroWidthElement(measure) {
                if (zwspSupported == null) {
                    var test = elt("span", "\u200b");
                    removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
                    if (measure.firstChild.offsetHeight != 0)
                        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
                }
                var node = zwspSupported ? elt("span", "\u200b") :
                    elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
                node.setAttribute("cm-text", "");
                return node;
            }

            // Feature-detect IE's crummy client rect reporting for bidi text
            var badBidiRects;
            function hasBadBidiRects(measure) {
                if (badBidiRects != null) return badBidiRects;
                var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
                var r0 = range(txt, 0, 1).getBoundingClientRect();
                if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)
                var r1 = range(txt, 1, 2).getBoundingClientRect();
                return badBidiRects = (r1.right - r0.right < 3);
            }

            // See if "".split is the broken IE version, if so, provide an
            // alternative way to split lines.
            var splitLinesAuto = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
                var pos = 0, result = [], l = string.length;
                while (pos <= l) {
                    var nl = string.indexOf("\n", pos);
                    if (nl == -1) nl = string.length;
                    var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
                    var rt = line.indexOf("\r");
                    if (rt != -1) {
                        result.push(line.slice(0, rt));
                        pos += rt + 1;
                    } else {
                        result.push(line);
                        pos = nl + 1;
                    }
                }
                return result;
            } : function(string){return string.split(/\r\n?|\n/);};

            var hasSelection = window.getSelection ? function(te) {
                try { return te.selectionStart != te.selectionEnd; }
                catch(e) { return false; }
            } : function(te) {
                try {var range = te.ownerDocument.selection.createRange();}
                catch(e) {}
                if (!range || range.parentElement() != te) return false;
                return range.compareEndPoints("StartToEnd", range) != 0;
            };

            var hasCopyEvent = (function() {
                var e = elt("div");
                if ("oncopy" in e) return true;
                e.setAttribute("oncopy", "return;");
                return typeof e.oncopy == "function";
            })();

            var badZoomedRects = null;
            function hasBadZoomedRects(measure) {
                if (badZoomedRects != null) return badZoomedRects;
                var node = removeChildrenAndAdd(measure, elt("span", "x"));
                var normal = node.getBoundingClientRect();
                var fromRange = range(node, 0, 1).getBoundingClientRect();
                return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
            }

            // KEY NAMES

            var keyNames = CodeMirror.keyNames = {
                3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
                19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
                36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
                46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
                106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
                173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
                221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
                63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
            };
            (function() {
                // Number keys
                for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
                // Alphabetic keys
                for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
                // Function keys
                for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
            })();

            // BIDI HELPERS

            function iterateBidiSections(order, from, to, f) {
                if (!order) return f(from, to, "ltr");
                var found = false;
                for (var i = 0; i < order.length; ++i) {
                    var part = order[i];
                    if (part.from < to && part.to > from || from == to && part.to == from) {
                        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
                        found = true;
                    }
                }
                if (!found) f(from, to, "ltr");
            }

            function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
            function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

            function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
            function lineRight(line) {
                var order = getOrder(line);
                if (!order) return line.text.length;
                return bidiRight(lst(order));
            }

            function lineStart(cm, lineN) {
                var line = getLine(cm.doc, lineN);
                var visual = visualLine(line);
                if (visual != line) lineN = lineNo(visual);
                var order = getOrder(visual);
                var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
                return Pos(lineN, ch);
            }
            function lineEnd(cm, lineN) {
                var merged, line = getLine(cm.doc, lineN);
                while (merged = collapsedSpanAtEnd(line)) {
                    line = merged.find(1, true).line;
                    lineN = null;
                }
                var order = getOrder(line);
                var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
                return Pos(lineN == null ? lineNo(line) : lineN, ch);
            }
            function lineStartSmart(cm, pos) {
                var start = lineStart(cm, pos.line);
                var line = getLine(cm.doc, start.line);
                var order = getOrder(line);
                if (!order || order[0].level == 0) {
                    var firstNonWS = Math.max(0, line.text.search(/\S/));
                    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
                    return Pos(start.line, inWS ? 0 : firstNonWS);
                }
                return start;
            }

            function compareBidiLevel(order, a, b) {
                var linedir = order[0].level;
                if (a == linedir) return true;
                if (b == linedir) return false;
                return a < b;
            }
            var bidiOther;
            function getBidiPartAt(order, pos) {
                bidiOther = null;
                for (var i = 0, found; i < order.length; ++i) {
                    var cur = order[i];
                    if (cur.from < pos && cur.to > pos) return i;
                    if ((cur.from == pos || cur.to == pos)) {
                        if (found == null) {
                            found = i;
                        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
                            if (cur.from != cur.to) bidiOther = found;
                            return i;
                        } else {
                            if (cur.from != cur.to) bidiOther = i;
                            return found;
                        }
                    }
                }
                return found;
            }

            function moveInLine(line, pos, dir, byUnit) {
                if (!byUnit) return pos + dir;
                do pos += dir;
                while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
                return pos;
            }

            // This is needed in order to move 'visually' through bi-directional
            // text -- i.e., pressing left should make the cursor go left, even
            // when in RTL text. The tricky part is the 'jumps', where RTL and
            // LTR text touch each other. This often requires the cursor offset
            // to move more than one unit, in order to visually move one unit.
            function moveVisually(line, start, dir, byUnit) {
                var bidi = getOrder(line);
                if (!bidi) return moveLogically(line, start, dir, byUnit);
                var pos = getBidiPartAt(bidi, start), part = bidi[pos];
                var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

                for (;;) {
                    if (target > part.from && target < part.to) return target;
                    if (target == part.from || target == part.to) {
                        if (getBidiPartAt(bidi, target) == pos) return target;
                        part = bidi[pos += dir];
                        return (dir > 0) == part.level % 2 ? part.to : part.from;
                    } else {
                        part = bidi[pos += dir];
                        if (!part) return null;
                        if ((dir > 0) == part.level % 2)
                            target = moveInLine(line, part.to, -1, byUnit);
                        else
                            target = moveInLine(line, part.from, 1, byUnit);
                    }
                }
            }

            function moveLogically(line, start, dir, byUnit) {
                var target = start + dir;
                if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
                return target < 0 || target > line.text.length ? null : target;
            }

            // Bidirectional ordering algorithm
            // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
            // that this (partially) implements.

            // One-char codes used for character types:
            // L (L):   Left-to-Right
            // R (R):   Right-to-Left
            // r (AL):  Right-to-Left Arabic
            // 1 (EN):  European Number
            // + (ES):  European Number Separator
            // % (ET):  European Number Terminator
            // n (AN):  Arabic Number
            // , (CS):  Common Number Separator
            // m (NSM): Non-Spacing Mark
            // b (BN):  Boundary Neutral
            // s (B):   Paragraph Separator
            // t (S):   Segment Separator
            // w (WS):  Whitespace
            // N (ON):  Other Neutrals

            // Returns null if characters are ordered as they appear
            // (left-to-right), or an array of sections ({from, to, level}
            // objects) in the order in which they occur visually.
            var bidiOrdering = (function() {
                // Character types for codepoints 0 to 0xff
                var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
                // Character types for codepoints 0x600 to 0x6ff
                var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
                function charType(code) {
                    if (code <= 0xf7) return lowTypes.charAt(code);
                    else if (0x590 <= code && code <= 0x5f4) return "R";
                    else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
                    else if (0x6ee <= code && code <= 0x8ac) return "r";
                    else if (0x2000 <= code && code <= 0x200b) return "w";
                    else if (code == 0x200c) return "b";
                    else return "L";
                }

                var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
                var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
                // Browsers seem to always treat the boundaries of block elements as being L.
                var outerType = "L";

                function BidiSpan(level, from, to) {
                    this.level = level;
                    this.from = from; this.to = to;
                }

                return function(str) {
                    if (!bidiRE.test(str)) return false;
                    var len = str.length, types = [];
                    for (var i = 0, type; i < len; ++i)
                        types.push(type = charType(str.charCodeAt(i)));

                    // W1. Examine each non-spacing mark (NSM) in the level run, and
                    // change the type of the NSM to the type of the previous
                    // character. If the NSM is at the start of the level run, it will
                    // get the type of sor.
                    for (var i = 0, prev = outerType; i < len; ++i) {
                        var type = types[i];
                        if (type == "m") types[i] = prev;
                        else prev = type;
                    }

                    // W2. Search backwards from each instance of a European number
                    // until the first strong type (R, L, AL, or sor) is found. If an
                    // AL is found, change the type of the European number to Arabic
                    // number.
                    // W3. Change all ALs to R.
                    for (var i = 0, cur = outerType; i < len; ++i) {
                        var type = types[i];
                        if (type == "1" && cur == "r") types[i] = "n";
                        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
                    }

                    // W4. A single European separator between two European numbers
                    // changes to a European number. A single common separator between
                    // two numbers of the same type changes to that type.
                    for (var i = 1, prev = types[0]; i < len - 1; ++i) {
                        var type = types[i];
                        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
                        else if (type == "," && prev == types[i+1] &&
                            (prev == "1" || prev == "n")) types[i] = prev;
                        prev = type;
                    }

                    // W5. A sequence of European terminators adjacent to European
                    // numbers changes to all European numbers.
                    // W6. Otherwise, separators and terminators change to Other
                    // Neutral.
                    for (var i = 0; i < len; ++i) {
                        var type = types[i];
                        if (type == ",") types[i] = "N";
                        else if (type == "%") {
                            for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
                            var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
                            for (var j = i; j < end; ++j) types[j] = replace;
                            i = end - 1;
                        }
                    }

                    // W7. Search backwards from each instance of a European number
                    // until the first strong type (R, L, or sor) is found. If an L is
                    // found, then change the type of the European number to L.
                    for (var i = 0, cur = outerType; i < len; ++i) {
                        var type = types[i];
                        if (cur == "L" && type == "1") types[i] = "L";
                        else if (isStrong.test(type)) cur = type;
                    }

                    // N1. A sequence of neutrals takes the direction of the
                    // surrounding strong text if the text on both sides has the same
                    // direction. European and Arabic numbers act as if they were R in
                    // terms of their influence on neutrals. Start-of-level-run (sor)
                    // and end-of-level-run (eor) are used at level run boundaries.
                    // N2. Any remaining neutrals take the embedding direction.
                    for (var i = 0; i < len; ++i) {
                        if (isNeutral.test(types[i])) {
                            for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
                            var before = (i ? types[i-1] : outerType) == "L";
                            var after = (end < len ? types[end] : outerType) == "L";
                            var replace = before || after ? "L" : "R";
                            for (var j = i; j < end; ++j) types[j] = replace;
                            i = end - 1;
                        }
                    }

                    // Here we depart from the documented algorithm, in order to avoid
                    // building up an actual levels array. Since there are only three
                    // levels (0, 1, 2) in an implementation that doesn't take
                    // explicit embedding into account, we can build up the order on
                    // the fly, without following the level-based algorithm.
                    var order = [], m;
                    for (var i = 0; i < len;) {
                        if (countsAsLeft.test(types[i])) {
                            var start = i;
                            for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
                            order.push(new BidiSpan(0, start, i));
                        } else {
                            var pos = i, at = order.length;
                            for (++i; i < len && types[i] != "L"; ++i) {}
                            for (var j = pos; j < i;) {
                                if (countsAsNum.test(types[j])) {
                                    if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
                                    var nstart = j;
                                    for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
                                    order.splice(at, 0, new BidiSpan(2, nstart, j));
                                    pos = j;
                                } else ++j;
                            }
                            if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
                        }
                    }
                    if (order[0].level == 1 && (m = str.match(/^\s+/))) {
                        order[0].from = m[0].length;
                        order.unshift(new BidiSpan(0, 0, m[0].length));
                    }
                    if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
                        lst(order).to -= m[0].length;
                        order.push(new BidiSpan(0, len - m[0].length, len));
                    }
                    if (order[0].level == 2)
                        order.unshift(new BidiSpan(1, order[0].to, order[0].to));
                    if (order[0].level != lst(order).level)
                        order.push(new BidiSpan(order[0].level, len, len));

                    return order;
                };
            })();

            // THE END

            CodeMirror.version = "5.15.2";

            return CodeMirror;
        });

    },{}],11:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

        (function(mod) {
            if (typeof exports == "object" && typeof module == "object") // CommonJS
                mod(require("../../lib/codemirror"), require("../markdown/markdown"), require("../../addon/mode/overlay"));
            else if (typeof define == "function" && define.amd) // AMD
                define(["../../lib/codemirror", "../markdown/markdown", "../../addon/mode/overlay"], mod);
            else // Plain browser env
                mod(CodeMirror);
        })(function(CodeMirror) {
            "use strict";

            var urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\.beep|\.lwz|\.xpc|\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\.beeps?|xmpp|xri|ymsgr|z39\.50[rs]?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?]))/i

            CodeMirror.defineMode("gfm", function(config, modeConfig) {
                var codeDepth = 0;
                function blankLine(state) {
                    state.code = false;
                    return null;
                }
                var gfmOverlay = {
                    startState: function() {
                        return {
                            code: false,
                            codeBlock: false,
                            ateSpace: false
                        };
                    },
                    copyState: function(s) {
                        return {
                            code: s.code,
                            codeBlock: s.codeBlock,
                            ateSpace: s.ateSpace
                        };
                    },
                    token: function(stream, state) {
                        state.combineTokens = null;

                        // Hack to prevent formatting override inside code blocks (block and inline)
                        if (state.codeBlock) {
                            if (stream.match(/^```+/)) {
                                state.codeBlock = false;
                                return null;
                            }
                            stream.skipToEnd();
                            return null;
                        }
                        if (stream.sol()) {
                            state.code = false;
                        }
                        if (stream.sol() && stream.match(/^```+/)) {
                            stream.skipToEnd();
                            state.codeBlock = true;
                            return null;
                        }
                        // If this block is changed, it may need to be updated in Markdown mode
                        if (stream.peek() === '`') {
                            stream.next();
                            var before = stream.pos;
                            stream.eatWhile('`');
                            var difference = 1 + stream.pos - before;
                            if (!state.code) {
                                codeDepth = difference;
                                state.code = true;
                            } else {
                                if (difference === codeDepth) { // Must be exact
                                    state.code = false;
                                }
                            }
                            return null;
                        } else if (state.code) {
                            stream.next();
                            return null;
                        }
                        // Check if space. If so, links can be formatted later on
                        if (stream.eatSpace()) {
                            state.ateSpace = true;
                            return null;
                        }
                        if (stream.sol() || state.ateSpace) {
                            state.ateSpace = false;
                            if (modeConfig.gitHubSpice !== false) {
                                if(stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?:[a-f0-9]{7,40}\b)/)) {
                                    // User/Project@SHA
                                    // User@SHA
                                    // SHA
                                    state.combineTokens = true;
                                    return "link";
                                } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
                                    // User/Project#Num
                                    // User#Num
                                    // #Num
                                    state.combineTokens = true;
                                    return "link";
                                }
                            }
                        }
                        if (stream.match(urlRE) &&
                            stream.string.slice(stream.start - 2, stream.start) != "](" &&
                            (stream.start == 0 || /\W/.test(stream.string.charAt(stream.start - 1)))) {
                            // URLs
                            // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
                            // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine
                            // And then limited url schemes to the CommonMark list, so foo:bar isn't matched as a URL
                            state.combineTokens = true;
                            return "link";
                        }
                        stream.next();
                        return null;
                    },
                    blankLine: blankLine
                };

                var markdownConfig = {
                    underscoresBreakWords: false,
                    taskLists: true,
                    fencedCodeBlocks: '```',
                    strikethrough: true
                };
                for (var attr in modeConfig) {
                    markdownConfig[attr] = modeConfig[attr];
                }
                markdownConfig.name = "markdown";
                return CodeMirror.overlayMode(CodeMirror.getMode(config, markdownConfig), gfmOverlay);

            }, "markdown");

            CodeMirror.defineMIME("text/x-gfm", "gfm");
        });

    },{"../../addon/mode/overlay":8,"../../lib/codemirror":10,"../markdown/markdown":12}],12:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

        (function(mod) {
            if (typeof exports == "object" && typeof module == "object") // CommonJS
                mod(require("../../lib/codemirror"), require("../xml/xml"), require("../meta"));
            else if (typeof define == "function" && define.amd) // AMD
                define(["../../lib/codemirror", "../xml/xml", "../meta"], mod);
            else // Plain browser env
                mod(CodeMirror);
        })(function(CodeMirror) {
            "use strict";

            CodeMirror.defineMode("markdown", function(cmCfg, modeCfg) {

                var htmlMode = CodeMirror.getMode(cmCfg, "text/html");
                var htmlModeMissing = htmlMode.name == "null"

                function getMode(name) {
                    if (CodeMirror.findModeByName) {
                        var found = CodeMirror.findModeByName(name);
                        if (found) name = found.mime || found.mimes[0];
                    }
                    var mode = CodeMirror.getMode(cmCfg, name);
                    return mode.name == "null" ? null : mode;
                }

                // Should characters that affect highlighting be highlighted separate?
                // Does not include characters that will be output (such as `1.` and `-` for lists)
                if (modeCfg.highlightFormatting === undefined)
                    modeCfg.highlightFormatting = false;

                // Maximum number of nested blockquotes. Set to 0 for infinite nesting.
                // Excess `>` will emit `error` token.
                if (modeCfg.maxBlockquoteDepth === undefined)
                    modeCfg.maxBlockquoteDepth = 0;

                // Should underscores in words open/close em/strong?
                if (modeCfg.underscoresBreakWords === undefined)
                    modeCfg.underscoresBreakWords = true;

                // Use `fencedCodeBlocks` to configure fenced code blocks. false to
                // disable, string to specify a precise regexp that the fence should
                // match, and true to allow three or more backticks or tildes (as
                // per CommonMark).

                // Turn on task lists? ("- [ ] " and "- [x] ")
                if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;

                // Turn on strikethrough syntax
                if (modeCfg.strikethrough === undefined)
                    modeCfg.strikethrough = false;

                // Allow token types to be overridden by user-provided token types.
                if (modeCfg.tokenTypeOverrides === undefined)
                    modeCfg.tokenTypeOverrides = {};

                var tokenTypes = {
                    header: "header",
                    code: "comment",
                    quote: "quote",
                    list1: "variable-2",
                    list2: "variable-3",
                    list3: "keyword",
                    hr: "hr",
                    image: "tag",
                    formatting: "formatting",
                    linkInline: "link",
                    linkEmail: "link",
                    linkText: "link",
                    linkHref: "string",
                    em: "em",
                    strong: "strong",
                    strikethrough: "strikethrough"
                };

                for (var tokenType in tokenTypes) {
                    if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {
                        tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];
                    }
                }

                var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/
                    ,   ulRE = /^[*\-+]\s+/
                    ,   olRE = /^[0-9]+([.)])\s+/
                    ,   taskListRE = /^\[(x| )\](?=\s)/ // Must follow ulRE or olRE
                    ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/
                    ,   setextHeaderRE = /^ *(?:\={1,}|-{1,})\s*$/
                    ,   textRE = /^[^#!\[\]*_\\<>` "'(~]+/
                    ,   fencedCodeRE = new RegExp("^(" + (modeCfg.fencedCodeBlocks === true ? "~~~+|```+" : modeCfg.fencedCodeBlocks) +
                    ")[ \\t]*([\\w+#\-]*)");

                function switchInline(stream, state, f) {
                    state.f = state.inline = f;
                    return f(stream, state);
                }

                function switchBlock(stream, state, f) {
                    state.f = state.block = f;
                    return f(stream, state);
                }

                function lineIsEmpty(line) {
                    return !line || !/\S/.test(line.string)
                }

                // Blocks

                function blankLine(state) {
                    // Reset linkTitle state
                    state.linkTitle = false;
                    // Reset EM state
                    state.em = false;
                    // Reset STRONG state
                    state.strong = false;
                    // Reset strikethrough state
                    state.strikethrough = false;
                    // Reset state.quote
                    state.quote = 0;
                    // Reset state.indentedCode
                    state.indentedCode = false;
                    if (htmlModeMissing && state.f == htmlBlock) {
                        state.f = inlineNormal;
                        state.block = blockNormal;
                    }
                    // Reset state.trailingSpace
                    state.trailingSpace = 0;
                    state.trailingSpaceNewLine = false;
                    // Mark this line as blank
                    state.prevLine = state.thisLine
                    state.thisLine = null
                    return null;
                }

                function blockNormal(stream, state) {

                    var sol = stream.sol();

                    var prevLineIsList = state.list !== false,
                        prevLineIsIndentedCode = state.indentedCode;

                    state.indentedCode = false;

                    if (prevLineIsList) {
                        if (state.indentationDiff >= 0) { // Continued list
                            if (state.indentationDiff < 4) { // Only adjust indentation if *not* a code block
                                state.indentation -= state.indentationDiff;
                            }
                            state.list = null;
                        } else if (state.indentation > 0) {
                            state.list = null;
                        } else { // No longer a list
                            state.list = false;
                        }
                    }

                    var match = null;
                    if (state.indentationDiff >= 4) {
                        stream.skipToEnd();
                        if (prevLineIsIndentedCode || lineIsEmpty(state.prevLine)) {
                            state.indentation -= 4;
                            state.indentedCode = true;
                            return tokenTypes.code;
                        } else {
                            return null;
                        }
                    } else if (stream.eatSpace()) {
                        return null;
                    } else if ((match = stream.match(atxHeaderRE)) && match[1].length <= 6) {
                        state.header = match[1].length;
                        if (modeCfg.highlightFormatting) state.formatting = "header";
                        state.f = state.inline;
                        return getType(state);
                    } else if (!lineIsEmpty(state.prevLine) && !state.quote && !prevLineIsList &&
                        !prevLineIsIndentedCode && (match = stream.match(setextHeaderRE))) {
                        state.header = match[0].charAt(0) == '=' ? 1 : 2;
                        if (modeCfg.highlightFormatting) state.formatting = "header";
                        state.f = state.inline;
                        return getType(state);
                    } else if (stream.eat('>')) {
                        state.quote = sol ? 1 : state.quote + 1;
                        if (modeCfg.highlightFormatting) state.formatting = "quote";
                        stream.eatSpace();
                        return getType(state);
                    } else if (stream.peek() === '[') {
                        return switchInline(stream, state, footnoteLink);
                    } else if (stream.match(hrRE, true)) {
                        state.hr = true;
                        return tokenTypes.hr;
                    } else if ((lineIsEmpty(state.prevLine) || prevLineIsList) && (stream.match(ulRE, false) || stream.match(olRE, false))) {
                        var listType = null;
                        if (stream.match(ulRE, true)) {
                            listType = 'ul';
                        } else {
                            stream.match(olRE, true);
                            listType = 'ol';
                        }
                        state.indentation = stream.column() + stream.current().length;
                        state.list = true;

                        // While this list item's marker's indentation
                        // is less than the deepest list item's content's indentation,
                        // pop the deepest list item indentation off the stack.
                        while (state.listStack && stream.column() < state.listStack[state.listStack.length - 1]) {
                            state.listStack.pop();
                        }

                        // Add this list item's content's indentation to the stack
                        state.listStack.push(state.indentation);

                        if (modeCfg.taskLists && stream.match(taskListRE, false)) {
                            state.taskList = true;
                        }
                        state.f = state.inline;
                        if (modeCfg.highlightFormatting) state.formatting = ["list", "list-" + listType];
                        return getType(state);
                    } else if (modeCfg.fencedCodeBlocks && (match = stream.match(fencedCodeRE, true))) {
                        state.fencedChars = match[1]
                        // try switching mode
                        state.localMode = getMode(match[2]);
                        if (state.localMode) state.localState = CodeMirror.startState(state.localMode);
                        state.f = state.block = local;
                        if (modeCfg.highlightFormatting) state.formatting = "code-block";
                        state.code = -1
                        return getType(state);
                    }

                    return switchInline(stream, state, state.inline);
                }

                function htmlBlock(stream, state) {
                    var style = htmlMode.token(stream, state.htmlState);
                    if (!htmlModeMissing) {
                        var inner = CodeMirror.innerMode(htmlMode, state.htmlState)
                        if ((inner.mode.name == "xml" && inner.state.tagStart === null &&
                                (!inner.state.context && inner.state.tokenize.isInText)) ||
                            (state.md_inside && stream.current().indexOf(">") > -1)) {
                            state.f = inlineNormal;
                            state.block = blockNormal;
                            state.htmlState = null;
                        }
                    }
                    return style;
                }

                function local(stream, state) {
                    if (state.fencedChars && stream.match(state.fencedChars, false)) {
                        state.localMode = state.localState = null;
                        state.f = state.block = leavingLocal;
                        return null;
                    } else if (state.localMode) {
                        return state.localMode.token(stream, state.localState);
                    } else {
                        stream.skipToEnd();
                        return tokenTypes.code;
                    }
                }

                function leavingLocal(stream, state) {
                    stream.match(state.fencedChars);
                    state.block = blockNormal;
                    state.f = inlineNormal;
                    state.fencedChars = null;
                    if (modeCfg.highlightFormatting) state.formatting = "code-block";
                    state.code = 1
                    var returnType = getType(state);
                    state.code = 0
                    return returnType;
                }

                // Inline
                function getType(state) {
                    var styles = [];

                    if (state.formatting) {
                        styles.push(tokenTypes.formatting);

                        if (typeof state.formatting === "string") state.formatting = [state.formatting];

                        for (var i = 0; i < state.formatting.length; i++) {
                            styles.push(tokenTypes.formatting + "-" + state.formatting[i]);

                            if (state.formatting[i] === "header") {
                                styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.header);
                            }

                            // Add `formatting-quote` and `formatting-quote-#` for blockquotes
                            // Add `error` instead if the maximum blockquote nesting depth is passed
                            if (state.formatting[i] === "quote") {
                                if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                                    styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.quote);
                                } else {
                                    styles.push("error");
                                }
                            }
                        }
                    }

                    if (state.taskOpen) {
                        styles.push("meta");
                        return styles.length ? styles.join(' ') : null;
                    }
                    if (state.taskClosed) {
                        styles.push("property");
                        return styles.length ? styles.join(' ') : null;
                    }

                    if (state.linkHref) {
                        styles.push(tokenTypes.linkHref, "url");
                    } else { // Only apply inline styles to non-url text
                        if (state.strong) { styles.push(tokenTypes.strong); }
                        if (state.em) { styles.push(tokenTypes.em); }
                        if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }
                        if (state.linkText) { styles.push(tokenTypes.linkText); }
                        if (state.code) { styles.push(tokenTypes.code); }
                    }

                    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header); }

                    if (state.quote) {
                        styles.push(tokenTypes.quote);

                        // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth
                        if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                            styles.push(tokenTypes.quote + "-" + state.quote);
                        } else {
                            styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);
                        }
                    }

                    if (state.list !== false) {
                        var listMod = (state.listStack.length - 1) % 3;
                        if (!listMod) {
                            styles.push(tokenTypes.list1);
                        } else if (listMod === 1) {
                            styles.push(tokenTypes.list2);
                        } else {
                            styles.push(tokenTypes.list3);
                        }
                    }

                    if (state.trailingSpaceNewLine) {
                        styles.push("trailing-space-new-line");
                    } else if (state.trailingSpace) {
                        styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
                    }

                    return styles.length ? styles.join(' ') : null;
                }

                function handleText(stream, state) {
                    if (stream.match(textRE, true)) {
                        return getType(state);
                    }
                    return undefined;
                }

                function inlineNormal(stream, state) {
                    var style = state.text(stream, state);
                    if (typeof style !== 'undefined')
                        return style;

                    if (state.list) { // List marker (*, +, -, 1., etc)
                        state.list = null;
                        return getType(state);
                    }

                    if (state.taskList) {
                        var taskOpen = stream.match(taskListRE, true)[1] !== "x";
                        if (taskOpen) state.taskOpen = true;
                        else state.taskClosed = true;
                        if (modeCfg.highlightFormatting) state.formatting = "task";
                        state.taskList = false;
                        return getType(state);
                    }

                    state.taskOpen = false;
                    state.taskClosed = false;

                    if (state.header && stream.match(/^#+$/, true)) {
                        if (modeCfg.highlightFormatting) state.formatting = "header";
                        return getType(state);
                    }

                    // Get sol() value now, before character is consumed
                    var sol = stream.sol();

                    var ch = stream.next();

                    // Matches link titles present on next line
                    if (state.linkTitle) {
                        state.linkTitle = false;
                        var matchCh = ch;
                        if (ch === '(') {
                            matchCh = ')';
                        }
                        matchCh = (matchCh+'').replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
                        var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;
                        if (stream.match(new RegExp(regex), true)) {
                            return tokenTypes.linkHref;
                        }
                    }

                    // If this block is changed, it may need to be updated in GFM mode
                    if (ch === '`') {
                        var previousFormatting = state.formatting;
                        if (modeCfg.highlightFormatting) state.formatting = "code";
                        stream.eatWhile('`');
                        var count = stream.current().length
                        if (state.code == 0) {
                            state.code = count
                            return getType(state)
                        } else if (count == state.code) { // Must be exact
                            var t = getType(state)
                            state.code = 0
                            return t
                        } else {
                            state.formatting = previousFormatting
                            return getType(state)
                        }
                    } else if (state.code) {
                        return getType(state);
                    }

                    if (ch === '\\') {
                        stream.next();
                        if (modeCfg.highlightFormatting) {
                            var type = getType(state);
                            var formattingEscape = tokenTypes.formatting + "-escape";
                            return type ? type + " " + formattingEscape : formattingEscape;
                        }
                    }

                    if (ch === '!' && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
                        stream.match(/\[[^\]]*\]/);
                        state.inline = state.f = linkHref;
                        return tokenTypes.image;
                    }

                    if (ch === '[' && stream.match(/[^\]]*\](\(.*\)| ?\[.*?\])/, false)) {
                        state.linkText = true;
                        if (modeCfg.highlightFormatting) state.formatting = "link";
                        return getType(state);
                    }

                    if (ch === ']' && state.linkText && stream.match(/\(.*?\)| ?\[.*?\]/, false)) {
                        if (modeCfg.highlightFormatting) state.formatting = "link";
                        var type = getType(state);
                        state.linkText = false;
                        state.inline = state.f = linkHref;
                        return type;
                    }

                    if (ch === '<' && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
                        state.f = state.inline = linkInline;
                        if (modeCfg.highlightFormatting) state.formatting = "link";
                        var type = getType(state);
                        if (type){
                            type += " ";
                        } else {
                            type = "";
                        }
                        return type + tokenTypes.linkInline;
                    }

                    if (ch === '<' && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
                        state.f = state.inline = linkInline;
                        if (modeCfg.highlightFormatting) state.formatting = "link";
                        var type = getType(state);
                        if (type){
                            type += " ";
                        } else {
                            type = "";
                        }
                        return type + tokenTypes.linkEmail;
                    }

                    if (ch === '<' && stream.match(/^(!--|\w)/, false)) {
                        var end = stream.string.indexOf(">", stream.pos);
                        if (end != -1) {
                            var atts = stream.string.substring(stream.start, end);
                            if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) state.md_inside = true;
                        }
                        stream.backUp(1);
                        state.htmlState = CodeMirror.startState(htmlMode);
                        return switchBlock(stream, state, htmlBlock);
                    }

                    if (ch === '<' && stream.match(/^\/\w*?>/)) {
                        state.md_inside = false;
                        return "tag";
                    }

                    var ignoreUnderscore = false;
                    if (!modeCfg.underscoresBreakWords) {
                        if (ch === '_' && stream.peek() !== '_' && stream.match(/(\w)/, false)) {
                            var prevPos = stream.pos - 2;
                            if (prevPos >= 0) {
                                var prevCh = stream.string.charAt(prevPos);
                                if (prevCh !== '_' && prevCh.match(/(\w)/, false)) {
                                    ignoreUnderscore = true;
                                }
                            }
                        }
                    }
                    if (ch === '*' || (ch === '_' && !ignoreUnderscore)) {
                        if (sol && stream.peek() === ' ') {
                            // Do nothing, surrounded by newline and space
                        } else if (state.strong === ch && stream.eat(ch)) { // Remove STRONG
                            if (modeCfg.highlightFormatting) state.formatting = "strong";
                            var t = getType(state);
                            state.strong = false;
                            return t;
                        } else if (!state.strong && stream.eat(ch)) { // Add STRONG
                            state.strong = ch;
                            if (modeCfg.highlightFormatting) state.formatting = "strong";
                            return getType(state);
                        } else if (state.em === ch) { // Remove EM
                            if (modeCfg.highlightFormatting) state.formatting = "em";
                            var t = getType(state);
                            state.em = false;
                            return t;
                        } else if (!state.em) { // Add EM
                            state.em = ch;
                            if (modeCfg.highlightFormatting) state.formatting = "em";
                            return getType(state);
                        }
                    } else if (ch === ' ') {
                        if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces
                            if (stream.peek() === ' ') { // Surrounded by spaces, ignore
                                return getType(state);
                            } else { // Not surrounded by spaces, back up pointer
                                stream.backUp(1);
                            }
                        }
                    }

                    if (modeCfg.strikethrough) {
                        if (ch === '~' && stream.eatWhile(ch)) {
                            if (state.strikethrough) {// Remove strikethrough
                                if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
                                var t = getType(state);
                                state.strikethrough = false;
                                return t;
                            } else if (stream.match(/^[^\s]/, false)) {// Add strikethrough
                                state.strikethrough = true;
                                if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
                                return getType(state);
                            }
                        } else if (ch === ' ') {
                            if (stream.match(/^~~/, true)) { // Probably surrounded by space
                                if (stream.peek() === ' ') { // Surrounded by spaces, ignore
                                    return getType(state);
                                } else { // Not surrounded by spaces, back up pointer
                                    stream.backUp(2);
                                }
                            }
                        }
                    }

                    if (ch === ' ') {
                        if (stream.match(/ +$/, false)) {
                            state.trailingSpace++;
                        } else if (state.trailingSpace) {
                            state.trailingSpaceNewLine = true;
                        }
                    }

                    return getType(state);
                }

                function linkInline(stream, state) {
                    var ch = stream.next();

                    if (ch === ">") {
                        state.f = state.inline = inlineNormal;
                        if (modeCfg.highlightFormatting) state.formatting = "link";
                        var type = getType(state);
                        if (type){
                            type += " ";
                        } else {
                            type = "";
                        }
                        return type + tokenTypes.linkInline;
                    }

                    stream.match(/^[^>]+/, true);

                    return tokenTypes.linkInline;
                }

                function linkHref(stream, state) {
                    // Check if space, and return NULL if so (to avoid marking the space)
                    if(stream.eatSpace()){
                        return null;
                    }
                    var ch = stream.next();
                    if (ch === '(' || ch === '[') {
                        state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]", 0);
                        if (modeCfg.highlightFormatting) state.formatting = "link-string";
                        state.linkHref = true;
                        return getType(state);
                    }
                    return 'error';
                }

                var linkRE = {
                    ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
                    "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\\]]|\\.)*\])*?(?=\])/
                }

                function getLinkHrefInside(endChar) {
                    return function(stream, state) {
                        var ch = stream.next();

                        if (ch === endChar) {
                            state.f = state.inline = inlineNormal;
                            if (modeCfg.highlightFormatting) state.formatting = "link-string";
                            var returnState = getType(state);
                            state.linkHref = false;
                            return returnState;
                        }

                        stream.match(linkRE[endChar])
                        state.linkHref = true;
                        return getType(state);
                    };
                }

                function footnoteLink(stream, state) {
                    if (stream.match(/^([^\]\\]|\\.)*\]:/, false)) {
                        state.f = footnoteLinkInside;
                        stream.next(); // Consume [
                        if (modeCfg.highlightFormatting) state.formatting = "link";
                        state.linkText = true;
                        return getType(state);
                    }
                    return switchInline(stream, state, inlineNormal);
                }

                function footnoteLinkInside(stream, state) {
                    if (stream.match(/^\]:/, true)) {
                        state.f = state.inline = footnoteUrl;
                        if (modeCfg.highlightFormatting) state.formatting = "link";
                        var returnType = getType(state);
                        state.linkText = false;
                        return returnType;
                    }

                    stream.match(/^([^\]\\]|\\.)+/, true);

                    return tokenTypes.linkText;
                }

                function footnoteUrl(stream, state) {
                    // Check if space, and return NULL if so (to avoid marking the space)
                    if(stream.eatSpace()){
                        return null;
                    }
                    // Match URL
                    stream.match(/^[^\s]+/, true);
                    // Check for link title
                    if (stream.peek() === undefined) { // End of line, set flag to check next line
                        state.linkTitle = true;
                    } else { // More content on line, check if link title
                        stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
                    }
                    state.f = state.inline = inlineNormal;
                    return tokenTypes.linkHref + " url";
                }

                var mode = {
                    startState: function() {
                        return {
                            f: blockNormal,

                            prevLine: null,
                            thisLine: null,

                            block: blockNormal,
                            htmlState: null,
                            indentation: 0,

                            inline: inlineNormal,
                            text: handleText,

                            formatting: false,
                            linkText: false,
                            linkHref: false,
                            linkTitle: false,
                            code: 0,
                            em: false,
                            strong: false,
                            header: 0,
                            hr: false,
                            taskList: false,
                            list: false,
                            listStack: [],
                            quote: 0,
                            trailingSpace: 0,
                            trailingSpaceNewLine: false,
                            strikethrough: false,
                            fencedChars: null
                        };
                    },

                    copyState: function(s) {
                        return {
                            f: s.f,

                            prevLine: s.prevLine,
                            thisLine: s.thisLine,

                            block: s.block,
                            htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),
                            indentation: s.indentation,

                            localMode: s.localMode,
                            localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,

                            inline: s.inline,
                            text: s.text,
                            formatting: false,
                            linkTitle: s.linkTitle,
                            code: s.code,
                            em: s.em,
                            strong: s.strong,
                            strikethrough: s.strikethrough,
                            header: s.header,
                            hr: s.hr,
                            taskList: s.taskList,
                            list: s.list,
                            listStack: s.listStack.slice(0),
                            quote: s.quote,
                            indentedCode: s.indentedCode,
                            trailingSpace: s.trailingSpace,
                            trailingSpaceNewLine: s.trailingSpaceNewLine,
                            md_inside: s.md_inside,
                            fencedChars: s.fencedChars
                        };
                    },

                    token: function(stream, state) {

                        // Reset state.formatting
                        state.formatting = false;

                        if (stream != state.thisLine) {
                            var forceBlankLine = state.header || state.hr;

                            // Reset state.header and state.hr
                            state.header = 0;
                            state.hr = false;

                            if (stream.match(/^\s*$/, true) || forceBlankLine) {
                                blankLine(state);
                                if (!forceBlankLine) return null
                                state.prevLine = null
                            }

                            state.prevLine = state.thisLine
                            state.thisLine = stream

                            // Reset state.taskList
                            state.taskList = false;

                            // Reset state.trailingSpace
                            state.trailingSpace = 0;
                            state.trailingSpaceNewLine = false;

                            state.f = state.block;
                            var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, '    ').length;
                            state.indentationDiff = Math.min(indentation - state.indentation, 4);
                            state.indentation = state.indentation + state.indentationDiff;
                            if (indentation > 0) return null;
                        }
                        return state.f(stream, state);
                    },

                    innerMode: function(state) {
                        if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};
                        if (state.localState) return {state: state.localState, mode: state.localMode};
                        return {state: state, mode: mode};
                    },

                    blankLine: blankLine,

                    getType: getType,

                    fold: "markdown"
                };
                return mode;
            }, "xml");

            CodeMirror.defineMIME("text/x-markdown", "markdown");

        });

    },{"../../lib/codemirror":10,"../meta":13,"../xml/xml":14}],13:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

        (function(mod) {
            if (typeof exports == "object" && typeof module == "object") // CommonJS
                mod(require("../lib/codemirror"));
            else if (typeof define == "function" && define.amd) // AMD
                define(["../lib/codemirror"], mod);
            else // Plain browser env
                mod(CodeMirror);
        })(function(CodeMirror) {
            "use strict";

            CodeMirror.modeInfo = [
                {name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"]},
                {name: "PGP", mimes: ["application/pgp", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["pgp"]},
                {name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"]},
                {name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i},
                {name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"]},
                {name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h"]},
                {name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"]},
                {name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy"]},
                {name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp"]},
                {name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"]},
                {name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"]},
                {name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"]},
                {name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists.txt$/},
                {name: "CoffeeScript", mime: "text/x-coffeescript", mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"]},
                {name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"]},
                {name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"]},
                {name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"]},
                {name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"]},
                {name: "CSS", mime: "text/css", mode: "css", ext: ["css"]},
                {name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"]},
                {name: "D", mime: "text/x-d", mode: "d", ext: ["d"]},
                {name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"]},
                {name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"]},
                {name: "Django", mime: "text/x-django", mode: "django"},
                {name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/},
                {name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"]},
                {name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"]},
                {name: "EBNF", mime: "text/x-ebnf", mode: "ebnf"},
                {name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"]},
                {name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"]},
                {name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"]},
                {name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"]},
                {name: "Embedded Javascript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"]},
                {name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"]},
                {name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"]},
                {name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"]},
                {name: "FCL", mime: "text/x-fcl", mode: "fcl"},
                {name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"]},
                {name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90"]},
                {name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"]},
                {name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"]},
                {name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"]},
                {name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history).md$/i},
                {name: "Go", mime: "text/x-go", mode: "go", ext: ["go"]},
                {name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"]},
                {name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"]},
                {name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"]},
                {name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"]},
                {name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"]},
                {name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"]},
                {name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"]},
                {name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm"], alias: ["xhtml"]},
                {name: "HTTP", mime: "message/http", mode: "http"},
                {name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"]},
                {name: "Jade", mime: "text/x-jade", mode: "jade", ext: ["jade"]},
                {name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"]},
                {name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"]},
                {name: "JavaScript", mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
                    mode: "javascript", ext: ["js"], alias: ["ecmascript", "js", "node"]},
                {name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"]},
                {name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"]},
                {name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"]},
                {name: "Jinja2", mime: "null", mode: "jinja2"},
                {name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"]},
                {name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"]},
                {name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"]},
                {name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"]},
                {name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"]},
                {name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"]},
                {name: "mIRC", mime: "text/mirc", mode: "mirc"},
                {name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql"},
                {name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb"]},
                {name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"]},
                {name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"]},
                {name: "MS SQL", mime: "text/x-mssql", mode: "sql"},
                {name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"]},
                {name: "MySQL", mime: "text/x-mysql", mode: "sql"},
                {name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i},
                {name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"]},
                {name: "NTriples", mime: "text/n-triples", mode: "ntriples", ext: ["nt"]},
                {name: "Objective C", mime: "text/x-objectivec", mode: "clike", ext: ["m", "mm"], alias: ["objective-c", "objc"]},
                {name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"]},
                {name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"]},
                {name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"]},
                {name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"]},
                {name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"]},
                {name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"]},
                {name: "PHP", mime: "application/x-httpd-php", mode: "php", ext: ["php", "php3", "php4", "php5", "phtml"]},
                {name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"]},
                {name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"]},
                {name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"]},
                {name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"]},
                {name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"]},
                {name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"]},
                {name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/},
                {name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"]},
                {name: "Q", mime: "text/x-q", mode: "q", ext: ["q"]},
                {name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r"], alias: ["rscript"]},
                {name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"]},
                {name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm"},
                {name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"]},
                {name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"]},
                {name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"]},
                {name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"]},
                {name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"]},
                {name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"]},
                {name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"]},
                {name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"]},
                {name: "Shell", mime: "text/x-sh", mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/},
                {name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"]},
                {name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"]},
                {name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"]},
                {name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"]},
                {name: "Solr", mime: "text/x-solr", mode: "solr"},
                {name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"]},
                {name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"]},
                {name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"]},
                {name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"]},
                {name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"]},
                {name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"]},
                {name: "sTeX", mime: "text/x-stex", mode: "stex"},
                {name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx"], alias: ["tex"]},
                {name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v"]},
                {name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"]},
                {name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"]},
                {name: "TiddlyWiki ", mime: "text/x-tiddlywiki", mode: "tiddlywiki"},
                {name: "Tiki wiki", mime: "text/tiki", mode: "tiki"},
                {name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"]},
                {name: "Tornado", mime: "text/x-tornado", mode: "tornado"},
                {name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"]},
                {name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"]},
                {name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"]},
                {name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"]},
                {name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"]},
                {name: "Twig", mime: "text/x-twig", mode: "twig"},
                {name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"]},
                {name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"]},
                {name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"]},
                {name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"]},
                {name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"]},
                {name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"]},
                {name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd"], alias: ["rss", "wsdl", "xsd"]},
                {name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"]},
                {name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"]},
                {name: "YAML", mime: "text/x-yaml", mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"]},
                {name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"]},
                {name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"]},
                {name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"]},
                {name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"]}
            ];
            // Ensure all modes have a mime property for backwards compatibility
            for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
                var info = CodeMirror.modeInfo[i];
                if (info.mimes) info.mime = info.mimes[0];
            }

            CodeMirror.findModeByMIME = function(mime) {
                mime = mime.toLowerCase();
                for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
                    var info = CodeMirror.modeInfo[i];
                    if (info.mime == mime) return info;
                    if (info.mimes) for (var j = 0; j < info.mimes.length; j++)
                        if (info.mimes[j] == mime) return info;
                }
            };

            CodeMirror.findModeByExtension = function(ext) {
                for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
                    var info = CodeMirror.modeInfo[i];
                    if (info.ext) for (var j = 0; j < info.ext.length; j++)
                        if (info.ext[j] == ext) return info;
                }
            };

            CodeMirror.findModeByFileName = function(filename) {
                for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
                    var info = CodeMirror.modeInfo[i];
                    if (info.file && info.file.test(filename)) return info;
                }
                var dot = filename.lastIndexOf(".");
                var ext = dot > -1 && filename.substring(dot + 1, filename.length);
                if (ext) return CodeMirror.findModeByExtension(ext);
            };

            CodeMirror.findModeByName = function(name) {
                name = name.toLowerCase();
                for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
                    var info = CodeMirror.modeInfo[i];
                    if (info.name.toLowerCase() == name) return info;
                    if (info.alias) for (var j = 0; j < info.alias.length; j++)
                        if (info.alias[j].toLowerCase() == name) return info;
                }
            };
        });

    },{"../lib/codemirror":10}],14:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

        (function(mod) {
            if (typeof exports == "object" && typeof module == "object") // CommonJS
                mod(require("../../lib/codemirror"));
            else if (typeof define == "function" && define.amd) // AMD
                define(["../../lib/codemirror"], mod);
            else // Plain browser env
                mod(CodeMirror);
        })(function(CodeMirror) {
            "use strict";

            var htmlConfig = {
                autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                    'track': true, 'wbr': true, 'menuitem': true},
                implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                    'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                    'th': true, 'tr': true},
                contextGrabbers: {
                    'dd': {'dd': true, 'dt': true},
                    'dt': {'dd': true, 'dt': true},
                    'li': {'li': true},
                    'option': {'option': true, 'optgroup': true},
                    'optgroup': {'optgroup': true},
                    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
                        'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
                        'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
                        'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
                        'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
                    'rp': {'rp': true, 'rt': true},
                    'rt': {'rp': true, 'rt': true},
                    'tbody': {'tbody': true, 'tfoot': true},
                    'td': {'td': true, 'th': true},
                    'tfoot': {'tbody': true},
                    'th': {'td': true, 'th': true},
                    'thead': {'tbody': true, 'tfoot': true},
                    'tr': {'tr': true}
                },
                doNotIndent: {"pre": true},
                allowUnquoted: true,
                allowMissing: true,
                caseFold: true
            }

            var xmlConfig = {
                autoSelfClosers: {},
                implicitlyClosed: {},
                contextGrabbers: {},
                doNotIndent: {},
                allowUnquoted: false,
                allowMissing: false,
                caseFold: false
            }

            CodeMirror.defineMode("xml", function(editorConf, config_) {
                var indentUnit = editorConf.indentUnit
                var config = {}
                var defaults = config_.htmlMode ? htmlConfig : xmlConfig
                for (var prop in defaults) config[prop] = defaults[prop]
                for (var prop in config_) config[prop] = config_[prop]

                // Return variables for tokenizers
                var type, setStyle;

                function inText(stream, state) {
                    function chain(parser) {
                        state.tokenize = parser;
                        return parser(stream, state);
                    }

                    var ch = stream.next();
                    if (ch == "<") {
                        if (stream.eat("!")) {
                            if (stream.eat("[")) {
                                if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
                                else return null;
                            } else if (stream.match("--")) {
                                return chain(inBlock("comment", "-->"));
                            } else if (stream.match("DOCTYPE", true, true)) {
                                stream.eatWhile(/[\w\._\-]/);
                                return chain(doctype(1));
                            } else {
                                return null;
                            }
                        } else if (stream.eat("?")) {
                            stream.eatWhile(/[\w\._\-]/);
                            state.tokenize = inBlock("meta", "?>");
                            return "meta";
                        } else {
                            type = stream.eat("/") ? "closeTag" : "openTag";
                            state.tokenize = inTag;
                            return "tag bracket";
                        }
                    } else if (ch == "&") {
                        var ok;
                        if (stream.eat("#")) {
                            if (stream.eat("x")) {
                                ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
                            } else {
                                ok = stream.eatWhile(/[\d]/) && stream.eat(";");
                            }
                        } else {
                            ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
                        }
                        return ok ? "atom" : "error";
                    } else {
                        stream.eatWhile(/[^&<]/);
                        return null;
                    }
                }
                inText.isInText = true;

                function inTag(stream, state) {
                    var ch = stream.next();
                    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
                        state.tokenize = inText;
                        type = ch == ">" ? "endTag" : "selfcloseTag";
                        return "tag bracket";
                    } else if (ch == "=") {
                        type = "equals";
                        return null;
                    } else if (ch == "<") {
                        state.tokenize = inText;
                        state.state = baseState;
                        state.tagName = state.tagStart = null;
                        var next = state.tokenize(stream, state);
                        return next ? next + " tag error" : "tag error";
                    } else if (/[\'\"]/.test(ch)) {
                        state.tokenize = inAttribute(ch);
                        state.stringStartCol = stream.column();
                        return state.tokenize(stream, state);
                    } else {
                        stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
                        return "word";
                    }
                }

                function inAttribute(quote) {
                    var closure = function(stream, state) {
                        while (!stream.eol()) {
                            if (stream.next() == quote) {
                                state.tokenize = inTag;
                                break;
                            }
                        }
                        return "string";
                    };
                    closure.isInAttribute = true;
                    return closure;
                }

                function inBlock(style, terminator) {
                    return function(stream, state) {
                        while (!stream.eol()) {
                            if (stream.match(terminator)) {
                                state.tokenize = inText;
                                break;
                            }
                            stream.next();
                        }
                        return style;
                    };
                }
                function doctype(depth) {
                    return function(stream, state) {
                        var ch;
                        while ((ch = stream.next()) != null) {
                            if (ch == "<") {
                                state.tokenize = doctype(depth + 1);
                                return state.tokenize(stream, state);
                            } else if (ch == ">") {
                                if (depth == 1) {
                                    state.tokenize = inText;
                                    break;
                                } else {
                                    state.tokenize = doctype(depth - 1);
                                    return state.tokenize(stream, state);
                                }
                            }
                        }
                        return "meta";
                    };
                }

                function Context(state, tagName, startOfLine) {
                    this.prev = state.context;
                    this.tagName = tagName;
                    this.indent = state.indented;
                    this.startOfLine = startOfLine;
                    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
                        this.noIndent = true;
                }
                function popContext(state) {
                    if (state.context) state.context = state.context.prev;
                }
                function maybePopContext(state, nextTagName) {
                    var parentTagName;
                    while (true) {
                        if (!state.context) {
                            return;
                        }
                        parentTagName = state.context.tagName;
                        if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||
                            !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
                            return;
                        }
                        popContext(state);
                    }
                }

                function baseState(type, stream, state) {
                    if (type == "openTag") {
                        state.tagStart = stream.column();
                        return tagNameState;
                    } else if (type == "closeTag") {
                        return closeTagNameState;
                    } else {
                        return baseState;
                    }
                }
                function tagNameState(type, stream, state) {
                    if (type == "word") {
                        state.tagName = stream.current();
                        setStyle = "tag";
                        return attrState;
                    } else {
                        setStyle = "error";
                        return tagNameState;
                    }
                }
                function closeTagNameState(type, stream, state) {
                    if (type == "word") {
                        var tagName = stream.current();
                        if (state.context && state.context.tagName != tagName &&
                            config.implicitlyClosed.hasOwnProperty(state.context.tagName))
                            popContext(state);
                        if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
                            setStyle = "tag";
                            return closeState;
                        } else {
                            setStyle = "tag error";
                            return closeStateErr;
                        }
                    } else {
                        setStyle = "error";
                        return closeStateErr;
                    }
                }

                function closeState(type, _stream, state) {
                    if (type != "endTag") {
                        setStyle = "error";
                        return closeState;
                    }
                    popContext(state);
                    return baseState;
                }
                function closeStateErr(type, stream, state) {
                    setStyle = "error";
                    return closeState(type, stream, state);
                }

                function attrState(type, _stream, state) {
                    if (type == "word") {
                        setStyle = "attribute";
                        return attrEqState;
                    } else if (type == "endTag" || type == "selfcloseTag") {
                        var tagName = state.tagName, tagStart = state.tagStart;
                        state.tagName = state.tagStart = null;
                        if (type == "selfcloseTag" ||
                            config.autoSelfClosers.hasOwnProperty(tagName)) {
                            maybePopContext(state, tagName);
                        } else {
                            maybePopContext(state, tagName);
                            state.context = new Context(state, tagName, tagStart == state.indented);
                        }
                        return baseState;
                    }
                    setStyle = "error";
                    return attrState;
                }
                function attrEqState(type, stream, state) {
                    if (type == "equals") return attrValueState;
                    if (!config.allowMissing) setStyle = "error";
                    return attrState(type, stream, state);
                }
                function attrValueState(type, stream, state) {
                    if (type == "string") return attrContinuedState;
                    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
                    setStyle = "error";
                    return attrState(type, stream, state);
                }
                function attrContinuedState(type, stream, state) {
                    if (type == "string") return attrContinuedState;
                    return attrState(type, stream, state);
                }

                return {
                    startState: function(baseIndent) {
                        var state = {tokenize: inText,
                            state: baseState,
                            indented: baseIndent || 0,
                            tagName: null, tagStart: null,
                            context: null}
                        if (baseIndent != null) state.baseIndent = baseIndent
                        return state
                    },

                    token: function(stream, state) {
                        if (!state.tagName && stream.sol())
                            state.indented = stream.indentation();

                        if (stream.eatSpace()) return null;
                        type = null;
                        var style = state.tokenize(stream, state);
                        if ((style || type) && style != "comment") {
                            setStyle = null;
                            state.state = state.state(type || style, stream, state);
                            if (setStyle)
                                style = setStyle == "error" ? style + " error" : setStyle;
                        }
                        return style;
                    },

                    indent: function(state, textAfter, fullLine) {
                        var context = state.context;
                        // Indent multi-line strings (e.g. css).
                        if (state.tokenize.isInAttribute) {
                            if (state.tagStart == state.indented)
                                return state.stringStartCol + 1;
                            else
                                return state.indented + indentUnit;
                        }
                        if (context && context.noIndent) return CodeMirror.Pass;
                        if (state.tokenize != inTag && state.tokenize != inText)
                            return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
                        // Indent the starts of attribute names.
                        if (state.tagName) {
                            if (config.multilineTagIndentPastTag !== false)
                                return state.tagStart + state.tagName.length + 2;
                            else
                                return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
                        }
                        if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
                        var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
                        if (tagAfter && tagAfter[1]) { // Closing tag spotted
                            while (context) {
                                if (context.tagName == tagAfter[2]) {
                                    context = context.prev;
                                    break;
                                } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
                                    context = context.prev;
                                } else {
                                    break;
                                }
                            }
                        } else if (tagAfter) { // Opening tag spotted
                            while (context) {
                                var grabbers = config.contextGrabbers[context.tagName];
                                if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
                                    context = context.prev;
                                else
                                    break;
                            }
                        }
                        while (context && context.prev && !context.startOfLine)
                            context = context.prev;
                        if (context) return context.indent + indentUnit;
                        else return state.baseIndent || 0;
                    },

                    electricInput: /<\/[\s\w:]+>$/,
                    blockCommentStart: "<!--",
                    blockCommentEnd: "-->",

                    configuration: config.htmlMode ? "html" : "xml",
                    helperType: config.htmlMode ? "html" : "xml",

                    skipAttribute: function(state) {
                        if (state.state == attrValueState)
                            state.state = attrState
                    }
                };
            });

            CodeMirror.defineMIME("text/xml", "xml");
            CodeMirror.defineMIME("application/xml", "xml");
            if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
                CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

        });

    },{"../../lib/codemirror":10}],15:[function(require,module,exports){
        exports.read = function (buffer, offset, isLE, mLen, nBytes) {
            var e, m
            var eLen = nBytes * 8 - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var nBits = -7
            var i = isLE ? (nBytes - 1) : 0
            var d = isLE ? -1 : 1
            var s = buffer[offset + i]

            i += d

            e = s & ((1 << (-nBits)) - 1)
            s >>= (-nBits)
            nBits += eLen
            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

            m = e & ((1 << (-nBits)) - 1)
            e >>= (-nBits)
            nBits += mLen
            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

            if (e === 0) {
                e = 1 - eBias
            } else if (e === eMax) {
                return m ? NaN : ((s ? -1 : 1) * Infinity)
            } else {
                m = m + Math.pow(2, mLen)
                e = e - eBias
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
        }

        exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c
            var eLen = nBytes * 8 - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
            var i = isLE ? 0 : (nBytes - 1)
            var d = isLE ? 1 : -1
            var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

            value = Math.abs(value)

            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0
                e = eMax
            } else {
                e = Math.floor(Math.log(value) / Math.LN2)
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--
                    c *= 2
                }
                if (e + eBias >= 1) {
                    value += rt / c
                } else {
                    value += rt * Math.pow(2, 1 - eBias)
                }
                if (value * c >= 2) {
                    e++
                    c /= 2
                }

                if (e + eBias >= eMax) {
                    m = 0
                    e = eMax
                } else if (e + eBias >= 1) {
                    m = (value * c - 1) * Math.pow(2, mLen)
                    e = e + eBias
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
                    e = 0
                }
            }

            for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

            e = (e << mLen) | m
            eLen += mLen
            for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

            buffer[offset + i - d] |= s * 128
        }

    },{}],16:[function(require,module,exports){
        var toString = {}.toString;

        module.exports = Array.isArray || function (arr) {
            return toString.call(arr) == '[object Array]';
        };

    },{}],17:[function(require,module,exports){
        (function (global){
            /**
             * marked - a markdown parser
             * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
             * https://github.com/chjj/marked
             */

            ;(function() {

                /**
                 * Block-Level Grammar
                 */

                var block = {
                    newline: /^\n+/,
                    code: /^( {4}[^\n]+\n*)+/,
                    fences: noop,
                    hr: /^( *[-*_]){3,} *(?:\n+|$)/,
                    heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
                    nptable: noop,
                    lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
                    blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
                    list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
                    html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
                    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
                    table: noop,
                    paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
                    text: /^[^\n]+/
                };

                block.bullet = /(?:[*+-]|\d+\.)/;
                block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
                block.item = replace(block.item, 'gm')
                (/bull/g, block.bullet)
                ();

                block.list = replace(block.list)
                (/bull/g, block.bullet)
                ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
                ('def', '\\n+(?=' + block.def.source + ')')
                ();

                block.blockquote = replace(block.blockquote)
                ('def', block.def)
                ();

                block._tag = '(?!(?:'
                    + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
                    + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
                    + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

                block.html = replace(block.html)
                ('comment', /<!--[\s\S]*?-->/)
                ('closed', /<(tag)[\s\S]+?<\/\1>/)
                ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
                (/tag/g, block._tag)
                ();

                block.paragraph = replace(block.paragraph)
                ('hr', block.hr)
                ('heading', block.heading)
                ('lheading', block.lheading)
                ('blockquote', block.blockquote)
                ('tag', '<' + block._tag)
                ('def', block.def)
                ();

                /**
                 * Normal Block Grammar
                 */

                block.normal = merge({}, block);

                /**
                 * GFM Block Grammar
                 */

                block.gfm = merge({}, block.normal, {
                    fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
                    paragraph: /^/,
                    heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
                });

                block.gfm.paragraph = replace(block.paragraph)
                ('(?!', '(?!'
                    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
                    + block.list.source.replace('\\1', '\\3') + '|')
                ();

                /**
                 * GFM + Tables Block Grammar
                 */

                block.tables = merge({}, block.gfm, {
                    nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
                    table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
                });

                /**
                 * Block Lexer
                 */

                function Lexer(options) {
                    this.tokens = [];
                    this.tokens.links = {};
                    this.options = options || marked.defaults;
                    this.rules = block.normal;

                    if (this.options.gfm) {
                        if (this.options.tables) {
                            this.rules = block.tables;
                        } else {
                            this.rules = block.gfm;
                        }
                    }
                }

                /**
                 * Expose Block Rules
                 */

                Lexer.rules = block;

                /**
                 * Static Lex Method
                 */

                Lexer.lex = function(src, options) {
                    var lexer = new Lexer(options);
                    return lexer.lex(src);
                };

                /**
                 * Preprocessing
                 */

                Lexer.prototype.lex = function(src) {
                    src = src
                        .replace(/\r\n|\r/g, '\n')
                        .replace(/\t/g, '    ')
                        .replace(/\u00a0/g, ' ')
                        .replace(/\u2424/g, '\n');

                    return this.token(src, true);
                };

                /**
                 * Lexing
                 */

                Lexer.prototype.token = function(src, top, bq) {
                    var src = src.replace(/^ +$/gm, '')
                        , next
                        , loose
                        , cap
                        , bull
                        , b
                        , item
                        , space
                        , i
                        , l;

                    while (src) {
                        // newline
                        if (cap = this.rules.newline.exec(src)) {
                            src = src.substring(cap[0].length);
                            if (cap[0].length > 1) {
                                this.tokens.push({
                                    type: 'space'
                                });
                            }
                        }

                        // code
                        if (cap = this.rules.code.exec(src)) {
                            src = src.substring(cap[0].length);
                            cap = cap[0].replace(/^ {4}/gm, '');
                            this.tokens.push({
                                type: 'code',
                                text: !this.options.pedantic
                                    ? cap.replace(/\n+$/, '')
                                    : cap
                            });
                            continue;
                        }

                        // fences (gfm)
                        if (cap = this.rules.fences.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'code',
                                lang: cap[2],
                                text: cap[3] || ''
                            });
                            continue;
                        }

                        // heading
                        if (cap = this.rules.heading.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'heading',
                                depth: cap[1].length,
                                text: cap[2]
                            });
                            continue;
                        }

                        // table no leading pipe (gfm)
                        if (top && (cap = this.rules.nptable.exec(src))) {
                            src = src.substring(cap[0].length);

                            item = {
                                type: 'table',
                                header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
                                align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
                                cells: cap[3].replace(/\n$/, '').split('\n')
                            };

                            for (i = 0; i < item.align.length; i++) {
                                if (/^ *-+: *$/.test(item.align[i])) {
                                    item.align[i] = 'right';
                                } else if (/^ *:-+: *$/.test(item.align[i])) {
                                    item.align[i] = 'center';
                                } else if (/^ *:-+ *$/.test(item.align[i])) {
                                    item.align[i] = 'left';
                                } else {
                                    item.align[i] = null;
                                }
                            }

                            for (i = 0; i < item.cells.length; i++) {
                                item.cells[i] = item.cells[i].split(/ *\| */);
                            }

                            this.tokens.push(item);

                            continue;
                        }

                        // lheading
                        if (cap = this.rules.lheading.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'heading',
                                depth: cap[2] === '=' ? 1 : 2,
                                text: cap[1]
                            });
                            continue;
                        }

                        // hr
                        if (cap = this.rules.hr.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'hr'
                            });
                            continue;
                        }

                        // blockquote
                        if (cap = this.rules.blockquote.exec(src)) {
                            src = src.substring(cap[0].length);

                            this.tokens.push({
                                type: 'blockquote_start'
                            });

                            cap = cap[0].replace(/^ *> ?/gm, '');

                            // Pass `top` to keep the current
                            // "toplevel" state. This is exactly
                            // how markdown.pl works.
                            this.token(cap, top, true);

                            this.tokens.push({
                                type: 'blockquote_end'
                            });

                            continue;
                        }

                        // list
                        if (cap = this.rules.list.exec(src)) {
                            src = src.substring(cap[0].length);
                            bull = cap[2];

                            this.tokens.push({
                                type: 'list_start',
                                ordered: bull.length > 1
                            });

                            // Get each top-level item.
                            cap = cap[0].match(this.rules.item);

                            next = false;
                            l = cap.length;
                            i = 0;

                            for (; i < l; i++) {
                                item = cap[i];

                                // Remove the list item's bullet
                                // so it is seen as the next token.
                                space = item.length;
                                item = item.replace(/^ *([*+-]|\d+\.) +/, '');

                                // Outdent whatever the
                                // list item contains. Hacky.
                                if (~item.indexOf('\n ')) {
                                    space -= item.length;
                                    item = !this.options.pedantic
                                        ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
                                        : item.replace(/^ {1,4}/gm, '');
                                }

                                // Determine whether the next list item belongs here.
                                // Backpedal if it does not belong in this list.
                                if (this.options.smartLists && i !== l - 1) {
                                    b = block.bullet.exec(cap[i + 1])[0];
                                    if (bull !== b && !(bull.length > 1 && b.length > 1)) {
                                        src = cap.slice(i + 1).join('\n') + src;
                                        i = l - 1;
                                    }
                                }

                                // Determine whether item is loose or not.
                                // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
                                // for discount behavior.
                                loose = next || /\n\n(?!\s*$)/.test(item);
                                if (i !== l - 1) {
                                    next = item.charAt(item.length - 1) === '\n';
                                    if (!loose) loose = next;
                                }

                                this.tokens.push({
                                    type: loose
                                        ? 'loose_item_start'
                                        : 'list_item_start'
                                });

                                // Recurse.
                                this.token(item, false, bq);

                                this.tokens.push({
                                    type: 'list_item_end'
                                });
                            }

                            this.tokens.push({
                                type: 'list_end'
                            });

                            continue;
                        }

                        // html
                        if (cap = this.rules.html.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: this.options.sanitize
                                    ? 'paragraph'
                                    : 'html',
                                pre: !this.options.sanitizer
                                && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
                                text: cap[0]
                            });
                            continue;
                        }

                        // def
                        if ((!bq && top) && (cap = this.rules.def.exec(src))) {
                            src = src.substring(cap[0].length);
                            this.tokens.links[cap[1].toLowerCase()] = {
                                href: cap[2],
                                title: cap[3]
                            };
                            continue;
                        }

                        // table (gfm)
                        if (top && (cap = this.rules.table.exec(src))) {
                            src = src.substring(cap[0].length);

                            item = {
                                type: 'table',
                                header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
                                align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
                                cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
                            };

                            for (i = 0; i < item.align.length; i++) {
                                if (/^ *-+: *$/.test(item.align[i])) {
                                    item.align[i] = 'right';
                                } else if (/^ *:-+: *$/.test(item.align[i])) {
                                    item.align[i] = 'center';
                                } else if (/^ *:-+ *$/.test(item.align[i])) {
                                    item.align[i] = 'left';
                                } else {
                                    item.align[i] = null;
                                }
                            }

                            for (i = 0; i < item.cells.length; i++) {
                                item.cells[i] = item.cells[i]
                                    .replace(/^ *\| *| *\| *$/g, '')
                                    .split(/ *\| */);
                            }

                            this.tokens.push(item);

                            continue;
                        }

                        // top-level paragraph
                        if (top && (cap = this.rules.paragraph.exec(src))) {
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'paragraph',
                                text: cap[1].charAt(cap[1].length - 1) === '\n'
                                    ? cap[1].slice(0, -1)
                                    : cap[1]
                            });
                            continue;
                        }

                        // text
                        if (cap = this.rules.text.exec(src)) {
                            // Top-level should never reach here.
                            src = src.substring(cap[0].length);
                            this.tokens.push({
                                type: 'text',
                                text: cap[0]
                            });
                            continue;
                        }

                        if (src) {
                            throw new
                            Error('Infinite loop on byte: ' + src.charCodeAt(0));
                        }
                    }

                    return this.tokens;
                };

                /**
                 * Inline-Level Grammar
                 */

                var inline = {
                    escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
                    autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
                    url: noop,
                    tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
                    link: /^!?\[(inside)\]\(href\)/,
                    reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
                    nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
                    strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
                    em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
                    code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
                    br: /^ {2,}\n(?!\s*$)/,
                    del: noop,
                    text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
                };

                inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
                inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

                inline.link = replace(inline.link)
                ('inside', inline._inside)
                ('href', inline._href)
                ();

                inline.reflink = replace(inline.reflink)
                ('inside', inline._inside)
                ();

                /**
                 * Normal Inline Grammar
                 */

                inline.normal = merge({}, inline);

                /**
                 * Pedantic Inline Grammar
                 */

                inline.pedantic = merge({}, inline.normal, {
                    strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
                    em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
                });

                /**
                 * GFM Inline Grammar
                 */

                inline.gfm = merge({}, inline.normal, {
                    escape: replace(inline.escape)('])', '~|])')(),
                    url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
                    del: /^~~(?=\S)([\s\S]*?\S)~~/,
                    text: replace(inline.text)
                    (']|', '~]|')
                    ('|', '|https?://|')
                    ()
                });

                /**
                 * GFM + Line Breaks Inline Grammar
                 */

                inline.breaks = merge({}, inline.gfm, {
                    br: replace(inline.br)('{2,}', '*')(),
                    text: replace(inline.gfm.text)('{2,}', '*')()
                });

                /**
                 * Inline Lexer & Compiler
                 */

                function InlineLexer(links, options) {
                    this.options = options || marked.defaults;
                    this.links = links;
                    this.rules = inline.normal;
                    this.renderer = this.options.renderer || new Renderer;
                    this.renderer.options = this.options;

                    if (!this.links) {
                        throw new
                        Error('Tokens array requires a `links` property.');
                    }

                    if (this.options.gfm) {
                        if (this.options.breaks) {
                            this.rules = inline.breaks;
                        } else {
                            this.rules = inline.gfm;
                        }
                    } else if (this.options.pedantic) {
                        this.rules = inline.pedantic;
                    }
                }

                /**
                 * Expose Inline Rules
                 */

                InlineLexer.rules = inline;

                /**
                 * Static Lexing/Compiling Method
                 */

                InlineLexer.output = function(src, links, options) {
                    var inline = new InlineLexer(links, options);
                    return inline.output(src);
                };

                /**
                 * Lexing/Compiling
                 */

                InlineLexer.prototype.output = function(src) {
                    var out = ''
                        , link
                        , text
                        , href
                        , cap;

                    while (src) {
                        // escape
                        if (cap = this.rules.escape.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += cap[1];
                            continue;
                        }

                        // autolink
                        if (cap = this.rules.autolink.exec(src)) {
                            src = src.substring(cap[0].length);
                            if (cap[2] === '@') {
                                text = cap[1].charAt(6) === ':'
                                    ? this.mangle(cap[1].substring(7))
                                    : this.mangle(cap[1]);
                                href = this.mangle('mailto:') + text;
                            } else {
                                text = escape(cap[1]);
                                href = text;
                            }
                            out += this.renderer.link(href, null, text);
                            continue;
                        }

                        // url (gfm)
                        if (!this.inLink && (cap = this.rules.url.exec(src))) {
                            src = src.substring(cap[0].length);
                            text = escape(cap[1]);
                            href = text;
                            out += this.renderer.link(href, null, text);
                            continue;
                        }

                        // tag
                        if (cap = this.rules.tag.exec(src)) {
                            if (!this.inLink && /^<a /i.test(cap[0])) {
                                this.inLink = true;
                            } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
                                this.inLink = false;
                            }
                            src = src.substring(cap[0].length);
                            out += this.options.sanitize
                                ? this.options.sanitizer
                                    ? this.options.sanitizer(cap[0])
                                    : escape(cap[0])
                                : cap[0]
                            continue;
                        }

                        // link
                        if (cap = this.rules.link.exec(src)) {
                            src = src.substring(cap[0].length);
                            this.inLink = true;
                            out += this.outputLink(cap, {
                                href: cap[2],
                                title: cap[3]
                            });
                            this.inLink = false;
                            continue;
                        }

                        // reflink, nolink
                        if ((cap = this.rules.reflink.exec(src))
                            || (cap = this.rules.nolink.exec(src))) {
                            src = src.substring(cap[0].length);
                            link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
                            link = this.links[link.toLowerCase()];
                            if (!link || !link.href) {
                                out += cap[0].charAt(0);
                                src = cap[0].substring(1) + src;
                                continue;
                            }
                            this.inLink = true;
                            out += this.outputLink(cap, link);
                            this.inLink = false;
                            continue;
                        }

                        // strong
                        if (cap = this.rules.strong.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.strong(this.output(cap[2] || cap[1]));
                            continue;
                        }

                        // em
                        if (cap = this.rules.em.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.em(this.output(cap[2] || cap[1]));
                            continue;
                        }

                        // code
                        if (cap = this.rules.code.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.codespan(escape(cap[2], true));
                            continue;
                        }

                        // br
                        if (cap = this.rules.br.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.br();
                            continue;
                        }

                        // del (gfm)
                        if (cap = this.rules.del.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.del(this.output(cap[1]));
                            continue;
                        }

                        // text
                        if (cap = this.rules.text.exec(src)) {
                            src = src.substring(cap[0].length);
                            out += this.renderer.text(escape(this.smartypants(cap[0])));
                            continue;
                        }

                        if (src) {
                            throw new
                            Error('Infinite loop on byte: ' + src.charCodeAt(0));
                        }
                    }

                    return out;
                };

                /**
                 * Compile Link
                 */

                InlineLexer.prototype.outputLink = function(cap, link) {
                    var href = escape(link.href)
                        , title = link.title ? escape(link.title) : null;

                    return cap[0].charAt(0) !== '!'
                        ? this.renderer.link(href, title, this.output(cap[1]))
                        : this.renderer.image(href, title, escape(cap[1]));
                };

                /**
                 * Smartypants Transformations
                 */

                InlineLexer.prototype.smartypants = function(text) {
                    if (!this.options.smartypants) return text;
                    return text
                    // em-dashes
                        .replace(/---/g, '\u2014')
                        // en-dashes
                        .replace(/--/g, '\u2013')
                        // opening singles
                        .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
                        // closing singles & apostrophes
                        .replace(/'/g, '\u2019')
                        // opening doubles
                        .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
                        // closing doubles
                        .replace(/"/g, '\u201d')
                        // ellipses
                        .replace(/\.{3}/g, '\u2026');
                };

                /**
                 * Mangle Links
                 */

                InlineLexer.prototype.mangle = function(text) {
                    if (!this.options.mangle) return text;
                    var out = ''
                        , l = text.length
                        , i = 0
                        , ch;

                    for (; i < l; i++) {
                        ch = text.charCodeAt(i);
                        if (Math.random() > 0.5) {
                            ch = 'x' + ch.toString(16);
                        }
                        out += '&#' + ch + ';';
                    }

                    return out;
                };

                /**
                 * Renderer
                 */

                function Renderer(options) {
                    this.options = options || {};
                }

                Renderer.prototype.code = function(code, lang, escaped) {
                    if (this.options.highlight) {
                        var out = this.options.highlight(code, lang);
                        if (out != null && out !== code) {
                            escaped = true;
                            code = out;
                        }
                    }

                    if (!lang) {
                        return '<pre><code>'
                            + (escaped ? code : escape(code, true))
                            + '\n</code></pre>';
                    }

                    return '<pre><code class="'
                        + this.options.langPrefix
                        + escape(lang, true)
                        + '">'
                        + (escaped ? code : escape(code, true))
                        + '\n</code></pre>\n';
                };

                Renderer.prototype.blockquote = function(quote) {
                    return '<blockquote>\n' + quote + '</blockquote>\n';
                };

                Renderer.prototype.html = function(html) {
                    return html;
                };

                Renderer.prototype.heading = function(text, level, raw) {
                    return '<h'
                        + level
                        + ' id="'
                        + this.options.headerPrefix
                        + raw.toLowerCase().replace(/[^\w]+/g, '-')
                        + '">'
                        + text
                        + '</h'
                        + level
                        + '>\n';
                };

                Renderer.prototype.hr = function() {
                    return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
                };

                Renderer.prototype.list = function(body, ordered) {
                    var type = ordered ? 'ol' : 'ul';
                    return '<' + type + '>\n' + body + '</' + type + '>\n';
                };

                Renderer.prototype.listitem = function(text) {
                    return '<li>' + text + '</li>\n';
                };

                Renderer.prototype.paragraph = function(text) {
                    return '<p>' + text + '</p>\n';
                };

                Renderer.prototype.table = function(header, body) {
                    return '<table>\n'
                        + '<thead>\n'
                        + header
                        + '</thead>\n'
                        + '<tbody>\n'
                        + body
                        + '</tbody>\n'
                        + '</table>\n';
                };

                Renderer.prototype.tablerow = function(content) {
                    return '<tr>\n' + content + '</tr>\n';
                };

                Renderer.prototype.tablecell = function(content, flags) {
                    var type = flags.header ? 'th' : 'td';
                    var tag = flags.align
                        ? '<' + type + ' style="text-align:' + flags.align + '">'
                        : '<' + type + '>';
                    return tag + content + '</' + type + '>\n';
                };

// span level renderer
                Renderer.prototype.strong = function(text) {
                    return '<strong>' + text + '</strong>';
                };

                Renderer.prototype.em = function(text) {
                    return '<em>' + text + '</em>';
                };

                Renderer.prototype.codespan = function(text) {
                    return '<code>' + text + '</code>';
                };

                Renderer.prototype.br = function() {
                    return this.options.xhtml ? '<br/>' : '<br>';
                };

                Renderer.prototype.del = function(text) {
                    return '<del>' + text + '</del>';
                };

                Renderer.prototype.link = function(href, title, text) {
                    if (this.options.sanitize) {
                        try {
                            var prot = decodeURIComponent(unescape(href))
                                .replace(/[^\w:]/g, '')
                                .toLowerCase();
                        } catch (e) {
                            return '';
                        }
                        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
                            return '';
                        }
                    }
                    var out = '<a href="' + href + '"';
                    if (title) {
                        out += ' title="' + title + '"';
                    }
                    out += '>' + text + '</a>';
                    return out;
                };

                Renderer.prototype.image = function(href, title, text) {
                    var out = '<img src="' + href + '" alt="' + text + '"';
                    if (title) {
                        out += ' title="' + title + '"';
                    }
                    out += this.options.xhtml ? '/>' : '>';
                    return out;
                };

                Renderer.prototype.text = function(text) {
                    return text;
                };

                /**
                 * Parsing & Compiling
                 */

                function Parser(options) {
                    this.tokens = [];
                    this.token = null;
                    this.options = options || marked.defaults;
                    this.options.renderer = this.options.renderer || new Renderer;
                    this.renderer = this.options.renderer;
                    this.renderer.options = this.options;
                }

                /**
                 * Static Parse Method
                 */

                Parser.parse = function(src, options, renderer) {
                    var parser = new Parser(options, renderer);
                    return parser.parse(src);
                };

                /**
                 * Parse Loop
                 */

                Parser.prototype.parse = function(src) {
                    this.inline = new InlineLexer(src.links, this.options, this.renderer);
                    this.tokens = src.reverse();

                    var out = '';
                    while (this.next()) {
                        out += this.tok();
                    }

                    return out;
                };

                /**
                 * Next Token
                 */

                Parser.prototype.next = function() {
                    return this.token = this.tokens.pop();
                };

                /**
                 * Preview Next Token
                 */

                Parser.prototype.peek = function() {
                    return this.tokens[this.tokens.length - 1] || 0;
                };

                /**
                 * Parse Text Tokens
                 */

                Parser.prototype.parseText = function() {
                    var body = this.token.text;

                    while (this.peek().type === 'text') {
                        body += '\n' + this.next().text;
                    }

                    return this.inline.output(body);
                };

                /**
                 * Parse Current Token
                 */

                Parser.prototype.tok = function() {
                    switch (this.token.type) {
                        case 'space': {
                            return '';
                        }
                        case 'hr': {
                            return this.renderer.hr();
                        }
                        case 'heading': {
                            return this.renderer.heading(
                                this.inline.output(this.token.text),
                                this.token.depth,
                                this.token.text);
                        }
                        case 'code': {
                            return this.renderer.code(this.token.text,
                                this.token.lang,
                                this.token.escaped);
                        }
                        case 'table': {
                            var header = ''
                                , body = ''
                                , i
                                , row
                                , cell
                                , flags
                                , j;

                            // header
                            cell = '';
                            for (i = 0; i < this.token.header.length; i++) {
                                flags = { header: true, align: this.token.align[i] };
                                cell += this.renderer.tablecell(
                                    this.inline.output(this.token.header[i]),
                                    { header: true, align: this.token.align[i] }
                                );
                            }
                            header += this.renderer.tablerow(cell);

                            for (i = 0; i < this.token.cells.length; i++) {
                                row = this.token.cells[i];

                                cell = '';
                                for (j = 0; j < row.length; j++) {
                                    cell += this.renderer.tablecell(
                                        this.inline.output(row[j]),
                                        { header: false, align: this.token.align[j] }
                                    );
                                }

                                body += this.renderer.tablerow(cell);
                            }
                            return this.renderer.table(header, body);
                        }
                        case 'blockquote_start': {
                            var body = '';

                            while (this.next().type !== 'blockquote_end') {
                                body += this.tok();
                            }

                            return this.renderer.blockquote(body);
                        }
                        case 'list_start': {
                            var body = ''
                                , ordered = this.token.ordered;

                            while (this.next().type !== 'list_end') {
                                body += this.tok();
                            }

                            return this.renderer.list(body, ordered);
                        }
                        case 'list_item_start': {
                            var body = '';

                            while (this.next().type !== 'list_item_end') {
                                body += this.token.type === 'text'
                                    ? this.parseText()
                                    : this.tok();
                            }

                            return this.renderer.listitem(body);
                        }
                        case 'loose_item_start': {
                            var body = '';

                            while (this.next().type !== 'list_item_end') {
                                body += this.tok();
                            }

                            return this.renderer.listitem(body);
                        }
                        case 'html': {
                            var html = !this.token.pre && !this.options.pedantic
                                ? this.inline.output(this.token.text)
                                : this.token.text;
                            return this.renderer.html(html);
                        }
                        case 'paragraph': {
                            return this.renderer.paragraph(this.inline.output(this.token.text));
                        }
                        case 'text': {
                            return this.renderer.paragraph(this.parseText());
                        }
                    }
                };

                /**
                 * Helpers
                 */

                function escape(html, encode) {
                    return html
                        .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                }

                function unescape(html) {
                    return html.replace(/&([#\w]+);/g, function(_, n) {
                        n = n.toLowerCase();
                        if (n === 'colon') return ':';
                        if (n.charAt(0) === '#') {
                            return n.charAt(1) === 'x'
                                ? String.fromCharCode(parseInt(n.substring(2), 16))
                                : String.fromCharCode(+n.substring(1));
                        }
                        return '';
                    });
                }

                function replace(regex, opt) {
                    regex = regex.source;
                    opt = opt || '';
                    return function self(name, val) {
                        if (!name) return new RegExp(regex, opt);
                        val = val.source || val;
                        val = val.replace(/(^|[^\[])\^/g, '$1');
                        regex = regex.replace(name, val);
                        return self;
                    };
                }

                function noop() {}
                noop.exec = noop;

                function merge(obj) {
                    var i = 1
                        , target
                        , key;

                    for (; i < arguments.length; i++) {
                        target = arguments[i];
                        for (key in target) {
                            if (Object.prototype.hasOwnProperty.call(target, key)) {
                                obj[key] = target[key];
                            }
                        }
                    }

                    return obj;
                }


                /**
                 * Marked
                 */

                function marked(src, opt, callback) {
                    if (callback || typeof opt === 'function') {
                        if (!callback) {
                            callback = opt;
                            opt = null;
                        }

                        opt = merge({}, marked.defaults, opt || {});

                        var highlight = opt.highlight
                            , tokens
                            , pending
                            , i = 0;

                        try {
                            tokens = Lexer.lex(src, opt)
                        } catch (e) {
                            return callback(e);
                        }

                        pending = tokens.length;

                        var done = function(err) {
                            if (err) {
                                opt.highlight = highlight;
                                return callback(err);
                            }

                            var out;

                            try {
                                out = Parser.parse(tokens, opt);
                            } catch (e) {
                                err = e;
                            }

                            opt.highlight = highlight;

                            return err
                                ? callback(err)
                                : callback(null, out);
                        };

                        if (!highlight || highlight.length < 3) {
                            return done();
                        }

                        delete opt.highlight;

                        if (!pending) return done();

                        for (; i < tokens.length; i++) {
                            (function(token) {
                                if (token.type !== 'code') {
                                    return --pending || done();
                                }
                                return highlight(token.text, token.lang, function(err, code) {
                                    if (err) return done(err);
                                    if (code == null || code === token.text) {
                                        return --pending || done();
                                    }
                                    token.text = code;
                                    token.escaped = true;
                                    --pending || done();
                                });
                            })(tokens[i]);
                        }

                        return;
                    }
                    try {
                        if (opt) opt = merge({}, marked.defaults, opt);
                        return Parser.parse(Lexer.lex(src, opt), opt);
                    } catch (e) {
                        e.message += '\nPlease report this to https://github.com/chjj/marked.';
                        if ((opt || marked.defaults).silent) {
                            return '<p>An error occured:</p><pre>'
                                + escape(e.message + '', true)
                                + '</pre>';
                        }
                        throw e;
                    }
                }

                /**
                 * Options
                 */

                marked.options =
                    marked.setOptions = function(opt) {
                        merge(marked.defaults, opt);
                        return marked;
                    };

                marked.defaults = {
                    gfm: true,
                    tables: true,
                    breaks: false,
                    pedantic: false,
                    sanitize: false,
                    sanitizer: null,
                    mangle: true,
                    smartLists: false,
                    silent: false,
                    highlight: null,
                    langPrefix: 'lang-',
                    smartypants: false,
                    headerPrefix: '',
                    renderer: new Renderer,
                    xhtml: false
                };

                /**
                 * Expose
                 */

                marked.Parser = Parser;
                marked.parser = Parser.parse;

                marked.Renderer = Renderer;

                marked.Lexer = Lexer;
                marked.lexer = Lexer.lex;

                marked.InlineLexer = InlineLexer;
                marked.inlineLexer = InlineLexer.output;

                marked.parse = marked;

                if (typeof module !== 'undefined' && typeof exports === 'object') {
                    module.exports = marked;
                } else if (typeof define === 'function' && define.amd) {
                    define(function() { return marked; });
                } else {
                    this.marked = marked;
                }

            }).call(function() {
                return this || (typeof window !== 'undefined' ? window : global);
            }());

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{}],18:[function(require,module,exports){
        (function (Buffer,__dirname){
            'use strict';

            /**
             * Typo is a JavaScript implementation of a spellchecker using hunspell-style
             * dictionaries.
             */

            /**
             * Typo constructor.
             *
             * @param {String} [dictionary] The locale code of the dictionary being used. e.g.,
             *                              "en_US". This is only used to auto-load dictionaries.
             * @param {String} [affData]    The data from the dictionary's .aff file. If omitted
             *                              and Typo.js is being used in a Chrome extension, the .aff
             *                              file will be loaded automatically from
             *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff
             *                              In other environments, it will be loaded from
             *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff
             * @param {String} [wordsData]  The data from the dictionary's .dic file. If omitted
             *                              and Typo.js is being used in a Chrome extension, the .dic
             *                              file will be loaded automatically from
             *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic
             *                              In other environments, it will be loaded from
             *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic
             * @param {Object} [settings]   Constructor settings. Available properties are:
             *                              {String} [dictionaryPath]: path to load dictionary from in non-chrome
             *                              environment.
             *                              {Object} [flags]: flag information.
             *
             *
             * @returns {Typo} A Typo object.
             */

            var Typo = function (dictionary, affData, wordsData, settings) {
                settings = settings || {};

                this.dictionary = null;

                this.rules = {};
                this.dictionaryTable = {};

                this.compoundRules = [];
                this.compoundRuleCodes = {};

                this.replacementTable = [];

                this.flags = settings.flags || {};

                if (dictionary) {
                    this.dictionary = dictionary;

                    if (typeof window !== 'undefined' && 'chrome' in window && 'extension' in window.chrome && 'getURL' in window.chrome.extension) {
                        if (!affData) affData = this._readFile(chrome.extension.getURL("lib/typo/dictionaries/" + dictionary + "/" + dictionary + ".aff"));
                        if (!wordsData) wordsData = this._readFile(chrome.extension.getURL("lib/typo/dictionaries/" + dictionary + "/" + dictionary + ".dic"));
                    } else {
                        if (settings.dictionaryPath) {
                            var path = settings.dictionaryPath;
                        }
                        else if (typeof __dirname !== 'undefined') {
                            var path = __dirname + '/dictionaries';
                        }
                        else {
                            var path = './dictionaries';
                        }

                        if (!affData) affData = this._readFile(path + "/" + dictionary + "/" + dictionary + ".aff");
                        if (!wordsData) wordsData = this._readFile(path + "/" + dictionary + "/" + dictionary + ".dic");
                    }

                    this.rules = this._parseAFF(affData);

                    // Save the rule codes that are used in compound rules.
                    this.compoundRuleCodes = {};

                    for (var i = 0, _len = this.compoundRules.length; i < _len; i++) {
                        var rule = this.compoundRules[i];

                        for (var j = 0, _jlen = rule.length; j < _jlen; j++) {
                            this.compoundRuleCodes[rule[j]] = [];
                        }
                    }

                    // If we add this ONLYINCOMPOUND flag to this.compoundRuleCodes, then _parseDIC
                    // will do the work of saving the list of words that are compound-only.
                    if ("ONLYINCOMPOUND" in this.flags) {
                        this.compoundRuleCodes[this.flags.ONLYINCOMPOUND] = [];
                    }

                    this.dictionaryTable = this._parseDIC(wordsData);

                    // Get rid of any codes from the compound rule codes that are never used
                    // (or that were special regex characters).  Not especially necessary...
                    for (var i in this.compoundRuleCodes) {
                        if (this.compoundRuleCodes[i].length == 0) {
                            delete this.compoundRuleCodes[i];
                        }
                    }

                    // Build the full regular expressions for each compound rule.
                    // I have a feeling (but no confirmation yet) that this method of
                    // testing for compound words is probably slow.
                    for (var i = 0, _len = this.compoundRules.length; i < _len; i++) {
                        var ruleText = this.compoundRules[i];

                        var expressionText = "";

                        for (var j = 0, _jlen = ruleText.length; j < _jlen; j++) {
                            var character = ruleText[j];

                            if (character in this.compoundRuleCodes) {
                                expressionText += "(" + this.compoundRuleCodes[character].join("|") + ")";
                            }
                            else {
                                expressionText += character;
                            }
                        }

                        this.compoundRules[i] = new RegExp(expressionText, "i");
                    }
                }

                return this;
            };

            Typo.prototype = {
                /**
                 * Loads a Typo instance from a hash of all of the Typo properties.
                 *
                 * @param object obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).
                 */

                load : function (obj) {
                    for (var i in obj) {
                        this[i] = obj[i];
                    }

                    return this;
                },

                /**
                 * Read the contents of a file.
                 *
                 * @param {String} path The path (relative) to the file.
                 * @param {String} [charset="ISO8859-1"] The expected charset of the file
                 * @returns string The file data.
                 */

                _readFile : function (path, charset) {
                    if (!charset) charset = "utf8";

                    if (typeof XMLHttpRequest !== 'undefined') {
                        var req = new XMLHttpRequest();
                        req.open("GET", path, false);

                        if (req.overrideMimeType)
                            req.overrideMimeType("text/plain; charset=" + charset);

                        req.send(null);

                        return req.responseText;
                    }
                    else if (typeof require !== 'undefined') {
                        // Node.js
                        var fs = require("fs");

                        try {
                            if (fs.existsSync(path)) {
                                var stats = fs.statSync(path);

                                var fileDescriptor = fs.openSync(path, 'r');

                                var buffer = new Buffer(stats.size);

                                fs.readSync(fileDescriptor, buffer, 0, buffer.length, null);

                                return buffer.toString(charset, 0, buffer.length);
                            }
                            else {
                                console.log("Path " + path + " does not exist.");
                            }
                        } catch (e) {
                            console.log(e);
                            return '';
                        }
                    }
                },

                /**
                 * Parse the rules out from a .aff file.
                 *
                 * @param {String} data The contents of the affix file.
                 * @returns object The rules from the file.
                 */

                _parseAFF : function (data) {
                    var rules = {};

                    // Remove comment lines
                    data = this._removeAffixComments(data);

                    var lines = data.split("\n");

                    for (var i = 0, _len = lines.length; i < _len; i++) {
                        var line = lines[i];

                        var definitionParts = line.split(/\s+/);

                        var ruleType = definitionParts[0];

                        if (ruleType == "PFX" || ruleType == "SFX") {
                            var ruleCode = definitionParts[1];
                            var combineable = definitionParts[2];
                            var numEntries = parseInt(definitionParts[3], 10);

                            var entries = [];

                            for (var j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
                                var line = lines[j];

                                var lineParts = line.split(/\s+/);
                                var charactersToRemove = lineParts[2];

                                var additionParts = lineParts[3].split("/");

                                var charactersToAdd = additionParts[0];
                                if (charactersToAdd === "0") charactersToAdd = "";

                                var continuationClasses = this.parseRuleCodes(additionParts[1]);

                                var regexToMatch = lineParts[4];

                                var entry = {};
                                entry.add = charactersToAdd;

                                if (continuationClasses.length > 0) entry.continuationClasses = continuationClasses;

                                if (regexToMatch !== ".") {
                                    if (ruleType === "SFX") {
                                        entry.match = new RegExp(regexToMatch + "$");
                                    }
                                    else {
                                        entry.match = new RegExp("^" + regexToMatch);
                                    }
                                }

                                if (charactersToRemove != "0") {
                                    if (ruleType === "SFX") {
                                        entry.remove = new RegExp(charactersToRemove  + "$");
                                    }
                                    else {
                                        entry.remove = charactersToRemove;
                                    }
                                }

                                entries.push(entry);
                            }

                            rules[ruleCode] = { "type" : ruleType, "combineable" : (combineable == "Y"), "entries" : entries };

                            i += numEntries;
                        }
                        else if (ruleType === "COMPOUNDRULE") {
                            var numEntries = parseInt(definitionParts[1], 10);

                            for (var j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
                                var line = lines[j];

                                var lineParts = line.split(/\s+/);
                                this.compoundRules.push(lineParts[1]);
                            }

                            i += numEntries;
                        }
                        else if (ruleType === "REP") {
                            var lineParts = line.split(/\s+/);

                            if (lineParts.length === 3) {
                                this.replacementTable.push([ lineParts[1], lineParts[2] ]);
                            }
                        }
                        else {
                            // ONLYINCOMPOUND
                            // COMPOUNDMIN
                            // FLAG
                            // KEEPCASE
                            // NEEDAFFIX

                            this.flags[ruleType] = definitionParts[1];
                        }
                    }

                    return rules;
                },

                /**
                 * Removes comment lines and then cleans up blank lines and trailing whitespace.
                 *
                 * @param {String} data The data from an affix file.
                 * @return {String} The cleaned-up data.
                 */

                _removeAffixComments : function (data) {
                    // Remove comments
                    data = data.replace(/#.*$/mg, "");

                    // Trim each line
                    data = data.replace(/^\s\s*/m, '').replace(/\s\s*$/m, '');

                    // Remove blank lines.
                    data = data.replace(/\n{2,}/g, "\n");

                    // Trim the entire string
                    data = data.replace(/^\s\s*/, '').replace(/\s\s*$/, '');

                    return data;
                },

                /**
                 * Parses the words out from the .dic file.
                 *
                 * @param {String} data The data from the dictionary file.
                 * @returns object The lookup table containing all of the words and
                 *                 word forms from the dictionary.
                 */

                _parseDIC : function (data) {
                    data = this._removeDicComments(data);

                    var lines = data.split("\n");
                    var dictionaryTable = {};

                    function addWord(word, rules) {
                        // Some dictionaries will list the same word multiple times with different rule sets.
                        if (!(word in dictionaryTable) || typeof dictionaryTable[word] != 'object') {
                            dictionaryTable[word] = [];
                        }

                        dictionaryTable[word].push(rules);
                    }

                    // The first line is the number of words in the dictionary.
                    for (var i = 1, _len = lines.length; i < _len; i++) {
                        var line = lines[i];

                        var parts = line.split("/", 2);

                        var word = parts[0];

                        // Now for each affix rule, generate that form of the word.
                        if (parts.length > 1) {
                            var ruleCodesArray = this.parseRuleCodes(parts[1]);

                            // Save the ruleCodes for compound word situations.
                            if (!("NEEDAFFIX" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {
                                addWord(word, ruleCodesArray);
                            }

                            for (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {
                                var code = ruleCodesArray[j];

                                var rule = this.rules[code];

                                if (rule) {
                                    var newWords = this._applyRule(word, rule);

                                    for (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {
                                        var newWord = newWords[ii];

                                        addWord(newWord, []);

                                        if (rule.combineable) {
                                            for (var k = j + 1; k < _jlen; k++) {
                                                var combineCode = ruleCodesArray[k];

                                                var combineRule = this.rules[combineCode];

                                                if (combineRule) {
                                                    if (combineRule.combineable && (rule.type != combineRule.type)) {
                                                        var otherNewWords = this._applyRule(newWord, combineRule);

                                                        for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {
                                                            var otherNewWord = otherNewWords[iii];
                                                            addWord(otherNewWord, []);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                if (code in this.compoundRuleCodes) {
                                    this.compoundRuleCodes[code].push(word);
                                }
                            }
                        }
                        else {
                            addWord(word.trim(), []);
                        }
                    }

                    return dictionaryTable;
                },


                /**
                 * Removes comment lines and then cleans up blank lines and trailing whitespace.
                 *
                 * @param {String} data The data from a .dic file.
                 * @return {String} The cleaned-up data.
                 */

                _removeDicComments : function (data) {
                    // I can't find any official documentation on it, but at least the de_DE
                    // dictionary uses tab-indented lines as comments.

                    // Remove comments
                    data = data.replace(/^\t.*$/mg, "");

                    return data;
                },

                parseRuleCodes : function (textCodes) {
                    if (!textCodes) {
                        return [];
                    }
                    else if (!("FLAG" in this.flags)) {
                        return textCodes.split("");
                    }
                    else if (this.flags.FLAG === "long") {
                        var flags = [];

                        for (var i = 0, _len = textCodes.length; i < _len; i += 2) {
                            flags.push(textCodes.substr(i, 2));
                        }

                        return flags;
                    }
                    else if (this.flags.FLAG === "num") {
                        return textCode.split(",");
                    }
                },

                /**
                 * Applies an affix rule to a word.
                 *
                 * @param {String} word The base word.
                 * @param {Object} rule The affix rule.
                 * @returns {String[]} The new words generated by the rule.
                 */

                _applyRule : function (word, rule) {
                    var entries = rule.entries;
                    var newWords = [];

                    for (var i = 0, _len = entries.length; i < _len; i++) {
                        var entry = entries[i];

                        if (!entry.match || word.match(entry.match)) {
                            var newWord = word;

                            if (entry.remove) {
                                newWord = newWord.replace(entry.remove, "");
                            }

                            if (rule.type === "SFX") {
                                newWord = newWord + entry.add;
                            }
                            else {
                                newWord = entry.add + newWord;
                            }

                            newWords.push(newWord);

                            if ("continuationClasses" in entry) {
                                for (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {
                                    var continuationRule = this.rules[entry.continuationClasses[j]];

                                    if (continuationRule) {
                                        newWords = newWords.concat(this._applyRule(newWord, continuationRule));
                                    }
                                    /*
                        else {
                            // This shouldn't happen, but it does, at least in the de_DE dictionary.
                            // I think the author mistakenly supplied lower-case rule codes instead
                            // of upper-case.
                        }
                        */
                                }
                            }
                        }
                    }

                    return newWords;
                },

                /**
                 * Checks whether a word or a capitalization variant exists in the current dictionary.
                 * The word is trimmed and several variations of capitalizations are checked.
                 * If you want to check a word without any changes made to it, call checkExact()
                 *
                 * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function
                 *
                 * @param {String} aWord The word to check.
                 * @returns {Boolean}
                 */

                check : function (aWord) {
                    // Remove leading and trailing whitespace
                    var trimmedWord = aWord.replace(/^\s\s*/, '').replace(/\s\s*$/, '');

                    if (this.checkExact(trimmedWord)) {
                        return true;
                    }

                    // The exact word is not in the dictionary.
                    if (trimmedWord.toUpperCase() === trimmedWord) {
                        // The word was supplied in all uppercase.
                        // Check for a capitalized form of the word.
                        var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();

                        if (this.hasFlag(capitalizedWord, "KEEPCASE")) {
                            // Capitalization variants are not allowed for this word.
                            return false;
                        }

                        if (this.checkExact(capitalizedWord)) {
                            return true;
                        }
                    }

                    var lowercaseWord = trimmedWord.toLowerCase();

                    if (lowercaseWord !== trimmedWord) {
                        if (this.hasFlag(lowercaseWord, "KEEPCASE")) {
                            // Capitalization variants are not allowed for this word.
                            return false;
                        }

                        // Check for a lowercase form
                        if (this.checkExact(lowercaseWord)) {
                            return true;
                        }
                    }

                    return false;
                },

                /**
                 * Checks whether a word exists in the current dictionary.
                 *
                 * @param {String} word The word to check.
                 * @returns {Boolean}
                 */

                checkExact : function (word) {
                    var ruleCodes = this.dictionaryTable[word];

                    if (typeof ruleCodes === 'undefined') {
                        // Check if this might be a compound word.
                        if ("COMPOUNDMIN" in this.flags && word.length >= this.flags.COMPOUNDMIN) {
                            for (var i = 0, _len = this.compoundRules.length; i < _len; i++) {
                                if (word.match(this.compoundRules[i])) {
                                    return true;
                                }
                            }
                        }

                        return false;
                    }
                    else if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.
                        for (var i = 0, _len = ruleCodes.length; i < _len; i++) {
                            if (!this.hasFlag(word, "ONLYINCOMPOUND", ruleCodes[i])) {
                                return true;
                            }
                        }

                        return false;
                    }
                },

                /**
                 * Looks up whether a given word is flagged with a given flag.
                 *
                 * @param {String} word The word in question.
                 * @param {String} flag The flag in question.
                 * @return {Boolean}
                 */

                hasFlag : function (word, flag, wordFlags) {
                    if (flag in this.flags) {
                        if (typeof wordFlags === 'undefined') {
                            var wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);
                        }

                        if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {
                            return true;
                        }
                    }

                    return false;
                },

                /**
                 * Returns a list of suggestions for a misspelled word.
                 *
                 * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.
                 * This suggestor is primitive, but it works.
                 *
                 * @param {String} word The misspelling.
                 * @param {Number} [limit=5] The maximum number of suggestions to return.
                 * @returns {String[]} The array of suggestions.
                 */

                alphabet : "",

                suggest : function (word, limit) {
                    if (!limit) limit = 5;

                    if (this.check(word)) return [];

                    // Check the replacement table.
                    for (var i = 0, _len = this.replacementTable.length; i < _len; i++) {
                        var replacementEntry = this.replacementTable[i];

                        if (word.indexOf(replacementEntry[0]) !== -1) {
                            var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);

                            if (this.check(correctedWord)) {
                                return [ correctedWord ];
                            }
                        }
                    }

                    var self = this;
                    self.alphabet = "abcdefghijklmnopqrstuvwxyz";

                    /*
        if (!self.alphabet) {
            // Use the alphabet as implicitly defined by the words in the dictionary.
            var alphaHash = {};

            for (var i in self.dictionaryTable) {
                for (var j = 0, _len = i.length; j < _len; j++) {
                    alphaHash[i[j]] = true;
                }
            }

            for (var i in alphaHash) {
                self.alphabet += i;
            }

            var alphaArray = self.alphabet.split("");
            alphaArray.sort();
            self.alphabet = alphaArray.join("");
        }
        */

                    function edits1(words) {
                        var rv = [];

                        for (var ii = 0, _iilen = words.length; ii < _iilen; ii++) {
                            var word = words[ii];

                            var splits = [];

                            for (var i = 0, _len = word.length + 1; i < _len; i++) {
                                splits.push([ word.substring(0, i), word.substring(i, word.length) ]);
                            }

                            var deletes = [];

                            for (var i = 0, _len = splits.length; i < _len; i++) {
                                var s = splits[i];

                                if (s[1]) {
                                    deletes.push(s[0] + s[1].substring(1));
                                }
                            }

                            var transposes = [];

                            for (var i = 0, _len = splits.length; i < _len; i++) {
                                var s = splits[i];

                                if (s[1].length > 1) {
                                    transposes.push(s[0] + s[1][1] + s[1][0] + s[1].substring(2));
                                }
                            }

                            var replaces = [];

                            for (var i = 0, _len = splits.length; i < _len; i++) {
                                var s = splits[i];

                                if (s[1]) {
                                    for (var j = 0, _jlen = self.alphabet.length; j < _jlen; j++) {
                                        replaces.push(s[0] + self.alphabet[j] + s[1].substring(1));
                                    }
                                }
                            }

                            var inserts = [];

                            for (var i = 0, _len = splits.length; i < _len; i++) {
                                var s = splits[i];

                                if (s[1]) {
                                    for (var j = 0, _jlen = self.alphabet.length; j < _jlen; j++) {
                                        replaces.push(s[0] + self.alphabet[j] + s[1]);
                                    }
                                }
                            }

                            rv = rv.concat(deletes);
                            rv = rv.concat(transposes);
                            rv = rv.concat(replaces);
                            rv = rv.concat(inserts);
                        }

                        return rv;
                    }

                    function known(words) {
                        var rv = [];

                        for (var i = 0; i < words.length; i++) {
                            if (self.check(words[i])) {
                                rv.push(words[i]);
                            }
                        }

                        return rv;
                    }

                    function correct(word) {
                        // Get the edit-distance-1 and edit-distance-2 forms of this word.
                        var ed1 = edits1([word]);
                        var ed2 = edits1(ed1);

                        var corrections = known(ed1).concat(known(ed2));

                        // Sort the edits based on how many different ways they were created.
                        var weighted_corrections = {};

                        for (var i = 0, _len = corrections.length; i < _len; i++) {
                            if (!(corrections[i] in weighted_corrections)) {
                                weighted_corrections[corrections[i]] = 1;
                            }
                            else {
                                weighted_corrections[corrections[i]] += 1;
                            }
                        }

                        var sorted_corrections = [];

                        for (var i in weighted_corrections) {
                            sorted_corrections.push([ i, weighted_corrections[i] ]);
                        }

                        function sorter(a, b) {
                            if (a[1] < b[1]) {
                                return -1;
                            }

                            return 1;
                        }

                        sorted_corrections.sort(sorter).reverse();

                        var rv = [];

                        for (var i = 0, _len = Math.min(limit, sorted_corrections.length); i < _len; i++) {
                            if (!self.hasFlag(sorted_corrections[i][0], "NOSUGGEST")) {
                                rv.push(sorted_corrections[i][0]);
                            }
                        }

                        return rv;
                    }

                    return correct(word);
                }
            };

// Support for use as a node.js module.
            if (typeof module !== 'undefined') {
                module.exports = Typo;
            }
        }).call(this,require("buffer").Buffer,"/node_modules/typo-js")
    },{"buffer":3,"fs":2}],19:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

        var CodeMirror = require("codemirror");

        CodeMirror.commands.tabAndIndentMarkdownList = function (cm) {
            var ranges = cm.listSelections();
            var pos = ranges[0].head;
            var eolState = cm.getStateAfter(pos.line);
            var inList = eolState.list !== false;

            if (inList) {
                cm.execCommand("indentMore");
                return;
            }

            if (cm.options.indentWithTabs) {
                cm.execCommand("insertTab");
            }
            else {
                var spaces = Array(cm.options.tabSize + 1).join(" ");
                cm.replaceSelection(spaces);
            }
        };

        CodeMirror.commands.shiftTabAndUnindentMarkdownList = function (cm) {
            var ranges = cm.listSelections();
            var pos = ranges[0].head;
            var eolState = cm.getStateAfter(pos.line);
            var inList = eolState.list !== false;

            if (inList) {
                cm.execCommand("indentLess");
                return;
            }

            if (cm.options.indentWithTabs) {
                cm.execCommand("insertTab");
            }
            else {
                var spaces = Array(cm.options.tabSize + 1).join(" ");
                cm.replaceSelection(spaces);
            }
        };

    },{"codemirror":10}],20:[function(require,module,exports){
        /*global require,module*/
        "use strict";
        var CodeMirror = require("codemirror");
        require("codemirror/addon/edit/continuelist.js");
        require("./codemirror/tablist");
        require("codemirror/addon/display/fullscreen.js");
        require("codemirror/mode/markdown/markdown.js");
        require("codemirror/addon/mode/overlay.js");
        require("codemirror/addon/display/placeholder.js");
        require("codemirror/addon/selection/mark-selection.js");
        require("codemirror/mode/gfm/gfm.js");
        require("codemirror/mode/xml/xml.js");
        var CodeMirrorSpellChecker = require("codemirror-spell-checker");
        var marked = require("marked");


// Some variables
        var isMac = /Mac/.test(navigator.platform);

// Mapping of actions that can be bound to keyboard shortcuts or toolbar buttons
        var bindings = {
            "toggleBold": toggleBold,
            "toggleItalic": toggleItalic,
            "drawLink": drawLink,
            "toggleHeadingSmaller": toggleHeadingSmaller,
            "toggleHeadingBigger": toggleHeadingBigger,
            "drawImage": drawImage,
            "toggleBlockquote": toggleBlockquote,
            "toggleOrderedList": toggleOrderedList,
            "toggleUnorderedList": toggleUnorderedList,
            "toggleCodeBlock": toggleCodeBlock,
            "togglePreview": togglePreview,
            "toggleStrikethrough": toggleStrikethrough,
            "toggleHeading1": toggleHeading1,
            "toggleHeading2": toggleHeading2,
            "toggleHeading3": toggleHeading3,
            "cleanBlock": cleanBlock,
            "drawTable": drawTable,
            "drawHorizontalRule": drawHorizontalRule,
            "undo": undo,
            "redo": redo,
            "toggleSideBySide": toggleSideBySide,
            "toggleFullScreen": toggleFullScreen
        };

        var shortcuts = {
            "toggleBold": "Cmd-B",
            "toggleItalic": "Cmd-I",
            "drawLink": "Cmd-K",
            "toggleHeadingSmaller": "Cmd-H",
            "toggleHeadingBigger": "Shift-Cmd-H",
            "cleanBlock": "Cmd-E",
            "drawImage": "Cmd-Alt-I",
            "toggleBlockquote": "Cmd-'",
            "toggleOrderedList": "Cmd-Alt-L",
            "toggleUnorderedList": "Cmd-L",
            "toggleCodeBlock": "Cmd-Alt-C",
            "togglePreview": "Cmd-P",
            "toggleSideBySide": "F9",
            "toggleFullScreen": "F11"
        };

        var getBindingName = function(f) {
            for(var key in bindings) {
                if(bindings[key] === f) {
                    return key;
                }
            }
            return null;
        };

        var isMobile = function() {
            var check = false;
            (function(a) {
                if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;
            })(navigator.userAgent || navigator.vendor || window.opera);
            return check;
        };


        /**
         * Fix shortcut. Mac use Command, others use Ctrl.
         */
        function fixShortcut(name) {
            if(isMac) {
                name = name.replace("Ctrl", "Cmd");
            } else {
                name = name.replace("Cmd", "Ctrl");
            }
            return name;
        }


        /**
         * Create icon element for toolbar.
         */
        function createIcon(options, enableTooltips, shortcuts) {
            options = options || {};
            var el = document.createElement("a");
            enableTooltips = (enableTooltips == undefined) ? true : enableTooltips;

            if(options.title && enableTooltips) {
                el.title = createTootlip(options.title, options.action, shortcuts);

                if(isMac) {
                    el.title = el.title.replace("Ctrl", "");
                    el.title = el.title.replace("Alt", "");
                }
            }

            el.tabIndex = -1;
            el.className = options.className;
            return el;
        }

        function createSep() {
            var el = document.createElement("i");
            el.className = "separator";
            el.innerHTML = "|";
            return el;
        }

        function createTootlip(title, action, shortcuts) {
            var actionName;
            var tooltip = title;

            if(action) {
                actionName = getBindingName(action);
                if(shortcuts[actionName]) {
                    tooltip += " (" + fixShortcut(shortcuts[actionName]) + ")";
                }
            }

            return tooltip;
        }

        /**
         * The state of CodeMirror at the given position.
         */
        function getState(cm, pos) {
            pos = pos || cm.getCursor("start");
            var stat = cm.getTokenAt(pos);
            if(!stat.type) return {};

            var types = stat.type.split(" ");

            var ret = {},
                data, text;
            for(var i = 0; i < types.length; i++) {
                data = types[i];
                if(data === "strong") {
                    ret.bold = true;
                } else if(data === "variable-2") {
                    text = cm.getLine(pos.line);
                    if(/^\s*\d+\.\s/.test(text)) {
                        ret["ordered-list"] = true;
                    } else {
                        ret["unordered-list"] = true;
                    }
                } else if(data === "atom") {
                    ret.quote = true;
                } else if(data === "em") {
                    ret.italic = true;
                } else if(data === "quote") {
                    ret.quote = true;
                } else if(data === "strikethrough") {
                    ret.strikethrough = true;
                } else if(data === "comment") {
                    ret.code = true;
                } else if(data === "link") {
                    ret.link = true;
                } else if(data === "tag") {
                    ret.image = true;
                } else if(data.match(/^header(\-[1-6])?$/)) {
                    ret[data.replace("header", "heading")] = true;
                }
            }
            return ret;
        }


// Saved overflow setting
        var saved_overflow = "";

        /**
         * Toggle full screen of the editor.
         */
        function toggleFullScreen(editor) {
            // Set fullscreen
            var cm = editor.codemirror;
            cm.setOption("fullScreen", !cm.getOption("fullScreen"));


            // Prevent scrolling on body during fullscreen active
            if(cm.getOption("fullScreen")) {
                saved_overflow = document.body.style.overflow;
                document.body.style.overflow = "hidden";
            } else {
                document.body.style.overflow = saved_overflow;
            }


            // Update toolbar class
            var wrap = cm.getWrapperElement();

            if(!/fullscreen/.test(wrap.previousSibling.className)) {
                wrap.previousSibling.className += " fullscreen";
            } else {
                wrap.previousSibling.className = wrap.previousSibling.className.replace(/\s*fullscreen\b/, "");
            }


            // Update toolbar button
            var toolbarButton = editor.toolbarElements.fullscreen;

            if(!/active/.test(toolbarButton.className)) {
                toolbarButton.className += " active";
            } else {
                toolbarButton.className = toolbarButton.className.replace(/\s*active\s*/g, "");
            }


            // Hide side by side if needed
            var sidebyside = cm.getWrapperElement().nextSibling;
            if(/editor-preview-active-side/.test(sidebyside.className))
                toggleSideBySide(editor);
        }


        /**
         * Action for toggling bold.
         */
        function toggleBold(editor) {
            _toggleBlock(editor, "bold", editor.options.blockStyles.bold);
        }


        /**
         * Action for toggling italic.
         */
        function toggleItalic(editor) {
            _toggleBlock(editor, "italic", editor.options.blockStyles.italic);
        }


        /**
         * Action for toggling strikethrough.
         */
        function toggleStrikethrough(editor) {
            _toggleBlock(editor, "strikethrough", "~~");
        }

        /**
         * Action for toggling code block.
         */
        function toggleCodeBlock(editor) {
            var fenceCharsToInsert = editor.options.blockStyles.code;

            function fencing_line(line) {
                /* return true, if this is a ``` or ~~~ line */
                if(typeof line !== "object") {
                    throw "fencing_line() takes a 'line' object (not a line number, or line text).  Got: " + typeof line + ": " + line;
                }
                return line.styles && line.styles[2] && line.styles[2].indexOf("formatting-code-block") !== -1;
            }

            function token_state(token) {
                // base goes an extra level deep when mode backdrops are used, e.g. spellchecker on
                return token.state.base.base || token.state.base;
            }

            function code_type(cm, line_num, line, firstTok, lastTok) {
                /*
         * Return "single", "indented", "fenced" or false
         *
         * cm and line_num are required.  Others are optional for efficiency
         *   To check in the middle of a line, pass in firstTok yourself.
         */
                line = line || cm.getLineHandle(line_num);
                firstTok = firstTok || cm.getTokenAt({
                    line: line_num,
                    ch: 1
                });
                lastTok = lastTok || (!!line.text && cm.getTokenAt({
                    line: line_num,
                    ch: line.text.length - 1
                }));
                var types = firstTok.type ? firstTok.type.split(" ") : [];
                if(lastTok && token_state(lastTok).indentedCode) {
                    // have to check last char, since first chars of first line aren"t marked as indented
                    return "indented";
                } else if(types.indexOf("comment") === -1) {
                    // has to be after "indented" check, since first chars of first indented line aren"t marked as such
                    return false;
                } else if(token_state(firstTok).fencedChars || token_state(lastTok).fencedChars || fencing_line(line)) {
                    return "fenced";
                } else {
                    return "single";
                }
            }

            function insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert) {
                var start_line_sel = cur_start.line + 1,
                    end_line_sel = cur_end.line + 1,
                    sel_multi = cur_start.line !== cur_end.line,
                    repl_start = fenceCharsToInsert + "\n",
                    repl_end = "\n" + fenceCharsToInsert;
                if(sel_multi) {
                    end_line_sel++;
                }
                // handle last char including \n or not
                if(sel_multi && cur_end.ch === 0) {
                    repl_end = fenceCharsToInsert + "\n";
                    end_line_sel--;
                }
                _replaceSelection(cm, false, [repl_start, repl_end]);
                cm.setSelection({
                    line: start_line_sel,
                    ch: 0
                }, {
                    line: end_line_sel,
                    ch: 0
                });
            }

            var cm = editor.codemirror,
                cur_start = cm.getCursor("start"),
                cur_end = cm.getCursor("end"),
                tok = cm.getTokenAt({
                    line: cur_start.line,
                    ch: cur_start.ch || 1
                }), // avoid ch 0 which is a cursor pos but not token
                line = cm.getLineHandle(cur_start.line),
                is_code = code_type(cm, cur_start.line, line, tok);
            var block_start, block_end, lineCount;

            if(is_code === "single") {
                // similar to some SimpleMDE _toggleBlock logic
                var start = line.text.slice(0, cur_start.ch).replace("`", ""),
                    end = line.text.slice(cur_start.ch).replace("`", "");
                cm.replaceRange(start + end, {
                    line: cur_start.line,
                    ch: 0
                }, {
                    line: cur_start.line,
                    ch: 99999999999999
                });
                cur_start.ch--;
                if(cur_start !== cur_end) {
                    cur_end.ch--;
                }
                cm.setSelection(cur_start, cur_end);
                cm.focus();
            } else if(is_code === "fenced") {
                if(cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
                    // use selection

                    // find the fenced line so we know what type it is (tilde, backticks, number of them)
                    for(block_start = cur_start.line; block_start >= 0; block_start--) {
                        line = cm.getLineHandle(block_start);
                        if(fencing_line(line)) {
                            break;
                        }
                    }
                    var fencedTok = cm.getTokenAt({
                        line: block_start,
                        ch: 1
                    });
                    var fence_chars = token_state(fencedTok).fencedChars;
                    var start_text, start_line;
                    var end_text, end_line;
                    // check for selection going up against fenced lines, in which case we don't want to add more fencing
                    if(fencing_line(cm.getLineHandle(cur_start.line))) {
                        start_text = "";
                        start_line = cur_start.line;
                    } else if(fencing_line(cm.getLineHandle(cur_start.line - 1))) {
                        start_text = "";
                        start_line = cur_start.line - 1;
                    } else {
                        start_text = fence_chars + "\n";
                        start_line = cur_start.line;
                    }
                    if(fencing_line(cm.getLineHandle(cur_end.line))) {
                        end_text = "";
                        end_line = cur_end.line;
                        if(cur_end.ch === 0) {
                            end_line += 1;
                        }
                    } else if(cur_end.ch !== 0 && fencing_line(cm.getLineHandle(cur_end.line + 1))) {
                        end_text = "";
                        end_line = cur_end.line + 1;
                    } else {
                        end_text = fence_chars + "\n";
                        end_line = cur_end.line + 1;
                    }
                    if(cur_end.ch === 0) {
                        // full last line selected, putting cursor at beginning of next
                        end_line -= 1;
                    }
                    cm.operation(function() {
                        // end line first, so that line numbers don't change
                        cm.replaceRange(end_text, {
                            line: end_line,
                            ch: 0
                        }, {
                            line: end_line + (end_text ? 0 : 1),
                            ch: 0
                        });
                        cm.replaceRange(start_text, {
                            line: start_line,
                            ch: 0
                        }, {
                            line: start_line + (start_text ? 0 : 1),
                            ch: 0
                        });
                    });
                    cm.setSelection({
                        line: start_line + (start_text ? 1 : 0),
                        ch: 0
                    }, {
                        line: end_line + (start_text ? 1 : -1),
                        ch: 0
                    });
                    cm.focus();
                } else {
                    // no selection, search for ends of this fenced block
                    var search_from = cur_start.line;
                    if(fencing_line(cm.getLineHandle(cur_start.line))) { // gets a little tricky if cursor is right on a fenced line
                        if(code_type(cm, cur_start.line + 1) === "fenced") {
                            block_start = cur_start.line;
                            search_from = cur_start.line + 1; // for searching for "end"
                        } else {
                            block_end = cur_start.line;
                            search_from = cur_start.line - 1; // for searching for "start"
                        }
                    }
                    if(block_start === undefined) {
                        for(block_start = search_from; block_start >= 0; block_start--) {
                            line = cm.getLineHandle(block_start);
                            if(fencing_line(line)) {
                                break;
                            }
                        }
                    }
                    if(block_end === undefined) {
                        lineCount = cm.lineCount();
                        for(block_end = search_from; block_end < lineCount; block_end++) {
                            line = cm.getLineHandle(block_end);
                            if(fencing_line(line)) {
                                break;
                            }
                        }
                    }
                    cm.operation(function() {
                        cm.replaceRange("", {
                            line: block_start,
                            ch: 0
                        }, {
                            line: block_start + 1,
                            ch: 0
                        });
                        cm.replaceRange("", {
                            line: block_end - 1,
                            ch: 0
                        }, {
                            line: block_end,
                            ch: 0
                        });
                    });
                    cm.focus();
                }
            } else if(is_code === "indented") {
                if(cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
                    // use selection
                    block_start = cur_start.line;
                    block_end = cur_end.line;
                    if(cur_end.ch === 0) {
                        block_end--;
                    }
                } else {
                    // no selection, search for ends of this indented block
                    for(block_start = cur_start.line; block_start >= 0; block_start--) {
                        line = cm.getLineHandle(block_start);
                        if(line.text.match(/^\s*$/)) {
                            // empty or all whitespace - keep going
                            continue;
                        } else {
                            if(code_type(cm, block_start, line) !== "indented") {
                                block_start += 1;
                                break;
                            }
                        }
                    }
                    lineCount = cm.lineCount();
                    for(block_end = cur_start.line; block_end < lineCount; block_end++) {
                        line = cm.getLineHandle(block_end);
                        if(line.text.match(/^\s*$/)) {
                            // empty or all whitespace - keep going
                            continue;
                        } else {
                            if(code_type(cm, block_end, line) !== "indented") {
                                block_end -= 1;
                                break;
                            }
                        }
                    }
                }
                // if we are going to un-indent based on a selected set of lines, and the next line is indented too, we need to
                // insert a blank line so that the next line(s) continue to be indented code
                var next_line = cm.getLineHandle(block_end + 1),
                    next_line_last_tok = next_line && cm.getTokenAt({
                        line: block_end + 1,
                        ch: next_line.text.length - 1
                    }),
                    next_line_indented = next_line_last_tok && token_state(next_line_last_tok).indentedCode;
                if(next_line_indented) {
                    cm.replaceRange("\n", {
                        line: block_end + 1,
                        ch: 0
                    });
                }

                for(var i = block_start; i <= block_end; i++) {
                    cm.indentLine(i, "subtract"); // TODO: this doesn't get tracked in the history, so can't be undone :(
                }
                cm.focus();
            } else {
                // insert code formatting
                var no_sel_and_starting_of_line = (cur_start.line === cur_end.line && cur_start.ch === cur_end.ch && cur_start.ch === 0);
                var sel_multi = cur_start.line !== cur_end.line;
                if(no_sel_and_starting_of_line || sel_multi) {
                    insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert);
                } else {
                    _replaceSelection(cm, false, ["`", "`"]);
                }
            }
        }

        /**
         * Action for toggling blockquote.
         */
        function toggleBlockquote(editor) {
            var cm = editor.codemirror;
            _toggleLine(cm, "quote");
        }

        /**
         * Action for toggling heading size: normal -> h1 -> h2 -> h3 -> h4 -> h5 -> h6 -> normal
         */
        function toggleHeadingSmaller(editor) {
            var cm = editor.codemirror;
            _toggleHeading(cm, "smaller");
        }

        /**
         * Action for toggling heading size: normal -> h6 -> h5 -> h4 -> h3 -> h2 -> h1 -> normal
         */
        function toggleHeadingBigger(editor) {
            var cm = editor.codemirror;
            _toggleHeading(cm, "bigger");
        }

        /**
         * Action for toggling heading size 1
         */
        function toggleHeading1(editor) {
            var cm = editor.codemirror;
            _toggleHeading(cm, undefined, 1);
        }

        /**
         * Action for toggling heading size 2
         */
        function toggleHeading2(editor) {
            var cm = editor.codemirror;
            _toggleHeading(cm, undefined, 2);
        }

        /**
         * Action for toggling heading size 3
         */
        function toggleHeading3(editor) {
            var cm = editor.codemirror;
            _toggleHeading(cm, undefined, 3);
        }


        /**
         * Action for toggling ul.
         */
        function toggleUnorderedList(editor) {
            var cm = editor.codemirror;
            _toggleLine(cm, "unordered-list");
        }


        /**
         * Action for toggling ol.
         */
        function toggleOrderedList(editor) {
            var cm = editor.codemirror;
            _toggleLine(cm, "ordered-list");
        }

        /**
         * Action for clean block (remove headline, list, blockquote code, markers)
         */
        function cleanBlock(editor) {
            var cm = editor.codemirror;
            _cleanBlock(cm);
        }

        /**
         * Action for drawing a link.
         */
        function drawLink(editor) {
            var cm = editor.codemirror;
            var stat = getState(cm);
            var options = editor.options;
            var url = "http://";
            if(options.promptURLs) {
                url = prompt(options.promptTexts.link);
                if(!url) {
                    return false;
                }
            }
            _replaceSelection(cm, stat.link, options.insertTexts.link, url);
        }

        /**
         * Action for drawing an img.
         */
        function drawImage(editor) {
            var cm = editor.codemirror;
            var stat = getState(cm);
            var options = editor.options;
            var url = "http://";
            if(options.promptURLs) {
                url = prompt(options.promptTexts.image);
                if(!url) {
                    return false;
                }
            }
            _replaceSelection(cm, stat.image, options.insertTexts.image, url);
        }

        /**
         * Action for drawing a table.
         */
        function drawTable(editor) {
            var cm = editor.codemirror;
            var stat = getState(cm);
            var options = editor.options;
            _replaceSelection(cm, stat.table, options.insertTexts.table);
        }

        /**
         * Action for drawing a horizontal rule.
         */
        function drawHorizontalRule(editor) {
            var cm = editor.codemirror;
            var stat = getState(cm);
            var options = editor.options;
            _replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);
        }


        /**
         * Undo action.
         */
        function undo(editor) {
            var cm = editor.codemirror;
            cm.undo();
            cm.focus();
        }


        /**
         * Redo action.
         */
        function redo(editor) {
            var cm = editor.codemirror;
            cm.redo();
            cm.focus();
        }


        /**
         * Toggle side by side preview
         */
        function toggleSideBySide(editor) {
            var cm = editor.codemirror;
            var wrapper = cm.getWrapperElement();
            var preview = wrapper.nextSibling;
            var toolbarButton = editor.toolbarElements["side-by-side"];
            var useSideBySideListener = false;
            if(/editor-preview-active-side/.test(preview.className)) {
                preview.className = preview.className.replace(
                    /\s*editor-preview-active-side\s*/g, ""
                );
                toolbarButton.className = toolbarButton.className.replace(/\s*active\s*/g, "");
                wrapper.className = wrapper.className.replace(/\s*CodeMirror-sided\s*/g, " ");
            } else {
                // When the preview button is clicked for the first time,
                // give some time for the transition from editor.css to fire and the view to slide from right to left,
                // instead of just appearing.
                setTimeout(function() {
                    if(!cm.getOption("fullScreen"))
                        toggleFullScreen(editor);
                    preview.className += " editor-preview-active-side";
                }, 1);
                toolbarButton.className += " active";
                wrapper.className += " CodeMirror-sided";
                useSideBySideListener = true;
            }

            // Hide normal preview if active
            var previewNormal = wrapper.lastChild;
            if(/editor-preview-active/.test(previewNormal.className)) {
                previewNormal.className = previewNormal.className.replace(
                    /\s*editor-preview-active\s*/g, ""
                );
                var toolbar = editor.toolbarElements.preview;
                var toolbar_div = wrapper.previousSibling;
                toolbar.className = toolbar.className.replace(/\s*active\s*/g, "");
                toolbar_div.className = toolbar_div.className.replace(/\s*disabled-for-preview*/g, "");
            }

            var sideBySideRenderingFunction = function() {
                preview.innerHTML = editor.options.previewRender(editor.value(), preview);
            };

            if(!cm.sideBySideRenderingFunction) {
                cm.sideBySideRenderingFunction = sideBySideRenderingFunction;
            }

            if(useSideBySideListener) {
                preview.innerHTML = editor.options.previewRender(editor.value(), preview);
                cm.on("update", cm.sideBySideRenderingFunction);
            } else {
                cm.off("update", cm.sideBySideRenderingFunction);
            }

            // Refresh to fix selection being off (#309)
            cm.refresh();
        }


        /**
         * Preview action.
         */
        function togglePreview(editor) {
            var cm = editor.codemirror;
            var wrapper = cm.getWrapperElement();
            var toolbar_div = wrapper.previousSibling;
            var toolbar = editor.options.toolbar ? editor.toolbarElements.preview : false;
            var preview = wrapper.lastChild;
            if(!preview || !/editor-preview/.test(preview.className)) {
                preview = document.createElement("div");
                preview.className = "editor-preview";
                wrapper.appendChild(preview);
            }
            if(/editor-preview-active/.test(preview.className)) {
                preview.className = preview.className.replace(
                    /\s*editor-preview-active\s*/g, ""
                );
                if(toolbar) {
                    toolbar.className = toolbar.className.replace(/\s*active\s*/g, "");
                    toolbar_div.className = toolbar_div.className.replace(/\s*disabled-for-preview*/g, "");
                }
            } else {
                // When the preview button is clicked for the first time,
                // give some time for the transition from editor.css to fire and the view to slide from right to left,
                // instead of just appearing.
                setTimeout(function() {
                    preview.className += " editor-preview-active";
                }, 1);
                if(toolbar) {
                    toolbar.className += " active";
                    toolbar_div.className += " disabled-for-preview";
                }
            }
            preview.innerHTML = editor.options.previewRender(editor.value(), preview);

            // Turn off side by side if needed
            var sidebyside = cm.getWrapperElement().nextSibling;
            if(/editor-preview-active-side/.test(sidebyside.className))
                toggleSideBySide(editor);
        }

        function _replaceSelection(cm, active, startEnd, url) {
            if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
                return;

            var text;
            var start = startEnd[0];
            var end = startEnd[1];
            var startPoint = cm.getCursor("start");
            var endPoint = cm.getCursor("end");
            if(url) {
                end = end.replace("#url#", url);
            }
            if(active) {
                text = cm.getLine(startPoint.line);
                start = text.slice(0, startPoint.ch);
                end = text.slice(startPoint.ch);
                cm.replaceRange(start + end, {
                    line: startPoint.line,
                    ch: 0
                });
            } else {
                text = cm.getSelection();
                cm.replaceSelection(start + text + end);

                startPoint.ch += start.length;
                if(startPoint !== endPoint) {
                    endPoint.ch += start.length;
                }
            }
            cm.setSelection(startPoint, endPoint);
            cm.focus();
        }


        function _toggleHeading(cm, direction, size) {
            if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
                return;

            var startPoint = cm.getCursor("start");
            var endPoint = cm.getCursor("end");
            for(var i = startPoint.line; i <= endPoint.line; i++) {
                (function(i) {
                    var text = cm.getLine(i);
                    var currHeadingLevel = text.search(/[^#]/);

                    if(direction !== undefined) {
                        if(currHeadingLevel <= 0) {
                            if(direction == "bigger") {
                                text = "###### " + text;
                            } else {
                                text = "# " + text;
                            }
                        } else if(currHeadingLevel == 6 && direction == "smaller") {
                            text = text.substr(7);
                        } else if(currHeadingLevel == 1 && direction == "bigger") {
                            text = text.substr(2);
                        } else {
                            if(direction == "bigger") {
                                text = text.substr(1);
                            } else {
                                text = "#" + text;
                            }
                        }
                    } else {
                        if(size == 1) {
                            if(currHeadingLevel <= 0) {
                                text = "# " + text;
                            } else if(currHeadingLevel == size) {
                                text = text.substr(currHeadingLevel + 1);
                            } else {
                                text = "# " + text.substr(currHeadingLevel + 1);
                            }
                        } else if(size == 2) {
                            if(currHeadingLevel <= 0) {
                                text = "## " + text;
                            } else if(currHeadingLevel == size) {
                                text = text.substr(currHeadingLevel + 1);
                            } else {
                                text = "## " + text.substr(currHeadingLevel + 1);
                            }
                        } else {
                            if(currHeadingLevel <= 0) {
                                text = "### " + text;
                            } else if(currHeadingLevel == size) {
                                text = text.substr(currHeadingLevel + 1);
                            } else {
                                text = "### " + text.substr(currHeadingLevel + 1);
                            }
                        }
                    }

                    cm.replaceRange(text, {
                        line: i,
                        ch: 0
                    }, {
                        line: i,
                        ch: 99999999999999
                    });
                })(i);
            }
            cm.focus();
        }


        function _toggleLine(cm, name) {
            if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
                return;

            var stat = getState(cm);
            var startPoint = cm.getCursor("start");
            var endPoint = cm.getCursor("end");
            var repl = {
                "quote": /^(\s*)\>\s+/,
                "unordered-list": /^(\s*)(\*|\-|\+)\s+/,
                "ordered-list": /^(\s*)\d+\.\s+/
            };
            var map = {
                "quote": "> ",
                "unordered-list": "* ",
                "ordered-list": "1. "
            };
            for(var i = startPoint.line; i <= endPoint.line; i++) {
                (function(i) {
                    var text = cm.getLine(i);
                    if(stat[name]) {
                        text = text.replace(repl[name], "$1");
                    } else {
                        text = map[name] + text;
                    }
                    cm.replaceRange(text, {
                        line: i,
                        ch: 0
                    }, {
                        line: i,
                        ch: 99999999999999
                    });
                })(i);
            }
            cm.focus();
        }

        function _toggleBlock(editor, type, start_chars, end_chars) {
            if(/editor-preview-active/.test(editor.codemirror.getWrapperElement().lastChild.className))
                return;

            end_chars = (typeof end_chars === "undefined") ? start_chars : end_chars;
            var cm = editor.codemirror;
            var stat = getState(cm);

            var text;
            var start = start_chars;
            var end = end_chars;

            var startPoint = cm.getCursor("start");
            var endPoint = cm.getCursor("end");

            if(stat[type]) {
                text = cm.getLine(startPoint.line);
                start = text.slice(0, startPoint.ch);
                end = text.slice(startPoint.ch);
                if(type == "bold") {
                    start = start.replace(/(\*\*|__)(?![\s\S]*(\*\*|__))/, "");
                    end = end.replace(/(\*\*|__)/, "");
                } else if(type == "italic") {
                    start = start.replace(/(\*|_)(?![\s\S]*(\*|_))/, "");
                    end = end.replace(/(\*|_)/, "");
                } else if(type == "strikethrough") {
                    start = start.replace(/(\*\*|~~)(?![\s\S]*(\*\*|~~))/, "");
                    end = end.replace(/(\*\*|~~)/, "");
                }
                cm.replaceRange(start + end, {
                    line: startPoint.line,
                    ch: 0
                }, {
                    line: startPoint.line,
                    ch: 99999999999999
                });

                if(type == "bold" || type == "strikethrough") {
                    startPoint.ch -= 2;
                    if(startPoint !== endPoint) {
                        endPoint.ch -= 2;
                    }
                } else if(type == "italic") {
                    startPoint.ch -= 1;
                    if(startPoint !== endPoint) {
                        endPoint.ch -= 1;
                    }
                }
            } else {
                text = cm.getSelection();
                if(type == "bold") {
                    text = text.split("**").join("");
                    text = text.split("__").join("");
                } else if(type == "italic") {
                    text = text.split("*").join("");
                    text = text.split("_").join("");
                } else if(type == "strikethrough") {
                    text = text.split("~~").join("");
                }
                cm.replaceSelection(start + text + end);

                startPoint.ch += start_chars.length;
                endPoint.ch = startPoint.ch + text.length;
            }

            cm.setSelection(startPoint, endPoint);
            cm.focus();
        }

        function _cleanBlock(cm) {
            if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
                return;

            var startPoint = cm.getCursor("start");
            var endPoint = cm.getCursor("end");
            var text;

            for(var line = startPoint.line; line <= endPoint.line; line++) {
                text = cm.getLine(line);
                text = text.replace(/^[ ]*([# ]+|\*|\-|[> ]+|[0-9]+(.|\)))[ ]*/, "");

                cm.replaceRange(text, {
                    line: line,
                    ch: 0
                }, {
                    line: line,
                    ch: 99999999999999
                });
            }
        }

// Merge the properties of one object into another.
        function _mergeProperties(target, source) {
            for(var property in source) {
                if(source.hasOwnProperty(property)) {
                    if(source[property] instanceof Array) {
                        target[property] = source[property].concat(target[property] instanceof Array ? target[property] : []);
                    } else if(
                        source[property] !== null &&
                        typeof source[property] === "object" &&
                        source[property].constructor === Object
                    ) {
                        target[property] = _mergeProperties(target[property] || {}, source[property]);
                    } else {
                        target[property] = source[property];
                    }
                }
            }

            return target;
        }

// Merge an arbitrary number of objects into one.
        function extend(target) {
            for(var i = 1; i < arguments.length; i++) {
                target = _mergeProperties(target, arguments[i]);
            }

            return target;
        }

        /* The right word count in respect for CJK. */
        function wordCount(data) {
            var pattern = /[a-zA-Z0-9_\u0392-\u03c9\u0410-\u04F9]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af]+/g;
            var m = data.match(pattern);
            var count = 0;
            if(m === null) return count;
            for(var i = 0; i < m.length; i++) {
                if(m[i].charCodeAt(0) >= 0x4E00) {
                    count += m[i].length;
                } else {
                    count += 1;
                }
            }
            return count;
        }

        var toolbarBuiltInButtons = {
            "bold": {
                name: "bold",
                action: toggleBold,
                className: "fa fa-bold",
                title: "Bold",
                default: true
            },
            "italic": {
                name: "italic",
                action: toggleItalic,
                className: "fa fa-italic",
                title: "Italic",
                default: true
            },
            "strikethrough": {
                name: "strikethrough",
                action: toggleStrikethrough,
                className: "fa fa-strikethrough",
                title: "Strikethrough"
            },
            "heading": {
                name: "heading",
                action: toggleHeadingSmaller,
                className: "fa fa-header",
                title: "Heading",
                default: true
            },
            "heading-smaller": {
                name: "heading-smaller",
                action: toggleHeadingSmaller,
                className: "fa fa-header fa-header-x fa-header-smaller",
                title: "Smaller Heading"
            },
            "heading-bigger": {
                name: "heading-bigger",
                action: toggleHeadingBigger,
                className: "fa fa-header fa-header-x fa-header-bigger",
                title: "Bigger Heading"
            },
            "heading-1": {
                name: "heading-1",
                action: toggleHeading1,
                className: "fa fa-header fa-header-x fa-header-1",
                title: "Big Heading"
            },
            "heading-2": {
                name: "heading-2",
                action: toggleHeading2,
                className: "fa fa-header fa-header-x fa-header-2",
                title: "Medium Heading"
            },
            "heading-3": {
                name: "heading-3",
                action: toggleHeading3,
                className: "fa fa-header fa-header-x fa-header-3",
                title: "Small Heading"
            },
            "separator-1": {
                name: "separator-1"
            },
            "code": {
                name: "code",
                action: toggleCodeBlock,
                className: "fa fa-code",
                title: "Code"
            },
            "quote": {
                name: "quote",
                action: toggleBlockquote,
                className: "fa fa-quote-left",
                title: "Quote",
                default: true
            },
            "unordered-list": {
                name: "unordered-list",
                action: toggleUnorderedList,
                className: "fa fa-list-ul",
                title: "Generic List",
                default: true
            },
            "ordered-list": {
                name: "ordered-list",
                action: toggleOrderedList,
                className: "fa fa-list-ol",
                title: "Numbered List",
                default: true
            },
            "clean-block": {
                name: "clean-block",
                action: cleanBlock,
                className: "fa fa-eraser fa-clean-block",
                title: "Clean block"
            },
            "separator-2": {
                name: "separator-2"
            },
            "link": {
                name: "link",
                action: drawLink,
                className: "fa fa-link",
                title: "Create Link",
                default: true
            },
            "image": {
                name: "image",
                action: drawImage,
                className: "fa fa-picture-o",
                title: "Insert Image",
                default: true
            },
            "table": {
                name: "table",
                action: drawTable,
                className: "fa fa-table",
                title: "Insert Table"
            },
            "horizontal-rule": {
                name: "horizontal-rule",
                action: drawHorizontalRule,
                className: "fa fa-minus",
                title: "Insert Horizontal Line"
            },
            "separator-3": {
                name: "separator-3"
            },
            "preview": {
                name: "preview",
                action: togglePreview,
                className: "fa fa-eye no-disable",
                title: "Toggle Preview",
                default: true
            },
            "side-by-side": {
                name: "side-by-side",
                action: toggleSideBySide,
                className: "fa fa-columns no-disable no-mobile",
                title: "Toggle Side by Side",
                default: true
            },
            "fullscreen": {
                name: "fullscreen",
                action: toggleFullScreen,
                className: "fa fa-arrows-alt no-disable no-mobile",
                title: "Toggle Fullscreen",
                default: true
            },
            "separator-4": {
                name: "separator-4"
            },
            "guide": {
                name: "guide",
                action: "https://simplemde.com/markdown-guide",
                className: "fa fa-question-circle",
                title: "Markdown Guide",
                default: true
            },
            "separator-5": {
                name: "separator-5"
            },
            "undo": {
                name: "undo",
                action: undo,
                className: "fa fa-undo no-disable",
                title: "Undo"
            },
            "redo": {
                name: "redo",
                action: redo,
                className: "fa fa-repeat no-disable",
                title: "Redo"
            }
        };

        var insertTexts = {
            link: ["[", "](#url#)"],
            image: ["![](", "#url#)"],
            table: ["", "\n\n| Column 1 | Column 2 | Column 3 |\n| -------- | -------- | -------- |\n| Text     | Text     | Text     |\n\n"],
            horizontalRule: ["", "\n\n-----\n\n"]
        };

        var promptTexts = {
            link: "URL for the link:",
            image: "URL of the image:"
        };

        var blockStyles = {
            "bold": "**",
            "code": "```",
            "italic": "*"
        };

        /**
         * Interface of SimpleMDE.
         */
        function SimpleMDE(options) {
            // Handle options parameter
            options = options || {};


            // Used later to refer to it"s parent
            options.parent = this;


            // Check if Font Awesome needs to be auto downloaded
            var autoDownloadFA = true;

            if(options.autoDownloadFontAwesome === false) {
                autoDownloadFA = false;
            }

            if(options.autoDownloadFontAwesome !== true) {
                var styleSheets = document.styleSheets;
                for(var i = 0; i < styleSheets.length; i++) {
                    if(!styleSheets[i].href)
                        continue;

                    if(styleSheets[i].href.indexOf("//cdn.bootcss.com/font-awesome/") > -1) {
                        autoDownloadFA = false;
                    }
                }
            }

            if(autoDownloadFA) {
                var link = document.createElement("link");
                link.rel = "stylesheet";
                link.href = "https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css";
                document.getElementsByTagName("head")[0].appendChild(link);
            }


            // Find the textarea to use
            if(options.element) {
                this.element = options.element;
            } else if(options.element === null) {
                // This means that the element option was specified, but no element was found
                console.log("SimpleMDE: Error. No element was found.");
                return;
            }


            // Handle toolbar
            if(options.toolbar === undefined) {
                // Initialize
                options.toolbar = [];


                // Loop over the built in buttons, to get the preferred order
                for(var key in toolbarBuiltInButtons) {
                    if(toolbarBuiltInButtons.hasOwnProperty(key)) {
                        if(key.indexOf("separator-") != -1) {
                            options.toolbar.push("|");
                        }

                        if(toolbarBuiltInButtons[key].default === true || (options.showIcons && options.showIcons.constructor === Array && options.showIcons.indexOf(key) != -1)) {
                            options.toolbar.push(key);
                        }
                    }
                }
            }


            // Handle status bar
            if(!options.hasOwnProperty("status")) {
                options.status = ["autosave", "lines", "words", "cursor"];
            }


            // Add default preview rendering function
            if(!options.previewRender) {
                options.previewRender = function(plainText) {
                    // Note: "this" refers to the options object
                    return this.parent.markdown(plainText);
                };
            }


            // Set default options for parsing config
            options.parsingConfig = extend({
                highlightFormatting: true // needed for toggleCodeBlock to detect types of code
            }, options.parsingConfig || {});


            // Merging the insertTexts, with the given options
            options.insertTexts = extend({}, insertTexts, options.insertTexts || {});


            // Merging the promptTexts, with the given options
            options.promptTexts = promptTexts;


            // Merging the blockStyles, with the given options
            options.blockStyles = extend({}, blockStyles, options.blockStyles || {});


            // Merging the shortcuts, with the given options
            options.shortcuts = extend({}, shortcuts, options.shortcuts || {});


            // Change unique_id to uniqueId for backwards compatibility
            if(options.autosave != undefined && options.autosave.unique_id != undefined && options.autosave.unique_id != "")
                options.autosave.uniqueId = options.autosave.unique_id;


            // Update this options
            this.options = options;


            // Auto render
            this.render();


            // The codemirror component is only available after rendering
            // so, the setter for the initialValue can only run after
            // the element has been rendered
            if(options.initialValue && (!this.options.autosave || this.options.autosave.foundSavedValue !== true)) {
                this.value(options.initialValue);
            }
        }

        /**
         * Default markdown render.
         */
        SimpleMDE.prototype.markdown = function(text) {
            if(marked) {
                // Initialize
                var markedOptions = {};


                // Update options
                if(this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === false) {
                    markedOptions.breaks = false;
                } else {
                    markedOptions.breaks = true;
                }

                if(this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === true && window.hljs) {
                    markedOptions.highlight = function(code) {
                        return window.hljs.highlightAuto(code).value;
                    };
                }


                // Set options
                marked.setOptions(markedOptions);


                // Return
                return marked(text);
            }
        };

        /**
         * Render editor to the given element.
         */
        SimpleMDE.prototype.render = function(el) {
            if(!el) {
                el = this.element || document.getElementsByTagName("textarea")[0];
            }

            if(this._rendered && this._rendered === el) {
                // Already rendered.
                return;
            }

            this.element = el;
            var options = this.options;

            var self = this;
            var keyMaps = {};

            for(var key in options.shortcuts) {
                // null stands for "do not bind this command"
                if(options.shortcuts[key] !== null && bindings[key] !== null) {
                    (function(key) {
                        keyMaps[fixShortcut(options.shortcuts[key])] = function() {
                            bindings[key](self);
                        };
                    })(key);
                }
            }

            keyMaps["Enter"] = "newlineAndIndentContinueMarkdownList";
            keyMaps["Tab"] = "tabAndIndentMarkdownList";
            keyMaps["Shift-Tab"] = "shiftTabAndUnindentMarkdownList";
            keyMaps["Esc"] = function(cm) {
                if(cm.getOption("fullScreen")) toggleFullScreen(self);
            };

            document.addEventListener("keydown", function(e) {
                e = e || window.event;

                if(e.keyCode == 27) {
                    if(self.codemirror.getOption("fullScreen")) toggleFullScreen(self);
                }
            }, false);

            var mode, backdrop;
            if(options.spellChecker !== false) {
                mode = "spell-checker";
                backdrop = options.parsingConfig;
                backdrop.name = "gfm";
                backdrop.gitHubSpice = false;

                CodeMirrorSpellChecker({
                    codeMirrorInstance: CodeMirror
                });
            } else {
                mode = options.parsingConfig;
                mode.name = "gfm";
                mode.gitHubSpice = false;
            }

            this.codemirror = CodeMirror.fromTextArea(el, {
                mode: mode,
                backdrop: backdrop,
                theme: "paper",
                tabSize: (options.tabSize != undefined) ? options.tabSize : 2,
                indentUnit: (options.tabSize != undefined) ? options.tabSize : 2,
                indentWithTabs: (options.indentWithTabs === false) ? false : true,
                lineNumbers: false,
                autofocus: (options.autofocus === true) ? true : false,
                extraKeys: keyMaps,
                lineWrapping: (options.lineWrapping === false) ? false : true,
                allowDropFileTypes: ["text/plain"],
                placeholder: options.placeholder || el.getAttribute("placeholder") || "",
                styleSelectedText: (options.styleSelectedText != undefined) ? options.styleSelectedText : true
            });

            if(options.forceSync === true) {
                var cm = this.codemirror;
                cm.on("change", function() {
                    cm.save();
                });
            }

            this.gui = {};

            if(options.toolbar !== false) {
                this.gui.toolbar = this.createToolbar();
            }
            if(options.status !== false) {
                this.gui.statusbar = this.createStatusbar();
            }
            if(options.autosave != undefined && options.autosave.enabled === true) {
                this.autosave();
            }

            this.gui.sideBySide = this.createSideBySide();

            this._rendered = this.element;


            // Fixes CodeMirror bug (#344)
            var temp_cm = this.codemirror;
            setTimeout(function() {
                temp_cm.refresh();
            }.bind(temp_cm), 0);
        };

// Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem throw QuotaExceededError. We're going to detect this and set a variable accordingly.
        function isLocalStorageAvailable() {
            if(typeof localStorage === "object") {
                try {
                    localStorage.setItem("smde_localStorage", 1);
                    localStorage.removeItem("smde_localStorage");
                } catch(e) {
                    return false;
                }
            } else {
                return false;
            }

            return true;
        }

        SimpleMDE.prototype.autosave = function() {
            if(isLocalStorageAvailable()) {
                var simplemde = this;

                if(this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == "") {
                    console.log("SimpleMDE: You must set a uniqueId to use the autosave feature");
                    return;
                }

                if(simplemde.element.form != null && simplemde.element.form != undefined) {
                    simplemde.element.form.addEventListener("submit", function() {
                        localStorage.removeItem("smde_" + simplemde.options.autosave.uniqueId);
                    });
                }

                if(this.options.autosave.loaded !== true) {
                    if(typeof localStorage.getItem("smde_" + this.options.autosave.uniqueId) == "string" && localStorage.getItem("smde_" + this.options.autosave.uniqueId) != "") {
                        this.codemirror.setValue(localStorage.getItem("smde_" + this.options.autosave.uniqueId));
                        this.options.autosave.foundSavedValue = true;
                    }

                    this.options.autosave.loaded = true;
                }

                localStorage.setItem("smde_" + this.options.autosave.uniqueId, simplemde.value());

                var el = document.getElementById("autosaved");
                if(el != null && el != undefined && el != "") {
                    var d = new Date();
                    var hh = d.getHours();
                    var m = d.getMinutes();
                    var dd = "am";
                    var h = hh;
                    if(h >= 12) {
                        h = hh - 12;
                        dd = "pm";
                    }
                    if(h == 0) {
                        h = 12;
                    }
                    m = m < 10 ? "0" + m : m;

                    el.innerHTML = "Autosaved: " + h + ":" + m + " " + dd;
                }

                this.autosaveTimeoutId = setTimeout(function() {
                    simplemde.autosave();
                }, this.options.autosave.delay || 10000);
            } else {
                console.log("SimpleMDE: localStorage not available, cannot autosave");
            }
        };

        SimpleMDE.prototype.clearAutosavedValue = function() {
            if(isLocalStorageAvailable()) {
                if(this.options.autosave == undefined || this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == "") {
                    console.log("SimpleMDE: You must set a uniqueId to clear the autosave value");
                    return;
                }

                localStorage.removeItem("smde_" + this.options.autosave.uniqueId);
            } else {
                console.log("SimpleMDE: localStorage not available, cannot autosave");
            }
        };

        SimpleMDE.prototype.createSideBySide = function() {
            var cm = this.codemirror;
            var wrapper = cm.getWrapperElement();
            var preview = wrapper.nextSibling;

            if(!preview || !/editor-preview-side/.test(preview.className)) {
                preview = document.createElement("div");
                preview.className = "editor-preview-side";
                wrapper.parentNode.insertBefore(preview, wrapper.nextSibling);
            }

            // Syncs scroll  editor -> preview
            var cScroll = false;
            var pScroll = false;
            cm.on("scroll", function(v) {
                if(cScroll) {
                    cScroll = false;
                    return;
                }
                pScroll = true;
                var height = v.getScrollInfo().height - v.getScrollInfo().clientHeight;
                var ratio = parseFloat(v.getScrollInfo().top) / height;
                var move = (preview.scrollHeight - preview.clientHeight) * ratio;
                preview.scrollTop = move;
            });

            // Syncs scroll  preview -> editor
            preview.onscroll = function() {
                if(pScroll) {
                    pScroll = false;
                    return;
                }
                cScroll = true;
                var height = preview.scrollHeight - preview.clientHeight;
                var ratio = parseFloat(preview.scrollTop) / height;
                var move = (cm.getScrollInfo().height - cm.getScrollInfo().clientHeight) * ratio;
                cm.scrollTo(0, move);
            };
            return preview;
        };

        SimpleMDE.prototype.createToolbar = function(items) {
            items = items || this.options.toolbar;

            if(!items || items.length === 0) {
                return;
            }
            var i;
            for(i = 0; i < items.length; i++) {
                if(toolbarBuiltInButtons[items[i]] != undefined) {
                    items[i] = toolbarBuiltInButtons[items[i]];
                }
            }

            var bar = document.createElement("div");
            bar.className = "editor-toolbar";

            var self = this;

            var toolbarData = {};
            self.toolbar = items;

            for(i = 0; i < items.length; i++) {
                if(items[i].name == "guide" && self.options.toolbarGuideIcon === false)
                    continue;

                if(self.options.hideIcons && self.options.hideIcons.indexOf(items[i].name) != -1)
                    continue;

                // Fullscreen does not work well on mobile devices (even tablets)
                // In the future, hopefully this can be resolved
                if((items[i].name == "fullscreen" || items[i].name == "side-by-side") && isMobile())
                    continue;


                // Don't include trailing separators
                if(items[i] === "|") {
                    var nonSeparatorIconsFollow = false;

                    for(var x = (i + 1); x < items.length; x++) {
                        if(items[x] !== "|" && (!self.options.hideIcons || self.options.hideIcons.indexOf(items[x].name) == -1)) {
                            nonSeparatorIconsFollow = true;
                        }
                    }

                    if(!nonSeparatorIconsFollow)
                        continue;
                }


                // Create the icon and append to the toolbar
                (function(item) {
                    var el;
                    if(item === "|") {
                        el = createSep();
                    } else {
                        el = createIcon(item, self.options.toolbarTips, self.options.shortcuts);
                    }

                    // bind events, special for info
                    if(item.action) {
                        if(typeof item.action === "function") {
                            el.onclick = function(e) {
                                e.preventDefault();
                                item.action(self);
                            };
                        } else if(typeof item.action === "string") {
                            el.href = item.action;
                            el.target = "_blank";
                        }
                    }

                    toolbarData[item.name || item] = el;
                    bar.appendChild(el);
                })(items[i]);
            }

            self.toolbarElements = toolbarData;

            var cm = this.codemirror;
            cm.on("cursorActivity", function() {
                var stat = getState(cm);

                for(var key in toolbarData) {
                    (function(key) {
                        var el = toolbarData[key];
                        if(stat[key]) {
                            el.className += " active";
                        } else if(key != "fullscreen" && key != "side-by-side") {
                            el.className = el.className.replace(/\s*active\s*/g, "");
                        }
                    })(key);
                }
            });

            var cmWrapper = cm.getWrapperElement();
            cmWrapper.parentNode.insertBefore(bar, cmWrapper);
            return bar;
        };

        SimpleMDE.prototype.createStatusbar = function(status) {
            // Initialize
            status = status || this.options.status;
            var options = this.options;
            var cm = this.codemirror;


            // Make sure the status variable is valid
            if(!status || status.length === 0)
                return;


            // Set up the built-in items
            var items = [];
            var i, onUpdate, defaultValue;

            for(i = 0; i < status.length; i++) {
                // Reset some values
                onUpdate = undefined;
                defaultValue = undefined;


                // Handle if custom or not
                if(typeof status[i] === "object") {
                    items.push({
                        className: status[i].className,
                        defaultValue: status[i].defaultValue,
                        onUpdate: status[i].onUpdate
                    });
                } else {
                    var name = status[i];

                    if(name === "words") {
                        defaultValue = function(el) {
                            el.innerHTML = wordCount(cm.getValue());
                        };
                        onUpdate = function(el) {
                            el.innerHTML = wordCount(cm.getValue());
                        };
                    } else if(name === "lines") {
                        defaultValue = function(el) {
                            el.innerHTML = cm.lineCount();
                        };
                        onUpdate = function(el) {
                            el.innerHTML = cm.lineCount();
                        };
                    } else if(name === "cursor") {
                        defaultValue = function(el) {
                            el.innerHTML = "0:0";
                        };
                        onUpdate = function(el) {
                            var pos = cm.getCursor();
                            el.innerHTML = pos.line + ":" + pos.ch;
                        };
                    } else if(name === "autosave") {
                        defaultValue = function(el) {
                            if(options.autosave != undefined && options.autosave.enabled === true) {
                                el.setAttribute("id", "autosaved");
                            }
                        };
                    }

                    items.push({
                        className: name,
                        defaultValue: defaultValue,
                        onUpdate: onUpdate
                    });
                }
            }


            // Create element for the status bar
            var bar = document.createElement("div");
            bar.className = "editor-statusbar";


            // Create a new span for each item
            for(i = 0; i < items.length; i++) {
                // Store in temporary variable
                var item = items[i];


                // Create span element
                var el = document.createElement("span");
                el.className = item.className;


                // Ensure the defaultValue is a function
                if(typeof item.defaultValue === "function") {
                    item.defaultValue(el);
                }


                // Ensure the onUpdate is a function
                if(typeof item.onUpdate === "function") {
                    // Create a closure around the span of the current action, then execute the onUpdate handler
                    this.codemirror.on("update", (function(el, item) {
                        return function() {
                            item.onUpdate(el);
                        };
                    }(el, item)));
                }


                // Append the item to the status bar
                bar.appendChild(el);
            }


            // Insert the status bar into the DOM
            var cmWrapper = this.codemirror.getWrapperElement();
            cmWrapper.parentNode.insertBefore(bar, cmWrapper.nextSibling);
            return bar;
        };

        /**
         * Get or set the text content.
         */
        SimpleMDE.prototype.value = function(val) {
            if(val === undefined) {
                return this.codemirror.getValue();
            } else {
                this.codemirror.getDoc().setValue(val);
                return this;
            }
        };


        /**
         * Bind static methods for exports.
         */
        SimpleMDE.toggleBold = toggleBold;
        SimpleMDE.toggleItalic = toggleItalic;
        SimpleMDE.toggleStrikethrough = toggleStrikethrough;
        SimpleMDE.toggleBlockquote = toggleBlockquote;
        SimpleMDE.toggleHeadingSmaller = toggleHeadingSmaller;
        SimpleMDE.toggleHeadingBigger = toggleHeadingBigger;
        SimpleMDE.toggleHeading1 = toggleHeading1;
        SimpleMDE.toggleHeading2 = toggleHeading2;
        SimpleMDE.toggleHeading3 = toggleHeading3;
        SimpleMDE.toggleCodeBlock = toggleCodeBlock;
        SimpleMDE.toggleUnorderedList = toggleUnorderedList;
        SimpleMDE.toggleOrderedList = toggleOrderedList;
        SimpleMDE.cleanBlock = cleanBlock;
        SimpleMDE.drawLink = drawLink;
        SimpleMDE.drawImage = drawImage;
        SimpleMDE.drawTable = drawTable;
        SimpleMDE.drawHorizontalRule = drawHorizontalRule;
        SimpleMDE.undo = undo;
        SimpleMDE.redo = redo;
        SimpleMDE.togglePreview = togglePreview;
        SimpleMDE.toggleSideBySide = toggleSideBySide;
        SimpleMDE.toggleFullScreen = toggleFullScreen;

        /**
         * Bind instance methods for exports.
         */
        SimpleMDE.prototype.toggleBold = function() {
            toggleBold(this);
        };
        SimpleMDE.prototype.toggleItalic = function() {
            toggleItalic(this);
        };
        SimpleMDE.prototype.toggleStrikethrough = function() {
            toggleStrikethrough(this);
        };
        SimpleMDE.prototype.toggleBlockquote = function() {
            toggleBlockquote(this);
        };
        SimpleMDE.prototype.toggleHeadingSmaller = function() {
            toggleHeadingSmaller(this);
        };
        SimpleMDE.prototype.toggleHeadingBigger = function() {
            toggleHeadingBigger(this);
        };
        SimpleMDE.prototype.toggleHeading1 = function() {
            toggleHeading1(this);
        };
        SimpleMDE.prototype.toggleHeading2 = function() {
            toggleHeading2(this);
        };
        SimpleMDE.prototype.toggleHeading3 = function() {
            toggleHeading3(this);
        };
        SimpleMDE.prototype.toggleCodeBlock = function() {
            toggleCodeBlock(this);
        };
        SimpleMDE.prototype.toggleUnorderedList = function() {
            toggleUnorderedList(this);
        };
        SimpleMDE.prototype.toggleOrderedList = function() {
            toggleOrderedList(this);
        };
        SimpleMDE.prototype.cleanBlock = function() {
            cleanBlock(this);
        };
        SimpleMDE.prototype.drawLink = function() {
            drawLink(this);
        };
        SimpleMDE.prototype.drawImage = function() {
            drawImage(this);
        };
        SimpleMDE.prototype.drawTable = function() {
            drawTable(this);
        };
        SimpleMDE.prototype.drawHorizontalRule = function() {
            drawHorizontalRule(this);
        };
        SimpleMDE.prototype.undo = function() {
            undo(this);
        };
        SimpleMDE.prototype.redo = function() {
            redo(this);
        };
        SimpleMDE.prototype.togglePreview = function() {
            togglePreview(this);
        };
        SimpleMDE.prototype.toggleSideBySide = function() {
            toggleSideBySide(this);
        };
        SimpleMDE.prototype.toggleFullScreen = function() {
            toggleFullScreen(this);
        };

        SimpleMDE.prototype.isPreviewActive = function() {
            var cm = this.codemirror;
            var wrapper = cm.getWrapperElement();
            var preview = wrapper.lastChild;

            return /editor-preview-active/.test(preview.className);
        };

        SimpleMDE.prototype.isSideBySideActive = function() {
            var cm = this.codemirror;
            var wrapper = cm.getWrapperElement();
            var preview = wrapper.nextSibling;

            return /editor-preview-active-side/.test(preview.className);
        };

        SimpleMDE.prototype.isFullscreenActive = function() {
            var cm = this.codemirror;

            return cm.getOption("fullScreen");
        };

        SimpleMDE.prototype.getState = function() {
            var cm = this.codemirror;

            return getState(cm);
        };

        SimpleMDE.prototype.toTextArea = function() {
            var cm = this.codemirror;
            var wrapper = cm.getWrapperElement();

            if(wrapper.parentNode) {
                if(this.gui.toolbar) {
                    wrapper.parentNode.removeChild(this.gui.toolbar);
                }
                if(this.gui.statusbar) {
                    wrapper.parentNode.removeChild(this.gui.statusbar);
                }
                if(this.gui.sideBySide) {
                    wrapper.parentNode.removeChild(this.gui.sideBySide);
                }
            }

            cm.toTextArea();

            if(this.autosaveTimeoutId) {
                clearTimeout(this.autosaveTimeoutId);
                this.autosaveTimeoutId = undefined;
                this.clearAutosavedValue();
            }
        };

        module.exports = SimpleMDE;
    },{"./codemirror/tablist":19,"codemirror":10,"codemirror-spell-checker":4,"codemirror/addon/display/fullscreen.js":5,"codemirror/addon/display/placeholder.js":6,"codemirror/addon/edit/continuelist.js":7,"codemirror/addon/mode/overlay.js":8,"codemirror/addon/selection/mark-selection.js":9,"codemirror/mode/gfm/gfm.js":11,"codemirror/mode/markdown/markdown.js":12,"codemirror/mode/xml/xml.js":14,"marked":17}]},{},[20])(20)
});
/*

    jQuery Tags Input Plugin 1.3.3

    Copyright (c) 2011 XOXCO, Inc

    Documentation for this plugin lives here:
    http://xoxco.com/clickable/jquery-tags-input

    Licensed under the MIT license:
    http://www.opensource.org/licenses/mit-license.php

    ben@xoxco.com

*/

(function($) {

    var delimiter = new Array();
    var tags_callbacks = new Array();
    $.fn.doAutosize = function(o){
        var minWidth = $(this).data('minwidth'),
            maxWidth = $(this).data('maxwidth'),
            val = '',
            input = $(this),
            testSubject = $('#'+$(this).data('tester_id'));

        if (val === (val = input.val())) {return;}

        // Enter new content into testSubject
        var escaped = val.replace(/&/g, '&amp;').replace(/\s/g,' ').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        testSubject.html(escaped);
        // Calculate new width + whether to change
        var testerWidth = testSubject.width(),
            newWidth = (testerWidth + o.comfortZone) >= minWidth ? testerWidth + o.comfortZone : minWidth,
            currentWidth = input.width(),
            isValidWidthChange = (newWidth < currentWidth && newWidth >= minWidth)
                || (newWidth > minWidth && newWidth < maxWidth);

        // Animate width
        if (isValidWidthChange) {
            input.width(newWidth);
        }


    };
    $.fn.resetAutosize = function(options){
        // alert(JSON.stringify(options));
        var minWidth =  $(this).data('minwidth') || options.minInputWidth || $(this).width(),
            maxWidth = $(this).data('maxwidth') || options.maxInputWidth || ($(this).closest('.tagsinput').width() - options.inputPadding),
            val = '',
            input = $(this),
            testSubject = $('<tester/>').css({
                position: 'absolute',
                top: -9999,
                left: -9999,
                width: 'auto',
                fontSize: input.css('fontSize'),
                fontFamily: input.css('fontFamily'),
                fontWeight: input.css('fontWeight'),
                letterSpacing: input.css('letterSpacing'),
                whiteSpace: 'nowrap'
            }),
            testerId = $(this).attr('id')+'_autosize_tester';
        if(! $('#'+testerId).length > 0){
            testSubject.attr('id', testerId);
            testSubject.appendTo('body');
        }

        input.data('minwidth', minWidth);
        input.data('maxwidth', maxWidth);
        input.data('tester_id', testerId);
        input.css('width', minWidth);
    };

    $.fn.addTag = function(value,options) {
        options = jQuery.extend({focus:false,callback:true},options);
        this.each(function() {
            var id = $(this).attr('id');

            var tagslist = $(this).val().split(delimiter[id]);
            if (tagslist[0] == '') {
                tagslist = new Array();
            }

            value = jQuery.trim(value);

            if (options.unique) {
                var skipTag = $(this).tagExist(value);
                if(skipTag == true) {
                    //Marks fake input as not_valid to let styling it
                    $('#'+id+'_tag').addClass('not_valid');
                }
            } else {
                var skipTag = false;
            }

            if (value !='' && skipTag != true) {
                $('<span>').addClass('tag').append(
                    $('<span>').text(value).append('&nbsp;&nbsp;'),
                    $('<a>', {
                        href  : '#',
                        title : 'Removing tag',
                        text  : 'x'
                    }).click(function () {
                        return $('#' + id).removeTag(escape(value));
                    })
                ).insertBefore('#' + id + '_addTag');

                tagslist.push(value);

                $('#'+id+'_tag').val('');
                if (options.focus) {
                    $('#'+id+'_tag').focus();
                } else {
                    $('#'+id+'_tag').blur();
                }

                $.fn.tagsInput.updateTagsField(this,tagslist);

                if (options.callback && tags_callbacks[id] && tags_callbacks[id]['onAddTag']) {
                    var f = tags_callbacks[id]['onAddTag'];
                    f.call(this, value);
                }
                if(tags_callbacks[id] && tags_callbacks[id]['onChange'])
                {
                    var i = tagslist.length;
                    var f = tags_callbacks[id]['onChange'];
                    f.call(this, $(this), tagslist[i-1]);
                }
            }

        });

        return false;
    };

    $.fn.removeTag = function(value) {
        value = unescape(value);
        this.each(function() {
            var id = $(this).attr('id');

            var old = $(this).val().split(delimiter[id]);

            $('#'+id+'_tagsinput .tag').remove();
            str = '';
            for (i=0; i< old.length; i++) {
                if (old[i]!=value) {
                    str = str + delimiter[id] +old[i];
                }
            }

            $.fn.tagsInput.importTags(this,str);

            if (tags_callbacks[id] && tags_callbacks[id]['onRemoveTag']) {
                var f = tags_callbacks[id]['onRemoveTag'];
                f.call(this, value);
            }
        });

        return false;
    };

    $.fn.tagExist = function(val) {
        var id = $(this).attr('id');
        var tagslist = $(this).val().split(delimiter[id]);
        return (jQuery.inArray(val, tagslist) >= 0); //true when tag exists, false when not
    };

    // clear all existing tags and import new ones from a string
    $.fn.importTags = function(str) {
        var id = $(this).attr('id');
        $('#'+id+'_tagsinput .tag').remove();
        $.fn.tagsInput.importTags(this,str);
    }

    $.fn.tagsInput = function(options) {
        var settings = jQuery.extend({
            interactive:true,
            defaultText:'add a tag',
            minChars:0,
            width:'300px',
            height:'100px',
            autocomplete: {selectFirst: false },
            hide:true,
            delimiter: ',',
            unique:true,
            removeWithBackspace:true,
            placeholderColor:'#666666',
            autosize: true,
            comfortZone: 20,
            inputPadding: 6*2
        },options);

        var uniqueIdCounter = 0;

        this.each(function() {
            // If we have already initialized the field, do not do it again
            if (typeof $(this).attr('data-tagsinput-init') !== 'undefined') {
                return;
            }

            // Mark the field as having been initialized
            $(this).attr('data-tagsinput-init', true);

            if (settings.hide) {
                $(this).hide();
            }
            var id = $(this).attr('id');
            if (!id || delimiter[$(this).attr('id')]) {
                id = $(this).attr('id', 'tags' + new Date().getTime() + (uniqueIdCounter++)).attr('id');
            }

            var data = jQuery.extend({
                pid:id,
                real_input: '#'+id,
                holder: '#'+id+'_tagsinput',
                input_wrapper: '#'+id+'_addTag',
                fake_input: '#'+id+'_tag'
            },settings);

            delimiter[id] = data.delimiter;

            if (settings.onAddTag || settings.onRemoveTag || settings.onChange) {
                tags_callbacks[id] = new Array();
                tags_callbacks[id]['onAddTag'] = settings.onAddTag;
                tags_callbacks[id]['onRemoveTag'] = settings.onRemoveTag;
                tags_callbacks[id]['onChange'] = settings.onChange;
            }

            var markup = '<div id="'+id+'_tagsinput" class="tagsinput"><div id="'+id+'_addTag">';

            if (settings.interactive) {
                markup = markup + '<input id="'+id+'_tag" value="" data-default="'+settings.defaultText+'" />';
            }

            markup = markup + '</div><div class="tags_clear"></div></div>';

            $(markup).insertAfter(this);

            $(data.holder).css('width',settings.width);
            $(data.holder).css('min-height',settings.height);
            $(data.holder).css('height',settings.height);

            if ($(data.real_input).val()!='') {
                $.fn.tagsInput.importTags($(data.real_input),$(data.real_input).val());
            }
            if (settings.interactive) {
                $(data.fake_input).val($(data.fake_input).attr('data-default'));
                $(data.fake_input).css('color',settings.placeholderColor);
                $(data.fake_input).resetAutosize(settings);

                $(data.holder).bind('click',data,function(event) {
                    $(event.data.fake_input).focus();
                });

                $(data.fake_input).bind('focus',data,function(event) {
                    if ($(event.data.fake_input).val()==$(event.data.fake_input).attr('data-default')) {
                        $(event.data.fake_input).val('');
                    }
                    $(event.data.fake_input).css('color','#000000');
                });

                if (settings.autocomplete_url != undefined) {
                    autocomplete_options = {source: settings.autocomplete_url};
                    for (attrname in settings.autocomplete) {
                        autocomplete_options[attrname] = settings.autocomplete[attrname];
                    }

                    if (jQuery.Autocompleter !== undefined) {
                        $(data.fake_input).autocomplete(settings.autocomplete_url, settings.autocomplete);
                        $(data.fake_input).bind('result',data,function(event,data,formatted) {
                            if (data) {
                                $('#'+id).addTag(data[0] + "",{focus:true,unique:(settings.unique)});
                            }
                        });
                    } else if (jQuery.ui.autocomplete !== undefined) {
                        $(data.fake_input).autocomplete(autocomplete_options);
                        $(data.fake_input).bind('autocompleteselect',data,function(event,ui) {
                            $(event.data.real_input).addTag(ui.item.value,{focus:true,unique:(settings.unique)});
                            return false;
                        });
                    }


                } else {
                    // if a user tabs out of the field, create a new tag
                    // this is only available if autocomplete is not used.
                    $(data.fake_input).bind('blur',data,function(event) {
                        var d = $(this).attr('data-default');
                        if ($(event.data.fake_input).val()!='' && $(event.data.fake_input).val()!=d) {
                            if( (event.data.minChars <= $(event.data.fake_input).val().length) && (!event.data.maxChars || (event.data.maxChars >= $(event.data.fake_input).val().length)) )
                                $(event.data.real_input).addTag($(event.data.fake_input).val(),{focus:true,unique:(settings.unique)});
                        } else {
                            $(event.data.fake_input).val($(event.data.fake_input).attr('data-default'));
                            $(event.data.fake_input).css('color',settings.placeholderColor);
                        }
                        return false;
                    });

                }
                // if user types a default delimiter like comma,semicolon and then create a new tag
                $(data.fake_input).bind('keypress',data,function(event) {
                    if (_checkDelimiter(event)) {
                        event.preventDefault();
                        if( (event.data.minChars <= $(event.data.fake_input).val().length) && (!event.data.maxChars || (event.data.maxChars >= $(event.data.fake_input).val().length)) )
                            $(event.data.real_input).addTag($(event.data.fake_input).val(),{focus:true,unique:(settings.unique)});
                        $(event.data.fake_input).resetAutosize(settings);
                        return false;
                    } else if (event.data.autosize) {
                        $(event.data.fake_input).doAutosize(settings);

                    }
                });
                //Delete last tag on backspace
                data.removeWithBackspace && $(data.fake_input).bind('keydown', function(event)
                {
                    if(event.keyCode == 8 && $(this).val() == '')
                    {
                        event.preventDefault();
                        var last_tag = $(this).closest('.tagsinput').find('.tag:last').text();
                        var id = $(this).attr('id').replace(/_tag$/, '');
                        last_tag = last_tag.replace(/[\s]+x$/, '');
                        $('#' + id).removeTag(escape(last_tag));
                        $(this).trigger('focus');
                    }
                });
                $(data.fake_input).blur();

                //Removes the not_valid class when user changes the value of the fake input
                if(data.unique) {
                    $(data.fake_input).keydown(function(event){
                        if(event.keyCode == 8 || String.fromCharCode(event.which).match(/\w+|[,/]+/)) {
                            $(this).removeClass('not_valid');
                        }
                    });
                }
            } // if settings.interactive
        });

        return this;

    };

    $.fn.tagsInput.updateTagsField = function(obj,tagslist) {
        var id = $(obj).attr('id');
        $(obj).val(tagslist.join(delimiter[id]));
    };

    $.fn.tagsInput.importTags = function(obj,val) {
        $(obj).val('');
        var id = $(obj).attr('id');
        var tags = val.split(delimiter[id]);
        for (i=0; i<tags.length; i++) {
            $(obj).addTag(tags[i],{focus:false,callback:false});
        }
        if(tags_callbacks[id] && tags_callbacks[id]['onChange'])
        {
            var f = tags_callbacks[id]['onChange'];
            f.call(obj, obj, tags[i]);
        }
    };

    /**
     * check delimiter Array
     * @param event
     * @returns {boolean}
     * @private
     */
    var _checkDelimiter = function(event){
        var found = false;
        if (event.which == 13) {
            return true;
        }

        if (typeof event.data.delimiter === 'string') {
            if (event.which == event.data.delimiter.charCodeAt(0)) {
                found = true;
            }
        } else {
            $.each(event.data.delimiter, function(index, delimiter) {
                if (event.which == delimiter.charCodeAt(0)) {
                    found = true;
                }
            });
        }

        return found;
    }
})(jQuery);

(function($){

    var original_title = document.title;
    var nCount = 0;

    var iKBCity = {
        init: function(){
            var self = this;

            self.siteBootUp();
        },

        siteBootUp: function(){
            var self = this;
            self.initExternalLink();
            self.initSematicUI();
            self.initAutocompleteAtUser();
            self.initScrollToTop();
            self.initLocalStorage();
            // self.initEditorPreview();
            self.initReplyOnPressKey();
            self.initDeleteForm();
            self.initInlineAttach();
            self.initAjax();
            self.initLogin();
            self.replyBtnShow();
            self.initFollow();
            self.initLoginRequired();
            self.initNotificationsCount();
            self.initTOC();
            self.initAnchorific();
            self.initGuide();
            self.initSubmitBtn();
            self.initLightBox();
        },

        initSubmitBtn: function(){
            $('button.loading-on-clicked[type="submit"]').click(function() {
                $(this).addClass('loading');

            });
        },

        initTOC: function(){
            $("#toc").tocify({
                context: '.article-content',
                selectors: "h2,h3"
            });
        },

        initGuide: function(){
            localforage.getItem('about-us-visited', function(err, value) {

            });

            $('.clicked-hide-guide').click(function() {
                $(this).find('.duke-pulse').hide();
            });
        },

        initSematicUI: function(){
            $('.ui.dropdown').dropdown();
            $('.ui.checkbox').checkbox();
            $('.ui.sticky').sticky();
            $('.ui.popover').popup({
                on: 'hover'
            });
            $('.message .close').on('click', function() {
                $('.message-container').transition('fade');
            });
            $('.ui.sidebar')
                .sidebar({
                    transition       : 'overlay',
                    mobileTransition : 'uncover'
                })
                .sidebar('attach events', '.launch.button, .chapter-title, .launch.item');

            $('.ui.progress').progress('increment');
            $('.ui.search').search({
                type: 'category',
                minCharacters : 1,
                cache : false,

            });
        },

        initAnchorific: function(){
            if ($('.anchorific').length == 0) {
                $('div.markdown-body').anchorific({
                    navigation: '.anchorific', // position of navigation
                    speed: 200, // speed of sliding back to top
                    anchorClass: 'anchorific', // class of anchor links
                    anchorText: '#', // prepended or appended to anchor headings
                    top: '.topx', // back to top button or link class
                    spy: true, // scroll spy
                    position: 'append', // position of anchor text
                    spyOffset: 0 // specify heading offset for spy scrolling
                });
            }
        },

        initFollow: function(){

            var changeFollowingState = function(that) {
                if (that.data('act') == 'follow') {
                    that.data('act', 'unfollow');
                    that.find('.state').text('');
                } else {
                    that.data('act', 'follow');
                    that.find('.state').text('');
                }
                that.toggleClass('teal');
            }

            $('.follow.button').api({
                method : 'POST',
                url: '',
                data: {
                    '_token': ""
                },
                onSuccess: function(response) {
                    // $('a.follower_count').text(response.count);
                }
            }).state({
                onActivate: function() {
                    changeFollowingState($(this));
                },
                onDeactivate: function() {
                    changeFollowingState($(this));
                }
            });

        },

        /**
         * Open External Links In New Window
         */
        initExternalLink: function(){
            $('.content-body a[href^="http://"], .content-body a[href^="https://"]').each(function() {
                var a = new RegExp('/' + window.location.host + '/');
                if(!a.test(this.href) ) {
                    $(this).click(function(event) {
                        event.preventDefault();
                        event.stopPropagation();
                        window.open(this.href, '_blank');
                    });
                }
            });
        },

        replyBtnShow: function(){
            $('.comments-feed .comment').each(function() {
                $(this).hover(function(event) {
                    $(this).find('.reply-btn').show();
                });
                $(this).mouseleave(function(event) {
                    $(this).find('.reply-btn').hide();
                });

            });
        },


        /**
         * Autocomplete @user
         */
        initAutocompleteAtUser: function() {
            var at_users = "",
                user;
            $users = $('.ui.comments .comment a.author');
            for (var i = 0; i < $users.length; i++) {
                user = $users.eq(i).text().trim();
                if ($.inArray(user, at_users) == -1) {
                    at_users.push(user);
                };
            };

            $('textarea').textcomplete([{
                mentions: at_users,
                match: /\B@(\S*)$/,
                search: function(term, callback) {
                    callback($.map(this.mentions, function(mention) {
                        console.log(term + ' -> '+ mention.indexOf(term) + ' -> ' + mention);
                        return (mention.indexOf(term) >= 0 // 
                            || mention.indexOf(term.toUpperCase()) >= 0 // 
                            || mention.indexOf(term.toLowerCase()) >= 0 // 
                        ) ? mention : null;
                    }));
                },
                index: 1,
                replace: function(mention) {
                    return '@' + mention + ' ';
                }
            }], {
                appendTo: 'body',
                onKeydown: function(e, commands){
                    console.log(commands);
                }
            });

        },

        /**
         * Scroll to top in one click.
         */
        initScrollToTop: function(){
            $.scrollUp.init();
        },

        /**
         * lightbox
         */
        initLightBox: function(){

            $('.content-body img:not(.emoji)').each(function() {
                $(this).wrap("<a href='"+ $(this).attr('src') +"' class='fluidbox'></a>");
            }).promise().done(function () {
                $('a.fluidbox').fluidbox();
            });

        },

        /**
         * do content preview
         */
        runPreview: function() {
            var replyContent = $("#comment-composing-box");
            var oldContent = replyContent.val();

            if (oldContent) {
                marked(oldContent, function (err, content) {
                    $('#preview-box').html(content);
                    emojify.run(document.getElementById('preview-box'));
                });
            }
        },

        /**
         * Init post content preview
         */
        initEditorPreview: function() {
            var self = this;
            $("#comment-composing-box").focus(function(event) {
                // $("#reply_notice").addClass('animated pulse');
                $("#preview-box").fadeIn(1500);
                $("#preview-lable").fadeIn(1500);
            });
            $('#comment-composing-box').keyup(function(){
                //
            });
        },

        /*
         * Use Ctrl + Enter for reply
         */
        initReplyOnPressKey: function() {
            $(document).on("keydown", "#comment-composing-box", function(e)
            {
                var submitBtn = $('#comment-composing-submit');
                if ((e.keyCode == 10 || e.keyCode == 13) && e.ctrlKey && submitBtn.is(':enabled')) {
                    submitBtn.addClass('loading').prop('disabled', true);
                    $(this).parents("form").submit();
                    localforage.removeItem('comment-composing-box');
                    return true;
                }
            });
        },

        /*
         * Construct a form when using the following code, makes more clean code.
         *   {{ link_to_route('tasks.destroy', 'D', $task->id, ['data-method'=>'delete']) }}
         * See this answer: http://stackoverflow.com/a/23082278/689832
         */
        initDeleteForm: function() {
            $('[data-method]').append(function(){
                return "\n"+
                    "<form action='"+$(this).attr('data-url')+"' method='POST' style='display:none'>\n"+
                    "   <input type='hidden' name='_method' value='"+$(this).attr('data-method').toUpperCase()+"'>\n"+
                    "   <input type='hidden' name='_token' value=''>\n"+
                    "</form>\n"
            })
                .attr('style','cursor:pointer;')
                .click(function() {
                    var that = $(this);
                    if (that.attr('data-method').toUpperCase() == 'DELETE') {
                        swal({
                            title: "",
                            html: $(this).attr('data-hint') ?  $(this).attr('data-hint') : "  ",
                            type: "warning",
                            showCancelButton: true,
                            cancelButtonText: "",
                            confirmButtonText: " "
                        }).then(function () {
                            that.find("form").submit();
                        }).catch(swal.noop);
                    }
                    if (that.attr('data-method').toUpperCase() == 'POST' || that.attr('data-method').toUpperCase() == 'GET' ) {
                        if (that.attr('data-prompt')) {
                            swal({
                                title: "",
                                html: $(this).attr('data-prompt'),
                                type: "warning",
                                showCancelButton: true,
                                cancelButtonText: "",
                                confirmButtonText: ""
                            }).then(function () {
                                that.find("form").submit();
                            }).catch(swal.noop);
                        } else {
                            that.find("form").submit();
                        }
                    }
                });
            // attr('onclick',' if (confirm("Are you sure want to proceed?")) { $(this).find("form").submit(); };');
        },

        /**
         * Local Storage
         */
        initLocalStorage: function() {
            var self = this;

            // Reply Content ON Topic Detail View
            localforage.getItem('comment-composing-box', function(err, value) {
                if ($('#comment-composing-box').val() == '' && !err) {
                    $('#comment-composing-box').val(value);
                }
            });
            $('#comment-composing-box').keyup(function(){
                localforage.setItem('comment-composing-box', $(this).val());
            });

            $("#comment-composing-form").submit(function(event){
                localforage.removeItem('comment-composing-box');
            });

        },

        /**
         * Upload image
         */
        initInlineAttach: function() {
            var self = this;
            $('#comment-composing-box').inlineattach({
                uploadUrl: "",
                extraParams: {
                    '_token': "",
                },
                // onUploadedFile: function(response) {
                //     setTimeout(self.runPreview, 200);
                // },
            });
        },

        initComment: function() {
            var self = this;
            var form = $('#comment-composing-form');
            var submitBtn = form.find('input[type=submit]');
            var submitBtnVal = submitBtn.val();
            var replies = $('.replies .list-group');
            var preview = $('#preview-box');
            var emptyBlock = $('#replies-empty-block');
            var count = 0;

            form.on('submit', function() {
                var tpl = '';
                var delTpl = '';
                var voteTpl = '';
                var introTpl = '';
                var badgeTpl = '';
                var total = $('.replies .total b');

                count = replies.find('li').length + 1;
                comment = $(this).find('textarea');
                commentText = comment.val();

                if ($.trim(commentText) !== '') {
                    submitBtn.val('...').addClass('disabled').prop('disabled', true);
                    $.ajax({
                        method: 'POST',
                        url: $(this).attr('action'),
                        data: {
                            body: commentText,
                            topic_id: $('[name=topic_id]').val()
                        },
                    }).done(function(data) {
                        if (data.status === 200) {
                            if (data.manage_topics === 'yes') {
                                delTpl = '<a class="" id="reply-delete-' + data.reply.id + '" data-ajax="delete" href="javascript:void(0);" data-url="/replies/delete/' + data.reply.id + '" title=" "><i class="fa fa-trash-o"></i></a><span>   </span>';
                            }

                            if (data.reply.user.introduction) {
                                introTpl = '' + data.reply.user.introduction;
                            }
                            if (Config.user_badge) {
                                badgeTpl = '<div>\
                                    <a class="label label-success role" href="' + Config.user_badge_link + '">' + Config.user_badge +'</a>\
                                </div>';
                            }

                            tpl = '<li class="list-group-item media" style="margin-top: 0px;">\
                                <div class="avatar avatar-container pull-left">\
                                    <a href="/users/' + data.reply.user_id + '"><img class="media-object img-thumbnail avatar" alt="' + data.reply.user.name + '" src="' + data.reply.user.image_url + '" style="width:55px;height:55px;"></a>\
                                ' + badgeTpl +'</div>\
                                <div class="infos">\
                                    <div class="media-heading">\
                                        <a href="/users/' + data.reply.user_id + '" title="' + data.reply.user.name + '" class="remove-padding-left author">' + data.reply.user.name + '</a>\
                                        <span class="introduction">' + introTpl + '</span>\
                                        <span class="operate pull-right">' + delTpl + '<a class="fa fa-reply" href="javascript:void(0)" onclick="replyOne(\'' + data.reply.user.name + '\');" title=" ' + data.reply.user.name + '"></a>\
                                        </span>\
                                        <div class="meta">\
                                            <a name="reply' + count + '" class="anchor" href="#reply' + count + '" aria-hidden="true">#' + count + '</a>\
                                            <span>   </span>\
                                            <abbr class="timeago" title="' + data.reply.created_at + '">' + data.reply.created_at + '</abbr>\
                                        </div>\
                                    </div>\
                                    <div class="media-body markdown-reply content-body">' + data.reply.body + '</div>\
                                </div>\
                            </li>';
                        }

                        $(tpl).hide().appendTo(replies).slideDown();
                        total.html(parseInt(total.html()) + 1);
                        emptyBlock.addClass('hide');
                        comment.val('');
                        localforage.removeItem('comment-composing-box');
                        preview.html('');
                        location.href = location.href.split('#')[0] + '#reply' + count;
                        self.initTimeAgo();
                        self.showPluginDownload();
                        emojify.run();
                    }).always(function() {
                        submitBtn.val(submitBtnVal).removeClass('disabled').prop('disabled', false);
                    });
                }

                return false;
            });
        },

        initAjax: function() {
            $.ajaxSetup({
                headers: {
                    'X-CSRF-TOKEN': $('meta[name="_token"]').attr('content')
                }
            });

            // this.initDataAjax();
            // this.initComment();
        },

        initDataAjax: function() {
            var self = this;
            $(document).on('click', '[data-ajax]', function() {
                var that = $(this);
                var method = that.data('ajax');
                var url = that.data('url');
                var active = that.is('.active');
                var cancelText = that.data('lang-cancel');
                var isRecomend = that.is('#topic-recomend-button');
                var isWiki = that.is('#topic-wiki-button');
                var ribbonContainer = $('.topic .ribbon-container');
                var ribbon = $('.topic .ribbon');
                var excellent = $('.topic .ribbon-excellent');
                var wiki = $('.topic .ribbon-wiki');
                var total = $('.replies .total b');
                var voteCount = $('#vote-count');
                var upVote = $('#up-vote');
                var isVote = that.is('.vote');
                var isUpVote = that.is('#up-vote');
                var isCommentVote= that.is('.comment-vote');
                var commenVoteCount= that.find('.vote-count');
                var emptyBlock = $('#replies-empty-block');
                var originUpVoteActive = upVote.is('.active');

                if (method === 'delete') {
                    swal({
                        title: "",
                        text: "Are you sure want to proceed?",
                        type: "warning",
                        showCancelButton: true,
                        cancelButtonText: "",
                        confirmButtonText: " "
                    }, function() {
                        that.closest('.list-group-item').slideUp();
                        $.ajax({
                            method: method,
                            url: url
                        }).done(function(data) {
                            if (data.status === 200) {
                                that.closest('.list-group-item').remove();
                                total.html(parseInt(total.html()) - 1);
                                if (parseInt(total.html()) === 0) {
                                    emptyBlock.removeClass('hide');
                                }
                            }
                        }).fail(function() {
                            that.closest('.list-group-item').show();
                        });
                    });

                    return;
                }

                if (that.is('.ajax-loading')) return;
                that.addClass('ajax-loading');

                if (active) {
                    that.removeClass('active');
                    that.removeClass('animated rubberBand');

                    if (isRecomend) {
                        excellent.hide();
                    } else if (isWiki) {
                        wiki.hide();
                    }

                    if (isVote) {

                    }
                } else {
                    that.addClass('active');
                    that.addClass('animated rubberBand');

                    if (cancelText) {
                        that.find('span').html(cancelText);
                        self.showPluginDownload();
                    }

                    if (isRecomend) {
                        var excellentText = ribbonContainer.data('lang-excellent');
                        if (excellent.length) {
                            excellent.show();
                        } else {
                            if (ribbon.length) {
                                ribbon.prepend('<div class="ribbon-excellent"><i class="fa fa-trophy"></i> ' + excellentText + ' </div>');
                            } else {
                                ribbonContainer.prepend('<div class="ribbon"><div class="ribbon-excellent"><i class="fa fa-trophy"></i> ' + excellentText + ' </div></div>');
                            }
                        }
                    } else if (isWiki) {
                        var wikiText = ribbonContainer.data('lang-wiki');
                        if (wiki.length) {
                            wiki.show();
                        } else {
                            if (ribbon.length) {
                                ribbon.append('<div class="ribbon-wiki"><i class="fa fa-graduation-cap"></i> ' + wikiText + ' </div>');
                            } else {
                                ribbonContainer.append('<div class="ribbon"><div class="ribbon-wiki"><i class="fa fa-graduation-cap"></i> ' + wikiText + ' </div></div>');
                            }
                        }
                    }

                    if (isVote) {
                        // @CJ 
                        var newContent = $('.voted-template').clone();
                        newContent.attr('data-userId', '');
                        newContent.attr('href', Config.user_link);
                        newContent.find('img').attr('src', Config.user_avatar);

                        newContent.prependTo('.user-lists').show('fast', function() {
                            $(this).addClass('animated swing');
                        });

                        $('.vote-hint').hide();
                    }
                }

                $.ajax({
                    method: method,
                    url: url
                }).done(function(data) {
                    if (data.status === 200) {
                        if (isCommentVote) {
                            var num = parseInt(commenVoteCount.html());
                            num = isNaN(num) ? 0 : num;

                            if (data.type === 'sub') {
                                commenVoteCount.html(num - 1 < 1 ? '' : num - 1);
                            } else if (data.type === 'add') {
                                commenVoteCount.html(num + 1);
                            }
                        }
                    }
                }).fail(function() {
                    if (!active) {
                        that.removeClass('active');

                        if (isRecomend) {
                            excellent.hide();
                        } else if (isWiki) {
                            wiki.hide();
                        }
                    } else {
                        that.addClass('active');

                        if (cancelText) {
                            that.find('span').html(cancelText);
                        }

                        if (isRecomend) {
                            excellent.show();
                        } else if (isWiki) {
                            wiki.show();
                        }
                    }

                    if (isVote) {
                        if (originUpVoteActive) {
                            upVote.addClass('active');
                        } else {
                            upVote.removeClass('active');
                        }
                    }
                })
                    .always(function() {
                        that.removeClass('ajax-loading');
                    });
            });
        },

        showMsg: function(msg, myobj) {
            if (!msg) return;
            Messenger().post(msg);
        },

        showPluginDownload: function() {
            this.showMsg('', {
                type: 'success',
                timer: 8000
            });
        },

        initLogin: function() {
            $('#login-out').on('click', function(e) {
                swal({
                    title: "",
                    text: "",
                    type: "warning",
                    showCancelButton: true,
                    cancelButtonText: "",
                    confirmButtonText: ""
                }).then(function () {
                    e.preventDefault();
                    $('#logout-form').submit();
                });

                return false;
            });
        },

        _resetTitle: function() {

            if(window.location.href.indexOf("notifications") > -1) {
                nCount = 0;
            }

            if (nCount > 0) {
                $('#notification-count').text(nCount);
                $('#notification-count').removeClass('basic');
                $('#notification-count').hasClass('red') || $('#notification-count').addClass('red');
                document.title = '(' + nCount + ') '+ original_title;
            } else {
                document.title =  original_title;
                $('#notification-count').text(0);
                $('#notification-count').addClass('basic');
                $('#notification-count').removeClass('red');
            }
        },

        initNotificationsCount: function() {
            var self = this;

        },

        initLoginRequired: function() {
            $('.login-required').on('click', function(e) {
                swal({
                    title: "",
                    text: "",
                    type: "warning",
                    showCancelButton: true,
                    cancelButtonText: "",
                    confirmButtonText: ""
                }).then(function () {
                    location.href = '/login';
                });

                return false;
            });
        },
    };
    window.iKBCity = iKBCity;
})(jQuery);

$(document).ready(function()
{
    iKBCity.init();
});

// reply a reply
function replyOne(username){
    replyContent = $("#comment-composing-box");
    oldContent = replyContent.val();
    prefix = "@" + username + " ";
    newContent = ''
    if(oldContent.length > 0){
        if (oldContent != prefix) {
            newContent = oldContent + "\n" + prefix;
        }
    } else {
        newContent = prefix
    }
    replyContent.focus();
    replyContent.val(newContent);
    moveEnd($("#comment-composing-box"));
}

var moveEnd = function(obj){
    obj.focus();

    var len = obj.value === undefined ? 0 : obj.value.length;

    if (document.selection) {
        var sel = obj.createTextRange();
        sel.moveStart('character',len);
        sel.collapse();
        sel.select();
    } else if (typeof obj.selectionStart == 'number' && typeof obj.selectionEnd == 'number') {
        obj.selectionStart = obj.selectionEnd = len;
    }
}